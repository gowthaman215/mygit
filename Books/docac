)0;
 sqlstm.sqharm[27] = (unsigned int  )0;
 sqlstm.sqadto[27] = (unsigned short )0;
 sqlstm.sqtdso[27] = (unsigned short )0;
 sqlstm.sqhstv[28] = (         void  *)&job_q.orig_start_stat;
 sqlstm.sqhstl[28] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[28] = (         int  )0;
 sqlstm.sqindv[28] = (         void  *)&job_q_ind.orig_start_stat;
 sqlstm.sqinds[28] = (         int  )0;
 sqlstm.sqharm[28] = (unsigned int  )0;
 sqlstm.sqadto[28] = (unsigned short )0;
 sqlstm.sqtdso[28] = (unsigned short )0;
 sqlstm.sqhstv[29] = (         void  *)job_q.job_suspended;
 sqlstm.sqhstl[29] = (unsigned int  )2;
 sqlstm.sqhsts[29] = (         int  )0;
 sqlstm.sqindv[29] = (         void  *)&job_q_ind.job_suspended;
 sqlstm.sqinds[29] = (         int  )0;
 sqlstm.sqharm[29] = (unsigned int  )0;
 sqlstm.sqadto[29] = (unsigned short )0;
 sqlstm.sqtdso[29] = (unsigned short )0;
 sqlstm.sqhstv[30] = (         void  *)job_q.restart;
 sqlstm.sqhstl[30] = (unsigned int  )9;
 sqlstm.sqhsts[30] = (         int  )0;
 sqlstm.sqindv[30] = (         void  *)&job_q_ind.restart;
 sqlstm.sqinds[30] = (         int  )0;
 sqlstm.sqharm[30] = (unsigned int  )0;
 sqlstm.sqadto[30] = (unsigned short )0;
 sqlstm.sqtdso[30] = (unsigned short )0;
 sqlstm.sqhstv[31] = (         void  *)job_q.job_class;
 sqlstm.sqhstl[31] = (unsigned int  )2;
 sqlstm.sqhsts[31] = (         int  )0;
 sqlstm.sqindv[31] = (         void  *)&job_q_ind.job_class;
 sqlstm.sqinds[31] = (         int  )0;
 sqlstm.sqharm[31] = (unsigned int  )0;
 sqlstm.sqadto[31] = (unsigned short )0;
 sqlstm.sqtdso[31] = (unsigned short )0;
 sqlstm.sqhstv[32] = (         void  *)job_q.base_dir;
 sqlstm.sqhstl[32] = (unsigned int  )81;
 sqlstm.sqhsts[32] = (         int  )0;
 sqlstm.sqindv[32] = (         void  *)&job_q_ind.base_dir;
 sqlstm.sqinds[32] = (         int  )0;
 sqlstm.sqharm[32] = (unsigned int  )0;
 sqlstm.sqadto[32] = (unsigned short )0;
 sqlstm.sqtdso[32] = (unsigned short )0;
 sqlstm.sqhstv[33] = (         void  *)&job_q.max_job_time_warn;
 sqlstm.sqhstl[33] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[33] = (         int  )0;
 sqlstm.sqindv[33] = (         void  *)&job_q_ind.max_job_time_warn;
 sqlstm.sqinds[33] = (         int  )0;
 sqlstm.sqharm[33] = (unsigned int  )0;
 sqlstm.sqadto[33] = (unsigned short )0;
 sqlstm.sqtdso[33] = (unsigned short )0;
 sqlstm.sqhstv[34] = (         void  *)job_q.debug_mode_yn;
 sqlstm.sqhstl[34] = (unsigned int  )2;
 sqlstm.sqhsts[34] = (         int  )0;
 sqlstm.sqindv[34] = (         void  *)&job_q_ind.debug_mode_yn;
 sqlstm.sqinds[34] = (         int  )0;
 sqlstm.sqharm[34] = (unsigned int  )0;
 sqlstm.sqadto[34] = (unsigned short )0;
 sqlstm.sqtdso[34] = (unsigned short )0;
 sqlstm.sqhstv[35] = (         void  *)&job_q.last_step;
 sqlstm.sqhstl[35] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[35] = (         int  )0;
 sqlstm.sqindv[35] = (         void  *)&job_q_ind.last_step;
 sqlstm.sqinds[35] = (         int  )0;
 sqlstm.sqharm[35] = (unsigned int  )0;
 sqlstm.sqadto[35] = (unsigned short )0;
 sqlstm.sqtdso[35] = (unsigned short )0;
 sqlstm.sqhstv[36] = (         void  *)job_q.last_s_name;
 sqlstm.sqhstl[36] = (unsigned int  )10;
 sqlstm.sqhsts[36] = (         int  )0;
 sqlstm.sqindv[36] = (         void  *)&job_q_ind.last_s_name;
 sqlstm.sqinds[36] = (         int  )0;
 sqlstm.sqharm[36] = (unsigned int  )0;
 sqlstm.sqadto[36] = (unsigned short )0;
 sqlstm.sqtdso[36] = (unsigned short )0;
 sqlstm.sqhstv[37] = (         void  *)job_q.last_g_name;
 sqlstm.sqhstl[37] = (unsigned int  )10;
 sqlstm.sqhsts[37] = (         int  )0;
 sqlstm.sqindv[37] = (         void  *)&job_q_ind.last_g_name;
 sqlstm.sqinds[37] = (         int  )0;
 sqlstm.sqharm[37] = (unsigned int  )0;
 sqlstm.sqadto[37] = (unsigned short )0;
 sqlstm.sqtdso[37] = (unsigned short )0;
 sqlstm.sqhstv[38] = (         void  *)job_q.submitted_file_name;
 sqlstm.sqhstl[38] = (unsigned int  )13;
 sqlstm.sqhsts[38] = (         int  )0;
 sqlstm.sqindv[38] = (         void  *)&job_q_ind.submitted_file_name;
 sqlstm.sqinds[38] = (         int  )0;
 sqlstm.sqharm[38] = (unsigned int  )0;
 sqlstm.sqadto[38] = (unsigned short )0;
 sqlstm.sqtdso[38] = (unsigned short )0;
 sqlstm.sqhstv[39] = (         void  *)job_q.p_msg_sent_yn;
 sqlstm.sqhstl[39] = (unsigned int  )2;
 sqlstm.sqhsts[39] = (         int  )0;
 sqlstm.sqindv[39] = (         void  *)&job_q_ind.p_msg_sent_yn;
 sqlstm.sqinds[39] = (         int  )0;
 sqlstm.sqharm[39] = (unsigned int  )0;
 sqlstm.sqadto[39] = (unsigned short )0;
 sqlstm.sqtdso[39] = (unsigned short )0;
 sqlstm.sqhstv[40] = (         void  *)&job_q.max_job_time_kill;
 sqlstm.sqhstl[40] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[40] = (         int  )0;
 sqlstm.sqindv[40] = (         void  *)&job_q_ind.max_job_time_kill;
 sqlstm.sqinds[40] = (         int  )0;
 sqlstm.sqharm[40] = (unsigned int  )0;
 sqlstm.sqadto[40] = (unsigned short )0;
 sqlstm.sqtdso[40] = (unsigned short )0;
 sqlstm.sqhstv[41] = (         void  *)job_q.max_c_msg_yn;
 sqlstm.sqhstl[41] = (unsigned int  )2;
 sqlstm.sqhsts[41] = (         int  )0;
 sqlstm.sqindv[41] = (         void  *)&job_q_ind.max_c_msg_yn;
 sqlstm.sqinds[41] = (         int  )0;
 sqlstm.sqharm[41] = (unsigned int  )0;
 sqlstm.sqadto[41] = (unsigned short )0;
 sqlstm.sqtdso[41] = (unsigned short )0;
 sqlstm.sqhstv[42] = (         void  *)job_q.stn_dependancy_yn;
 sqlstm.sqhstl[42] = (unsigned int  )2;
 sqlstm.sqhsts[42] = (         int  )0;
 sqlstm.sqindv[42] = (         void  *)&job_q_ind.stn_dependancy_yn;
 sqlstm.sqinds[42] = (         int  )0;
 sqlstm.sqharm[42] = (unsigned int  )0;
 sqlstm.sqadto[42] = (unsigned short )0;
 sqlstm.sqtdso[42] = (unsigned short )0;
 sqlstm.sqhstv[43] = (         void  *)job_q.no_fail_message_yn;
 sqlstm.sqhstl[43] = (unsigned int  )2;
 sqlstm.sqhsts[43] = (         int  )0;
 sqlstm.sqindv[43] = (         void  *)&job_q_ind.no_fail_message_yn;
 sqlstm.sqinds[43] = (         int  )0;
 sqlstm.sqharm[43] = (unsigned int  )0;
 sqlstm.sqadto[43] = (unsigned short )0;
 sqlstm.sqtdso[43] = (unsigned short )0;
 sqlstm.sqhstv[44] = (         void  *)job_q.msg_when_failed;
 sqlstm.sqhstl[44] = (unsigned int  )2;
 sqlstm.sqhsts[44] = (         int  )0;
 sqlstm.sqindv[44] = (         void  *)&job_q_ind.msg_when_failed;
 sqlstm.sqinds[44] = (         int  )0;
 sqlstm.sqharm[44] = (unsigned int  )0;
 sqlstm.sqadto[44] = (unsigned short )0;
 sqlstm.sqtdso[44] = (unsigned short )0;
 sqlstm.sqhstv[45] = (         void  *)&job_q.spawn_algorithm;
 sqlstm.sqhstl[45] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[45] = (         int  )0;
 sqlstm.sqindv[45] = (         void  *)&job_q_ind.spawn_algorithm;
 sqlstm.sqinds[45] = (         int  )0;
 sqlstm.sqharm[45] = (unsigned int  )0;
 sqlstm.sqadto[45] = (unsigned short )0;
 sqlstm.sqtdso[45] = (unsigned short )0;
 sqlstm.sqhstv[46] = (         void  *)&job_q.spawn_parm;
 sqlstm.sqhstl[46] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[46] = (         int  )0;
 sqlstm.sqindv[46] = (         void  *)&job_q_ind.spawn_parm;
 sqlstm.sqinds[46] = (         int  )0;
 sqlstm.sqharm[46] = (unsigned int  )0;
 sqlstm.sqadto[46] = (unsigned short )0;
 sqlstm.sqtdso[46] = (unsigned short )0;
 sqlstm.sqhstv[47] = (         void  *)job_q.d_station;
 sqlstm.sqhstl[47] = (unsigned int  )180;
 sqlstm.sqhsts[47] = (         int  )0;
 sqlstm.sqindv[47] = (         void  *)&job_q_ind.d_station;
 sqlstm.sqinds[47] = (         int  )0;
 sqlstm.sqharm[47] = (unsigned int  )0;
 sqlstm.sqadto[47] = (unsigned short )0;
 sqlstm.sqtdso[47] = (unsigned short )0;
 sqlstm.sqhstv[48] = (         void  *)job_q.jsgroup;
 sqlstm.sqhstl[48] = (unsigned int  )10;
 sqlstm.sqhsts[48] = (         int  )0;
 sqlstm.sqindv[48] = (         void  *)&job_q_ind.jsgroup;
 sqlstm.sqinds[48] = (         int  )0;
 sqlstm.sqharm[48] = (unsigned int  )0;
 sqlstm.sqadto[48] = (unsigned short )0;
 sqlstm.sqtdso[48] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);


	if (l_sqlcode == ORCL_NOT_FOUND)
	{
		EnterCriticalSection(&jsnt_sql_lock);

		/* EXEC SQL CLOSE active_job_curs; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 51;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )607;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
		LeaveCriticalSection(&jsnt_sql_lock);

		debug_log("No active files");
		return(0);
	}

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"active_job_curs", sqlmsg, "JOBQ table", NULL);
		_ltoa((DWORD) __LINE__, sznum, 10);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Fetch Cursor for active_job_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=", 
					szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "Fetch Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
		//			"active_job_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (0, szbuff);
		debug_log (szbuff);
		EnterCriticalSection(&jsnt_sql_lock);

		/* EXEC SQL CLOSE active_job_curs; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 51;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )622;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
		LeaveCriticalSection(&jsnt_sql_lock);

		return(-1);
	}

	trim_sql_jobq(&job_q);

	job_q_num = job_q.no;

	// Open active_step_curs cursor
	memset(&step_q, 0, sizeof(step_q));
	EnterCriticalSection(&jsnt_sql_lock);

	/* EXEC SQL OPEN active_step_curs; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 51;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = sq0010;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )637;
 sqlstm.selerr = (unsigned short)0;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqcmod = (unsigned int )0;
 sqlstm.sqhstv[0] = (         void  *)&job_q_num;
 sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"active_step_curs", sqlmsg, " ", NULL);
		_ltoa((DWORD) __LINE__, sznum, 10);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Open Cursor for active_step_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=", 
					szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "Open Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
		//			"active_step_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (0, szbuff);
		debug_log (szbuff);
		return(-1);
	}
 



	while(1) 
	{
		if(j_first_time == 0) 
		{

 
			// Fetch next record into job_q structure using status='A' and pos >= 0
			memset(&job_q, 0, sizeof(job_q) );
			EnterCriticalSection(&jsnt_sql_lock);

			/* EXEC SQL FETCH active_job_curs INTO :job_q:job_q_ind; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 51;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )656;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqfoff = (           int )0;
   sqlstm.sqfmod = (unsigned int )2;
   sqlstm.sqhstv[0] = (         void  *)job_q.status;
   sqlstm.sqhstl[0] = (unsigned int  )2;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)&job_q_ind.status;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)&job_q.pos;
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(long);
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)&job_q_ind.pos;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)job_q.name;
   sqlstm.sqhstl[2] = (unsigned int  )10;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)&job_q_ind.name;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)&job_q.no;
   sqlstm.sqhstl[3] = (unsigned int  )sizeof(long);
   sqlstm.sqhsts[3] = (         int  )0;
   sqlstm.sqindv[3] = (         void  *)&job_q_ind.no;
   sqlstm.sqinds[3] = (         int  )0;
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqhstv[4] = (         void  *)job_q.station;
   sqlstm.sqhstl[4] = (unsigned int  )10;
   sqlstm.sqhsts[4] = (         int  )0;
   sqlstm.sqindv[4] = (         void  *)&job_q_ind.station;
   sqlstm.sqinds[4] = (         int  )0;
   sqlstm.sqharm[4] = (unsigned int  )0;
   sqlstm.sqadto[4] = (unsigned short )0;
   sqlstm.sqtdso[4] = (unsigned short )0;
   sqlstm.sqhstv[5] = (         void  *)job_q.date_time_entered;
   sqlstm.sqhstl[5] = (unsigned int  )15;
   sqlstm.sqhsts[5] = (         int  )0;
   sqlstm.sqindv[5] = (         void  *)&job_q_ind.time_entered;
   sqlstm.sqinds[5] = (         int  )0;
   sqlstm.sqharm[5] = (unsigned int  )0;
   sqlstm.sqadto[5] = (unsigned short )0;
   sqlstm.sqtdso[5] = (unsigned short )0;
   sqlstm.sqhstv[6] = (         void  *)job_q.date_time_started;
   sqlstm.sqhstl[6] = (unsigned int  )15;
   sqlstm.sqhsts[6] = (         int  )0;
   sqlstm.sqindv[6] = (         void  *)&job_q_ind.time_started;
   sqlstm.sqinds[6] = (         int  )0;
   sqlstm.sqharm[6] = (unsigned int  )0;
   sqlstm.sqadto[6] = (unsigned short )0;
   sqlstm.sqtdso[6] = (unsigned short )0;
   sqlstm.sqhstv[7] = (         void  *)job_q.date_time_completed;
   sqlstm.sqhstl[7] = (unsigned int  )15;
   sqlstm.sqhsts[7] = (         int  )0;
   sqlstm.sqindv[7] = (         void  *)&job_q_ind.time_completed;
   sqlstm.sqinds[7] = (         int  )0;
   sqlstm.sqharm[7] = (unsigned int  )0;
   sqlstm.sqadto[7] = (unsigned short )0;
   sqlstm.sqtdso[7] = (unsigned short )0;
   sqlstm.sqhstv[8] = (         void  *)&job_q.exit_code;
   sqlstm.sqhstl[8] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[8] = (         int  )0;
   sqlstm.sqindv[8] = (         void  *)&job_q_ind.exit_code;
   sqlstm.sqinds[8] = (         int  )0;
   sqlstm.sqharm[8] = (unsigned int  )0;
   sqlstm.sqadto[8] = (unsigned short )0;
   sqlstm.sqtdso[8] = (unsigned short )0;
   sqlstm.sqhstv[9] = (         void  *)job_q.station_submitting;
   sqlstm.sqhstl[9] = (unsigned int  )2;
   sqlstm.sqhsts[9] = (         int  )0;
   sqlstm.sqindv[9] = (         void  *)&job_q_ind.station_submitting;
   sqlstm.sqinds[9] = (         int  )0;
   sqlstm.sqharm[9] = (unsigned int  )0;
   sqlstm.sqadto[9] = (unsigned short )0;
   sqlstm.sqtdso[9] = (unsigned short )0;
   sqlstm.sqhstv[10] = (         void  *)job_q.msg_when_started;
   sqlstm.sqhstl[10] = (unsigned int  )2;
   sqlstm.sqhsts[10] = (         int  )0;
   sqlstm.sqindv[10] = (         void  *)&job_q_ind.msg_when_started;
   sqlstm.sqinds[10] = (         int  )0;
   sqlstm.sqharm[10] = (unsigned int  )0;
   sqlstm.sqadto[10] = (unsigned short )0;
   sqlstm.sqtdso[10] = (unsigned short )0;
   sqlstm.sqhstv[11] = (         void  *)job_q.msg_when_done;
   sqlstm.sqhstl[11] = (unsigned int  )2;
   sqlstm.sqhsts[11] = (         int  )0;
   sqlstm.sqindv[11] = (         void  *)&job_q_ind.msg_when_done;
   sqlstm.sqinds[11] = (         int  )0;
   sqlstm.sqharm[11] = (unsigned int  )0;
   sqlstm.sqadto[11] = (unsigned short )0;
   sqlstm.sqtdso[11] = (unsigned short )0;
   sqlstm.sqhstv[12] = (         void  *)job_q.multi_processing;
   sqlstm.sqhstl[12] = (unsigned int  )2;
   sqlstm.sqhsts[12] = (         int  )0;
   sqlstm.sqindv[12] = (         void  *)&job_q_ind.multi_processing;
   sqlstm.sqinds[12] = (         int  )0;
   sqlstm.sqharm[12] = (unsigned int  )0;
   sqlstm.sqadto[12] = (unsigned short )0;
   sqlstm.sqtdso[12] = (unsigned short )0;
   sqlstm.sqhstv[13] = (         void  *)job_q.date_time_to_start;
   sqlstm.sqhstl[13] = (unsigned int  )15;
   sqlstm.sqhsts[13] = (         int  )0;
   sqlstm.sqindv[13] = (         void  *)&job_q_ind.date_time_to_start;
   sqlstm.sqinds[13] = (         int  )0;
   sqlstm.sqharm[13] = (unsigned int  )0;
   sqlstm.sqadto[13] = (unsigned short )0;
   sqlstm.sqtdso[13] = (unsigned short )0;
   sqlstm.sqhstv[14] = (         void  *)&job_q.start_stat;
   sqlstm.sqhstl[14] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[14] = (         int  )0;
   sqlstm.sqindv[14] = (         void  *)&job_q_ind.start_stat;
   sqlstm.sqinds[14] = (         int  )0;
   sqlstm.sqharm[14] = (unsigned int  )0;
   sqlstm.sqadto[14] = (unsigned short )0;
   sqlstm.sqtdso[14] = (unsigned short )0;
   sqlstm.sqhstv[15] = (         void  *)job_q.must_complete_by;
   sqlstm.sqhstl[15] = (unsigned int  )5;
   sqlstm.sqhsts[15] = (         int  )0;
   sqlstm.sqindv[15] = (         void  *)&job_q_ind.must_complete_by;
   sqlstm.sqinds[15] = (         int  )0;
   sqlstm.sqharm[15] = (unsigned int  )0;
   sqlstm.sqadto[15] = (unsigned short )0;
   sqlstm.sqtdso[15] = (unsigned short )0;
   sqlstm.sqhstv[16] = (         void  *)job_q.c_msg_sent_yn;
   sqlstm.sqhstl[16] = (unsigned int  )2;
   sqlstm.sqhsts[16] = (         int  )0;
   sqlstm.sqindv[16] = (         void  *)&job_q_ind.c_msg_sent_yn;
   sqlstm.sqinds[16] = (         int  )0;
   sqlstm.sqharm[16] = (unsigned int  )0;
   sqlstm.sqadto[16] = (unsigned short )0;
   sqlstm.sqtdso[16] = (unsigned short )0;
   sqlstm.sqhstv[17] = (         void  *)job_q.must_start_by;
   sqlstm.sqhstl[17] = (unsigned int  )5;
   sqlstm.sqhsts[17] = (         int  )0;
   sqlstm.sqindv[17] = (         void  *)&job_q_ind.must_start_by;
   sqlstm.sqinds[17] = (         int  )0;
   sqlstm.sqharm[17] = (unsigned int  )0;
   sqlstm.sqadto[17] = (unsigned short )0;
   sqlstm.sqtdso[17] = (unsigned short )0;
   sqlstm.sqhstv[18] = (         void  *)job_q.s_msg_sent_yn;
   sqlstm.sqhstl[18] = (unsigned int  )2;
   sqlstm.sqhsts[18] = (         int  )0;
   sqlstm.sqindv[18] = (         void  *)&job_q_ind.s_msg_sent_yn;
   sqlstm.sqinds[18] = (         int  )0;
   sqlstm.sqharm[18] = (unsigned int  )0;
   sqlstm.sqadto[18] = (unsigned short )0;
   sqlstm.sqtdso[18] = (unsigned short )0;
   sqlstm.sqhstv[19] = (         void  *)job_q.msg_to_operator_yn;
   sqlstm.sqhstl[19] = (unsigned int  )2;
   sqlstm.sqhsts[19] = (         int  )0;
   sqlstm.sqindv[19] = (         void  *)&job_q_ind.msg_to_operator_yn;
   sqlstm.sqinds[19] = (         int  )0;
   sqlstm.sqharm[19] = (unsigned int  )0;
   sqlstm.sqadto[19] = (unsigned short )0;
   sqlstm.sqtdso[19] = (unsigned short )0;
   sqlstm.sqhstv[20] = (         void  *)job_q.msg_to;
   sqlstm.sqhstl[20] = (unsigned int  )31;
   sqlstm.sqhsts[20] = (         int  )0;
   sqlstm.sqindv[20] = (         void  *)&job_q_ind.msg_to;
   sqlstm.sqinds[20] = (         int  )0;
   sqlstm.sqharm[20] = (unsigned int  )0;
   sqlstm.sqadto[20] = (unsigned short )0;
   sqlstm.sqtdso[20] = (unsigned short )0;
   sqlstm.sqhstv[21] = (         void  *)&job_q.priority;
   sqlstm.sqhstl[21] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[21] = (         int  )0;
   sqlstm.sqindv[21] = (         void  *)&job_q_ind.priority;
   sqlstm.sqinds[21] = (         int  )0;
   sqlstm.sqharm[21] = (unsigned int  )0;
   sqlstm.sqadto[21] = (unsigned short )0;
   sqlstm.sqtdso[21] = (unsigned short )0;
   sqlstm.sqhstv[22] = (         void  *)job_q.stn_started;
   sqlstm.sqhstl[22] = (unsigned int  )10;
   sqlstm.sqhsts[22] = (         int  )0;
   sqlstm.sqindv[22] = (         void  *)&job_q_ind.stn_started;
   sqlstm.sqinds[22] = (         int  )0;
   sqlstm.sqharm[22] = (unsigned int  )0;
   sqlstm.sqadto[22] = (unsigned short )0;
   sqlstm.sqtdso[22] = (unsigned short )0;
   sqlstm.sqhstv[23] = (         void  *)&job_q.num_d;
   sqlstm.sqhstl[23] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[23] = (         int  )0;
   sqlstm.sqindv[23] = (         void  *)&job_q_ind.num_d;
   sqlstm.sqinds[23] = (         int  )0;
   sqlstm.sqharm[23] = (unsigned int  )0;
   sqlstm.sqadto[23] = (unsigned short )0;
   sqlstm.sqtdso[23] = (unsigned short )0;
   sqlstm.sqhstv[24] = (         void  *)job_q.d_job;
   sqlstm.sqhstl[24] = (unsigned int  )180;
   sqlstm.sqhsts[24] = (         int  )0;
   sqlstm.sqindv[24] = (         void  *)&job_q_ind.d_job;
   sqlstm.sqinds[24] = (         int  )0;
   sqlstm.sqharm[24] = (unsigned int  )0;
   sqlstm.sqadto[24] = (unsigned short )0;
   sqlstm.sqtdso[24] = (unsigned short )0;
   sqlstm.sqhstv[25] = (         void  *)job_q.d_hrs_back;
   sqlstm.sqhstl[25] = (unsigned int  )100;
   sqlstm.sqhsts[25] = (         int  )0;
   sqlstm.sqindv[25] = (         void  *)&job_q_ind.d_hrs_back;
   sqlstm.sqinds[25] = (         int  )0;
   sqlstm.sqharm[25] = (unsigned int  )0;
   sqlstm.sqadto[25] = (unsigned short )0;
   sqlstm.sqtdso[25] = (unsigned short )0;
   sqlstm.sqhstv[26] = (         void  *)job_q.d_cmplt;
   sqlstm.sqhstl[26] = (unsigned int  )20;
   sqlstm.sqhsts[26] = (         int  )0;
   sqlstm.sqindv[26] = (         void  *)&job_q_ind.d_cmplt;
   sqlstm.sqinds[26] = (         int  )0;
   sqlstm.sqharm[26] = (unsigned int  )0;
   sqlstm.sqadto[26] = (unsigned short )0;
   sqlstm.sqtdso[26] = (unsigned short )0;
   sqlstm.sqhstv[27] = (         void  *)job_q.d_last_tested;
   sqlstm.sqhstl[27] = (unsigned int  )200;
   sqlstm.sqhsts[27] = (         int  )0;
   sqlstm.sqindv[27] = (         void  *)&job_q_ind.d_last_tested;
   sqlstm.sqinds[27] = (         int  )0;
   sqlstm.sqharm[27] = (unsigned int  )0;
   sqlstm.sqadto[27] = (unsigned short )0;
   sqlstm.sqtdso[27] = (unsigned short )0;
   sqlstm.sqhstv[28] = (         void  *)&job_q.orig_start_stat;
   sqlstm.sqhstl[28] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[28] = (         int  )0;
   sqlstm.sqindv[28] = (         void  *)&job_q_ind.orig_start_stat;
   sqlstm.sqinds[28] = (         int  )0;
   sqlstm.sqharm[28] = (unsigned int  )0;
   sqlstm.sqadto[28] = (unsigned short )0;
   sqlstm.sqtdso[28] = (unsigned short )0;
   sqlstm.sqhstv[29] = (         void  *)job_q.job_suspended;
   sqlstm.sqhstl[29] = (unsigned int  )2;
   sqlstm.sqhsts[29] = (         int  )0;
   sqlstm.sqindv[29] = (         void  *)&job_q_ind.job_suspended;
   sqlstm.sqinds[29] = (         int  )0;
   sqlstm.sqharm[29] = (unsigned int  )0;
   sqlstm.sqadto[29] = (unsigned short )0;
   sqlstm.sqtdso[29] = (unsigned short )0;
   sqlstm.sqhstv[30] = (         void  *)job_q.restart;
   sqlstm.sqhstl[30] = (unsigned int  )9;
   sqlstm.sqhsts[30] = (         int  )0;
   sqlstm.sqindv[30] = (         void  *)&job_q_ind.restart;
   sqlstm.sqinds[30] = (         int  )0;
   sqlstm.sqharm[30] = (unsigned int  )0;
   sqlstm.sqadto[30] = (unsigned short )0;
   sqlstm.sqtdso[30] = (unsigned short )0;
   sqlstm.sqhstv[31] = (         void  *)job_q.job_class;
   sqlstm.sqhstl[31] = (unsigned int  )2;
   sqlstm.sqhsts[31] = (         int  )0;
   sqlstm.sqindv[31] = (         void  *)&job_q_ind.job_class;
   sqlstm.sqinds[31] = (         int  )0;
   sqlstm.sqharm[31] = (unsigned int  )0;
   sqlstm.sqadto[31] = (unsigned short )0;
   sqlstm.sqtdso[31] = (unsigned short )0;
   sqlstm.sqhstv[32] = (         void  *)job_q.base_dir;
   sqlstm.sqhstl[32] = (unsigned int  )81;
   sqlstm.sqhsts[32] = (         int  )0;
   sqlstm.sqindv[32] = (         void  *)&job_q_ind.base_dir;
   sqlstm.sqinds[32] = (         int  )0;
   sqlstm.sqharm[32] = (unsigned int  )0;
   sqlstm.sqadto[32] = (unsigned short )0;
   sqlstm.sqtdso[32] = (unsigned short )0;
   sqlstm.sqhstv[33] = (         void  *)&job_q.max_job_time_warn;
   sqlstm.sqhstl[33] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[33] = (         int  )0;
   sqlstm.sqindv[33] = (         void  *)&job_q_ind.max_job_time_warn;
   sqlstm.sqinds[33] = (         int  )0;
   sqlstm.sqharm[33] = (unsigned int  )0;
   sqlstm.sqadto[33] = (unsigned short )0;
   sqlstm.sqtdso[33] = (unsigned short )0;
   sqlstm.sqhstv[34] = (         void  *)job_q.debug_mode_yn;
   sqlstm.sqhstl[34] = (unsigned int  )2;
   sqlstm.sqhsts[34] = (         int  )0;
   sqlstm.sqindv[34] = (         void  *)&job_q_ind.debug_mode_yn;
   sqlstm.sqinds[34] = (         int  )0;
   sqlstm.sqharm[34] = (unsigned int  )0;
   sqlstm.sqadto[34] = (unsigned short )0;
   sqlstm.sqtdso[34] = (unsigned short )0;
   sqlstm.sqhstv[35] = (         void  *)&job_q.last_step;
   sqlstm.sqhstl[35] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[35] = (         int  )0;
   sqlstm.sqindv[35] = (         void  *)&job_q_ind.last_step;
   sqlstm.sqinds[35] = (         int  )0;
   sqlstm.sqharm[35] = (unsigned int  )0;
   sqlstm.sqadto[35] = (unsigned short )0;
   sqlstm.sqtdso[35] = (unsigned short )0;
   sqlstm.sqhstv[36] = (         void  *)job_q.last_s_name;
   sqlstm.sqhstl[36] = (unsigned int  )10;
   sqlstm.sqhsts[36] = (         int  )0;
   sqlstm.sqindv[36] = (         void  *)&job_q_ind.last_s_name;
   sqlstm.sqinds[36] = (         int  )0;
   sqlstm.sqharm[36] = (unsigned int  )0;
   sqlstm.sqadto[36] = (unsigned short )0;
   sqlstm.sqtdso[36] = (unsigned short )0;
   sqlstm.sqhstv[37] = (         void  *)job_q.last_g_name;
   sqlstm.sqhstl[37] = (unsigned int  )10;
   sqlstm.sqhsts[37] = (         int  )0;
   sqlstm.sqindv[37] = (         void  *)&job_q_ind.last_g_name;
   sqlstm.sqinds[37] = (         int  )0;
   sqlstm.sqharm[37] = (unsigned int  )0;
   sqlstm.sqadto[37] = (unsigned short )0;
   sqlstm.sqtdso[37] = (unsigned short )0;
   sqlstm.sqhstv[38] = (         void  *)job_q.submitted_file_name;
   sqlstm.sqhstl[38] = (unsigned int  )13;
   sqlstm.sqhsts[38] = (         int  )0;
   sqlstm.sqindv[38] = (         void  *)&job_q_ind.submitted_file_name;
   sqlstm.sqinds[38] = (         int  )0;
   sqlstm.sqharm[38] = (unsigned int  )0;
   sqlstm.sqadto[38] = (unsigned short )0;
   sqlstm.sqtdso[38] = (unsigned short )0;
   sqlstm.sqhstv[39] = (         void  *)job_q.p_msg_sent_yn;
   sqlstm.sqhstl[39] = (unsigned int  )2;
   sqlstm.sqhsts[39] = (         int  )0;
   sqlstm.sqindv[39] = (         void  *)&job_q_ind.p_msg_sent_yn;
   sqlstm.sqinds[39] = (         int  )0;
   sqlstm.sqharm[39] = (unsigned int  )0;
   sqlstm.sqadto[39] = (unsigned short )0;
   sqlstm.sqtdso[39] = (unsigned short )0;
   sqlstm.sqhstv[40] = (         void  *)&job_q.max_job_time_kill;
   sqlstm.sqhstl[40] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[40] = (         int  )0;
   sqlstm.sqindv[40] = (         void  *)&job_q_ind.max_job_time_kill;
   sqlstm.sqinds[40] = (         int  )0;
   sqlstm.sqharm[40] = (unsigned int  )0;
   sqlstm.sqadto[40] = (unsigned short )0;
   sqlstm.sqtdso[40] = (unsigned short )0;
   sqlstm.sqhstv[41] = (         void  *)job_q.max_c_msg_yn;
   sqlstm.sqhstl[41] = (unsigned int  )2;
   sqlstm.sqhsts[41] = (         int  )0;
   sqlstm.sqindv[41] = (         void  *)&job_q_ind.max_c_msg_yn;
   sqlstm.sqinds[41] = (         int  )0;
   sqlstm.sqharm[41] = (unsigned int  )0;
   sqlstm.sqadto[41] = (unsigned short )0;
   sqlstm.sqtdso[41] = (unsigned short )0;
   sqlstm.sqhstv[42] = (         void  *)job_q.stn_dependancy_yn;
   sqlstm.sqhstl[42] = (unsigned int  )2;
   sqlstm.sqhsts[42] = (         int  )0;
   sqlstm.sqindv[42] = (         void  *)&job_q_ind.stn_dependancy_yn;
   sqlstm.sqinds[42] = (         int  )0;
   sqlstm.sqharm[42] = (unsigned int  )0;
   sqlstm.sqadto[42] = (unsigned short )0;
   sqlstm.sqtdso[42] = (unsigned short )0;
   sqlstm.sqhstv[43] = (         void  *)job_q.no_fail_message_yn;
   sqlstm.sqhstl[43] = (unsigned int  )2;
   sqlstm.sqhsts[43] = (         int  )0;
   sqlstm.sqindv[43] = (         void  *)&job_q_ind.no_fail_message_yn;
   sqlstm.sqinds[43] = (         int  )0;
   sqlstm.sqharm[43] = (unsigned int  )0;
   sqlstm.sqadto[43] = (unsigned short )0;
   sqlstm.sqtdso[43] = (unsigned short )0;
   sqlstm.sqhstv[44] = (         void  *)job_q.msg_when_failed;
   sqlstm.sqhstl[44] = (unsigned int  )2;
   sqlstm.sqhsts[44] = (         int  )0;
   sqlstm.sqindv[44] = (         void  *)&job_q_ind.msg_when_failed;
   sqlstm.sqinds[44] = (         int  )0;
   sqlstm.sqharm[44] = (unsigned int  )0;
   sqlstm.sqadto[44] = (unsigned short )0;
   sqlstm.sqtdso[44] = (unsigned short )0;
   sqlstm.sqhstv[45] = (         void  *)&job_q.spawn_algorithm;
   sqlstm.sqhstl[45] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[45] = (         int  )0;
   sqlstm.sqindv[45] = (         void  *)&job_q_ind.spawn_algorithm;
   sqlstm.sqinds[45] = (         int  )0;
   sqlstm.sqharm[45] = (unsigned int  )0;
   sqlstm.sqadto[45] = (unsigned short )0;
   sqlstm.sqtdso[45] = (unsigned short )0;
   sqlstm.sqhstv[46] = (         void  *)&job_q.spawn_parm;
   sqlstm.sqhstl[46] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[46] = (         int  )0;
   sqlstm.sqindv[46] = (         void  *)&job_q_ind.spawn_parm;
   sqlstm.sqinds[46] = (         int  )0;
   sqlstm.sqharm[46] = (unsigned int  )0;
   sqlstm.sqadto[46] = (unsigned short )0;
   sqlstm.sqtdso[46] = (unsigned short )0;
   sqlstm.sqhstv[47] = (         void  *)job_q.d_station;
   sqlstm.sqhstl[47] = (unsigned int  )180;
   sqlstm.sqhsts[47] = (         int  )0;
   sqlstm.sqindv[47] = (         void  *)&job_q_ind.d_station;
   sqlstm.sqinds[47] = (         int  )0;
   sqlstm.sqharm[47] = (unsigned int  )0;
   sqlstm.sqadto[47] = (unsigned short )0;
   sqlstm.sqtdso[47] = (unsigned short )0;
   sqlstm.sqhstv[48] = (         void  *)job_q.jsgroup;
   sqlstm.sqhstl[48] = (unsigned int  )10;
   sqlstm.sqhsts[48] = (         int  )0;
   sqlstm.sqindv[48] = (         void  *)&job_q_ind.jsgroup;
   sqlstm.sqinds[48] = (         int  )0;
   sqlstm.sqharm[48] = (unsigned int  )0;
   sqlstm.sqadto[48] = (unsigned short )0;
   sqlstm.sqtdso[48] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



			l_sqlcode = sqlca.sqlcode;
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			LeaveCriticalSection(&jsnt_sql_lock);


			if (l_sqlcode == ORCL_NOT_FOUND)
			{
				debug_log("No active files");
				EnterCriticalSection(&jsnt_sql_lock);

				/* EXEC SQL CLOSE active_step_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )867;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
				/* EXEC SQL CLOSE active_job_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )882;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
				LeaveCriticalSection(&jsnt_sql_lock);

				return(0);
			}

			if (l_sqlcode != ORCL_NO_ERROR)
			{
				ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
							"active_job_curs", sqlmsg, "JOBQ table", NULL);
				_ltoa((DWORD) __LINE__, sznum, 10);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff,"Fetch Cursor for active_job_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=", 
							szret, " ", sqlmsg, NULL);
				//sprintf(szbuff, "Fetch Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
				//			"active_job_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
				logit (0, szbuff);
				debug_log (szbuff);
				EnterCriticalSection(&jsnt_sql_lock);

				/* EXEC SQL CLOSE active_step_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )897;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
				/* EXEC SQL CLOSE active_job_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )912;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
				LeaveCriticalSection(&jsnt_sql_lock);

				return(-1);
			}

			trim_sql_jobq(&job_q);

			job_q_num = job_q.no;			


			// DAN SAYS I HAVE TO REOPEN THE STEPQ CURSOR BEFORE TRYING TO OBTAIN NEW STEPS
			// Open active_step_curs cursor
			EnterCriticalSection(&jsnt_sql_lock);

			/* EXEC SQL OPEN active_step_curs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 51;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = sq0010;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )927;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqcmod = (unsigned int )0;
   sqlstm.sqhstv[0] = (         void  *)&job_q_num;
   sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



			l_sqlcode = sqlca.sqlcode;
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			LeaveCriticalSection(&jsnt_sql_lock);


			if (l_sqlcode != ORCL_NO_ERROR)
			{
				ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
							"active_step_curs", sqlmsg, " ", NULL);
				_ltoa((DWORD) __LINE__, sznum, 10);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff,"Open Cursor for active_step_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=",
							szret, " ", sqlmsg, NULL);
				//sprintf(szbuff, "Open Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
				//			"active_step_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
				logit (0, szbuff);
				debug_log (szbuff);
				EnterCriticalSection(&jsnt_sql_lock);

				/* EXEC SQL CLOSE active_job_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )946;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
				LeaveCriticalSection(&jsnt_sql_lock);

				return(-1);
			}
 
		}

		j_first_time=0;

 
		if(job_q.status[0] != 'A') 
 
		{
			debug_log("No more active jobs found");
			if(base_dir_job > 0) 
				base_dir_job = 0;

			if(same_group_job > 0) 
			{
				same_group_job=0;
				same_machine_group_name[0] = 0;
			}

			break;
		}
	
		copy_cat(szbuff, "Checking active job ", job_q.name, NULL);
		//sprintf(szbuff, "Checking active job %s", job_q.name);
		debug_log(szbuff);

		status = check_class();                     
		if(status != 0)                             
		{                                      
			debug_log("Job skipped because of class");      
			 continue;                             
		}                                      

		/* Check machine dependencey */
		trimr((char*)job_q.station);
		if(job_q.station[0]) 
		{
			if(strcmp(szjsname, (char*)job_q.station) != 0) 
			{
				debug_log("Skipped because of station dependency");
				continue;
			}
		}


 
		trimr(job_q.job_suspended);
		if(job_q.job_suspended[0]) 
		{
			debug_log("Skipped because job is suspended");
			continue;
		}
 
		/* If we started a Non-multiprocessing job or a Group dependent
		on the same machine - make sure we select this job */
		if(base_dir_job > 0) 
		{
			if(job_q.no != base_dir_job) 
			{
				debug_log("Skipped because job number not same as base directory job");
				continue;
			}
		}

		if(same_group_job > 0) 
		{
			if(job_q.no != same_group_job) 
			{
				debug_log("Skipped because job number not same as same group job");
				continue;
			}
		}



 
		// Select using step_q.no and step_q.d_step
		memset(&step_q, 0, sizeof(step_q) );
		EnterCriticalSection(&jsnt_sql_lock);

		/* EXEC SQL FETCH active_step_curs INTO :step_q:step_q_ind; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 51;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )961;
  sqlstm.selerr = (unsigned short)0;
  sqlstm.sqlpfmem = (unsigned int  )0;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlstm.sqfoff = (           int )0;
  sqlstm.sqfmod = (unsigned int )2;
  sqlstm.sqhstv[0] = (         void  *)&step_q.no;
  sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
  sqlstm.sqhsts[0] = (         int  )0;
  sqlstm.sqindv[0] = (         void  *)&step_q_ind.no;
  sqlstm.sqinds[0] = (         int  )0;
  sqlstm.sqharm[0] = (unsigned int  )0;
  sqlstm.sqadto[0] = (unsigned short )0;
  sqlstm.sqtdso[0] = (unsigned short )0;
  sqlstm.sqhstv[1] = (         void  *)&step_q.step;
  sqlstm.sqhstl[1] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[1] = (         int  )0;
  sqlstm.sqindv[1] = (         void  *)&step_q_ind.step;
  sqlstm.sqinds[1] = (         int  )0;
  sqlstm.sqharm[1] = (unsigned int  )0;
  sqlstm.sqadto[1] = (unsigned short )0;
  sqlstm.sqtdso[1] = (unsigned short )0;
  sqlstm.sqhstv[2] = (         void  *)step_q.s_name;
  sqlstm.sqhstl[2] = (unsigned int  )10;
  sqlstm.sqhsts[2] = (         int  )0;
  sqlstm.sqindv[2] = (         void  *)&step_q_ind.s_name;
  sqlstm.sqinds[2] = (         int  )0;
  sqlstm.sqharm[2] = (unsigned int  )0;
  sqlstm.sqadto[2] = (unsigned short )0;
  sqlstm.sqtdso[2] = (unsigned short )0;
  sqlstm.sqhstv[3] = (         void  *)step_q.status;
  sqlstm.sqhstl[3] = (unsigned int  )2;
  sqlstm.sqhsts[3] = (         int  )0;
  sqlstm.sqindv[3] = (         void  *)&step_q_ind.status;
  sqlstm.sqinds[3] = (         int  )0;
  sqlstm.sqharm[3] = (unsigned int  )0;
  sqlstm.sqadto[3] = (unsigned short )0;
  sqlstm.sqtdso[3] = (unsigned short )0;
  sqlstm.sqhstv[4] = (         void  *)step_q.j_name;
  sqlstm.sqhstl[4] = (unsigned int  )10;
  sqlstm.sqhsts[4] = (         int  )0;
  sqlstm.sqindv[4] = (         void  *)&step_q_ind.j_name;
  sqlstm.sqinds[4] = (         int  )0;
  sqlstm.sqharm[4] = (unsigned int  )0;
  sqlstm.sqadto[4] = (unsigned short )0;
  sqlstm.sqtdso[4] = (unsigned short )0;
  sqlstm.sqhstv[5] = (         void  *)step_q.date_time_started;
  sqlstm.sqhstl[5] = (unsigned int  )15;
  sqlstm.sqhsts[5] = (         int  )0;
  sqlstm.sqindv[5] = (         void  *)&step_q_ind.time_started;
  sqlstm.sqinds[5] = (         int  )0;
  sqlstm.sqharm[5] = (unsigned int  )0;
  sqlstm.sqadto[5] = (unsigned short )0;
  sqlstm.sqtdso[5] = (unsigned short )0;
  sqlstm.sqhstv[6] = (         void  *)step_q.date_time_completed;
  sqlstm.sqhstl[6] = (unsigned int  )15;
  sqlstm.sqhsts[6] = (         int  )0;
  sqlstm.sqindv[6] = (         void  *)&step_q_ind.time_completed;
  sqlstm.sqinds[6] = (         int  )0;
  sqlstm.sqharm[6] = (unsigned int  )0;
  sqlstm.sqadto[6] = (unsigned short )0;
  sqlstm.sqtdso[6] = (unsigned short )0;
  sqlstm.sqhstv[7] = (         void  *)&step_q.exit_code;
  sqlstm.sqhstl[7] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[7] = (         int  )0;
  sqlstm.sqindv[7] = (         void  *)&step_q_ind.exit_code;
  sqlstm.sqinds[7] = (         int  )0;
  sqlstm.sqharm[7] = (unsigned int  )0;
  sqlstm.sqadto[7] = (unsigned short )0;
  sqlstm.sqtdso[7] = (unsigned short )0;
  sqlstm.sqhstv[8] = (         void  *)step_q.command_line;
  sqlstm.sqhstl[8] = (unsigned int  )140;
  sqlstm.sqhsts[8] = (         int  )0;
  sqlstm.sqindv[8] = (         void  *)&step_q_ind.command_line;
  sqlstm.sqinds[8] = (         int  )0;
  sqlstm.sqharm[8] = (unsigned int  )0;
  sqlstm.sqadto[8] = (unsigned short )0;
  sqlstm.sqtdso[8] = (unsigned short )0;
  sqlstm.sqhstv[9] = (         void  *)&step_q.num_d;
  sqlstm.sqhstl[9] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[9] = (         int  )0;
  sqlstm.sqindv[9] = (         void  *)&step_q_ind.num_d;
  sqlstm.sqinds[9] = (         int  )0;
  sqlstm.sqharm[9] = (unsigned int  )0;
  sqlstm.sqadto[9] = (unsigned short )0;
  sqlstm.sqtdso[9] = (unsigned short )0;
  sqlstm.sqhstv[10] = (         void  *)step_q.d_step;
  sqlstm.sqhstl[10] = (unsigned int  )180;
  sqlstm.sqhsts[10] = (         int  )0;
  sqlstm.sqindv[10] = (         void  *)&step_q_ind.d_step;
  sqlstm.sqinds[10] = (         int  )0;
  sqlstm.sqharm[10] = (unsigned int  )0;
  sqlstm.sqadto[10] = (unsigned short )0;
  sqlstm.sqtdso[10] = (unsigned short )0;
  sqlstm.sqhstv[11] = (         void  *)step_q.d_cmplt;
  sqlstm.sqhstl[11] = (unsigned int  )20;
  sqlstm.sqhsts[11] = (         int  )0;
  sqlstm.sqindv[11] = (         void  *)&step_q_ind.d_cmplt;
  sqlstm.sqinds[11] = (         int  )0;
  sqlstm.sqharm[11] = (unsigned int  )0;
  sqlstm.sqadto[11] = (unsigned short )0;
  sqlstm.sqtdso[11] = (unsigned short )0;
  sqlstm.sqhstv[12] = (         void  *)step_q.d_last_tested;
  sqlstm.sqhstl[12] = (unsigned int  )200;
  sqlstm.sqhsts[12] = (         int  )0;
  sqlstm.sqindv[12] = (         void  *)&step_q_ind.d_last_tested;
  sqlstm.sqinds[12] = (         int  )0;
  sqlstm.sqharm[12] = (unsigned int  )0;
  sqlstm.sqadto[12] = (unsigned short )0;
  sqlstm.sqtdso[12] = (unsigned short )0;
  sqlstm.sqhstv[13] = (         void  *)&step_q.num_a;
  sqlstm.sqhstl[13] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[13] = (         int  )0;
  sqlstm.sqindv[13] = (         void  *)&step_q_ind.num_a;
  sqlstm.sqinds[13] = (         int  )0;
  sqlstm.sqharm[13] = (unsigned int  )0;
  sqlstm.sqadto[13] = (unsigned short )0;
  sqlstm.sqtdso[13] = (unsigned short )0;
  sqlstm.sqhstv[14] = (         void  *)step_q.exit_codes_acceptable;
  sqlstm.sqhstl[14] = (unsigned int  )100;
  sqlstm.sqhsts[14] = (         int  )0;
  sqlstm.sqindv[14] = (         void  *)&step_q_ind.exit_codes_acceptable;
  sqlstm.sqinds[14] = (         int  )0;
  sqlstm.sqharm[14] = (unsigned int  )0;
  sqlstm.sqadto[14] = (unsigned short )0;
  sqlstm.sqtdso[14] = (unsigned short )0;
  sqlstm.sqhstv[15] = (         void  *)step_q.job_machine;
  sqlstm.sqhstl[15] = (unsigned int  )10;
  sqlstm.sqhsts[15] = (         int  )0;
  sqlstm.sqindv[15] = (         void  *)&step_q_ind.job_machine;
  sqlstm.sqinds[15] = (         int  )0;
  sqlstm.sqharm[15] = (unsigned int  )0;
  sqlstm.sqadto[15] = (unsigned short )0;
  sqlstm.sqtdso[15] = (unsigned short )0;
  sqlstm.sqhstv[16] = (         void  *)step_q.d_group;
  sqlstm.sqhstl[16] = (unsigned int  )21;
  sqlstm.sqhsts[16] = (         int  )0;
  sqlstm.sqindv[16] = (         void  *)&step_q_ind.d_group;
  sqlstm.sqinds[16] = (         int  )0;
  sqlstm.sqharm[16] = (unsigned int  )0;
  sqlstm.sqadto[16] = (unsigned short )0;
  sqlstm.sqtdso[16] = (unsigned short )0;
  sqlstm.sqhstv[17] = (         void  *)step_q.group_name;
  sqlstm.sqhstl[17] = (unsigned int  )10;
  sqlstm.sqhsts[17] = (         int  )0;
  sqlstm.sqindv[17] = (         void  *)&step_q_ind.group_name;
  sqlstm.sqinds[17] = (         int  )0;
  sqlstm.sqharm[17] = (unsigned int  )0;
  sqlstm.sqadto[17] = (unsigned short )0;
  sqlstm.sqtdso[17] = (unsigned short )0;
  sqlstm.sqhstv[18] = (         void  *)step_q.same_machine_flag_yn;
  sqlstm.sqhstl[18] = (unsigned int  )2;
  sqlstm.sqhsts[18] = (         int  )0;
  sqlstm.sqindv[18] = (         void  *)&step_q_ind.same_machine_flag_yn;
  sqlstm.sqinds[18] = (         int  )0;
  sqlstm.sqharm[18] = (unsigned int  )0;
  sqlstm.sqadto[18] = (unsigned short )0;
  sqlstm.sqtdso[18] = (unsigned short )0;
  sqlstm.sqhstv[19] = (         void  *)step_q.group_first_step_yn;
  sqlstm.sqhstl[19] = (unsigned int  )2;
  sqlstm.sqhsts[19] = (         int  )0;
  sqlstm.sqindv[19] = (         void  *)&step_q_ind.group_first_step_yn;
  sqlstm.sqinds[19] = (         int  )0;
  sqlstm.sqharm[19] = (unsigned int  )0;
  sqlstm.sqadto[19] = (unsigned short )0;
  sqlstm.sqtdso[19] = (unsigned short )0;
  sqlstm.sqhstv[20] = (         void  *)step_q.skip_yn;
  sqlstm.sqhstl[20] = (unsigned int  )2;
  sqlstm.sqhsts[20] = (         int  )0;
  sqlstm.sqindv[20] = (         void  *)&step_q_ind.skip_yn;
  sqlstm.sqinds[20] = (         int  )0;
  sqlstm.sqharm[20] = (unsigned int  )0;
  sqlstm.sqadto[20] = (unsigned short )0;
  sqlstm.sqtdso[20] = (unsigned short )0;
  sqlstm.sqhstv[21] = (         void  *)step_q.beg_console_msg;
  sqlstm.sqhstl[21] = (unsigned int  )81;
  sqlstm.sqhsts[21] = (         int  )0;
  sqlstm.sqindv[21] = (         void  *)&step_q_ind.beg_console_msg;
  sqlstm.sqinds[21] = (         int  )0;
  sqlstm.sqharm[21] = (unsigned int  )0;
  sqlstm.sqadto[21] = (unsigned short )0;
  sqlstm.sqtdso[21] = (unsigned short )0;
  sqlstm.sqhstv[22] = (         void  *)step_q.beg_suspend_yn;
  sqlstm.sqhstl[22] = (unsigned int  )2;
  sqlstm.sqhsts[22] = (         int  )0;
  sqlstm.sqindv[22] = (         void  *)&step_q_ind.beg_suspend_yn;
  sqlstm.sqinds[22] = (         int  )0;
  sqlstm.sqharm[22] = (unsigned int  )0;
  sqlstm.sqadto[22] = (unsigned short )0;
  sqlstm.sqtdso[22] = (unsigned short )0;
  sqlstm.sqhstv[23] = (         void  *)step_q.end_console_msg;
  sqlstm.sqhstl[23] = (unsigned int  )81;
  sqlstm.sqhsts[23] = (         int  )0;
  sqlstm.sqindv[23] = (         void  *)&step_q_ind.end_console_msg;
  sqlstm.sqinds[23] = (         int  )0;
  sqlstm.sqharm[23] = (unsigned int  )0;
  sqlstm.sqadto[23] = (unsigned short )0;
  sqlstm.sqtdso[23] = (unsigned short )0;
  sqlstm.sqhstv[24] = (         void  *)step_q.end_suspend_yn;
  sqlstm.sqhstl[24] = (unsigned int  )2;
  sqlstm.sqhsts[24] = (         int  )0;
  sqlstm.sqindv[24] = (         void  *)&step_q_ind.end_suspend_yn;
  sqlstm.sqinds[24] = (         int  )0;
  sqlstm.sqharm[24] = (unsigned int  )0;
  sqlstm.sqadto[24] = (unsigned short )0;
  sqlstm.sqtdso[24] = (unsigned short )0;
  sqlstm.sqhstv[25] = (         void  *)step_q.send_msg;
  sqlstm.sqhstl[25] = (unsigned int  )81;
  sqlstm.sqhsts[25] = (         int  )0;
  sqlstm.sqindv[25] = (         void  *)&step_q_ind.send_msg;
  sqlstm.sqinds[25] = (         int  )0;
  sqlstm.sqharm[25] = (unsigned int  )0;
  sqlstm.sqadto[25] = (unsigned short )0;
  sqlstm.sqtdso[25] = (unsigned short )0;
  sqlstm.sqhstv[26] = (         void  *)step_q.run_if_error;
  sqlstm.sqhstl[26] = (unsigned int  )65;
  sqlstm.sqhsts[26] = (         int  )0;
  sqlstm.sqindv[26] = (         void  *)&step_q_ind.run_if_error;
  sqlstm.sqinds[26] = (         int  )0;
  sqlstm.sqharm[26] = (unsigned int  )0;
  sqlstm.sqadto[26] = (unsigned short )0;
  sqlstm.sqtdso[26] = (unsigned short )0;
  sqlstm.sqhstv[27] = (         void  *)&step_q.status_interval;
  sqlstm.sqhstl[27] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[27] = (         int  )0;
  sqlstm.sqindv[27] = (         void  *)&step_q_ind.status_interval;
  sqlstm.sqinds[27] = (         int  )0;
  sqlstm.sqharm[27] = (unsigned int  )0;
  sqlstm.sqadto[27] = (unsigned short )0;
  sqlstm.sqtdso[27] = (unsigned short )0;
  sqlstm.sqphsv = sqlstm.sqhstv;
  sqlstm.sqphsl = sqlstm.sqhstl;
  sqlstm.sqphss = sqlstm.sqhsts;
  sqlstm.sqpind = sqlstm.sqindv;
  sqlstm.sqpins = sqlstm.sqinds;
  sqlstm.sqparm = sqlstm.sqharm;
  sqlstm.sqparc = sqlstm.sqharc;
  sqlstm.sqpadto = sqlstm.sqadto;
  sqlstm.sqptdso = sqlstm.sqtdso;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


		l_sqlcode = sqlca.sqlcode;
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		LeaveCriticalSection(&jsnt_sql_lock);



		if (l_sqlcode == ORCL_NOT_FOUND)
		{
			debug_log("No more steps for job");
			debug_log("Job has finished - closing job");
			if(close_job() != 0)
			{
				EnterCriticalSection(&jsnt_sql_lock);

				/* EXEC SQL CLOSE active_step_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )1088;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
				/* EXEC SQL CLOSE active_job_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )1103;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
				LeaveCriticalSection(&jsnt_sql_lock);

				return(-1);
			}
			return(0);
		}

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"active_step_curs", sqlmsg, "STEPQ table", NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"No step found for Job ", job_q.name, "  Fetch Cursor for active_step_curs Failed! on line ", 
						sznum, " - SQLCA.SQLCODE=", szret, " ", sqlmsg, NULL);
			//sprintf(szbuff, "No step found for Job %s.  Fetch Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
			//			job_q.name, "active_step_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log (szbuff);
			EnterCriticalSection(&jsnt_sql_lock);

			/* EXEC SQL CLOSE active_step_curs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 51;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )1118;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
			/* EXEC SQL CLOSE active_job_curs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 51;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )1133;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
			LeaveCriticalSection(&jsnt_sql_lock);

			return(-1);
		}

		trim_sql_stepq(&step_q);
 

		if(step_q.no != job_q.no) 
		{
			logit(0,"Could not find step for job");
			debug_log("Could not find step for job");
 
			EnterCriticalSection(&jsnt_sql_lock);

			/* EXEC SQL CLOSE active_step_curs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 51;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )1148;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
			/* EXEC SQL CLOSE active_job_curs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 51;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )1163;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
			LeaveCriticalSection(&jsnt_sql_lock);

 
			return(-1);
		}
		s_dep = 0;
		s_first_time = 1;



		while (1) 
		{
			if(s_first_time == 0) 
			{

 
				// Select using step_q.no and step_q.d_step
				memset(&step_q, 0, sizeof(step_q) );
				EnterCriticalSection(&jsnt_sql_lock);

				/* EXEC SQL FETCH active_step_curs INTO :step_q:step_q_ind; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )1178;
    sqlstm.selerr = (unsigned short)0;
    sqlstm.sqlpfmem = (unsigned int  )0;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlstm.sqfoff = (           int )0;
    sqlstm.sqfmod = (unsigned int )2;
    sqlstm.sqhstv[0] = (         void  *)&step_q.no;
    sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
    sqlstm.sqhsts[0] = (         int  )0;
    sqlstm.sqindv[0] = (         void  *)&step_q_ind.no;
    sqlstm.sqinds[0] = (         int  )0;
    sqlstm.sqharm[0] = (unsigned int  )0;
    sqlstm.sqadto[0] = (unsigned short )0;
    sqlstm.sqtdso[0] = (unsigned short )0;
    sqlstm.sqhstv[1] = (         void  *)&step_q.step;
    sqlstm.sqhstl[1] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[1] = (         int  )0;
    sqlstm.sqindv[1] = (         void  *)&step_q_ind.step;
    sqlstm.sqinds[1] = (         int  )0;
    sqlstm.sqharm[1] = (unsigned int  )0;
    sqlstm.sqadto[1] = (unsigned short )0;
    sqlstm.sqtdso[1] = (unsigned short )0;
    sqlstm.sqhstv[2] = (         void  *)step_q.s_name;
    sqlstm.sqhstl[2] = (unsigned int  )10;
    sqlstm.sqhsts[2] = (         int  )0;
    sqlstm.sqindv[2] = (         void  *)&step_q_ind.s_name;
    sqlstm.sqinds[2] = (         int  )0;
    sqlstm.sqharm[2] = (unsigned int  )0;
    sqlstm.sqadto[2] = (unsigned short )0;
    sqlstm.sqtdso[2] = (unsigned short )0;
    sqlstm.sqhstv[3] = (         void  *)step_q.status;
    sqlstm.sqhstl[3] = (unsigned int  )2;
    sqlstm.sqhsts[3] = (         int  )0;
    sqlstm.sqindv[3] = (         void  *)&step_q_ind.status;
    sqlstm.sqinds[3] = (         int  )0;
    sqlstm.sqharm[3] = (unsigned int  )0;
    sqlstm.sqadto[3] = (unsigned short )0;
    sqlstm.sqtdso[3] = (unsigned short )0;
    sqlstm.sqhstv[4] = (         void  *)step_q.j_name;
    sqlstm.sqhstl[4] = (unsigned int  )10;
    sqlstm.sqhsts[4] = (         int  )0;
    sqlstm.sqindv[4] = (         void  *)&step_q_ind.j_name;
    sqlstm.sqinds[4] = (         int  )0;
    sqlstm.sqharm[4] = (unsigned int  )0;
    sqlstm.sqadto[4] = (unsigned short )0;
    sqlstm.sqtdso[4] = (unsigned short )0;
    sqlstm.sqhstv[5] = (         void  *)step_q.date_time_started;
    sqlstm.sqhstl[5] = (unsigned int  )15;
    sqlstm.sqhsts[5] = (         int  )0;
    sqlstm.sqindv[5] = (         void  *)&step_q_ind.time_started;
    sqlstm.sqinds[5] = (         int  )0;
    sqlstm.sqharm[5] = (unsigned int  )0;
    sqlstm.sqadto[5] = (unsigned short )0;
    sqlstm.sqtdso[5] = (unsigned short )0;
    sqlstm.sqhstv[6] = (         void  *)step_q.date_time_completed;
    sqlstm.sqhstl[6] = (unsigned int  )15;
    sqlstm.sqhsts[6] = (         int  )0;
    sqlstm.sqindv[6] = (         void  *)&step_q_ind.time_completed;
    sqlstm.sqinds[6] = (         int  )0;
    sqlstm.sqharm[6] = (unsigned int  )0;
    sqlstm.sqadto[6] = (unsigned short )0;
    sqlstm.sqtdso[6] = (unsigned short )0;
    sqlstm.sqhstv[7] = (         void  *)&step_q.exit_code;
    sqlstm.sqhstl[7] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[7] = (         int  )0;
    sqlstm.sqindv[7] = (         void  *)&step_q_ind.exit_code;
    sqlstm.sqinds[7] = (         int  )0;
    sqlstm.sqharm[7] = (unsigned int  )0;
    sqlstm.sqadto[7] = (unsigned short )0;
    sqlstm.sqtdso[7] = (unsigned short )0;
    sqlstm.sqhstv[8] = (         void  *)step_q.command_line;
    sqlstm.sqhstl[8] = (unsigned int  )140;
    sqlstm.sqhsts[8] = (         int  )0;
    sqlstm.sqindv[8] = (         void  *)&step_q_ind.command_line;
    sqlstm.sqinds[8] = (         int  )0;
    sqlstm.sqharm[8] = (unsigned int  )0;
    sqlstm.sqadto[8] = (unsigned short )0;
    sqlstm.sqtdso[8] = (unsigned short )0;
    sqlstm.sqhstv[9] = (         void  *)&step_q.num_d;
    sqlstm.sqhstl[9] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[9] = (         int  )0;
    sqlstm.sqindv[9] = (         void  *)&step_q_ind.num_d;
    sqlstm.sqinds[9] = (         int  )0;
    sqlstm.sqharm[9] = (unsigned int  )0;
    sqlstm.sqadto[9] = (unsigned short )0;
    sqlstm.sqtdso[9] = (unsigned short )0;
    sqlstm.sqhstv[10] = (         void  *)step_q.d_step;
    sqlstm.sqhstl[10] = (unsigned int  )180;
    sqlstm.sqhsts[10] = (         int  )0;
    sqlstm.sqindv[10] = (         void  *)&step_q_ind.d_step;
    sqlstm.sqinds[10] = (         int  )0;
    sqlstm.sqharm[10] = (unsigned int  )0;
    sqlstm.sqadto[10] = (unsigned short )0;
    sqlstm.sqtdso[10] = (unsigned short )0;
    sqlstm.sqhstv[11] = (         void  *)step_q.d_cmplt;
    sqlstm.sqhstl[11] = (unsigned int  )20;
    sqlstm.sqhsts[11] = (         int  )0;
    sqlstm.sqindv[11] = (         void  *)&step_q_ind.d_cmplt;
    sqlstm.sqinds[11] = (         int  )0;
    sqlstm.sqharm[11] = (unsigned int  )0;
    sqlstm.sqadto[11] = (unsigned short )0;
    sqlstm.sqtdso[11] = (unsigned short )0;
    sqlstm.sqhstv[12] = (         void  *)step_q.d_last_tested;
    sqlstm.sqhstl[12] = (unsigned int  )200;
    sqlstm.sqhsts[12] = (         int  )0;
    sqlstm.sqindv[12] = (         void  *)&step_q_ind.d_last_tested;
    sqlstm.sqinds[12] = (         int  )0;
    sqlstm.sqharm[12] = (unsigned int  )0;
    sqlstm.sqadto[12] = (unsigned short )0;
    sqlstm.sqtdso[12] = (unsigned short )0;
    sqlstm.sqhstv[13] = (         void  *)&step_q.num_a;
    sqlstm.sqhstl[13] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[13] = (         int  )0;
    sqlstm.sqindv[13] = (         void  *)&step_q_ind.num_a;
    sqlstm.sqinds[13] = (         int  )0;
    sqlstm.sqharm[13] = (unsigned int  )0;
    sqlstm.sqadto[13] = (unsigned short )0;
    sqlstm.sqtdso[13] = (unsigned short )0;
    sqlstm.sqhstv[14] = (         void  *)step_q.exit_codes_acceptable;
    sqlstm.sqhstl[14] = (unsigned int  )100;
    sqlstm.sqhsts[14] = (         int  )0;
    sqlstm.sqindv[14] = (         void  *)&step_q_ind.exit_codes_acceptable;
    sqlstm.sqinds[14] = (         int  )0;
    sqlstm.sqharm[14] = (unsigned int  )0;
    sqlstm.sqadto[14] = (unsigned short )0;
    sqlstm.sqtdso[14] = (unsigned short )0;
    sqlstm.sqhstv[15] = (         void  *)step_q.job_machine;
    sqlstm.sqhstl[15] = (unsigned int  )10;
    sqlstm.sqhsts[15] = (         int  )0;
    sqlstm.sqindv[15] = (         void  *)&step_q_ind.job_machine;
    sqlstm.sqinds[15] = (         int  )0;
    sqlstm.sqharm[15] = (unsigned int  )0;
    sqlstm.sqadto[15] = (unsigned short )0;
    sqlstm.sqtdso[15] = (unsigned short )0;
    sqlstm.sqhstv[16] = (         void  *)step_q.d_group;
    sqlstm.sqhstl[16] = (unsigned int  )21;
    sqlstm.sqhsts[16] = (         int  )0;
    sqlstm.sqindv[16] = (         void  *)&step_q_ind.d_group;
    sqlstm.sqinds[16] = (         int  )0;
    sqlstm.sqharm[16] = (unsigned int  )0;
    sqlstm.sqadto[16] = (unsigned short )0;
    sqlstm.sqtdso[16] = (unsigned short )0;
    sqlstm.sqhstv[17] = (         void  *)step_q.group_name;
    sqlstm.sqhstl[17] = (unsigned int  )10;
    sqlstm.sqhsts[17] = (         int  )0;
    sqlstm.sqindv[17] = (         void  *)&step_q_ind.group_name;
    sqlstm.sqinds[17] = (         int  )0;
    sqlstm.sqharm[17] = (unsigned int  )0;
    sqlstm.sqadto[17] = (unsigned short )0;
    sqlstm.sqtdso[17] = (unsigned short )0;
    sqlstm.sqhstv[18] = (         void  *)step_q.same_machine_flag_yn;
    sqlstm.sqhstl[18] = (unsigned int  )2;
    sqlstm.sqhsts[18] = (         int  )0;
    sqlstm.sqindv[18] = (         void  *)&step_q_ind.same_machine_flag_yn;
    sqlstm.sqinds[18] = (         int  )0;
    sqlstm.sqharm[18] = (unsigned int  )0;
    sqlstm.sqadto[18] = (unsigned short )0;
    sqlstm.sqtdso[18] = (unsigned short )0;
    sqlstm.sqhstv[19] = (         void  *)step_q.group_first_step_yn;
    sqlstm.sqhstl[19] = (unsigned int  )2;
    sqlstm.sqhsts[19] = (         int  )0;
    sqlstm.sqindv[19] = (         void  *)&step_q_ind.group_first_step_yn;
    sqlstm.sqinds[19] = (         int  )0;
    sqlstm.sqharm[19] = (unsigned int  )0;
    sqlstm.sqadto[19] = (unsigned short )0;
    sqlstm.sqtdso[19] = (unsigned short )0;
    sqlstm.sqhstv[20] = (         void  *)step_q.skip_yn;
    sqlstm.sqhstl[20] = (unsigned int  )2;
    sqlstm.sqhsts[20] = (         int  )0;
    sqlstm.sqindv[20] = (         void  *)&step_q_ind.skip_yn;
    sqlstm.sqinds[20] = (         int  )0;
    sqlstm.sqharm[20] = (unsigned int  )0;
    sqlstm.sqadto[20] = (unsigned short )0;
    sqlstm.sqtdso[20] = (unsigned short )0;
    sqlstm.sqhstv[21] = (         void  *)step_q.beg_console_msg;
    sqlstm.sqhstl[21] = (unsigned int  )81;
    sqlstm.sqhsts[21] = (         int  )0;
    sqlstm.sqindv[21] = (         void  *)&step_q_ind.beg_console_msg;
    sqlstm.sqinds[21] = (         int  )0;
    sqlstm.sqharm[21] = (unsigned int  )0;
    sqlstm.sqadto[21] = (unsigned short )0;
    sqlstm.sqtdso[21] = (unsigned short )0;
    sqlstm.sqhstv[22] = (         void  *)step_q.beg_suspend_yn;
    sqlstm.sqhstl[22] = (unsigned int  )2;
    sqlstm.sqhsts[22] = (         int  )0;
    sqlstm.sqindv[22] = (         void  *)&step_q_ind.beg_suspend_yn;
    sqlstm.sqinds[22] = (         int  )0;
    sqlstm.sqharm[22] = (unsigned int  )0;
    sqlstm.sqadto[22] = (unsigned short )0;
    sqlstm.sqtdso[22] = (unsigned short )0;
    sqlstm.sqhstv[23] = (         void  *)step_q.end_console_msg;
    sqlstm.sqhstl[23] = (unsigned int  )81;
    sqlstm.sqhsts[23] = (         int  )0;
    sqlstm.sqindv[23] = (         void  *)&step_q_ind.end_console_msg;
    sqlstm.sqinds[23] = (         int  )0;
    sqlstm.sqharm[23] = (unsigned int  )0;
    sqlstm.sqadto[23] = (unsigned short )0;
    sqlstm.sqtdso[23] = (unsigned short )0;
    sqlstm.sqhstv[24] = (         void  *)step_q.end_suspend_yn;
    sqlstm.sqhstl[24] = (unsigned int  )2;
    sqlstm.sqhsts[24] = (         int  )0;
    sqlstm.sqindv[24] = (         void  *)&step_q_ind.end_suspend_yn;
    sqlstm.sqinds[24] = (         int  )0;
    sqlstm.sqharm[24] = (unsigned int  )0;
    sqlstm.sqadto[24] = (unsigned short )0;
    sqlstm.sqtdso[24] = (unsigned short )0;
    sqlstm.sqhstv[25] = (         void  *)step_q.send_msg;
    sqlstm.sqhstl[25] = (unsigned int  )81;
    sqlstm.sqhsts[25] = (         int  )0;
    sqlstm.sqindv[25] = (         void  *)&step_q_ind.send_msg;
    sqlstm.sqinds[25] = (         int  )0;
    sqlstm.sqharm[25] = (unsigned int  )0;
    sqlstm.sqadto[25] = (unsigned short )0;
    sqlstm.sqtdso[25] = (unsigned short )0;
    sqlstm.sqhstv[26] = (         void  *)step_q.run_if_error;
    sqlstm.sqhstl[26] = (unsigned int  )65;
    sqlstm.sqhsts[26] = (         int  )0;
    sqlstm.sqindv[26] = (         void  *)&step_q_ind.run_if_error;
    sqlstm.sqinds[26] = (         int  )0;
    sqlstm.sqharm[26] = (unsigned int  )0;
    sqlstm.sqadto[26] = (unsigned short )0;
    sqlstm.sqtdso[26] = (unsigned short )0;
    sqlstm.sqhstv[27] = (         void  *)&step_q.status_interval;
    sqlstm.sqhstl[27] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[27] = (         int  )0;
    sqlstm.sqindv[27] = (         void  *)&step_q_ind.status_interval;
    sqlstm.sqinds[27] = (         int  )0;
    sqlstm.sqharm[27] = (unsigned int  )0;
    sqlstm.sqadto[27] = (unsigned short )0;
    sqlstm.sqtdso[27] = (unsigned short )0;
    sqlstm.sqphsv = sqlstm.sqhstv;
    sqlstm.sqphsl = sqlstm.sqhstl;
    sqlstm.sqphss = sqlstm.sqhsts;
    sqlstm.sqpind = sqlstm.sqindv;
    sqlstm.sqpins = sqlstm.sqinds;
    sqlstm.sqparm = sqlstm.sqharm;
    sqlstm.sqparc = sqlstm.sqharc;
    sqlstm.sqpadto = sqlstm.sqadto;
    sqlstm.sqptdso = sqlstm.sqtdso;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



				l_sqlcode = sqlca.sqlcode;
				strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
				LeaveCriticalSection(&jsnt_sql_lock);


				if (l_sqlcode == ORCL_NOT_FOUND)
				{
					debug_log("No more steps for job");
					break;
				}

				if (l_sqlcode != ORCL_NO_ERROR)
				{
					ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
								"active_step_curs", sqlmsg, "STEPQ table", NULL);
					_ltoa((DWORD) __LINE__, sznum, 10);
					_itoa(l_sqlcode, szret, 10);
					copy_cat(szbuff,"Fetch Cursor for active_step_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=",
								szret, " ", sqlmsg, NULL);
					//sprintf(szbuff, "Fetch Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
					//			"active_step_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
					logit (0, szbuff);
					debug_log (szbuff);
					EnterCriticalSection(&jsnt_sql_lock);

					/* EXEC SQL CLOSE active_step_curs; */ 

{
     struct sqlexd sqlstm;
     sqlstm.sqlvsn = 13;
     sqlstm.arrsiz = 51;
     sqlstm.sqladtp = &sqladt;
     sqlstm.sqltdsp = &sqltds;
     sqlstm.iters = (unsigned int  )1;
     sqlstm.offset = (unsigned int  )1305;
     sqlstm.cud = sqlcud0;
     sqlstm.sqlest = (unsigned char  *)&sqlca;
     sqlstm.sqlety = (unsigned short)4352;
     sqlstm.occurs = (unsigned int  )0;
     sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
					/* EXEC SQL CLOSE active_job_curs; */ 

{
     struct sqlexd sqlstm;
     sqlstm.sqlvsn = 13;
     sqlstm.arrsiz = 51;
     sqlstm.sqladtp = &sqladt;
     sqlstm.sqltdsp = &sqltds;
     sqlstm.iters = (unsigned int  )1;
     sqlstm.offset = (unsigned int  )1320;
     sqlstm.cud = sqlcud0;
     sqlstm.sqlest = (unsigned char  *)&sqlca;
     sqlstm.sqlety = (unsigned short)4352;
     sqlstm.occurs = (unsigned int  )0;
     sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
					LeaveCriticalSection(&jsnt_sql_lock);

					return(-1);
				}

				trim_sql_stepq(&step_q);
 
			}

			s_first_time = 0;

			if(step_q.no != job_q.no) 
			{
				debug_log("No more steps for job");
				break;
			}

			copy_cat(szbuff, "Checking active step ", step_q.s_name, NULL);
			//sprintf(szbuff, "Checking active step %s",step_q.s_name);
			debug_log(szbuff);


 
			if(step_q.status[0] != 'N' ) 
 
			{
				debug_log("Step skipped because it is not waiting to execute");
					continue;
			}
			
			/* Check Step Dependencies */
			status = test_s_dep();
			if(status == 1)
			{
				s_dep = 1;
				debug_log("A step dependency still exists");
				continue;      /* A step dependency still exists */   
			}
			else
			{
				if(status != 0)
				{
 
					EnterCriticalSection(&jsnt_sql_lock);

					/* EXEC SQL CLOSE active_job_curs; */ 

{
     struct sqlexd sqlstm;
     sqlstm.sqlvsn = 13;
     sqlstm.arrsiz = 51;
     sqlstm.sqladtp = &sqladt;
     sqlstm.sqltdsp = &sqltds;
     sqlstm.iters = (unsigned int  )1;
     sqlstm.offset = (unsigned int  )1335;
     sqlstm.cud = sqlcud0;
     sqlstm.sqlest = (unsigned char  *)&sqlca;
     sqlstm.sqlety = (unsigned short)4352;
     sqlstm.occurs = (unsigned int  )0;
     sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
					/* EXEC SQL CLOSE active_step_curs; */ 

{
     struct sqlexd sqlstm;
     sqlstm.sqlvsn = 13;
     sqlstm.arrsiz = 51;
     sqlstm.sqladtp = &sqladt;
     sqlstm.sqltdsp = &sqltds;
     sqlstm.iters = (unsigned int  )1;
     sqlstm.offset = (unsigned int  )1350;
     sqlstm.cud = sqlcud0;
     sqlstm.sqlest = (unsigned char  *)&sqlca;
     sqlstm.sqlety = (unsigned short)4352;
     sqlstm.occurs = (unsigned int  )0;
     sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
					LeaveCriticalSection(&jsnt_sql_lock);

 
					return(-1);
				}
			}
						
			if(same_group_job > 0) 
			{
				if(strcmp(same_machine_group_name, step_q.group_name) != 0) 
				{
					same_group_job=0;
					same_machine_group_name[0] = 0;
				}
			}

			/* Check group same machine dependency */
			trimr(step_q.group_name);
			if(strlen(step_q.group_name) > 0) 
			{


 
				if( (step_q.same_machine_flag_yn[0]=='Y') && (step_q.group_first_step_yn[0] == 'Y') ) 
 
				{
					same_group_job = job_q.no;
					strcpy(same_machine_group_name, step_q.group_name);
				}
			}


 
			last_step = step_q.step;
			strcpy((char*)last_s_name, step_q.s_name);
			strcpy((char*)last_g_name, step_q.group_name);


	   		// Try to Lock the row for updating up to 10 times before Erroring out.
			EnterCriticalSection(&jsnt_sql_lock);

			//for(tries=0; tries < LOCK_TRIES; tries++)
			//{
				/* EXEC SQL SELECT 
					status,
					pos,
					name
				INTO :job_status, :job_pos, :job_name
				FROM JOBQ
				WHERE name = :job_q.name
				AND   no   = :job_q.no
				FOR UPDATE; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.stmt = "select status ,pos ,name into :b0,:b1,:b2  from JOBQ wher\
e (name=:b3 and no=:b4) for update ";
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )1365;
    sqlstm.selerr = (unsigned short)1;
    sqlstm.sqlpfmem = (unsigned int  )0;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlstm.sqhstv[0] = (         void  *)job_status;
    sqlstm.sqhstl[0] = (unsigned int  )2;
    sqlstm.sqhsts[0] = (         int  )0;
    sqlstm.sqindv[0] = (         void  *)0;
    sqlstm.sqinds[0] = (         int  )0;
    sqlstm.sqharm[0] = (unsigned int  )0;
    sqlstm.sqadto[0] = (unsigned short )0;
    sqlstm.sqtdso[0] = (unsigned short )0;
    sqlstm.sqhstv[1] = (         void  *)&job_pos;
    sqlstm.sqhstl[1] = (unsigned int  )sizeof(long);
    sqlstm.sqhsts[1] = (         int  )0;
    sqlstm.sqindv[1] = (         void  *)0;
    sqlstm.sqinds[1] = (         int  )0;
    sqlstm.sqharm[1] = (unsigned int  )0;
    sqlstm.sqadto[1] = (unsigned short )0;
    sqlstm.sqtdso[1] = (unsigned short )0;
    sqlstm.sqhstv[2] = (         void  *)job_name;
    sqlstm.sqhstl[2] = (unsigned int  )10;
    sqlstm.sqhsts[2] = (         int  )0;
    sqlstm.sqindv[2] = (         void  *)0;
    sqlstm.sqinds[2] = (         int  )0;
    sqlstm.sqharm[2] = (unsigned int  )0;
    sqlstm.sqadto[2] = (unsigned short )0;
    sqlstm.sqtdso[2] = (unsigned short )0;
    sqlstm.sqhstv[3] = (         void  *)(job_q.name);
    sqlstm.sqhstl[3] = (unsigned int  )10;
    sqlstm.sqhsts[3] = (         int  )0;
    sqlstm.sqindv[3] = (         void  *)0;
    sqlstm.sqinds[3] = (         int  )0;
    sqlstm.sqharm[3] = (unsigned int  )0;
    sqlstm.sqadto[3] = (unsigned short )0;
    sqlstm.sqtdso[3] = (unsigned short )0;
    sqlstm.sqhstv[4] = (         void  *)&(job_q.no);
    sqlstm.sqhstl[4] = (unsigned int  )sizeof(long);
    sqlstm.sqhsts[4] = (         int  )0;
    sqlstm.sqindv[4] = (         void  *)0;
    sqlstm.sqinds[4] = (         int  )0;
    sqlstm.sqharm[4] = (unsigned int  )0;
    sqlstm.sqadto[4] = (unsigned short )0;
    sqlstm.sqtdso[4] = (unsigned short )0;
    sqlstm.sqphsv = sqlstm.sqhstv;
    sqlstm.sqphsl = sqlstm.sqhstl;
    sqlstm.sqphss = sqlstm.sqhsts;
    sqlstm.sqpind = sqlstm.sqindv;
    sqlstm.sqpins = sqlstm.sqinds;
    sqlstm.sqparm = sqlstm.sqharm;
    sqlstm.sqparc = sqlstm.sqharc;
    sqlstm.sqpadto = sqlstm.sqadto;
    sqlstm.sqptdso = sqlstm.sqtdso;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


				//FOR UPDATE NOWAIT;

				l_sqlcode = sqlca.sqlcode;
					
				if (l_sqlcode != ORCL_NO_ERROR)
				{
			//		if(tries < LOCK_TRIES)
			//			Sleep(1000);
			//		else
			//		{
						/* EXEC SQL CLOSE active_step_curs; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 51;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )1400;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
						/* EXEC SQL CLOSE active_job_curs; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 51;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )1415;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
						strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
						LeaveCriticalSection(&jsnt_sql_lock);

						ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
									"JOBQ", sqlmsg, "For Update", NULL);
						_itoa(l_sqlcode, szret, 10);
						copy_cat(szbuff, "Error selecting JOBQ for Update - sqlca.sqlcode=", 
									szret, sqlmsg, NULL);
						//sprintf (szbuff, "Error selecting JOBQ for Update - sqlca.sqlcode=%d, %s", 
						//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
						logit (0, szbuff);
						debug_log (szbuff);
						return -1;
			//		} 
				}
			//	break;
			//}


			/* EXEC SQL UPDATE JOBQ
				SET last_step = :last_step,
					last_s_name = :last_s_name,
					last_g_name = :last_g_name
				WHERE name = :job_q.name
				AND   no   = :job_q.no; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 51;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "update JOBQ  set last_step=:b0,last_s_name=:b1,last_g_name\
=:b2 where (name=:b3 and no=:b4)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )1430;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)&last_step;
   sqlstm.sqhstl[0] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)last_s_name;
   sqlstm.sqhstl[1] = (unsigned int  )10;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)last_g_name;
   sqlstm.sqhstl[2] = (unsigned int  )10;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)(job_q.name);
   sqlstm.sqhstl[3] = (unsigned int  )10;
   sqlstm.sqhsts[3] = (         int  )0;
   sqlstm.sqindv[3] = (         void  *)0;
   sqlstm.sqinds[3] = (         int  )0;
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqhstv[4] = (         void  *)&(job_q.no);
   sqlstm.sqhstl[4] = (unsigned int  )sizeof(long);
   sqlstm.sqhsts[4] = (         int  )0;
   sqlstm.sqindv[4] = (         void  *)0;
   sqlstm.sqinds[4] = (         int  )0;
   sqlstm.sqharm[4] = (unsigned int  )0;
   sqlstm.sqadto[4] = (unsigned short )0;
   sqlstm.sqtdso[4] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



			l_sqlcode = sqlca.sqlcode;
	
			if(l_sqlcode != ORCL_NO_ERROR)
			{
				strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
				/* EXEC SQL CLOSE active_step_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )1465;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
				/* EXEC SQL CLOSE active_job_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )1480;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
				/* EXEC SQL ROLLBACK; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )1495;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


				LeaveCriticalSection(&jsnt_sql_lock);
				ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
								"JOBQ", sqlmsg, " ", NULL);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff,"Error during UPDATE of JOBQ table - SQLCA.SQLCODE=",
							szret, " ", sqlmsg, NULL);
				//sprintf(szbuff, "Error during UPDATE of JOBQ table - SQLCA.SQLCODE=%d, %s", 
				//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
				logit (0, szbuff);
				debug_log(szbuff);
				return -1;
			}
			

			/* EXEC SQL COMMIT; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 51;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )1510;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


			l_sqlcode = sqlca.sqlcode;

			if (l_sqlcode != ORCL_NO_ERROR)
			{
				strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
				/* EXEC SQL ROLLBACK; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )1525;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


				/* EXEC SQL CLOSE active_step_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )1540;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
				/* EXEC SQL CLOSE active_job_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )1555;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
				LeaveCriticalSection(&jsnt_sql_lock);

				ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
							"JOBQ", sqlmsg, " ", NULL);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff,"ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=",
							szret, " ", sqlmsg, NULL);
				//sprintf(szbuff, "ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=%d, %s", 
				//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
				logit (0, szbuff);
				debug_log(szbuff);
				return -1;
			}

			LeaveCriticalSection(&jsnt_sql_lock);

 

			return(1);        /* We found a step to process */
		}

		if(s_dep == 0)          /* Job Has Finished */
		{
			debug_log("Job has finished - closing job");
			if(close_job() != 0)
			{
 
				EnterCriticalSection(&jsnt_sql_lock);

				/* EXEC SQL CLOSE active_step_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )1570;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
				/* EXEC SQL CLOSE active_job_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )1585;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
				LeaveCriticalSection(&jsnt_sql_lock);

 
				return(-1);
			}
		}
	}

 
	EnterCriticalSection(&jsnt_sql_lock);

	/* EXEC SQL CLOSE active_step_curs; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 51;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )1600;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
	/* EXEC SQL CLOSE active_job_curs; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 51;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )1615;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 
	LeaveCriticalSection(&jsnt_sql_lock);

 

	return(0);              /* No Active Jobs Found */
}


/********************* check_waiting ***************************
*                                                              *
* Description: This function checks the waiting job queue for  *
*  jobs to process.                                            *
*                                                              *
*  Returns values:											   *
*  SUCCESS	- No jobs waiting.								   *
*  ERR      - Error checking for jobs waiting                  *
*  (1)      - Job is waiting, and has been started             *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
* Modifiy Date:  07/29/99        By: Mike West                 *
* Modifiy Date:  17/Apr/2000 By: Sasidhar D & Sabari Girish J  *
* Description: Added code for priority checking				   *
*                                                              *
***************************************************************/
int check_waiting(void) 
{
	short int status=0;
	short int first_time=1;
	char szbuff[300];
	int l_sqlcode;
	char szret[10];
	char sznum[20];
	char sqlmsg[80];

	// WR27164 - Hamsha
	char szcode[10];
	char tempstr[500];

 
	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		short l_rownum;
		long l_count;
		char  l_rowid[ROWS][19];
		char  job_server[10];
		char js_group[10]; // WR27164 - Hamsha
	/* EXEC SQL END DECLARE SECTION; */ 

	
 
 
/* First, check to see if there are any rows there that are Ready & with priority 1 */
	strcpy(job_server, szjsname);

	EnterCriticalSection(&jsnt_sql_lock);

// Added for WR27164 on 02/14/2005 - Hamsha

	trimlr(job_server);
	memset(js_group,'\0',sizeof(js_group));

	/* EXEC SQL 
		SELECT trim(jsgroup) 
        INTO   :js_group
		FROM   JOB_SERVER_GROUPS
		WHERE  trim(STATION) = :job_server; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 51;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = "select trim(jsgroup) into :b0  from JOB_SERVER_GROUPS where \
trim(STATION)=:b1";
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )1630;
 sqlstm.selerr = (unsigned short)1;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqhstv[0] = (         void  *)js_group;
 sqlstm.sqhstl[0] = (unsigned int  )10;
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)job_server;
 sqlstm.sqhstl[1] = (unsigned int  )10;
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


	
	l_sqlcode = sqlca.sqlcode;

	LeaveCriticalSection(&jsnt_sql_lock);

	if( (l_sqlcode != ORCL_NO_ERROR) &&  (l_sqlcode != ORCL_NOT_FOUND) )
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
				"JOB_SERVER_GROUPS", sqlmsg, "JS_GROUP", NULL);
		_itoa(l_sqlcode, szcode, 10);
		copy_cat(tempstr, "Error during SELECT FROM JOB_SERVER_GROUPS table - SQLCA.SQLCODE=",
				szcode, sqlmsg, NULL);
		logit (0, tempstr);
		debug_log(tempstr);
		return ERR;

	}
	
	if (l_sqlcode == ORCL_NOT_FOUND)
		memset(js_group, 0x00, sizeof(js_group));

	trimlr(js_group);

// End - Hamsha

	EnterCriticalSection(&jsnt_sql_lock);

   /* EXEC SQL SELECT rowid 
      INTO :l_rowid[0]
      FROM   JOBQ

// Modified for WR27164 on 02/14/2005 - Hamsha

//    WHERE status = 'R' 
//	  AND   (station is NULL OR station = :job_server)
//    AND   priority = 1 
//	  AND pos >= 0;
	   
	  WHERE status = 'R' 
		AND   ((station is NULL and jsgroup is NULL)
		OR  ( TRIM(station) = :job_server )  
		OR  ( TRIM(jsgroup) = :js_group ))
		AND   priority = 1 
		AND pos >= 0; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 51;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select rowid into :b0  from JOBQ where (((status='R' and (\
((station is null  and jsgroup is null ) or trim(station)=:b1) or trim(jsgroup\
)=:b2)) and priority=1) and pos>=0)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )1653;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)l_rowid[0];
   sqlstm.sqhstl[0] = (unsigned int  )19;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)job_server;
   sqlstm.sqhstl[1] = (unsigned int  )10;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)js_group;
   sqlstm.sqhstl[2] = (unsigned int  )10;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



// End - Hamsha


   l_sqlcode = sqlca.sqlcode;
   l_count = sqlca.sqlerrd[2];		// returns how many rows were found
	
	LeaveCriticalSection(&jsnt_sql_lock);

/* if no record found with priority 1, then process sequentially */
	if( l_sqlcode == ORCL_NOT_FOUND )
	{
      EnterCriticalSection(&jsnt_sql_lock);

      /* EXEC SQL DECLARE ready_job_curs CURSOR FOR 
         SELECT rowid 
         FROM   JOBQ

// Modified for WR27164 on 02/14/2005 - Hamsha

//       WHERE status = 'R' 
//  	    AND   (station is NULL OR station = :job_server)
//          AND pos >= 0;


		 WHERE status = 'R' 
			AND   ((station is NULL and jsgroup is NULL)
			OR  ( TRIM(station) = :job_server )  
			OR  ( TRIM(jsgroup) = :js_group ))
			AND pos >= 0
			order by no	; */ 
//KLK WR 27164 - jobs were not being processed in order they were entered into jobq;

// End - Hamsha

		// Open ready_job_curs cursor
		/* EXEC SQL OPEN ready_job_curs; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 51;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.stmt = sq0018;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )1680;
  sqlstm.selerr = (unsigned short)0;
  sqlstm.sqlpfmem = (unsigned int  )0;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlstm.sqcmod = (unsigned int )0;
  sqlstm.sqhstv[0] = (         void  *)job_server;
  sqlstm.sqhstl[0] = (unsigned int  )10;
  sqlstm.sqhsts[0] = (         int  )0;
  sqlstm.sqindv[0] = (         void  *)0;
  sqlstm.sqinds[0] = (         int  )0;
  sqlstm.sqharm[0] = (unsigned int  )0;
  sqlstm.sqadto[0] = (unsigned short )0;
  sqlstm.sqtdso[0] = (unsigned short )0;
  sqlstm.sqhstv[1] = (         void  *)js_group;
  sqlstm.sqhstl[1] = (unsigned int  )10;
  sqlstm.sqhsts[1] = (         int  )0;
  sqlstm.sqindv[1] = (         void  *)0;
  sqlstm.sqinds[1] = (         int  )0;
  sqlstm.sqharm[1] = (unsigned int  )0;
  sqlstm.sqadto[1] = (unsigned short )0;
  sqlstm.sqtdso[1] = (unsigned short )0;
  sqlstm.sqphsv = sqlstm.sqhstv;
  sqlstm.sqphsl = sqlstm.sqhstl;
  sqlstm.sqphss = sqlstm.sqhsts;
  sqlstm.sqpind = sqlstm.sqindv;
  sqlstm.sqpins = sqlstm.sqinds;
  sqlstm.sqparm = sqlstm.sqharm;
  sqlstm.sqparc = sqlstm.sqharc;
  sqlstm.sqpadto = sqlstm.sqadto;
  sqlstm.sqptdso = sqlstm.sqtdso;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



		l_sqlcode = sqlca.sqlcode;
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		LeaveCriticalSection(&jsnt_sql_lock);


		if (l_sqlcode != ORCL_NO_ERROR)
		{
			ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"ready_job_curs", sqlmsg, "JOBQ table", NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"Open Cursor for ready_job_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=",
						szret, " ",sqlmsg, NULL);
			//sprintf(szbuff, "Open Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
			//			"ready_job_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log (szbuff);
			return(ERR);
		}

		// Fetch up to 100 rowid's from the JOBQ table
		EnterCriticalSection(&jsnt_sql_lock);

		/* EXEC SQL FETCH ready_job_curs INTO :l_rowid; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 51;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )100;
  sqlstm.offset = (unsigned int  )1703;
  sqlstm.selerr = (unsigned short)0;
  sqlstm.sqlpfmem = (unsigned int  )0;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlstm.sqfoff = (           int )0;
  sqlstm.sqfmod = (unsigned int )2;
  sqlstm.sqhstv[0] = (         void  *)l_rowid;
  sqlstm.sqhstl[0] = (unsigned int  )19;
  sqlstm.sqhsts[0] = (         int  )19;
  sqlstm.sqindv[0] = (         void  *)0;
  sqlstm.sqinds[0] = (         int  )0;
  sqlstm.sqharm[0] = (unsigned int  )0;
  sqlstm.sqharc[0] = (unsigned int   *)0;
  sqlstm.sqadto[0] = (unsigned short )0;
  sqlstm.sqtdso[0] = (unsigned short )0;
  sqlstm.sqphsv = sqlstm.sqhstv;
  sqlstm.sqphsl = sqlstm.sqhstl;
  sqlstm.sqphss = sqlstm.sqhsts;
  sqlstm.sqpind = sqlstm.sqindv;
  sqlstm.sqpins = sqlstm.sqinds;
  sqlstm.sqparm = sqlstm.sqharm;
  sqlstm.sqparc = sqlstm.sqharc;
  sqlstm.sqpadto = sqlstm.sqadto;
  sqlstm.sqptdso = sqlstm.sqtdso;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



		l_sqlcode = sqlca.sqlcode;
		l_count = sqlca.sqlerrd[2];		// returns how many rows were found
		
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

		//LeaveCriticalSection(&jsnt_sql_lock); //KLK 2002-045

		if (l_sqlcode == ORCL_NOT_FOUND && l_count == 0)
		{
			debug_log("No ready files");
			/* EXEC SQL CLOSE ready_job_curs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 51;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )1722;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

			//KLK 2002-045
			LeaveCriticalSection(&jsnt_sql_lock);	//KLK 2002-045
			return(SUCCESS);
		}

		if (l_sqlcode != ORCL_NO_ERROR && l_count == 0)
		{
			ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"ready_job_curs", sqlmsg, "JOBQ table", NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"Fetch Cursor for ready_job_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=", 
						szret, " ", sqlmsg, NULL);
			//sprintf(szbuff, "Fetch Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
			//			"ready_job_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log (szbuff);
			/* EXEC SQL CLOSE ready_job_curs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 51;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )1737;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

			//KLK 2002-045
			LeaveCriticalSection(&jsnt_sql_lock);	//KLK 2002-045
			return(ERR);
		}

		LeaveCriticalSection(&jsnt_sql_lock); //KLK 2002-045
	}



	// If there are rows, then perform them row by row
	for(l_rownum=0; l_rownum < l_count; l_rownum++)
	{


		memset(&job_q, 0, sizeof(job_q) );

		EnterCriticalSection(&jsnt_sql_lock);

		/* EXEC SQL 
	   	  SELECT 
			status,
			pos,
			name,
			no,
			station,
			date_time_entered,
			date_time_started,
			date_time_completed,
			exit_code,
			station_submitting,
			msg_when_started,
			msg_when_done,
			multi_processing,
			date_time_to_start,
			start_stat,
			must_complete_by,
			c_msg_sent_yn,
			must_start_by,
			s_msg_sent_yn,
			msg_to_operator_yn,
			msg_to,
			priority,
			stn_started,
			num_d,
			d_job,
			d_hrs_back,
			d_cmplt,
			d_last_tested,
			orig_start_stat,
			job_suspended,
			restart,
			job_class,
			base_dir,
			max_job_time_warn,
			debug_mode_yn,
			last_step,
			last_s_name,
			last_g_name,
			submitted_file_name,
			p_msg_sent_yn,
			max_job_time_kill,
			max_c_msg_yn,
			stn_dependancy_yn,
			no_fail_message_yn,
			msg_when_failed,
			spawn_algorithm,
			spawn_parm,
			d_station,
			jsgroup   // WR27164 - Hamsha
		INTO :job_q:job_q_ind
		FROM JOBQ
		WHERE rowid = :l_rowid[l_rownum]
		FOR UPDATE; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 51;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlbuft(&g_ctx,
    "select status ,pos ,name ,no ,station ,date_time_entered ,date_time_sta\
rted ,date_time_completed ,exit_code ,station_submitting ,msg_when_started ,\
msg_when_done ,multi_processing ,date_time_to_start ,start_stat ,must_comple\
te_by ,c_msg_sent_yn ,must_start_by ,s_msg_sent_yn ,msg_to_operator_yn ,msg_\
to ,priority ,stn_started ,num_d ,d_job ,d_hrs_back ,d_cmplt ,d_last_tested \
,orig_start_stat ,job_suspended ,restart ,job_class ,base_dir ,max_job_time_\
warn ,debug_mode_yn ,last_step ,last_s_name ,last_g_name ,submitted_file_nam\
e ,p_msg_sent_yn ,max_job_time_kill ,max_c_msg_yn ,stn_dependancy_yn ,no_fai\
l_message_yn ,msg_when_failed ,spawn_algorithm ,spawn_parm ,d_station ,jsgro\
up into :s1:s2 ,:s3:s4 ,:s5:s6 ,:s7:s8 ,:s9:s10 ,:s11:s12 ,:s13:s14 ,:s15:s1\
6 ,:s17:s18 ,:s19:s20 ,:s21:s22 ,:s23:s24 ,:s25:s26 ,:s27:s28 ,:s29:s30 ,:s3\
1:s32 ,:s33:s34 ,:s35:s36 ,:s37:s38 ,:s39:s40 ,:s41:s42 ,:s43:s44 ,:s45:s46 \
,:s47:s48 ,:s49:s50 ,:s51:s52 ,:s53:s54 ,:s55:s56 ,:s57:s58 ,:s59:s60 ,:s61:\
s62 ,:s63:s64 ,:s65:s66 ,:s67:s68 ,:s69:s");
  sqlstm.stmt = "70 ,:s71:s72 ,:s73:s74 ,:s75:s76 ,:s77:s78 ,:s79:s80 ,:s81:\
s82 ,:s83:s84 ,:s85:s86 ,:s87:s88 ,:s89:s90 ,:s91:s92 ,:s93:s94 ,:s95:s96 ,:s9\
7:s98   from JOBQ where rowid=:b2 for update ";
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )1752;
  sqlstm.selerr = (unsigned short)1;
  sqlstm.sqlpfmem = (unsigned int  )0;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlstm.sqhstv[0] = (         void  *)job_q.status;
  sqlstm.sqhstl[0] = (unsigned int  )2;
  sqlstm.sqhsts[0] = (         int  )0;
  sqlstm.sqindv[0] = (         void  *)&job_q_ind.status;
  sqlstm.sqinds[0] = (         int  )0;
  sqlstm.sqharm[0] = (unsigned int  )0;
  sqlstm.sqadto[0] = (unsigned short )0;
  sqlstm.sqtdso[0] = (unsigned short )0;
  sqlstm.sqhstv[1] = (         void  *)&job_q.pos;
  sqlstm.sqhstl[1] = (unsigned int  )sizeof(long);
  sqlstm.sqhsts[1] = (         int  )0;
  sqlstm.sqindv[1] = (         void  *)&job_q_ind.pos;
  sqlstm.sqinds[1] = (         int  )0;
  sqlstm.sqharm[1] = (unsigned int  )0;
  sqlstm.sqadto[1] = (unsigned short )0;
  sqlstm.sqtdso[1] = (unsigned short )0;
  sqlstm.sqhstv[2] = (         void  *)job_q.name;
  sqlstm.sqhstl[2] = (unsigned int  )10;
  sqlstm.sqhsts[2] = (         int  )0;
  sqlstm.sqindv[2] = (         void  *)&job_q_ind.name;
  sqlstm.sqinds[2] = (         int  )0;
  sqlstm.sqharm[2] = (unsigned int  )0;
  sqlstm.sqadto[2] = (unsigned short )0;
  sqlstm.sqtdso[2] = (unsigned short )0;
  sqlstm.sqhstv[3] = (         void  *)&job_q.no;
  sqlstm.sqhstl[3] = (unsigned int  )sizeof(long);
  sqlstm.sqhsts[3] = (         int  )0;
  sqlstm.sqindv[3] = (         void  *)&job_q_ind.no;
  sqlstm.sqinds[3] = (         int  )0;
  sqlstm.sqharm[3] = (unsigned int  )0;
  sqlstm.sqadto[3] = (unsigned short )0;
  sqlstm.sqtdso[3] = (unsigned short )0;
  sqlstm.sqhstv[4] = (         void  *)job_q.station;
  sqlstm.sqhstl[4] = (unsigned int  )10;
  sqlstm.sqhsts[4] = (         int  )0;
  sqlstm.sqindv[4] = (         void  *)&job_q_ind.station;
  sqlstm.sqinds[4] = (         int  )0;
  sqlstm.sqharm[4] = (unsigned int  )0;
  sqlstm.sqadto[4] = (unsigned short )0;
  sqlstm.sqtdso[4] = (unsigned short )0;
  sqlstm.sqhstv[5] = (         void  *)job_q.date_time_entered;
  sqlstm.sqhstl[5] = (unsigned int  )15;
  sqlstm.sqhsts[5] = (         int  )0;
  sqlstm.sqindv[5] = (         void  *)&job_q_ind.time_entered;
  sqlstm.sqinds[5] = (         int  )0;
  sqlstm.sqharm[5] = (unsigned int  )0;
  sqlstm.sqadto[5] = (unsigned short )0;
  sqlstm.sqtdso[5] = (unsigned short )0;
  sqlstm.sqhstv[6] = (         void  *)job_q.date_time_started;
  sqlstm.sqhstl[6] = (unsigned int  )15;
  sqlstm.sqhsts[6] = (         int  )0;
  sqlstm.sqindv[6] = (         void  *)&job_q_ind.time_started;
  sqlstm.sqinds[6] = (         int  )0;
  sqlstm.sqharm[6] = (unsigned int  )0;
  sqlstm.sqadto[6] = (unsigned short )0;
  sqlstm.sqtdso[6] = (unsigned short )0;
  sqlstm.sqhstv[7] = (         void  *)job_q.date_time_completed;
  sqlstm.sqhstl[7] = (unsigned int  )15;
  sqlstm.sqhsts[7] = (         int  )0;
  sqlstm.sqindv[7] = (         void  *)&job_q_ind.time_completed;
  sqlstm.sqinds[7] = (         int  )0;
  sqlstm.sqharm[7] = (unsigned int  )0;
  sqlstm.sqadto[7] = (unsigned short )0;
  sqlstm.sqtdso[7] = (unsigned short )0;
  sqlstm.sqhstv[8] = (         void  *)&job_q.exit_code;
  sqlstm.sqhstl[8] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[8] = (         int  )0;
  sqlstm.sqindv[8] = (         void  *)&job_q_ind.exit_code;
  sqlstm.sqinds[8] = (         int  )0;
  sqlstm.sqharm[8] = (unsigned int  )0;
  sqlstm.sqadto[8] = (unsigned short )0;
  sqlstm.sqtdso[8] = (unsigned short )0;
  sqlstm.sqhstv[9] = (         void  *)job_q.station_submitting;
  sqlstm.sqhstl[9] = (unsigned int  )2;
  sqlstm.sqhsts[9] = (         int  )0;
  sqlstm.sqindv[9] = (         void  *)&job_q_ind.station_submitting;
  sqlstm.sqinds[9] = (         int  )0;
  sqlstm.sqharm[9] = (unsigned int  )0;
  sqlstm.sqadto[9] = (unsigned short )0;
  sqlstm.sqtdso[9] = (unsigned short )0;
  sqlstm.sqhstv[10] = (         void  *)job_q.msg_when_started;
  sqlstm.sqhstl[10] = (unsigned int  )2;
  sqlstm.sqhsts[10] = (         int  )0;
  sqlstm.sqindv[10] = (         void  *)&job_q_ind.msg_when_started;
  sqlstm.sqinds[10] = (         int  )0;
  sqlstm.sqharm[10] = (unsigned int  )0;
  sqlstm.sqadto[10] = (unsigned short )0;
  sqlstm.sqtdso[10] = (unsigned short )0;
  sqlstm.sqhstv[11] = (         void  *)job_q.msg_when_done;
  sqlstm.sqhstl[11] = (unsigned int  )2;
  sqlstm.sqhsts[11] = (         int  )0;
  sqlstm.sqindv[11] = (         void  *)&job_q_ind.msg_when_done;
  sqlstm.sqinds[11] = (         int  )0;
  sqlstm.sqharm[11] = (unsigned int  )0;
  sqlstm.sqadto[11] = (unsigned short )0;
  sqlstm.sqtdso[11] = (unsigned short )0;
  sqlstm.sqhstv[12] = (         void  *)job_q.multi_processing;
  sqlstm.sqhstl[12] = (unsigned int  )2;
  sqlstm.sqhsts[12] = (         int  )0;
  sqlstm.sqindv[12] = (         void  *)&job_q_ind.multi_processing;
  sqlstm.sqinds[12] = (         int  )0;
  sqlstm.sqharm[12] = (unsigned int  )0;
  sqlstm.sqadto[12] = (unsigned short )0;
  sqlstm.sqtdso[12] = (unsigned short )0;
  sqlstm.sqhstv[13] = (         void  *)job_q.date_time_to_start;
  sqlstm.sqhstl[13] = (unsigned int  )15;
  sqlstm.sqhsts[13] = (         int  )0;
  sqlstm.sqindv[13] = (         void  *)&job_q_ind.date_time_to_start;
  sqlstm.sqinds[13] = (         int  )0;
  sqlstm.sqharm[13] = (unsigned int  )0;
  sqlstm.sqadto[13] = (unsigned short )0;
  sqlstm.sqtdso[13] = (unsigned short )0;
  sqlstm.sqhstv[14] = (         void  *)&job_q.start_stat;
  sqlstm.sqhstl[14] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[14] = (         int  )0;
  sqlstm.sqindv[14] = (         void  *)&job_q_ind.start_stat;
  sqlstm.sqinds[14] = (         int  )0;
  sqlstm.sqharm[14] = (unsigned int  )0;
  sqlstm.sqadto[14] = (unsigned short )0;
  sqlstm.sqtdso[14] = (unsigned short )0;
  sqlstm.sqhstv[15] = (         void  *)job_q.must_complete_by;
  sqlstm.sqhstl[15] = (unsigned int  )5;
  sqlstm.sqhsts[15] = (         int  )0;
  sqlstm.sqindv[15] = (         void  *)&job_q_ind.must_complete_by;
  sqlstm.sqinds[15] = (         int  )0;
  sqlstm.sqharm[15] = (unsigned int  )0;
  sqlstm.sqadto[15] = (unsigned short )0;
  sqlstm.sqtdso[15] = (unsigned short )0;
  sqlstm.sqhstv[16] = (         void  *)job_q.c_msg_sent_yn;
  sqlstm.sqhstl[16] = (unsigned int  )2;
  sqlstm.sqhsts[16] = (         int  )0;
  sqlstm.sqindv[16] = (         void  *)&job_q_ind.c_msg_sent_yn;
  sqlstm.sqinds[16] = (         int  )0;
  sqlstm.sqharm[16] = (unsigned int  )0;
  sqlstm.sqadto[16] = (unsigned short )0;
  sqlstm.sqtdso[16] = (unsigned short )0;
  sqlstm.sqhstv[17] = (         void  *)job_q.must_start_by;
  sqlstm.sqhstl[17] = (unsigned int  )5;
  sqlstm.sqhsts[17] = (         int  )0;
  sqlstm.sqindv[17] = (         void  *)&job_q_ind.must_start_by;
  sqlstm.sqinds[17] = (         int  )0;
  sqlstm.sqharm[17] = (unsigned int  )0;
  sqlstm.sqadto[17] = (unsigned short )0;
  sqlstm.sqtdso[17] = (unsigned short )0;
  sqlstm.sqhstv[18] = (         void  *)job_q.s_msg_sent_yn;
  sqlstm.sqhstl[18] = (unsigned int  )2;
  sqlstm.sqhsts[18] = (         int  )0;
  sqlstm.sqindv[18] = (         void  *)&job_q_ind.s_msg_sent_yn;
  sqlstm.sqinds[18] = (         int  )0;
  sqlstm.sqharm[18] = (unsigned int  )0;
  sqlstm.sqadto[18] = (unsigned short )0;
  sqlstm.sqtdso[18] = (unsigned short )0;
  sqlstm.sqhstv[19] = (         void  *)job_q.msg_to_operator_yn;
  sqlstm.sqhstl[19] = (unsigned int  )2;
  sqlstm.sqhsts[19] = (         int  )0;
  sqlstm.sqindv[19] = (         void  *)&job_q_ind.msg_to_operator_yn;
  sqlstm.sqinds[19] = (         int  )0;
  sqlstm.sqharm[19] = (unsigned int  )0;
  sqlstm.sqadto[19] = (unsigned short )0;
  sqlstm.sqtdso[19] = (unsigned short )0;
  sqlstm.sqhstv[20] = (         void  *)job_q.msg_to;
  sqlstm.sqhstl[20] = (unsigned int  )31;
  sqlstm.sqhsts[20] = (         int  )0;
  sqlstm.sqindv[20] = (         void  *)&job_q_ind.msg_to;
  sqlstm.sqinds[20] = (         int  )0;
  sqlstm.sqharm[20] = (unsigned int  )0;
  sqlstm.sqadto[20] = (unsigned short )0;
  sqlstm.sqtdso[20] = (unsigned short )0;
  sqlstm.sqhstv[21] = (         void  *)&job_q.priority;
  sqlstm.sqhstl[21] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[21] = (         int  )0;
  sqlstm.sqindv[21] = (         void  *)&job_q_ind.priority;
  sqlstm.sqinds[21] = (         int  )0;
  sqlstm.sqharm[21] = (unsigned int  )0;
  sqlstm.sqadto[21] = (unsigned short )0;
  sqlstm.sqtdso[21] = (unsigned short )0;
  sqlstm.sqhstv[22] = (         void  *)job_q.stn_started;
  sqlstm.sqhstl[22] = (unsigned int  )10;
  sqlstm.sqhsts[22] = (         int  )0;
  sqlstm.sqindv[22] = (         void  *)&job_q_ind.stn_started;
  sqlstm.sqinds[22] = (         int  )0;
  sqlstm.sqharm[22] = (unsigned int  )0;
  sqlstm.sqadto[22] = (unsigned short )0;
  sqlstm.sqtdso[22] = (unsigned short )0;
  sqlstm.sqhstv[23] = (         void  *)&job_q.num_d;
  sqlstm.sqhstl[23] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[23] = (         int  )0;
  sqlstm.sqindv[23] = (         void  *)&job_q_ind.num_d;
  sqlstm.sqinds[23] = (         int  )0;
  sqlstm.sqharm[23] = (unsigned int  )0;
  sqlstm.sqadto[23] = (unsigned short )0;
  sqlstm.sqtdso[23] = (unsigned short )0;
  sqlstm.sqhstv[24] = (         void  *)job_q.d_job;
  sqlstm.sqhstl[24] = (unsigned int  )180;
  sqlstm.sqhsts[24] = (         int  )0;
  sqlstm.sqindv[24] = (         void  *)&job_q_ind.d_job;
  sqlstm.sqinds[24] = (         int  )0;
  sqlstm.sqharm[24] = (unsigned int  )0;
  sqlstm.sqadto[24] = (unsigned short )0;
  sqlstm.sqtdso[24] = (unsigned short )0;
  sqlstm.sqhstv[25] = (         void  *)job_q.d_hrs_back;
  sqlstm.sqhstl[25] = (unsigned int  )100;
  sqlstm.sqhsts[25] = (         int  )0;
  sqlstm.sqindv[25] = (         void  *)&job_q_ind.d_hrs_back;
  sqlstm.sqinds[25] = (         int  )0;
  sqlstm.sqharm[25] = (unsigned int  )0;
  sqlstm.sqadto[25] = (unsigned short )0;
  sqlstm.sqtdso[25] = (unsigned short )0;
  sqlstm.sqhstv[26] = (         void  *)job_q.d_cmplt;
  sqlstm.sqhstl[26] = (unsigned int  )20;
  sqlstm.sqhsts[26] = (         int  )0;
  sqlstm.sqindv[26] = (         void  *)&job_q_ind.d_cmplt;
  sqlstm.sqinds[26] = (         int  )0;
  sqlstm.sqharm[26] = (unsigned int  )0;
  sqlstm.sqadto[26] = (unsigned short )0;
  sqlstm.sqtdso[26] = (unsigned short )0;
  sqlstm.sqhstv[27] = (         void  *)job_q.d_last_tested;
  sqlstm.sqhstl[27] = (unsigned int  )200;
  sqlstm.sqhsts[27] = (         int  )0;
  sqlstm.sqindv[27] = (         void  *)&job_q_ind.d_last_tested;
  sqlstm.sqinds[27] = (         int  )0;
  sqlstm.sqharm[27] = (unsigned int  )0;
  sqlstm.sqadto[27] = (unsigned short )0;
  sqlstm.sqtdso[27] = (unsigned short )0;
  sqlstm.sqhstv[28] = (         void  *)&job_q.orig_start_stat;
  sqlstm.sqhstl[28] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[28] = (         int  )0;
  sqlstm.sqindv[28] = (         void  *)&job_q_ind.orig_start_stat;
  sqlstm.sqinds[28] = (         int  )0;
  sqlstm.sqharm[28] = (unsigned int  )0;
  sqlstm.sqadto[28] = (unsigned short )0;
  sqlstm.sqtdso[28] = (unsigned short )0;
  sqlstm.sqhstv[29] = (         void  *)job_q.job_suspended;
  sqlstm.sqhstl[29] = (unsigned int  )2;
  sqlstm.sqhsts[29] = (         int  )0;
  sqlstm.sqindv[29] = (         void  *)&job_q_ind.job_suspended;
  sqlstm.sqinds[29] = (         int  )0;
  sqlstm.sqharm[29] = (unsigned int  )0;
  sqlstm.sqadto[29] = (unsigned short )0;
  sqlstm.sqtdso[29] = (unsigned short )0;
  sqlstm.sqhstv[30] = (         void  *)job_q.restart;
  sqlstm.sqhstl[30] = (unsigned int  )9;
  sqlstm.sqhsts[30] = (         int  )0;
  sqlstm.sqindv[30] = (         void  *)&job_q_ind.restart;
  sqlstm.sqinds[30] = (         int  )0;
  sqlstm.sqharm[30] = (unsigned int  )0;
  sqlstm.sqadto[30] = (unsigned short )0;
  sqlstm.sqtdso[30] = (unsigned short )0;
  sqlstm.sqhstv[31] = (         void  *)job_q.job_class;
  sqlstm.sqhstl[31] = (unsigned int  )2;
  sqlstm.sqhsts[31] = (         int  )0;
  sqlstm.sqindv[31] = (         void  *)&job_q_ind.job_class;
  sqlstm.sqinds[31] = (         int  )0;
  sqlstm.sqharm[31] = (unsigned int  )0;
  sqlstm.sqadto[31] = (unsigned short )0;
  sqlstm.sqtdso[31] = (unsigned short )0;
  sqlstm.sqhstv[32] = (         void  *)job_q.base_dir;
  sqlstm.sqhstl[32] = (unsigned int  )81;
  sqlstm.sqhsts[32] = (         int  )0;
  sqlstm.sqindv[32] = (         void  *)&job_q_ind.base_dir;
  sqlstm.sqinds[32] = (         int  )0;
  sqlstm.sqharm[32] = (unsigned int  )0;
  sqlstm.sqadto[32] = (unsigned short )0;
  sqlstm.sqtdso[32] = (unsigned short )0;
  sqlstm.sqhstv[33] = (         void  *)&job_q.max_job_time_warn;
  sqlstm.sqhstl[33] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[33] = (         int  )0;
  sqlstm.sqindv[33] = (         void  *)&job_q_ind.max_job_time_warn;
  sqlstm.sqinds[33] = (         int  )0;
  sqlstm.sqharm[33] = (unsigned int  )0;
  sqlstm.sqadto[33] = (unsigned short )0;
  sqlstm.sqtdso[33] = (unsigned short )0;
  sqlstm.sqhstv[34] = (         void  *)job_q.debug_mode_yn;
  sqlstm.sqhstl[34] = (unsigned int  )2;
  sqlstm.sqhsts[34] = (         int  )0;
  sqlstm.sqindv[34] = (         void  *)&job_q_ind.debug_mode_yn;
  sqlstm.sqinds[34] = (         int  )0;
  sqlstm.sqharm[34] = (unsigned int  )0;
  sqlstm.sqadto[34] = (unsigned short )0;
  sqlstm.sqtdso[34] = (unsigned short )0;
  sqlstm.sqhstv[35] = (         void  *)&job_q.last_step;
  sqlstm.sqhstl[35] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[35] = (         int  )0;
  sqlstm.sqindv[35] = (         void  *)&job_q_ind.last_step;
  sqlstm.sqinds[35] = (         int  )0;
  sqlstm.sqharm[35] = (unsigned int  )0;
  sqlstm.sqadto[35] = (unsigned short )0;
  sqlstm.sqtdso[35] = (unsigned short )0;
  sqlstm.sqhstv[36] = (         void  *)job_q.last_s_name;
  sqlstm.sqhstl[36] = (unsigned int  )10;
  sqlstm.sqhsts[36] = (         int  )0;
  sqlstm.sqindv[36] = (         void  *)&job_q_ind.last_s_name;
  sqlstm.sqinds[36] = (         int  )0;
  sqlstm.sqharm[36] = (unsigned int  )0;
  sqlstm.sqadto[36] = (unsigned short )0;
  sqlstm.sqtdso[36] = (unsigned short )0;
  sqlstm.sqhstv[37] = (         void  *)job_q.last_g_name;
  sqlstm.sqhstl[37] = (unsigned int  )10;
  sqlstm.sqhsts[37] = (         int  )0;
  sqlstm.sqindv[37] = (         void  *)&job_q_ind.last_g_name;
  sqlstm.sqinds[37] = (         int  )0;
  sqlstm.sqharm[37] = (unsigned int  )0;
  sqlstm.sqadto[37] = (unsigned short )0;
  sqlstm.sqtdso[37] = (unsigned short )0;
  sqlstm.sqhstv[38] = (         void  *)job_q.submitted_file_name;
  sqlstm.sqhstl[38] = (unsigned int  )13;
  sqlstm.sqhsts[38] = (         int  )0;
  sqlstm.sqindv[38] = (         void  *)&job_q_ind.submitted_file_name;
  sqlstm.sqinds[38] = (         int  )0;
  sqlstm.sqharm[38] = (unsigned int  )0;
  sqlstm.sqadto[38] = (unsigned short )0;
  sqlstm.sqtdso[38] = (unsigned short )0;
  sqlstm.sqhstv[39] = (         void  *)job_q.p_msg_sent_yn;
  sqlstm.sqhstl[39] = (unsigned int  )2;
  sqlstm.sqhsts[39] = (         int  )0;
  sqlstm.sqindv[39] = (         void  *)&job_q_ind.p_msg_sent_yn;
  sqlstm.sqinds[39] = (         int  )0;
  sqlstm.sqharm[39] = (unsigned int  )0;
  sqlstm.sqadto[39] = (unsigned short )0;
  sqlstm.sqtdso[39] = (unsigned short )0;
  sqlstm.sqhstv[40] = (         void  *)&job_q.max_job_time_kill;
  sqlstm.sqhstl[40] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[40] = (         int  )0;
  sqlstm.sqindv[40] = (         void  *)&job_q_ind.max_job_time_kill;
  sqlstm.sqinds[40] = (         int  )0;
  sqlstm.sqharm[40] = (unsigned int  )0;
  sqlstm.sqadto[40] = (unsigned short )0;
  sqlstm.sqtdso[40] = (unsigned short )0;
  sqlstm.sqhstv[41] = (         void  *)job_q.max_c_msg_yn;
  sqlstm.sqhstl[41] = (unsigned int  )2;
  sqlstm.sqhsts[41] = (         int  )0;
  sqlstm.sqindv[41] = (         void  *)&job_q_ind.max_c_msg_yn;
  sqlstm.sqinds[41] = (         int  )0;
  sqlstm.sqharm[41] = (unsigned int  )0;
  sqlstm.sqadto[41] = (unsigned short )0;
  sqlstm.sqtdso[41] = (unsigned short )0;
  sqlstm.sqhstv[42] = (         void  *)job_q.stn_dependancy_yn;
  sqlstm.sqhstl[42] = (unsigned int  )2;
  sqlstm.sqhsts[42] = (         int  )0;
  sqlstm.sqindv[42] = (         void  *)&job_q_ind.stn_dependancy_yn;
  sqlstm.sqinds[42] = (         int  )0;
  sqlstm.sqharm[42] = (unsigned int  )0;
  sqlstm.sqadto[42] = (unsigned short )0;
  sqlstm.sqtdso[42] = (unsigned short )0;
  sqlstm.sqhstv[43] = (         void  *)job_q.no_fail_message_yn;
  sqlstm.sqhstl[43] = (unsigned int  )2;
  sqlstm.sqhsts[43] = (         int  )0;
  sqlstm.sqindv[43] = (         void  *)&job_q_ind.no_fail_message_yn;
  sqlstm.sqinds[43] = (         int  )0;
  sqlstm.sqharm[43] = (unsigned int  )0;
  sqlstm.sqadto[43] = (unsigned short )0;
  sqlstm.sqtdso[43] = (unsigned short )0;
  sqlstm.sqhstv[44] = (         void  *)job_q.msg_when_failed;
  sqlstm.sqhstl[44] = (unsigned int  )2;
  sqlstm.sqhsts[44] = (         int  )0;
  sqlstm.sqindv[44] = (         void  *)&job_q_ind.msg_when_failed;
  sqlstm.sqinds[44] = (         int  )0;
  sqlstm.sqharm[44] = (unsigned int  )0;
  sqlstm.sqadto[44] = (unsigned short )0;
  sqlstm.sqtdso[44] = (unsigned short )0;
  sqlstm.sqhstv[45] = (         void  *)&job_q.spawn_algorithm;
  sqlstm.sqhstl[45] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[45] = (         int  )0;
  sqlstm.sqindv[45] = (         void  *)&job_q_ind.spawn_algorithm;
  sqlstm.sqinds[45] = (         int  )0;
  sqlstm.sqharm[45] = (unsigned int  )0;
  sqlstm.sqadto[45] = (unsigned short )0;
  sqlstm.sqtdso[45] = (unsigned short )0;
  sqlstm.sqhstv[46] = (         void  *)&job_q.spawn_parm;
  sqlstm.sqhstl[46] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[46] = (         int  )0;
  sqlstm.sqindv[46] = (         void  *)&job_q_ind.spawn_parm;
  sqlstm.sqinds[46] = (         int  )0;
  sqlstm.sqharm[46] = (unsigned int  )0;
  sqlstm.sqadto[46] = (unsigned short )0;
  sqlstm.sqtdso[46] = (unsigned short )0;
  sqlstm.sqhstv[47] = (         void  *)job_q.d_station;
  sqlstm.sqhstl[47] = (unsigned int  )180;
  sqlstm.sqhsts[47] = (         int  )0;
  sqlstm.sqindv[47] = (         void  *)&job_q_ind.d_station;
  sqlstm.sqinds[47] = (         int  )0;
  sqlstm.sqharm[47] = (unsigned int  )0;
  sqlstm.sqadto[47] = (unsigned short )0;
  sqlstm.sqtdso[47] = (unsigned short )0;
  sqlstm.sqhstv[48] = (         void  *)job_q.jsgroup;
  sqlstm.sqhstl[48] = (unsigned int  )10;
  sqlstm.sqhsts[48] = (         int  )0;
  sqlstm.sqindv[48] = (         void  *)&job_q_ind.jsgroup;
  sqlstm.sqinds[48] = (         int  )0;
  sqlstm.sqharm[48] = (unsigned int  )0;
  sqlstm.sqadto[48] = (unsigned short )0;
  sqlstm.sqtdso[48] = (unsigned short )0;
  sqlstm.sqhstv[49] = (         void  *)l_rowid[l_rownum];
  sqlstm.sqhstl[49] = (unsigned int  )19;
  sqlstm.sqhsts[49] = (         int  )0;
  sqlstm.sqindv[49] = (         void  *)0;
  sqlstm.sqinds[49] = (         int  )0;
  sqlstm.sqharm[49] = (unsigned int  )0;
  sqlstm.sqadto[49] = (unsigned short )0;
  sqlstm.sqtdso[49] = (unsigned short )0;
  sqlstm.sqphsv = sqlstm.sqhstv;
  sqlstm.sqphsl = sqlstm.sqhstl;
  sqlstm.sqphss = sqlstm.sqhsts;
  sqlstm.sqpind = sqlstm.sqindv;
  sqlstm.sqpins = sqlstm.sqinds;
  sqlstm.sqparm = sqlstm.sqharm;
  sqlstm.sqparc = sqlstm.sqharc;
  sqlstm.sqpadto = sqlstm.sqadto;
  sqlstm.sqptdso = sqlstm.sqtdso;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



		l_sqlcode = sqlca.sqlcode;

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
				"JOBQ", sqlmsg, "no",	NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"Select Failed for JOBQ table on line ", sznum, " - SQLCA.SQLCODE=", 
							szret, " ", sqlmsg, NULL);
			//sprintf(szbuff, "Select Failed for %s on line %ld - SQLCA.SQLCODE=%d, %s", 
			//			"JOBQ table", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log (szbuff);
			return(ERR);
		}
		
		trim_sql_jobq(&job_q);	

		// We have to check this status because another job server may have
		// already picked up this job.
		if(job_q.status[0] == 'R')
		{
			copy_cat(szbuff, "Testing job ", job_q.name, NULL);
			//sprintf(szbuff, "Testing job %s", job_q.name);
			debug_log(szbuff);

			if (strlen(szjsclass) > 0) 
			{
				trimr(job_q.job_class);
				if (szjsclass[0] != job_q.job_class[0]) 
				{
					/* EXEC SQL ROLLBACK; */ 

{
     struct sqlexd sqlstm;
     sqlstm.sqlvsn = 13;
     sqlstm.arrsiz = 51;
     sqlstm.sqladtp = &sqladt;
     sqlstm.sqltdsp = &sqltds;
     sqlstm.iters = (unsigned int  )1;
     sqlstm.offset = (unsigned int  )1967;
     sqlstm.cud = sqlcud0;
     sqlstm.sqlest = (unsigned char  *)&sqlca;
     sqlstm.sqlety = (unsigned short)4352;
     sqlstm.occurs = (unsigned int  )0;
     sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


					LeaveCriticalSection(&jsnt_sql_lock);
					logit (0, "Job skipped because of class");
					debug_log("Job skipped because of class");
					continue;
				}
			}
	

			/* Make sure operator has released */
			if (job_q.start_stat == 2 || job_q.start_stat == 3) 
			{
				/* EXEC SQL ROLLBACK; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )1982;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


				LeaveCriticalSection(&jsnt_sql_lock);
				logit(0, "Operator has not released job");
				debug_log("Operator has not released job");
				continue;
			}
	
	
			/* Check Job depenencies */
			if (status = test_j_dep()) 
			{
				if (status == 1) 
				{
					/* EXEC SQL ROLLBACK; */ 

{
     struct sqlexd sqlstm;
     sqlstm.sqlvsn = 13;
     sqlstm.arrsiz = 51;
     sqlstm.sqladtp = &sqladt;
     sqlstm.sqltdsp = &sqltds;
     sqlstm.iters = (unsigned int  )1;
     sqlstm.offset = (unsigned int  )1997;
     sqlstm.cud = sqlcud0;
     sqlstm.sqlest = (unsigned char  *)&sqlca;
     sqlstm.sqlety = (unsigned short)4352;
     sqlstm.occurs = (unsigned int  )0;
     sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


					LeaveCriticalSection(&jsnt_sql_lock);
					logit(0, "A job dependency still exists");
					debug_log("A job dependency still exists");
					continue;      /* A job dependency still exists */
				}
				/* EXEC SQL ROLLBACK; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )2012;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


				/* EXEC SQL CLOSE ready_job_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )2027;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


				LeaveCriticalSection(&jsnt_sql_lock);

				return ERR;
			}
				
			/* Check station dependency */
			trimr((char*)job_q.station);
			if(strlen((char*)job_q.station) > 0) 
			{
				if(strcmp(szjsname, (char*)job_q.station) != 0) 
				{
					/* EXEC SQL ROLLBACK; */ 

{
     struct sqlexd sqlstm;
     sqlstm.sqlvsn = 13;
     sqlstm.arrsiz = 51;
     sqlstm.sqladtp = &sqladt;
     sqlstm.sqltdsp = &sqltds;
     sqlstm.iters = (unsigned int  )1;
     sqlstm.offset = (unsigned int  )2042;
     sqlstm.cud = sqlcud0;
     sqlstm.sqlest = (unsigned char  *)&sqlca;
     sqlstm.sqlety = (unsigned short)4352;
     sqlstm.occurs = (unsigned int  )0;
     sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


					LeaveCriticalSection(&jsnt_sql_lock);
					debug_log("Job not started because of station dependency");
					continue;
				}
			}
						
			debug_log ("Starting job");
			// if status = 1, another job server is running this job, 
			// if status <> 0, some other error happened
			if (status = start_job (l_rowid[l_rownum]) )  
			{
				/* EXEC SQL ROLLBACK; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )2057;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


				/* EXEC SQL CLOSE ready_job_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )2072;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


				LeaveCriticalSection(&jsnt_sql_lock);
				if (status==1) break;	/* Somebody else beat us to is, nothing to do now */
				return ERR;				/* Or - Serious error - get out */
			}
			else
			{
				/* EXEC SQL CLOSE ready_job_curs; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 51;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )2087;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 //KLK 2002-045
				LeaveCriticalSection(&jsnt_sql_lock);
				return (1);			// Else, we found a JOB to run, return */
			}
		}	// end of if(job_q.status[0] == 'R')

		/* EXEC SQL ROLLBACK; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 51;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )2102;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


		LeaveCriticalSection(&jsnt_sql_lock);
	}	// end of for loop

	// Nothing to do, close cursor
	EnterCriticalSection(&jsnt_sql_lock);
	/* EXEC SQL CLOSE ready_job_curs; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 51;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2117;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


	LeaveCriticalSection(&jsnt_sql_lock);


 



	return SUCCESS;
}


/************************ start_job ****************************
*                                                              *
* Description: This function sets up information in the step   *
*  and job queue records in order to start the job.            *
*                                                              *
* Called from check_waiting() function.                        *
*                                                              *
*  Return values:                                              *
*  SUCCESS - Job was started successfully.                     *
*  ERR     - An error occurred while trying to start the job.  *
*  (1)     - Another JSNT grabbed the job & started it before  *
*            we could get ahold of it.                         *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
* Modifiy Date:  12/26/96        By: Andrew Bartels            *
*                                                              *
***************************************************************/
int start_job (char *rowid) 
{
   short int status=0;
   short int start_step=1;
   short int set_drive;
   char szbuff[300];
   //short int tries;
   int   l_sqlcode;
   char  szret[20];
   char  sznum[10];
   char  sqlmsg[80];


 
	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		short int start_step_no=1;
		//char job_status[2];
		//long job_pos;
		//unsigned char job_name[10];
		char lcl_rowid[25];
	/* EXEC SQL END DECLARE SECTION; */ 

 

	trimr(job_q.base_dir);
	if (strlen (job_q.base_dir) > 0) 
	{
		_getcwd (curr_dir, _MAX_PATH);   /* get current path  */
		curr_drive = _getdrive ();      /* get current drive */

		if(job_q.base_dir[1] == ':') 
		{
			set_drive = job_q.base_dir[0] - 'A' + 1;
			_chdrive(set_drive);      /* change to the base drive */
		}

		_chdir(job_q.base_dir);         /* change to the base directory */
		base_dir_job = job_q.no;
	}


 
   strcpy(job_q.status, "A");
   if (job_q.multi_processing[0] == '0') 
   {
      strcpy((char*)job_q.station, szjsname);
      base_dir_job = job_q.no;
   }

   strcpy(job_q.stn_dependancy_yn, "Y");

   if(get_system_date_time(job_q.date_time_started) != SUCCESS)
      return(ERR);
 


   /* Temporary Fix to keep job running */
   /* job on job server it started on  KLK 8/11/99 */
   strcpy ((char*)job_q.station, szjsname);
   strcpy ((char*)job_q.stn_started, szjsname); /* update record with server name */

   

 
	memset(&step_q, 0, sizeof(step_q) );

	// NOTE: We don't need to do a critical section here because
	//       this function is called from check_waiting() which
	//       is already doing the critical section for us.
	/* EXEC SQL SELECT 
		no,
		step,
		s_name,
		status,
		j_name,
		date_time_started,
		date_time_completed,
		exit_code,
		command_line,
		num_d,
		d_step,
		d_cmplt,
		d_last_tested,
		num_a,
		exit_codes_acceptable,
		job_machine,
		d_group,
		group_name,
		same_machine_flag_yn,
		group_first_step_yn,
		skip_yn,
		beg_console_msg,
		beg_suspend_yn,
		end_console_msg,
		end_suspend_yn,
		send_msg,
		run_if_error,
		status_interval
	INTO :step_q:step_q_ind
	FROM STEPQ
	WHERE no = :job_q.no
	AND   step = :start_step_no; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 51;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = "select no ,step ,s_name ,status ,j_name ,date_time_started ,\
date_time_completed ,exit_code ,command_line ,num_d ,d_step ,d_cmplt ,d_last_t\
ested ,num_a ,exit_codes_acceptable ,job_machine ,d_group ,group_name ,same_ma\
chine_flag_yn ,group_first_step_yn ,skip_yn ,beg_console_msg ,beg_suspend_yn ,\
end_console_msg ,end_suspend_yn ,send_msg ,run_if_error ,status_interval into \
:s1:s2 ,:s3:s4 ,:s5:s6 ,:s7:s8 ,:s9:s10 ,:s11:s12 ,:s13:s14 ,:s15:s16 ,:s17:s1\
8 ,:s19:s20 ,:s21:s22 ,:s23:s24 ,:s25:s26 ,:s27:s28 ,:s29:s30 ,:s31:s32 ,:s33:\
s34 ,:s35:s36 ,:s37:s38 ,:s39:s40 ,:s41:s42 ,:s43:s44 ,:s45:s46 ,:s47:s48 ,:s4\
9:s50 ,:s51:s52 ,:s53:s54 ,:s55:s56   from STEPQ where (no=:b2 and step=:b3)";
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2132;
 sqlstm.selerr = (unsigned short)1;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqhstv[0] = (         void  *)&step_q.no;
 sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)&step_q_ind.no;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)&step_q.step;
 sqlstm.sqhstl[1] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)&step_q_ind.step;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqhstv[2] = (         void  *)step_q.s_name;
 sqlstm.sqhstl[2] = (unsigned int  )10;
 sqlstm.sqhsts[2] = (         int  )0;
 sqlstm.sqindv[2] = (         void  *)&step_q_ind.s_name;
 sqlstm.sqinds[2] = (         int  )0;
 sqlstm.sqharm[2] = (unsigned int  )0;
 sqlstm.sqadto[2] = (unsigned short )0;
 sqlstm.sqtdso[2] = (unsigned short )0;
 sqlstm.sqhstv[3] = (         void  *)step_q.status;
 sqlstm.sqhstl[3] = (unsigned int  )2;
 sqlstm.sqhsts[3] = (         int  )0;
 sqlstm.sqindv[3] = (         void  *)&step_q_ind.status;
 sqlstm.sqinds[3] = (         int  )0;
 sqlstm.sqharm[3] = (unsigned int  )0;
 sqlstm.sqadto[3] = (unsigned short )0;
 sqlstm.sqtdso[3] = (unsigned short )0;
 sqlstm.sqhstv[4] = (         void  *)step_q.j_name;
 sqlstm.sqhstl[4] = (unsigned int  )10;
 sqlstm.sqhsts[4] = (         int  )0;
 sqlstm.sqindv[4] = (         void  *)&step_q_ind.j_name;
 sqlstm.sqinds[4] = (         int  )0;
 sqlstm.sqharm[4] = (unsigned int  )0;
 sqlstm.sqadto[4] = (unsigned short )0;
 sqlstm.sqtdso[4] = (unsigned short )0;
 sqlstm.sqhstv[5] = (         void  *)step_q.date_time_started;
 sqlstm.sqhstl[5] = (unsigned int  )15;
 sqlstm.sqhsts[5] = (         int  )0;
 sqlstm.sqindv[5] = (         void  *)&step_q_ind.time_started;
 sqlstm.sqinds[5] = (         int  )0;
 sqlstm.sqharm[5] = (unsigned int  )0;
 sqlstm.sqadto[5] = (unsigned short )0;
 sqlstm.sqtdso[5] = (unsigned short )0;
 sqlstm.sqhstv[6] = (         void  *)step_q.date_time_completed;
 sqlstm.sqhstl[6] = (unsigned int  )15;
 sqlstm.sqhsts[6] = (         int  )0;
 sqlstm.sqindv[6] = (         void  *)&step_q_ind.time_completed;
 sqlstm.sqinds[6] = (         int  )0;
 sqlstm.sqharm[6] = (unsigned int  )0;
 sqlstm.sqadto[6] = (unsigned short )0;
 sqlstm.sqtdso[6] = (unsigned short )0;
 sqlstm.sqhstv[7] = (         void  *)&step_q.exit_code;
 sqlstm.sqhstl[7] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[7] = (         int  )0;
 sqlstm.sqindv[7] = (         void  *)&step_q_ind.exit_code;
 sqlstm.sqinds[7] = (         int  )0;
 sqlstm.sqharm[7] = (unsigned int  )0;
 sqlstm.sqadto[7] = (unsigned short )0;
 sqlstm.sqtdso[7] = (unsigned short )0;
 sqlstm.sqhstv[8] = (         void  *)step_q.command_line;
 sqlstm.sqhstl[8] = (unsigned int  )140;
 sqlstm.sqhsts[8] = (         int  )0;
 sqlstm.sqindv[8] = (         void  *)&step_q_ind.command_line;
 sqlstm.sqinds[8] = (         int  )0;
 sqlstm.sqharm[8] = (unsigned int  )0;
 sqlstm.sqadto[8] = (unsigned short )0;
 sqlstm.sqtdso[8] = (unsigned short )0;
 sqlstm.sqhstv[9] = (         void  *)&step_q.num_d;
 sqlstm.sqhstl[9] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[9] = (         int  )0;
 sqlstm.sqindv[9] = (         void  *)&step_q_ind.num_d;
 sqlstm.sqinds[9] = (         int  )0;
 sqlstm.sqharm[9] = (unsigned int  )0;
 sqlstm.sqadto[9] = (unsigned short )0;
 sqlstm.sqtdso[9] = (unsigned short )0;
 sqlstm.sqhstv[10] = (         void  *)step_q.d_step;
 sqlstm.sqhstl[10] = (unsigned int  )180;
 sqlstm.sqhsts[10] = (         int  )0;
 sqlstm.sqindv[10] = (         void  *)&step_q_ind.d_step;
 sqlstm.sqinds[10] = (         int  )0;
 sqlstm.sqharm[10] = (unsigned int  )0;
 sqlstm.sqadto[10] = (unsigned short )0;
 sqlstm.sqtdso[10] = (unsigned short )0;
 sqlstm.sqhstv[11] = (         void  *)step_q.d_cmplt;
 sqlstm.sqhstl[11] = (unsigned int  )20;
 sqlstm.sqhsts[11] = (         int  )0;
 sqlstm.sqindv[11] = (         void  *)&step_q_ind.d_cmplt;
 sqlstm.sqinds[11] = (         int  )0;
 sqlstm.sqharm[11] = (unsigned int  )0;
 sqlstm.sqadto[11] = (unsigned short )0;
 sqlstm.sqtdso[11] = (unsigned short )0;
 sqlstm.sqhstv[12] = (         void  *)step_q.d_last_tested;
 sqlstm.sqhstl[12] = (unsigned int  )200;
 sqlstm.sqhsts[12] = (         int  )0;
 sqlstm.sqindv[12] = (         void  *)&step_q_ind.d_last_tested;
 sqlstm.sqinds[12] = (         int  )0;
 sqlstm.sqharm[12] = (unsigned int  )0;
 sqlstm.sqadto[12] = (unsigned short )0;
 sqlstm.sqtdso[12] = (unsigned short )0;
 sqlstm.sqhstv[13] = (         void  *)&step_q.num_a;
 sqlstm.sqhstl[13] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[13] = (         int  )0;
 sqlstm.sqindv[13] = (         void  *)&step_q_ind.num_a;
 sqlstm.sqinds[13] = (         int  )0;
 sqlstm.sqharm[13] = (unsigned int  )0;
 sqlstm.sqadto[13] = (unsigned short )0;
 sqlstm.sqtdso[13] = (unsigned short )0;
 sqlstm.sqhstv[14] = (         void  *)step_q.exit_codes_acceptable;
 sqlstm.sqhstl[14] = (unsigned int  )100;
 sqlstm.sqhsts[14] = (         int  )0;
 sqlstm.sqindv[14] = (         void  *)&step_q_ind.exit_codes_acceptable;
 sqlstm.sqinds[14] = (         int  )0;
 sqlstm.sqharm[14] = (unsigned int  )0;
 sqlstm.sqadto[14] = (unsigned short )0;
 sqlstm.sqtdso[14] = (unsigned short )0;
 sqlstm.sqhstv[15] = (         void  *)step_q.job_machine;
 sqlstm.sqhstl[15] = (unsigned int  )10;
 sqlstm.sqhsts[15] = (         int  )0;
 sqlstm.sqindv[15] = (         void  *)&step_q_ind.job_machine;
 sqlstm.sqinds[15] = (         int  )0;
 sqlstm.sqharm[15] = (unsigned int  )0;
 sqlstm.sqadto[15] = (unsigned short )0;
 sqlstm.sqtdso[15] = (unsigned short )0;
 sqlstm.sqhstv[16] = (         void  *)step_q.d_group;
 sqlstm.sqhstl[16] = (unsigned int  )21;
 sqlstm.sqhsts[16] = (         int  )0;
 sqlstm.sqindv[16] = (         void  *)&step_q_ind.d_group;
 sqlstm.sqinds[16] = (         int  )0;
 sqlstm.sqharm[16] = (unsigned int  )0;
 sqlstm.sqadto[16] = (unsigned short )0;
 sqlstm.sqtdso[16] = (unsigned short )0;
 sqlstm.sqhstv[17] = (         void  *)step_q.group_name;
 sqlstm.sqhstl[17] = (unsigned int  )10;
 sqlstm.sqhsts[17] = (         int  )0;
 sqlstm.sqindv[17] = (         void  *)&step_q_ind.group_name;
 sqlstm.sqinds[17] = (         int  )0;
 sqlstm.sqharm[17] = (unsigned int  )0;
 sqlstm.sqadto[17] = (unsigned short )0;
 sqlstm.sqtdso[17] = (unsigned short )0;
 sqlstm.sqhstv[18] = (         void  *)step_q.same_machine_flag_yn;
 sqlstm.sqhstl[18] = (unsigned int  )2;
 sqlstm.sqhsts[18] = (         int  )0;
 sqlstm.sqindv[18] = (         void  *)&step_q_ind.same_machine_flag_yn;
 sqlstm.sqinds[18] = (         int  )0;
 sqlstm.sqharm[18] = (unsigned int  )0;
 sqlstm.sqadto[18] = (unsigned short )0;
 sqlstm.sqtdso[18] = (unsigned short )0;
 sqlstm.sqhstv[19] = (         void  *)step_q.group_first_step_yn;
 sqlstm.sqhstl[19] = (unsigned int  )2;
 sqlstm.sqhsts[19] = (         int  )0;
 sqlstm.sqindv[19] = (         void  *)&step_q_ind.group_first_step_yn;
 sqlstm.sqinds[19] = (         int  )0;
 sqlstm.sqharm[19] = (unsigned int  )0;
 sqlstm.sqadto[19] = (unsigned short )0;
 sqlstm.sqtdso[19] = (unsigned short )0;
 sqlstm.sqhstv[20] = (         void  *)step_q.skip_yn;
 sqlstm.sqhstl[20] = (unsigned int  )2;
 sqlstm.sqhsts[20] = (         int  )0;
 sqlstm.sqindv[20] = (         void  *)&step_q_ind.skip_yn;
 sqlstm.sqinds[20] = (         int  )0;
 sqlstm.sqharm[20] = (unsigned int  )0;
 sqlstm.sqadto[20] = (unsigned short )0;
 sqlstm.sqtdso[20] = (unsigned short )0;
 sqlstm.sqhstv[21] = (         void  *)step_q.beg_console_msg;
 sqlstm.sqhstl[21] = (unsigned int  )81;
 sqlstm.sqhsts[21] = (         int  )0;
 sqlstm.sqindv[21] = (         void  *)&step_q_ind.beg_console_msg;
 sqlstm.sqinds[21] = (         int  )0;
 sqlstm.sqharm[21] = (unsigned int  )0;
 sqlstm.sqadto[21] = (unsigned short )0;
 sqlstm.sqtdso[21] = (unsigned short )0;
 sqlstm.sqhstv[22] = (         void  *)step_q.beg_suspend_yn;
 sqlstm.sqhstl[22] = (unsigned int  )2;
 sqlstm.sqhsts[22] = (         int  )0;
 sqlstm.sqindv[22] = (         void  *)&step_q_ind.beg_suspend_yn;
 sqlstm.sqinds[22] = (         int  )0;
 sqlstm.sqharm[22] = (unsigned int  )0;
 sqlstm.sqadto[22] = (unsigned short )0;
 sqlstm.sqtdso[22] = (unsigned short )0;
 sqlstm.sqhstv[23] = (         void  *)step_q.end_console_msg;
 sqlstm.sqhstl[23] = (unsigned int  )81;
 sqlstm.sqhsts[23] = (         int  )0;
 sqlstm.sqindv[23] = (         void  *)&step_q_ind.end_console_msg;
 sqlstm.sqinds[23] = (         int  )0;
 sqlstm.sqharm[23] = (unsigned int  )0;
 sqlstm.sqadto[23] = (unsigned short )0;
 sqlstm.sqtdso[23] = (unsigned short )0;
 sqlstm.sqhstv[24] = (         void  *)step_q.end_suspend_yn;
 sqlstm.sqhstl[24] = (unsigned int  )2;
 sqlstm.sqhsts[24] = (         int  )0;
 sqlstm.sqindv[24] = (         void  *)&step_q_ind.end_suspend_yn;
 sqlstm.sqinds[24] = (         int  )0;
 sqlstm.sqharm[24] = (unsigned int  )0;
 sqlstm.sqadto[24] = (unsigned short )0;
 sqlstm.sqtdso[24] = (unsigned short )0;
 sqlstm.sqhstv[25] = (         void  *)step_q.send_msg;
 sqlstm.sqhstl[25] = (unsigned int  )81;
 sqlstm.sqhsts[25] = (         int  )0;
 sqlstm.sqindv[25] = (         void  *)&step_q_ind.send_msg;
 sqlstm.sqinds[25] = (         int  )0;
 sqlstm.sqharm[25] = (unsigned int  )0;
 sqlstm.sqadto[25] = (unsigned short )0;
 sqlstm.sqtdso[25] = (unsigned short )0;
 sqlstm.sqhstv[26] = (         void  *)step_q.run_if_error;
 sqlstm.sqhstl[26] = (unsigned int  )65;
 sqlstm.sqhsts[26] = (         int  )0;
 sqlstm.sqindv[26] = (         void  *)&step_q_ind.run_if_error;
 sqlstm.sqinds[26] = (         int  )0;
 sqlstm.sqharm[26] = (unsigned int  )0;
 sqlstm.sqadto[26] = (unsigned short )0;
 sqlstm.sqtdso[26] = (unsigned short )0;
 sqlstm.sqhstv[27] = (         void  *)&step_q.status_interval;
 sqlstm.sqhstl[27] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[27] = (         int  )0;
 sqlstm.sqindv[27] = (         void  *)&step_q_ind.status_interval;
 sqlstm.sqinds[27] = (         int  )0;
 sqlstm.sqharm[27] = (unsigned int  )0;
 sqlstm.sqadto[27] = (unsigned short )0;
 sqlstm.sqtdso[27] = (unsigned short )0;
 sqlstm.sqhstv[28] = (         void  *)&(job_q.no);
 sqlstm.sqhstl[28] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[28] = (         int  )0;
 sqlstm.sqindv[28] = (         void  *)0;
 sqlstm.sqinds[28] = (         int  )0;
 sqlstm.sqharm[28] = (unsigned int  )0;
 sqlstm.sqadto[28] = (unsigned short )0;
 sqlstm.sqtdso[28] = (unsigned short )0;
 sqlstm.sqhstv[29] = (         void  *)&start_step_no;
 sqlstm.sqhstl[29] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[29] = (         int  )0;
 sqlstm.sqindv[29] = (         void  *)0;
 sqlstm.sqinds[29] = (         int  )0;
 sqlstm.sqharm[29] = (unsigned int  )0;
 sqlstm.sqadto[29] = (unsigned short )0;
 sqlstm.sqtdso[29] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"STEPQ", sqlmsg, " ", NULL);
		//setxy(0,24);
		_itoa(l_sqlcode, szret, 10);
		_ltoa(job_q.no, sznum, 10);
		copy_cat(szbuff,"No Step 1 in Job ", sznum, " - sqlca.sqlcode=", 
					szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "No Step 1 in Job %ld - sqlca.sqlcode=%d, %s", 
		//			job_q.no, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (1, szbuff);
		debug_log(szbuff);
		return ERR;
	}

	trim_sql_stepq(&step_q);	

 
	

	while(step_q.num_d > 0)         /* while we have steps to run */
	{

 
		start_step_no++;

		memset(&step_q, 0, sizeof(step_q) );

		// NOTE: We don't need to do a critical section here because
		//       this function is called from check_waiting() which
		//       is already doing the critical section for us.
		/* EXEC SQL SELECT 
			no,
			step,
			s_name,
			status,
			j_name,
			date_time_started,
			date_time_completed,
			exit_code,
			command_line,
			num_d,
			d_step,
			d_cmplt,
			d_last_tested,
			num_a,
			exit_codes_acceptable,
			job_machine,
			d_group,
			group_name,
			same_machine_flag_yn,
			group_first_step_yn,
			skip_yn,
			beg_console_msg,
			beg_suspend_yn,
			end_console_msg,
			end_suspend_yn,
			send_msg,
			run_if_error,
			status_interval
		INTO :step_q:step_q_ind
		FROM STEPQ
		WHERE no = :job_q.no
		AND   step = :start_step_no; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 51;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.stmt = "select no ,step ,s_name ,status ,j_name ,date_time_started \
,date_time_completed ,exit_code ,command_line ,num_d ,d_step ,d_cmplt ,d_last_\
tested ,num_a ,exit_codes_acceptable ,job_machine ,d_group ,group_name ,same_m\
achine_flag_yn ,group_first_step_yn ,skip_yn ,beg_console_msg ,beg_suspend_yn \
,end_console_msg ,end_suspend_yn ,send_msg ,run_if_error ,status_interval into\
 :s1:s2 ,:s3:s4 ,:s5:s6 ,:s7:s8 ,:s9:s10 ,:s11:s12 ,:s13:s14 ,:s15:s16 ,:s17:s\
18 ,:s19:s20 ,:s21:s22 ,:s23:s24 ,:s25:s26 ,:s27:s28 ,:s29:s30 ,:s31:s32 ,:s33\
:s34 ,:s35:s36 ,:s37:s38 ,:s39:s40 ,:s41:s42 ,:s43:s44 ,:s45:s46 ,:s47:s48 ,:s\
49:s50 ,:s51:s52 ,:s53:s54 ,:s55:s56   from STEPQ where (no=:b2 and step=:b3)";
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )2267;
  sqlstm.selerr = (unsigned short)1;
  sqlstm.sqlpfmem = (unsigned int  )0;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlstm.sqhstv[0] = (         void  *)&step_q.no;
  sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
  sqlstm.sqhsts[0] = (         int  )0;
  sqlstm.sqindv[0] = (         void  *)&step_q_ind.no;
  sqlstm.sqinds[0] = (         int  )0;
  sqlstm.sqharm[0] = (unsigned int  )0;
  sqlstm.sqadto[0] = (unsigned short )0;
  sqlstm.sqtdso[0] = (unsigned short )0;
  sqlstm.sqhstv[1] = (         void  *)&step_q.step;
  sqlstm.sqhstl[1] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[1] = (         int  )0;
  sqlstm.sqindv[1] = (         void  *)&step_q_ind.step;
  sqlstm.sqinds[1] = (         int  )0;
  sqlstm.sqharm[1] = (unsigned int  )0;
  sqlstm.sqadto[1] = (unsigned short )0;
  sqlstm.sqtdso[1] = (unsigned short )0;
  sqlstm.sqhstv[2] = (         void  *)step_q.s_name;
  sqlstm.sqhstl[2] = (unsigned int  )10;
  sqlstm.sqhsts[2] = (         int  )0;
  sqlstm.sqindv[2] = (         void  *)&step_q_ind.s_name;
  sqlstm.sqinds[2] = (         int  )0;
  sqlstm.sqharm[2] = (unsigned int  )0;
  sqlstm.sqadto[2] = (unsigned short )0;
  sqlstm.sqtdso[2] = (unsigned short )0;
  sqlstm.sqhstv[3] = (         void  *)step_q.status;
  sqlstm.sqhstl[3] = (unsigned int  )2;
  sqlstm.sqhsts[3] = (         int  )0;
  sqlstm.sqindv[3] = (         void  *)&step_q_ind.status;
  sqlstm.sqinds[3] = (         int  )0;
  sqlstm.sqharm[3] = (unsigned int  )0;
  sqlstm.sqadto[3] = (unsigned short )0;
  sqlstm.sqtdso[3] = (unsigned short )0;
  sqlstm.sqhstv[4] = (         void  *)step_q.j_name;
  sqlstm.sqhstl[4] = (unsigned int  )10;
  sqlstm.sqhsts[4] = (         int  )0;
  sqlstm.sqindv[4] = (         void  *)&step_q_ind.j_name;
  sqlstm.sqinds[4] = (         int  )0;
  sqlstm.sqharm[4] = (unsigned int  )0;
  sqlstm.sqadto[4] = (unsigned short )0;
  sqlstm.sqtdso[4] = (unsigned short )0;
  sqlstm.sqhstv[5] = (         void  *)step_q.date_time_started;
  sqlstm.sqhstl[5] = (unsigned int  )15;
  sqlstm.sqhsts[5] = (         int  )0;
  sqlstm.sqindv[5] = (         void  *)&step_q_ind.time_started;
  sqlstm.sqinds[5] = (         int  )0;
  sqlstm.sqharm[5] = (unsigned int  )0;
  sqlstm.sqadto[5] = (unsigned short )0;
  sqlstm.sqtdso[5] = (unsigned short )0;
  sqlstm.sqhstv[6] = (         void  *)step_q.date_time_completed;
  sqlstm.sqhstl[6] = (unsigned int  )15;
  sqlstm.sqhsts[6] = (         int  )0;
  sqlstm.sqindv[6] = (         void  *)&step_q_ind.time_completed;
  sqlstm.sqinds[6] = (         int  )0;
  sqlstm.sqharm[6] = (unsigned int  )0;
  sqlstm.sqadto[6] = (unsigned short )0;
  sqlstm.sqtdso[6] = (unsigned short )0;
  sqlstm.sqhstv[7] = (         void  *)&step_q.exit_code;
  sqlstm.sqhstl[7] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[7] = (         int  )0;
  sqlstm.sqindv[7] = (         void  *)&step_q_ind.exit_code;
  sqlstm.sqinds[7] = (         int  )0;
  sqlstm.sqharm[7] = (unsigned int  )0;
  sqlstm.sqadto[7] = (unsigned short )0;
  sqlstm.sqtdso[7] = (unsigned short )0;
  sqlstm.sqhstv[8] = (         void  *)step_q.command_line;
  sqlstm.sqhstl[8] = (unsigned int  )140;
  sqlstm.sqhsts[8] = (         int  )0;
  sqlstm.sqindv[8] = (         void  *)&step_q_ind.command_line;
  sqlstm.sqinds[8] = (         int  )0;
  sqlstm.sqharm[8] = (unsigned int  )0;
  sqlstm.sqadto[8] = (unsigned short )0;
  sqlstm.sqtdso[8] = (unsigned short )0;
  sqlstm.sqhstv[9] = (         void  *)&step_q.num_d;
  sqlstm.sqhstl[9] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[9] = (         int  )0;
  sqlstm.sqindv[9] = (         void  *)&step_q_ind.num_d;
  sqlstm.sqinds[9] = (         int  )0;
  sqlstm.sqharm[9] = (unsigned int  )0;
  sqlstm.sqadto[9] = (unsigned short )0;
  sqlstm.sqtdso[9] = (unsigned short )0;
  sqlstm.sqhstv[10] = (         void  *)step_q.d_step;
  sqlstm.sqhstl[10] = (unsigned int  )180;
  sqlstm.sqhsts[10] = (         int  )0;
  sqlstm.sqindv[10] = (         void  *)&step_q_ind.d_step;
  sqlstm.sqinds[10] = (         int  )0;
  sqlstm.sqharm[10] = (unsigned int  )0;
  sqlstm.sqadto[10] = (unsigned short )0;
  sqlstm.sqtdso[10] = (unsigned short )0;
  sqlstm.sqhstv[11] = (         void  *)step_q.d_cmplt;
  sqlstm.sqhstl[11] = (unsigned int  )20;
  sqlstm.sqhsts[11] = (         int  )0;
  sqlstm.sqindv[11] = (         void  *)&step_q_ind.d_cmplt;
  sqlstm.sqinds[11] = (         int  )0;
  sqlstm.sqharm[11] = (unsigned int  )0;
  sqlstm.sqadto[11] = (unsigned short )0;
  sqlstm.sqtdso[11] = (unsigned short )0;
  sqlstm.sqhstv[12] = (         void  *)step_q.d_last_tested;
  sqlstm.sqhstl[12] = (unsigned int  )200;
  sqlstm.sqhsts[12] = (         int  )0;
  sqlstm.sqindv[12] = (         void  *)&step_q_ind.d_last_tested;
  sqlstm.sqinds[12] = (         int  )0;
  sqlstm.sqharm[12] = (unsigned int  )0;
  sqlstm.sqadto[12] = (unsigned short )0;
  sqlstm.sqtdso[12] = (unsigned short )0;
  sqlstm.sqhstv[13] = (         void  *)&step_q.num_a;
  sqlstm.sqhstl[13] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[13] = (         int  )0;
  sqlstm.sqindv[13] = (         void  *)&step_q_ind.num_a;
  sqlstm.sqinds[13] = (         int  )0;
  sqlstm.sqharm[13] = (unsigned int  )0;
  sqlstm.sqadto[13] = (unsigned short )0;
  sqlstm.sqtdso[13] = (unsigned short )0;
  sqlstm.sqhstv[14] = (         void  *)step_q.exit_codes_acceptable;
  sqlstm.sqhstl[14] = (unsigned int  )100;
  sqlstm.sqhsts[14] = (         int  )0;
  sqlstm.sqindv[14] = (         void  *)&step_q_ind.exit_codes_acceptable;
  sqlstm.sqinds[14] = (         int  )0;
  sqlstm.sqharm[14] = (unsigned int  )0;
  sqlstm.sqadto[14] = (unsigned short )0;
  sqlstm.sqtdso[14] = (unsigned short )0;
  sqlstm.sqhstv[15] = (         void  *)step_q.job_machine;
  sqlstm.sqhstl[15] = (unsigned int  )10;
  sqlstm.sqhsts[15] = (         int  )0;
  sqlstm.sqindv[15] = (         void  *)&step_q_ind.job_machine;
  sqlstm.sqinds[15] = (         int  )0;
  sqlstm.sqharm[15] = (unsigned int  )0;
  sqlstm.sqadto[15] = (unsigned short )0;
  sqlstm.sqtdso[15] = (unsigned short )0;
  sqlstm.sqhstv[16] = (         void  *)step_q.d_group;
  sqlstm.sqhstl[16] = (unsigned int  )21;
  sqlstm.sqhsts[16] = (         int  )0;
  sqlstm.sqindv[16] = (         void  *)&step_q_ind.d_group;
  sqlstm.sqinds[16] = (         int  )0;
  sqlstm.sqharm[16] = (unsigned int  )0;
  sqlstm.sqadto[16] = (unsigned short )0;
  sqlstm.sqtdso[16] = (unsigned short )0;
  sqlstm.sqhstv[17] = (         void  *)step_q.group_name;
  sqlstm.sqhstl[17] = (unsigned int  )10;
  sqlstm.sqhsts[17] = (         int  )0;
  sqlstm.sqindv[17] = (         void  *)&step_q_ind.group_name;
  sqlstm.sqinds[17] = (         int  )0;
  sqlstm.sqharm[17] = (unsigned int  )0;
  sqlstm.sqadto[17] = (unsigned short )0;
  sqlstm.sqtdso[17] = (unsigned short )0;
  sqlstm.sqhstv[18] = (         void  *)step_q.same_machine_flag_yn;
  sqlstm.sqhstl[18] = (unsigned int  )2;
  sqlstm.sqhsts[18] = (         int  )0;
  sqlstm.sqindv[18] = (         void  *)&step_q_ind.same_machine_flag_yn;
  sqlstm.sqinds[18] = (         int  )0;
  sqlstm.sqharm[18] = (unsigned int  )0;
  sqlstm.sqadto[18] = (unsigned short )0;
  sqlstm.sqtdso[18] = (unsigned short )0;
  sqlstm.sqhstv[19] = (         void  *)step_q.group_first_step_yn;
  sqlstm.sqhstl[19] = (unsigned int  )2;
  sqlstm.sqhsts[19] = (         int  )0;
  sqlstm.sqindv[19] = (         void  *)&step_q_ind.group_first_step_yn;
  sqlstm.sqinds[19] = (         int  )0;
  sqlstm.sqharm[19] = (unsigned int  )0;
  sqlstm.sqadto[19] = (unsigned short )0;
  sqlstm.sqtdso[19] = (unsigned short )0;
  sqlstm.sqhstv[20] = (         void  *)step_q.skip_yn;
  sqlstm.sqhstl[20] = (unsigned int  )2;
  sqlstm.sqhsts[20] = (         int  )0;
  sqlstm.sqindv[20] = (         void  *)&step_q_ind.skip_yn;
  sqlstm.sqinds[20] = (         int  )0;
  sqlstm.sqharm[20] = (unsigned int  )0;
  sqlstm.sqadto[20] = (unsigned short )0;
  sqlstm.sqtdso[20] = (unsigned short )0;
  sqlstm.sqhstv[21] = (         void  *)step_q.beg_console_msg;
  sqlstm.sqhstl[21] = (unsigned int  )81;
  sqlstm.sqhsts[21] = (         int  )0;
  sqlstm.sqindv[21] = (         void  *)&step_q_ind.beg_console_msg;
  sqlstm.sqinds[21] = (         int  )0;
  sqlstm.sqharm[21] = (unsigned int  )0;
  sqlstm.sqadto[21] = (unsigned short )0;
  sqlstm.sqtdso[21] = (unsigned short )0;
  sqlstm.sqhstv[22] = (         void  *)step_q.beg_suspend_yn;
  sqlstm.sqhstl[22] = (unsigned int  )2;
  sqlstm.sqhsts[22] = (         int  )0;
  sqlstm.sqindv[22] = (         void  *)&step_q_ind.beg_suspend_yn;
  sqlstm.sqinds[22] = (         int  )0;
  sqlstm.sqharm[22] = (unsigned int  )0;
  sqlstm.sqadto[22] = (unsigned short )0;
  sqlstm.sqtdso[22] = (unsigned short )0;
  sqlstm.sqhstv[23] = (         void  *)step_q.end_console_msg;
  sqlstm.sqhstl[23] = (unsigned int  )81;
  sqlstm.sqhsts[23] = (         int  )0;
  sqlstm.sqindv[23] = (         void  *)&step_q_ind.end_console_msg;
  sqlstm.sqinds[23] = (         int  )0;
  sqlstm.sqharm[23] = (unsigned int  )0;
  sqlstm.sqadto[23] = (unsigned short )0;
  sqlstm.sqtdso[23] = (unsigned short )0;
  sqlstm.sqhstv[24] = (         void  *)step_q.end_suspend_yn;
  sqlstm.sqhstl[24] = (unsigned int  )2;
  sqlstm.sqhsts[24] = (         int  )0;
  sqlstm.sqindv[24] = (         void  *)&step_q_ind.end_suspend_yn;
  sqlstm.sqinds[24] = (         int  )0;
  sqlstm.sqharm[24] = (unsigned int  )0;
  sqlstm.sqadto[24] = (unsigned short )0;
  sqlstm.sqtdso[24] = (unsigned short )0;
  sqlstm.sqhstv[25] = (         void  *)step_q.send_msg;
  sqlstm.sqhstl[25] = (unsigned int  )81;
  sqlstm.sqhsts[25] = (         int  )0;
  sqlstm.sqindv[25] = (         void  *)&step_q_ind.send_msg;
  sqlstm.sqinds[25] = (         int  )0;
  sqlstm.sqharm[25] = (unsigned int  )0;
  sqlstm.sqadto[25] = (unsigned short )0;
  sqlstm.sqtdso[25] = (unsigned short )0;
  sqlstm.sqhstv[26] = (         void  *)step_q.run_if_error;
  sqlstm.sqhstl[26] = (unsigned int  )65;
  sqlstm.sqhsts[26] = (         int  )0;
  sqlstm.sqindv[26] = (         void  *)&step_q_ind.run_if_error;
  sqlstm.sqinds[26] = (         int  )0;
  sqlstm.sqharm[26] = (unsigned int  )0;
  sqlstm.sqadto[26] = (unsigned short )0;
  sqlstm.sqtdso[26] = (unsigned short )0;
  sqlstm.sqhstv[27] = (         void  *)&step_q.status_interval;
  sqlstm.sqhstl[27] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[27] = (         int  )0;
  sqlstm.sqindv[27] = (         void  *)&step_q_ind.status_interval;
  sqlstm.sqinds[27] = (         int  )0;
  sqlstm.sqharm[27] = (unsigned int  )0;
  sqlstm.sqadto[27] = (unsigned short )0;
  sqlstm.sqtdso[27] = (unsigned short )0;
  sqlstm.sqhstv[28] = (         void  *)&(job_q.no);
  sqlstm.sqhstl[28] = (unsigned int  )sizeof(long);
  sqlstm.sqhsts[28] = (         int  )0;
  sqlstm.sqindv[28] = (         void  *)0;
  sqlstm.sqinds[28] = (         int  )0;
  sqlstm.sqharm[28] = (unsigned int  )0;
  sqlstm.sqadto[28] = (unsigned short )0;
  sqlstm.sqtdso[28] = (unsigned short )0;
  sqlstm.sqhstv[29] = (         void  *)&start_step_no;
  sqlstm.sqhstl[29] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[29] = (         int  )0;
  sqlstm.sqindv[29] = (         void  *)0;
  sqlstm.sqinds[29] = (         int  )0;
  sqlstm.sqharm[29] = (unsigned int  )0;
  sqlstm.sqadto[29] = (unsigned short )0;
  sqlstm.sqtdso[29] = (unsigned short )0;
  sqlstm.sqphsv = sqlstm.sqhstv;
  sqlstm.sqphsl = sqlstm.sqhstl;
  sqlstm.sqphss = sqlstm.sqhsts;
  sqlstm.sqpind = sqlstm.sqindv;
  sqlstm.sqpins = sqlstm.sqinds;
  sqlstm.sqparm = sqlstm.sqharm;
  sqlstm.sqparc = sqlstm.sqharc;
  sqlstm.sqpadto = sqlstm.sqadto;
  sqlstm.sqptdso = sqlstm.sqtdso;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



		l_sqlcode = sqlca.sqlcode;

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"STEPQ", sqlmsg, " ", NULL);
			//setxy(0,24);
			logit (1, "No Steps found without dependencies");
			debug_log("No Steps found without dependencies");
			return ERR;
		}

		trim_sql_stepq(&step_q);	

 

	}		// end of while loop


	// Update JOBQ with information from STEPQ
	job_q.last_step = step_q.step;					/* set last step in job record  */
	strcpy ((char*)job_q.last_s_name, (char*)step_q.s_name);      /* set step name in job record  */
	strcpy ((char*)job_q.last_g_name, (char*)step_q.group_name);  /* set group name in job record */


 

	// This row should be locked from the check_waiting() function
	strcpy(lcl_rowid, rowid);


	// NOTE: We don't need to do a critical section here because
	//       this function is called from check_waiting() which
	//       is already doing the critical section for us.

	// NOTE: The SELECT FOR UPDATE is done in the check_waiting() function.
	//       Therefore, it's ok to go ahead and update this table now because this
	//       row is already locked.
	/* EXEC SQL UPDATE JOBQ
		SET last_step = :job_q.last_step,				/o set last step in job record  o/
			last_s_name = :job_q.last_s_name,			/o set step name in job record  o/
			last_g_name = :job_q.last_g_name,			/o set group name in job record o/
			status      = :job_q.status,
			date_time_started = :job_q.date_time_started,
			stn_started  = :job_q.stn_started,
			station      = :job_q.station
			WHERE 
				ROWID = :lcl_rowid
				AND	 name = :job_q.name
				AND  no   = :job_q.no; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 51;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = "update JOBQ  set last_step=:b0,last_s_name=:b1,last_g_name=:\
b2,status=:b3,date_time_started=:b4,stn_started=:b5,station=:b6 where ((ROWID=\
:b7 and name=:b8) and no=:b9)";
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2402;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqhstv[0] = (         void  *)&(job_q.last_step);
 sqlstm.sqhstl[0] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)(job_q.last_s_name);
 sqlstm.sqhstl[1] = (unsigned int  )10;
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqhstv[2] = (         void  *)(job_q.last_g_name);
 sqlstm.sqhstl[2] = (unsigned int  )10;
 sqlstm.sqhsts[2] = (         int  )0;
 sqlstm.sqindv[2] = (         void  *)0;
 sqlstm.sqinds[2] = (         int  )0;
 sqlstm.sqharm[2] = (unsigned int  )0;
 sqlstm.sqadto[2] = (unsigned short )0;
 sqlstm.sqtdso[2] = (unsigned short )0;
 sqlstm.sqhstv[3] = (         void  *)(job_q.status);
 sqlstm.sqhstl[3] = (unsigned int  )2;
 sqlstm.sqhsts[3] = (         int  )0;
 sqlstm.sqindv[3] = (         void  *)0;
 sqlstm.sqinds[3] = (         int  )0;
 sqlstm.sqharm[3] = (unsigned int  )0;
 sqlstm.sqadto[3] = (unsigned short )0;
 sqlstm.sqtdso[3] = (unsigned short )0;
 sqlstm.sqhstv[4] = (         void  *)(job_q.date_time_started);
 sqlstm.sqhstl[4] = (unsigned int  )15;
 sqlstm.sqhsts[4] = (         int  )0;
 sqlstm.sqindv[4] = (         void  *)0;
 sqlstm.sqinds[4] = (         int  )0;
 sqlstm.sqharm[4] = (unsigned int  )0;
 sqlstm.sqadto[4] = (unsigned short )0;
 sqlstm.sqtdso[4] = (unsigned short )0;
 sqlstm.sqhstv[5] = (         void  *)(job_q.stn_started);
 sqlstm.sqhstl[5] = (unsigned int  )10;
 sqlstm.sqhsts[5] = (         int  )0;
 sqlstm.sqindv[5] = (         void  *)0;
 sqlstm.sqinds[5] = (         int  )0;
 sqlstm.sqharm[5] = (unsigned int  )0;
 sqlstm.sqadto[5] = (unsigned short )0;
 sqlstm.sqtdso[5] = (unsigned short )0;
 sqlstm.sqhstv[6] = (         void  *)(job_q.station);
 sqlstm.sqhstl[6] = (unsigned int  )10;
 sqlstm.sqhsts[6] = (         int  )0;
 sqlstm.sqindv[6] = (         void  *)0;
 sqlstm.sqinds[6] = (         int  )0;
 sqlstm.sqharm[6] = (unsigned int  )0;
 sqlstm.sqadto[6] = (unsigned short )0;
 sqlstm.sqtdso[6] = (unsigned short )0;
 sqlstm.sqhstv[7] = (         void  *)lcl_rowid;
 sqlstm.sqhstl[7] = (unsigned int  )25;
 sqlstm.sqhsts[7] = (         int  )0;
 sqlstm.sqindv[7] = (         void  *)0;
 sqlstm.sqinds[7] = (         int  )0;
 sqlstm.sqharm[7] = (unsigned int  )0;
 sqlstm.sqadto[7] = (unsigned short )0;
 sqlstm.sqtdso[7] = (unsigned short )0;
 sqlstm.sqhstv[8] = (         void  *)(job_q.name);
 sqlstm.sqhstl[8] = (unsigned int  )10;
 sqlstm.sqhsts[8] = (         int  )0;
 sqlstm.sqindv[8] = (         void  *)0;
 sqlstm.sqinds[8] = (         int  )0;
 sqlstm.sqharm[8] = (unsigned int  )0;
 sqlstm.sqadto[8] = (unsigned short )0;
 sqlstm.sqtdso[8] = (unsigned short )0;
 sqlstm.sqhstv[9] = (         void  *)&(job_q.no);
 sqlstm.sqhstl[9] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[9] = (         int  )0;
 sqlstm.sqindv[9] = (         void  *)0;
 sqlstm.sqinds[9] = (         int  )0;
 sqlstm.sqharm[9] = (unsigned int  )0;
 sqlstm.sqadto[9] = (unsigned short )0;
 sqlstm.sqtdso[9] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;

	if(l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		/* EXEC SQL ROLLBACK; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 51;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )2457;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


		ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"JOBQ", sqlmsg, " ", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff, "Error during UPDATE of JOBQ table - SQLCA.SQLCODE=", 
					szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "Error during UPDATE of JOBQ table - SQLCA.SQLCODE=%d, %s", 
		//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (0, szbuff);
		debug_log(szbuff);
		return ERR;
	}

	// NOTE: We don't need to do a critical section here because
	//       this function is called from check_waiting() which
	//       is already doing the critical section for us.
	/* EXEC SQL COMMIT; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 51;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2472;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		/* EXEC SQL ROLLBACK; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 51;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )2487;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


		ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
				sqlmsg, "JOBQ table", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=", 
					szret, " ", sqlmsg, NULL);			
		//sprintf(szbuff, "ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=%d, %s", 
		//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (0, szbuff);
		debug_log(szbuff);
		return ERR;
	}

	if (job_q.msg_when_started[0] == '1')          /* need to send message that this */
	{
		debug_log ("Sending job begin message");   /* job is starting?             */
		send_begin_msg();
	}

 


   logit (1, "Job Started");
   return SUCCESS;

}


 

void trim_sql_jobq(js_jobq_sql_def *jobq)
{
		trimlr(jobq->status);
		trimlr(jobq->name);	
		trimlr(jobq->station);
		trimlr(jobq->date_time_entered);
		trimlr(jobq->date_time_started);
		trimlr(jobq->date_time_completed);
		trimlr(jobq->station_submitting);
		trimlr(jobq->msg_when_started);			
		trimlr(jobq->msg_when_done);	
		trimlr(jobq->multi_processing);
		trimlr(jobq->date_time_to_start);
		trimlr(jobq->must_complete_by);
		trimlr(jobq->c_msg_sent_yn);
		trimlr(jobq->must_start_by);             
		trimlr(jobq->s_msg_sent_yn);		
		trimlr(jobq->msg_to_operator_yn);
		trimlr(jobq->msg_to);
		trimlr((char*)jobq->stn_started);
		trimlr(jobq->d_job);
		trimlr(jobq->d_hrs_back);
		trimlr((char*)jobq->d_cmplt);
		trimlr(jobq->d_last_tested);
		trimlr(jobq->job_suspended);            
		trimlr(jobq->restart);                   
		trimlr(jobq->job_class);                  
		trimlr(jobq->base_dir);                  
		trimlr(jobq->debug_mode_yn);		     
		trimlr(jobq->last_s_name);	
		trimlr(jobq->last_g_name);				
		trimlr(jobq->submitted_file_name);       
		trimlr(jobq->p_msg_sent_yn);		        
		trimlr(jobq->max_c_msg_yn);		        
		trimlr(jobq->stn_dependancy_yn);		
		trimlr(jobq->no_fail_message_yn);			
		trimlr(jobq->msg_when_failed);			
		trimlr(jobq->d_station);
		trimlr(jobq->jsgroup);  // WR27164 - Hamsha	
				
}

void trim_sql_stepq(js_stepq_sql_def *stepq)
{
		trimlr(stepq->s_name);			
		trimlr(stepq->status);						
		trimlr(stepq->j_name);		
		trimlr(stepq->date_time_started);         
		trimlr(stepq->date_time_completed);       
		trimlr(stepq->command_line);            
		trimlr(stepq->d_step);                   
		trimlr(stepq->d_cmplt);					
		trimlr(stepq->d_last_tested);            
		trimlr(stepq->exit_codes_acceptable);
		trimlr(stepq->job_machine);				
		trimlr(stepq->d_group);					
		trimlr(stepq->group_name);                
		trimlr(stepq->same_machine_flag_yn);		
		trimlr(stepq->group_first_step_yn);		
		trimlr(stepq->skip_yn);				
		trimlr(stepq->beg_console_msg);          
		trimlr(stepq->beg_suspend_yn);			   
		trimlr(stepq->end_console_msg);           
		trimlr(stepq->end_suspend_yn);			
		trimlr(stepq->send_msg);                  
		trimlr(stepq->run_if_error);
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                           document/set1/QUEUES.PC_2.pdf                                                                       0000644     %g4001001 00000155224 14011436757 014106  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               /****************************************************************

JSNT
Copyright (C) 1999 - 2000 eFunds Corporation. All Rights Reserved.

Queue Checking Module - (Delivery Queue Handling Is In DELIVERY.C)

****************************************************************/
#define SQLCA_STORAGE_CLASS extern
#define	ORACA_STORAGE_CLASS extern


EXEC SQL INCLUDE	"sqlca.h"; 
EXEC SQL INCLUDE	"orcltype.h";
EXEC SQL INCLUDE	"jsnt_sql.h"; 


#include "jsnt.h"


 
void trim_sql_jobq(js_jobq_sql_def *jobq);
void trim_sql_stepq(js_stepq_sql_def *stepq);
 

/*********************** search_queue **************************
*                                                              *
* Description: Start searching through the Schedule, Active    *
*  and Waiting queues to see if there are any jobs to run.     *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
*  Modifed Date: 06/28/96        By: Mike West                 *
*                                                              *
***************************************************************/
int search_queue (void) 
{
	short int ret;
	char szbuff[500];
	long tim;
	static long last_tim = 0;
	char tempstr[50];
	char szret[10];


 
	EXEC SQL CONTEXT USE :g_ctx;
 


	Sleep(1500);
	time(&tim);

	if (idle && !now) {
		if(tim > (last_tim + INTERVAL) );
		else return SUCCESS;
	}
	last_tim = tim;
	now = 0;

/*  Search the delivery configuration file for any matching files  */

//	if (! job_processing)	// only do delivery when we don't have a job processing
//	{
		if (! no_delivery)	// command line parameter to not do delivery
		{
			if (search_delivery() != SUCCESS)
				return(-2);
		}
//	}

// WR 28164  - sujatha/Veera

    if(station_only)
	{
		if(search_delivery() != SUCCESS)
			return -3;
	}

	if(!no_delivery && !no_submit)
		qtext(xpos,ypos+STATUS_LINE,           "        Waiting for Job or Delivery...     ");
	else if (!no_delivery)
		qtext(xpos,ypos+STATUS_LINE,           "        Waiting for Delivery...            ");
	else
		qtext(xpos,ypos+STATUS_LINE,           "        Waiting for Job...                 ");

/* First check scheduled queue and see if anything ready to go */
	if (!no_submit)  // command line parameter to not to submit
	{
		debug_log ("Checking Scheduled Queue");
		ret = check_scheduled ();

		if(ret != 0) 
		{
			logit (0,"Error on scheduled queue check");
			debug_log ("Error on scheduled queue check");
			return ERR;
		}
	

/* Next Check the Active Jobs to see if any STEPS need processing */
		debug_log ("Checking active jobs");
		ret = check_actives();

		if (ret == 1) 
		{
			job_processing = 1;
			debug_log ("Found job - actives - Processing");
		ret = process_task();

			if(ret == -2) 
			{
				_itoa(ret, szret, 10);
				copy_cat(szbuff, "ERROR Active Jobs: Process Task returned ", szret, NULL);
				//sprintf (szbuff, "ERROR Active Jobs: Process Task returned %d", ret);
				logit (0, szbuff);
				debug_log (szbuff);
				return ERR;
			}

			if(ret) 
			{
				_itoa(ret, szret, 10);
				copy_cat(szbuff, "ERROR Active Jobs: Process Task returned ", szret, NULL);
				//sprintf (szbuff, "ERROR Active Jobs: Process Task returned %d", ret);
				logit (0, szbuff);
				debug_log (szbuff);
				return ERR;
			}
			return SUCCESS;
		}

		if (ret == 2)     /* A task is waiting to be completed on another job server */
		{
			debug_log ("Abandoned check active queue so another JS could close task");
			return SUCCESS;  
		}
		
		if (ret) 			/* Some other error */
		{
			logit (0,"Error on check actives");
			debug_log ("Error on check actives");
			return ERR;
		}
	

/* If NO active STEPS ready to go, then look at WAITING QUEUE and 
 start 1st Step */

		debug_log ("Checking Waiting Queue");
		ret = check_waiting ();
		if (ret == 1) 
		{
			job_processing = 1;
			debug_log("Found job - waiting - processing");
			ret = process_task ();

			if(ret == -2) 
			{
				_itoa(ret, szret, 10);
				copy_cat(szbuff, "ERROR Waiting Jobs: Process Task returned ", szret, NULL);
				//sprintf (szbuff, "ERROR Waiting Jobs: Process Task returned %d", ret);
				logit (0, szbuff);
				debug_log (szbuff);
				return ERR;
			}

			if(ret) 
			{
				_itoa(ret, szret, 10);
				copy_cat(szbuff, "ERROR Waiting Jobs: Process Task returned ", szret, NULL);
				//sprintf (szbuff, "ERROR Waiting Jobs: Process Task returned %d", ret);
				logit (0, szbuff);
				debug_log (szbuff);
				return ERR;
			}
			return SUCCESS;
		}

		if (ret) 			/* Some other error */
		{
			logit (0,"Error on check waiting");
			debug_log ("Error on check waiting");
			return ERR;
		}
	}

	if(no_delivery && no_submit && (!station_only))
	{
		//nothing would be executed.
		qtext(xpos,ypos+STATUS_LINE," JOB Server set to idle. Check Config file.");
		logit (0,"JOB Server set to idle. Check Config file.");
		debug_log ("JOB Server set to idle. Check Config file.");
		Sleep (5000);
	}

	debug_log ("No jobs to run or execute.");

	if (! idle) 
	{
		if (login_js ()) 
			return ERR;
		idle = 1;
		copy_cat(tempstr, "[", szjsname, "] - IDLE                              ", prog_version, NULL);
		//sprintf (tempstr, "[%s] - IDLE                              %s", szjsname, prog_version);
		SetConsoleTitle (tempstr);                  /* set the console title       */
	}

	return SUCCESS;  
}

/********************* check_scheduled *************************
*                                                              *
* Description: Start searching through the schedule queue for  *
*  any jobs that are on hold or time scheduled jobs to run.    *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
*  Modifed Date: 06/28/96        By: Mike West                 *
*  Modifed Date: 07/29/99        By: Mike West                 *
*                                                              *
***************************************************************/
int check_scheduled (void) {
	char test_d[20];
	char j_test[20];
	char szbuff[300];
	SYSTIME st;
	//short int tries;
	int l_sqlcode;
	char szret[10];
	char sqlmsg[80];

	// WR27164 - Hamsha

	char szcode[10];
	char tempstr[500];


   char month[3];
   char day[3];
   char year[5];
   char hour[3];
   char minute[3];
   char second[3];


 
   	EXEC SQL BEGIN DECLARE SECTION;
		char job_status[2];			/* A=Active, H=On Hold R=Ready S=Scheduled Y=Completed */
		long job_pos;               /* Position in Queue */
		char job_name[10];
	EXEC SQL END DECLARE SECTION;
 


	while (1) 
	{

 

   	EXEC SQL BEGIN DECLARE SECTION;
		char job_server[10];
		char js_group[10]; // WR27164 - Hamsha
   	EXEC SQL END DECLARE SECTION;

	strcpy(job_server, szjsname);
	memset(&job_q, 0, sizeof(job_q) );
	EnterCriticalSection(&jsnt_sql_lock);

// Added for WR27164 on 02/14/2005 - Hamsha

	trimlr(job_server);
	memset(js_group,'\0',sizeof(js_group));

	EXEC SQL 
		SELECT trim(jsgroup) 
        INTO   :js_group
		FROM   JOB_SERVER_GROUPS
		WHERE  trim(STATION) = :job_server;

	l_sqlcode = sqlca.sqlcode;

	LeaveCriticalSection(&jsnt_sql_lock);

	if( (l_sqlcode != ORCL_NO_ERROR) &&  (l_sqlcode != ORCL_NOT_FOUND) )
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
				"JOB_SERVER_GROUPS", sqlmsg, "JS_GROUP", NULL);
		_itoa(l_sqlcode, szcode, 10);
		copy_cat(tempstr, "Error during SELECT FROM JOB_SERVER_GROUPS table - SQLCA.SQLCODE=",
				szcode, sqlmsg, NULL);
		logit (0, tempstr);
		debug_log(tempstr);
		return ERR;

	}
	if (l_sqlcode == ORCL_NOT_FOUND)
		memset(js_group, 0x00, sizeof(js_group));
	
	trimlr(js_group);

// End - Hamsha

		EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL SELECT 
			status,
			pos,
			name,
			no,
			station,
			date_time_entered,
			date_time_started,
			date_time_completed,
			exit_code,
			station_submitting,
			msg_when_started,
			msg_when_done,
			multi_processing,
			date_time_to_start,
			start_stat,
			must_complete_by,
			c_msg_sent_yn,
			must_start_by,
			s_msg_sent_yn,
			msg_to_operator_yn,
			msg_to,
			priority,
			stn_started,
			num_d,
			d_job,
			d_hrs_back,
			d_cmplt,
			d_last_tested,
			orig_start_stat,
			job_suspended,
			restart,
			job_class,
			base_dir,
			max_job_time_warn,
			debug_mode_yn,
			last_step,
			last_s_name,
			last_g_name,
			submitted_file_name,
			p_msg_sent_yn,
			max_job_time_kill,
			max_c_msg_yn,
			stn_dependancy_yn,
			no_fail_message_yn,
			msg_when_failed,
			spawn_algorithm,
			spawn_parm,
			d_station,
			jsgroup			// WR27164 - Hamsha
		INTO :job_q:job_q_ind
		FROM JOBQ

// Modified for WR27164 on 02/14/2005 - Hamsha

//		WHERE status = 'S'
//		AND   to_char(date_time_to_start, 'YYYYMMDDHH24MISS') >= '00000000000000'
//		AND   (station is NULL OR station = :job_server)
//		AND   ROWNUM=1;

		WHERE status = 'S'
		AND   to_char(date_time_to_start, 'YYYYMMDDHH24MISS') >= '00000000000000'
		and ((station is NULL and jsgroup is NULL)
			OR  ( TRIM(station) = :job_server )  
			OR  ( TRIM(jsgroup) = :js_group ))
		AND   ROWNUM=1;

// End - Hamsha

		l_sqlcode = sqlca.sqlcode;
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		LeaveCriticalSection(&jsnt_sql_lock);

	
		if (l_sqlcode == ORCL_NOT_FOUND)
		{
			debug_log("No Scheduled Jobs");
			break;
		}

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"JOBQ", sqlmsg, " ", NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff, "Error selecting Scheduled Jobs from JOBQ - sqlca.sqlcode=",
						szret, sqlmsg, NULL);
			//sprintf (szbuff, "Error selecting Scheduled Jobs from JOBQ - sqlca.sqlcode=%d, %s", 
			//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log (szbuff);
			return ERR;
		} 

		trim_sql_jobq(&job_q);	

		/*		Even if it thinks it found a record, check the status to make sure */
		if(job_q.status[0] != 'S')      /* status 'S' mean scheduled job */
		{
			debug_log("No scheduled jobs");
			break;
		}
 

		getsystime (&st);           /* get current system date & time    */

		_itoa(st.wMonth, month, 10);
		if(st.wMonth < 10)
			_padl(month, '0', 2);

		_itoa(st.wDay, day, 10);
		if(st.wDay < 10)
			_padl(day, '0', 2);

		_itoa(st.wHour, hour, 10);
		if(st.wHour < 10)
			_padl(hour, '0', 2);

		_itoa(st.wMinute, minute, 10);
		if(st.wMinute < 10)
			_padl(minute, '0', 2);

		_itoa(st.wSecond, second, 10);
		if(st.wSecond < 10)
			_padl(second, '0', 2);


 
		_itoa(st.wYear, year, 10);
		copy_cat(test_d, year, month, day, hour, minute, second, NULL);

		//sprintf(test_d, "%04d%02d%02d%02d%02d%02d", st.wYear, st.wMonth,
		//				st.wDay, st.wHour, st.wMinute, st.wSecond);		
		memset(j_test, 0, sizeof(j_test) );
		memcpy(j_test, job_q.date_time_to_start, sizeof(job_q.date_time_to_start) );
 

		copy_cat(szbuff, "Job: ", job_q.name, " ", j_test, NULL);
		//sprintf(szbuff, "Job: %s %s", job_q.name, j_test);
		debug_log(szbuff);

		/* Is it time to run this job yet? */
		if (strcmp(test_d, j_test) < 0)  /* compare system time against scheduled time.*/
		{
			debug_log("Not time yet");
			break;
		}

 
/*		j_rec.start_stat, 0=Run, 1=On Hold, 2=Prompt Operator, 3=Both */
		if(job_q.start_stat == 1 || job_q.start_stat == 3) 
		{
			debug_log ("Job changed to Hold Queue");
			strcpy(job_q.status, "H");  /* Change to HOLD status */
		}
		else 
		{
			debug_log ("Job changed to Ready Queue");
			strcpy(job_q.status, "R");  /* Change to READY status */
		}

		time(&job_q.pos);
 



 
	   	// Try to Lock the row for updating up to 10 times before Erroring out.
		EnterCriticalSection(&jsnt_sql_lock);

		//for(tries=0; tries < LOCK_TRIES; tries++)
		//{
			EXEC SQL SELECT 
				status,
				pos,
				name
			INTO :job_status, :job_pos, job_name
			FROM JOBQ
			WHERE status = 'S'
			AND   to_char(date_time_to_start, 'YYYYMMDDHH24MISS') = :job_q.date_time_to_start
			FOR UPDATE;
			//FOR UPDATE NOWAIT;
			l_sqlcode = sqlca.sqlcode;
						
   			if(l_sqlcode != ORCL_NO_ERROR)
			{
		//		if(tries < LOCK_TRIES)
		//			Sleep(1000);
		//		else
		//		{
					strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
					LeaveCriticalSection(&jsnt_sql_lock);

					ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
								"JOBQ", sqlmsg, "For Update", NULL);
					_itoa(l_sqlcode, szret, 10);
					copy_cat(szbuff, "Error selecting JOBQ for Update - sqlca.sqlcode=", 
								szret, " ", sqlmsg, NULL);
					//sprintf (szbuff, "Error selecting JOBQ for Update - sqlca.sqlcode=%d, %s", 
					//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
					logit (0, szbuff);
					debug_log (szbuff);
					return ERR;
		//		} 
			}
		//	break;
		//}

		EXEC SQL UPDATE JOBQ
			SET status = :job_q.status,	
				pos    = :job_q.pos
			WHERE status = 'S'
			AND   to_char(date_time_to_start, 'YYYYMMDDHH24MISS') = :job_q.date_time_to_start;

		l_sqlcode = sqlca.sqlcode;

		if(l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			EXEC SQL ROLLBACK;
			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"JOBQ", sqlmsg, " ", NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"Error during UPDATE of JOBQ table - SQLCA.SQLCODE=", 
						szret, " ", sqlmsg, NULL);
			//sprintf(szbuff, "Error during UPDATE of JOBQ table - SQLCA.SQLCODE=%d, %s", 
			//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log(szbuff);
			return ERR;
		}
	
		EXEC SQL COMMIT;
		l_sqlcode = sqlca.sqlcode;

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			EXEC SQL ROLLBACK;
			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"JOBQ", sqlmsg, NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=",  
						szret, " ", sqlmsg, NULL);
			//sprintf(szbuff, "ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=%d, %s", 
			//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log(szbuff);
			return ERR;
		}	

		LeaveCriticalSection(&jsnt_sql_lock);

 
	}
	return SUCCESS;
}


/*********************** check_actives *************************
*                                                              *
* Description: This function checks the active job queue for   *
*  any work to do.                                             *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
* Modifiy Date:  07/29/99        By: Mike West                 *
*                                                              *
***************************************************************/
int check_actives (void) 
{
	short int status=0;
	short int zero=0;
	short int s_dep;
	short int s_first_time=1;
	short int j_first_time=1;
	short int task_semaphore=0;
	//short int tries;
	unsigned long same_group_job = 0;
	char same_machine_group_name[10];
	char szbuff[300];
	int l_sqlcode;
	char szret[10];
	char sznum[20];
	char sqlmsg[80];

	// WR27164 - Hamsha

	char szcode[10];
	char tempstr[500];

//int errcode;
//char *errmsg;

 
   	EXEC SQL BEGIN DECLARE SECTION;
		short int last_step;
		unsigned long job_q_num;
		unsigned char last_s_name[10];
		unsigned char last_g_name[10];
		char job_status[2];			/* A=Active, H=On Hold R=Ready S=Scheduled Y=Completed */
		long job_pos;               /* Position in Queue */
		char job_name[10];
		char job_server[10];
		char js_group[10]; // WR27164 - Hamsha
	EXEC SQL END DECLARE SECTION;

 



 
	strcpy(job_server,szjsname);

	EnterCriticalSection(&jsnt_sql_lock);

	// Added for WR27164 on 02/14/2005 - Hamsha

	trimlr(job_server);
	memset(js_group,'\0',sizeof(js_group));


	EXEC SQL 
		SELECT trim(jsgroup) 
        INTO   :js_group
		FROM   JOB_SERVER_GROUPS
		WHERE  trim(STATION) = :job_server;
	
	l_sqlcode = sqlca.sqlcode;

	LeaveCriticalSection(&jsnt_sql_lock);

	if( (l_sqlcode != ORCL_NO_ERROR) &&  (l_sqlcode != ORCL_NOT_FOUND) )
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
				"JOB_SERVER_GROUPS", sqlmsg, "JS_GROUP", NULL);
		_itoa(l_sqlcode, szcode, 10);
		copy_cat(tempstr, "Error during SELECT FROM JOB_SERVER_GROUPS table - SQLCA.SQLCODE=",
				szcode, sqlmsg, NULL);
		logit (0, tempstr);
		debug_log(tempstr);
		return ERR;

	}

	if (l_sqlcode == ORCL_NOT_FOUND)
		memset(js_group, 0x00, sizeof(js_group));

	trimlr(js_group);

// End - Hamsha

	EnterCriticalSection(&jsnt_sql_lock);

	EXEC SQL DECLARE active_job_curs CURSOR FOR 
	 SELECT 
		status,
		pos,
		name,
		no,
		station,
		date_time_entered,
		date_time_started,
		date_time_completed,
		exit_code,
		station_submitting,
		msg_when_started,
		msg_when_done,
		multi_processing,
		date_time_to_start,
		start_stat,
		must_complete_by,
		c_msg_sent_yn,
		must_start_by,
		s_msg_sent_yn,
		msg_to_operator_yn,
		msg_to,
		priority,
		stn_started,
		num_d,
		d_job,
		d_hrs_back,
		d_cmplt,
		d_last_tested,
		orig_start_stat,
		job_suspended,
		restart,
		job_class,
		base_dir,
		max_job_time_warn,
		debug_mode_yn,
		last_step,
		last_s_name,
		last_g_name,
		submitted_file_name,
		p_msg_sent_yn,
		max_job_time_kill,
		max_c_msg_yn,
		stn_dependancy_yn,
		no_fail_message_yn,
		msg_when_failed,
		spawn_algorithm,
		spawn_parm,
		d_station,
		jsgroup // WR27164 - Hamsha
	FROM JOBQ

//Modified for WR27164 on 02/14/2005 - Hamsha

//	WHERE status = 'A'
//	AND   (station is NULL OR station = :job_server)
//	AND   pos >= 0;

	WHERE 
		status = 'A' and 
		((station is NULL and jsgroup is NULL)
		OR  ( TRIM(station) = :job_server )  
		OR  ( TRIM(jsgroup) = :js_group ))
		AND   pos >= 0;

// End - Hamsha

	EXEC SQL DECLARE active_step_curs CURSOR FOR 
	 SELECT 
		no,
		step,
		s_name,
		status,
		j_name,
		date_time_started,
		date_time_completed,
		exit_code,
		command_line,
		num_d,
		d_step,
		d_cmplt,
		d_last_tested,
		num_a,
		exit_codes_acceptable,
		job_machine,
		d_group,
		group_name,
		same_machine_flag_yn,
		group_first_step_yn,
		skip_yn,
		beg_console_msg,
		beg_suspend_yn,
		end_console_msg,
		end_suspend_yn,
		send_msg,
		run_if_error,
		status_interval
	FROM STEPQ
	WHERE no = :job_q_num
	AND step >= 0
	AND status <> 'Y'
	ORDER BY step;



	// Open active_job_curs cursor
	EXEC SQL OPEN active_job_curs;

	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);


	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"active_job_curs", sqlmsg, " ", NULL);
		_ltoa((DWORD) __LINE__, sznum, 10);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Open Cursor for active_job_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=",
					szret, sqlmsg, NULL);
		//sprintf(szbuff, "Open Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
		//			"active_job_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (0, szbuff);
		debug_log (szbuff);
		return(-1);
	}

	// Fetch into job_q structure using status='A' and pos >= 0
	memset(&job_q, 0, sizeof(job_q) );
	EnterCriticalSection(&jsnt_sql_lock);

	EXEC SQL FETCH active_job_curs INTO :job_q:job_q_ind;

	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);


	if (l_sqlcode == ORCL_NOT_FOUND)
	{
		EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL CLOSE active_job_curs; 
		LeaveCriticalSection(&jsnt_sql_lock);

		debug_log("No active files");
		return(0);
	}

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"active_job_curs", sqlmsg, "JOBQ table", NULL);
		_ltoa((DWORD) __LINE__, sznum, 10);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Fetch Cursor for active_job_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=", 
					szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "Fetch Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
		//			"active_job_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (0, szbuff);
		debug_log (szbuff);
		EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL CLOSE active_job_curs; 
		LeaveCriticalSection(&jsnt_sql_lock);

		return(-1);
	}

	trim_sql_jobq(&job_q);

	job_q_num = job_q.no;

	// Open active_step_curs cursor
	memset(&step_q, 0, sizeof(step_q));
	EnterCriticalSection(&jsnt_sql_lock);

	EXEC SQL OPEN active_step_curs;

	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"active_step_curs", sqlmsg, " ", NULL);
		_ltoa((DWORD) __LINE__, sznum, 10);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Open Cursor for active_step_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=", 
					szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "Open Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
		//			"active_step_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (0, szbuff);
		debug_log (szbuff);
		return(-1);
	}
 



	while(1) 
	{
		if(j_first_time == 0) 
		{

 
			// Fetch next record into job_q structure using status='A' and pos >= 0
			memset(&job_q, 0, sizeof(job_q) );
			EnterCriticalSection(&jsnt_sql_lock);

			EXEC SQL FETCH active_job_curs INTO :job_q:job_q_ind;

			l_sqlcode = sqlca.sqlcode;
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			LeaveCriticalSection(&jsnt_sql_lock);


			if (l_sqlcode == ORCL_NOT_FOUND)
			{
				debug_log("No active files");
				EnterCriticalSection(&jsnt_sql_lock);

				EXEC SQL CLOSE active_step_curs; 
				EXEC SQL CLOSE active_job_curs; 
				LeaveCriticalSection(&jsnt_sql_lock);

				return(0);
			}

			if (l_sqlcode != ORCL_NO_ERROR)
			{
				ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
							"active_job_curs", sqlmsg, "JOBQ table", NULL);
				_ltoa((DWORD) __LINE__, sznum, 10);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff,"Fetch Cursor for active_job_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=", 
							szret, " ", sqlmsg, NULL);
				//sprintf(szbuff, "Fetch Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
				//			"active_job_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
				logit (0, szbuff);
				debug_log (szbuff);
				EnterCriticalSection(&jsnt_sql_lock);

				EXEC SQL CLOSE active_step_curs; 
				EXEC SQL CLOSE active_job_curs; 
				LeaveCriticalSection(&jsnt_sql_lock);

				return(-1);
			}

			trim_sql_jobq(&job_q);

			job_q_num = job_q.no;			


			// DAN SAYS I HAVE TO REOPEN THE STEPQ CURSOR BEFORE TRYING TO OBTAIN NEW STEPS
			// Open active_step_curs cursor
			EnterCriticalSection(&jsnt_sql_lock);

			EXEC SQL OPEN active_step_curs;

			l_sqlcode = sqlca.sqlcode;
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			LeaveCriticalSection(&jsnt_sql_lock);


			if (l_sqlcode != ORCL_NO_ERROR)
			{
				ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
							"active_step_curs", sqlmsg, " ", NULL);
				_ltoa((DWORD) __LINE__, sznum, 10);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff,"Open Cursor for active_step_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=",
							szret, " ", sqlmsg, NULL);
				//sprintf(szbuff, "Open Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
				//			"active_step_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
				logit (0, szbuff);
				debug_log (szbuff);
				EnterCriticalSection(&jsnt_sql_lock);

				EXEC SQL CLOSE active_job_curs; 
				LeaveCriticalSection(&jsnt_sql_lock);

				return(-1);
			}
 
		}

		j_first_time=0;

 
		if(job_q.status[0] != 'A') 
 
		{
			debug_log("No more active jobs found");
			if(base_dir_job > 0) 
				base_dir_job = 0;

			if(same_group_job > 0) 
			{
				same_group_job=0;
				same_machine_group_name[0] = 0;
			}

			break;
		}
	
		copy_cat(szbuff, "Checking active job ", job_q.name, NULL);
		//sprintf(szbuff, "Checking active job %s", job_q.name);
		debug_log(szbuff);

		status = check_class();                     
		if(status != 0)                             
		{                                      
			debug_log("Job skipped because of class");      
			 continue;                             
		}                                      

		/* Check machine dependencey */
		trimr((char*)job_q.station);
		if(job_q.station[0]) 
		{
			if(strcmp(szjsname, (char*)job_q.station) != 0) 
			{
				debug_log("Skipped because of station dependency");
				continue;
			}
		}


 
		trimr(job_q.job_suspended);
		if(job_q.job_suspended[0]) 
		{
			debug_log("Skipped because job is suspended");
			continue;
		}
 
		/* If we started a Non-multiprocessing job or a Group dependent
		on the same machine - make sure we select this job */
		if(base_dir_job > 0) 
		{
			if(job_q.no != base_dir_job) 
			{
				debug_log("Skipped because job number not same as base directory job");
				continue;
			}
		}

		if(same_group_job > 0) 
		{
			if(job_q.no != same_group_job) 
			{
				debug_log("Skipped because job number not same as same group job");
				continue;
			}
		}



 
		// Select using step_q.no and step_q.d_step
		memset(&step_q, 0, sizeof(step_q) );
		EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL FETCH active_step_curs INTO :step_q:step_q_ind;
		l_sqlcode = sqlca.sqlcode;
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		LeaveCriticalSection(&jsnt_sql_lock);



		if (l_sqlcode == ORCL_NOT_FOUND)
		{
			debug_log("No more steps for job");
			debug_log("Job has finished - closing job");
			if(close_job() != 0)
			{
				EnterCriticalSection(&jsnt_sql_lock);

				EXEC SQL CLOSE active_step_curs; 
				EXEC SQL CLOSE active_job_curs; 
				LeaveCriticalSection(&jsnt_sql_lock);

				return(-1);
			}
			return(0);
		}

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"active_step_curs", sqlmsg, "STEPQ table", NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"No step found for Job ", job_q.name, "  Fetch Cursor for active_step_curs Failed! on line ", 
						sznum, " - SQLCA.SQLCODE=", szret, " ", sqlmsg, NULL);
			//sprintf(szbuff, "No step found for Job %s.  Fetch Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
			//			job_q.name, "active_step_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log (szbuff);
			EnterCriticalSection(&jsnt_sql_lock);

			EXEC SQL CLOSE active_step_curs; 
			EXEC SQL CLOSE active_job_curs; 
			LeaveCriticalSection(&jsnt_sql_lock);

			return(-1);
		}

		trim_sql_stepq(&step_q);
 

		if(step_q.no != job_q.no) 
		{
			logit(0,"Could not find step for job");
			debug_log("Could not find step for job");
 
			EnterCriticalSection(&jsnt_sql_lock);

			EXEC SQL CLOSE active_step_curs; 
			EXEC SQL CLOSE active_job_curs; 
			LeaveCriticalSection(&jsnt_sql_lock);

 
			return(-1);
		}
		s_dep = 0;
		s_first_time = 1;



		while (1) 
		{
			if(s_first_time == 0) 
			{

 
				// Select using step_q.no and step_q.d_step
				memset(&step_q, 0, sizeof(step_q) );
				EnterCriticalSection(&jsnt_sql_lock);

				EXEC SQL FETCH active_step_curs INTO :step_q:step_q_ind;

				l_sqlcode = sqlca.sqlcode;
				strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
				LeaveCriticalSection(&jsnt_sql_lock);


				if (l_sqlcode == ORCL_NOT_FOUND)
				{
					debug_log("No more steps for job");
					break;
				}

				if (l_sqlcode != ORCL_NO_ERROR)
				{
					ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
								"active_step_curs", sqlmsg, "STEPQ table", NULL);
					_ltoa((DWORD) __LINE__, sznum, 10);
					_itoa(l_sqlcode, szret, 10);
					copy_cat(szbuff,"Fetch Cursor for active_step_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=",
								szret, " ", sqlmsg, NULL);
					//sprintf(szbuff, "Fetch Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
					//			"active_step_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
					logit (0, szbuff);
					debug_log (szbuff);
					EnterCriticalSection(&jsnt_sql_lock);

					EXEC SQL CLOSE active_step_curs; 
					EXEC SQL CLOSE active_job_curs; 
					LeaveCriticalSection(&jsnt_sql_lock);

					return(-1);
				}

				trim_sql_stepq(&step_q);
 
			}

			s_first_time = 0;

			if(step_q.no != job_q.no) 
			{
				debug_log("No more steps for job");
				break;
			}

			copy_cat(szbuff, "Checking active step ", step_q.s_name, NULL);
			//sprintf(szbuff, "Checking active step %s",step_q.s_name);
			debug_log(szbuff);


 
			if(step_q.status[0] != 'N' ) 
 
			{
				debug_log("Step skipped because it is not waiting to execute");
					continue;
			}
			
			/* Check Step Dependencies */
			status = test_s_dep();
			if(status == 1)
			{
				s_dep = 1;
				debug_log("A step dependency still exists");
				continue;      /* A step dependency still exists */   
			}
			else
			{
				if(status != 0)
				{
 
					EnterCriticalSection(&jsnt_sql_lock);

					EXEC SQL CLOSE active_job_curs; 
					EXEC SQL CLOSE active_step_curs; 
					LeaveCriticalSection(&jsnt_sql_lock);

 
					return(-1);
				}
			}
						
			if(same_group_job > 0) 
			{
				if(strcmp(same_machine_group_name, step_q.group_name) != 0) 
				{
					same_group_job=0;
					same_machine_group_name[0] = 0;
				}
			}

			/* Check group same machine dependency */
			trimr(step_q.group_name);
			if(strlen(step_q.group_name) > 0) 
			{


 
				if( (step_q.same_machine_flag_yn[0]=='Y') && (step_q.group_first_step_yn[0] == 'Y') ) 
 
				{
					same_group_job = job_q.no;
					strcpy(same_machine_group_name, step_q.group_name);
				}
			}


 
			last_step = step_q.step;
			strcpy((char*)last_s_name, step_q.s_name);
			strcpy((char*)last_g_name, step_q.group_name);


	   		// Try to Lock the row for updating up to 10 times before Erroring out.
			EnterCriticalSection(&jsnt_sql_lock);

			//for(tries=0; tries < LOCK_TRIES; tries++)
			//{
				EXEC SQL SELECT 
					status,
					pos,
					name
				INTO :job_status, :job_pos, :job_name
				FROM JOBQ
				WHERE name = :job_q.name
				AND   no   = :job_q.no
				FOR UPDATE;
				//FOR UPDATE NOWAIT;

				l_sqlcode = sqlca.sqlcode;
					
				if (l_sqlcode != ORCL_NO_ERROR)
				{
			//		if(tries < LOCK_TRIES)
			//			Sleep(1000);
			//		else
			//		{
						EXEC SQL CLOSE active_step_curs; 
						EXEC SQL CLOSE active_job_curs; 
						strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
						LeaveCriticalSection(&jsnt_sql_lock);

						ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
									"JOBQ", sqlmsg, "For Update", NULL);
						_itoa(l_sqlcode, szret, 10);
						copy_cat(szbuff, "Error selecting JOBQ for Update - sqlca.sqlcode=", 
									szret, sqlmsg, NULL);
						//sprintf (szbuff, "Error selecting JOBQ for Update - sqlca.sqlcode=%d, %s", 
						//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
						logit (0, szbuff);
						debug_log (szbuff);
						return -1;
			//		} 
				}
			//	break;
			//}


			EXEC SQL UPDATE JOBQ
				SET last_step = :last_step,
					last_s_name = :last_s_name,
					last_g_name = :last_g_name
				WHERE name = :job_q.name
				AND   no   = :job_q.no;

			l_sqlcode = sqlca.sqlcode;
	
			if(l_sqlcode != ORCL_NO_ERROR)
			{
				strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
				EXEC SQL CLOSE active_step_curs; 
				EXEC SQL CLOSE active_job_curs; 
				EXEC SQL ROLLBACK;
				LeaveCriticalSection(&jsnt_sql_lock);
				ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
								"JOBQ", sqlmsg, " ", NULL);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff,"Error during UPDATE of JOBQ table - SQLCA.SQLCODE=",
							szret, " ", sqlmsg, NULL);
				//sprintf(szbuff, "Error during UPDATE of JOBQ table - SQLCA.SQLCODE=%d, %s", 
				//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
				logit (0, szbuff);
				debug_log(szbuff);
				return -1;
			}
			

			EXEC SQL COMMIT;
			l_sqlcode = sqlca.sqlcode;

			if (l_sqlcode != ORCL_NO_ERROR)
			{
				strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
				EXEC SQL ROLLBACK;
				EXEC SQL CLOSE active_step_curs; 
				EXEC SQL CLOSE active_job_curs; 
				LeaveCriticalSection(&jsnt_sql_lock);

				ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
							"JOBQ", sqlmsg, " ", NULL);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff,"ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=",
							szret, " ", sqlmsg, NULL);
				//sprintf(szbuff, "ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=%d, %s", 
				//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
				logit (0, szbuff);
				debug_log(szbuff);
				return -1;
			}

			LeaveCriticalSection(&jsnt_sql_lock);

 

			return(1);        /* We found a step to process */
		}

		if(s_dep == 0)          /* Job Has Finished */
		{
			debug_log("Job has finished - closing job");
			if(close_job() != 0)
			{
 
				EnterCriticalSection(&jsnt_sql_lock);

				EXEC SQL CLOSE active_step_curs; 
				EXEC SQL CLOSE active_job_curs; 
				LeaveCriticalSection(&jsnt_sql_lock);

 
				return(-1);
			}
		}
	}

 
	EnterCriticalSection(&jsnt_sql_lock);

	EXEC SQL CLOSE active_step_curs; 
	EXEC SQL CLOSE active_job_curs; 
	LeaveCriticalSection(&jsnt_sql_lock);

 

	return(0);              /* No Active Jobs Found */
}


/********************* check_waiting ***************************
*                                                              *
* Description: This function checks the waiting job queue for  *
*  jobs to process.                                            *
*                                                              *
*  Returns values:											   *
*  SUCCESS	- No jobs waiting.								   *
*  ERR      - Error checking for jobs waiting                  *
*  (1)      - Job is waiting, and has been started             *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
* Modifiy Date:  07/29/99        By: Mike West                 *
* Modifiy Date:  17/Apr/2000 By: Sasidhar D & Sabari Girish J  *
* Description: Added code for priority checking				   *
*                                                              *
***************************************************************/
int check_waiting(void) 
{
	short int status=0;
	short int first_time=1;
	char szbuff[300];
	int l_sqlcode;
	char szret[10];
	char sznum[20];
	char sqlmsg[80];

	// WR27164 - Hamsha
	char szcode[10];
	char tempstr[500];

 
	EXEC SQL BEGIN DECLARE SECTION;
		short l_rownum;
		long l_count;
		char  l_rowid[ROWS][19];
		char  job_server[10];
		char js_group[10]; // WR27164 - Hamsha
	EXEC SQL END DECLARE SECTION;
	
 
 
/* First, check to see if there are any rows there that are Ready & with priority 1 */
	strcpy(job_server, szjsname);

	EnterCriticalSection(&jsnt_sql_lock);

// Added for WR27164 on 02/14/2005 - Hamsha

	trimlr(job_server);
	memset(js_group,'\0',sizeof(js_group));

	EXEC SQL 
		SELECT trim(jsgroup) 
        INTO   :js_group
		FROM   JOB_SERVER_GROUPS
		WHERE  trim(STATION) = :job_server;
	
	l_sqlcode = sqlca.sqlcode;

	LeaveCriticalSection(&jsnt_sql_lock);

	if( (l_sqlcode != ORCL_NO_ERROR) &&  (l_sqlcode != ORCL_NOT_FOUND) )
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
				"JOB_SERVER_GROUPS", sqlmsg, "JS_GROUP", NULL);
		_itoa(l_sqlcode, szcode, 10);
		copy_cat(tempstr, "Error during SELECT FROM JOB_SERVER_GROUPS table - SQLCA.SQLCODE=",
				szcode, sqlmsg, NULL);
		logit (0, tempstr);
		debug_log(tempstr);
		return ERR;

	}
	
	if (l_sqlcode == ORCL_NOT_FOUND)
		memset(js_group, 0x00, sizeof(js_group));

	trimlr(js_group);

// End - Hamsha

	EnterCriticalSection(&jsnt_sql_lock);

   EXEC SQL SELECT rowid 
      INTO :l_rowid[0]
      FROM   JOBQ

// Modified for WR27164 on 02/14/2005 - Hamsha

//    WHERE status = 'R' 
//	  AND   (station is NULL OR station = :job_server)
//    AND   priority = 1 
//	  AND pos >= 0;
	   
	  WHERE status = 'R' 
		AND   ((station is NULL and jsgroup is NULL)
		OR  ( TRIM(station) = :job_server )  
		OR  ( TRIM(jsgroup) = :js_group ))
		AND   priority = 1 
		AND pos >= 0;

// End - Hamsha


   l_sqlcode = sqlca.sqlcode;
   l_count = sqlca.sqlerrd[2];		// returns how many rows were found
	
	LeaveCriticalSection(&jsnt_sql_lock);

/* if no record found with priority 1, then process sequentially */
	if( l_sqlcode == ORCL_NOT_FOUND )
	{
      EnterCriticalSection(&jsnt_sql_lock);

      EXEC SQL DECLARE ready_job_curs CURSOR FOR 
         SELECT rowid 
         FROM   JOBQ

// Modified for WR27164 on 02/14/2005 - Hamsha

//       WHERE status = 'R' 
//  	    AND   (station is NULL OR station = :job_server)
//          AND pos >= 0;


		 WHERE status = 'R' 
			AND   ((station is NULL and jsgroup is NULL)
			OR  ( TRIM(station) = :job_server )  
			OR  ( TRIM(jsgroup) = :js_group ))
			AND pos >= 0
			order by no	;//KLK WR 27164 - jobs were not being processed in order they were entered into jobq;

// End - Hamsha

		// Open ready_job_curs cursor
		EXEC SQL OPEN ready_job_curs;

		l_sqlcode = sqlca.sqlcode;
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		LeaveCriticalSection(&jsnt_sql_lock);


		if (l_sqlcode != ORCL_NO_ERROR)
		{
			ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"ready_job_curs", sqlmsg, "JOBQ table", NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"Open Cursor for ready_job_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=",
						szret, " ",sqlmsg, NULL);
			//sprintf(szbuff, "Open Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
			//			"ready_job_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log (szbuff);
			return(ERR);
		}

		// Fetch up to 100 rowid's from the JOBQ table
		EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL FETCH ready_job_curs INTO :l_rowid;

		l_sqlcode = sqlca.sqlcode;
		l_count = sqlca.sqlerrd[2];		// returns how many rows were found
		
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

		//LeaveCriticalSection(&jsnt_sql_lock); //KLK 2002-045

		if (l_sqlcode == ORCL_NOT_FOUND && l_count == 0)
		{
			debug_log("No ready files");
			EXEC SQL CLOSE ready_job_curs;			//KLK 2002-045
			LeaveCriticalSection(&jsnt_sql_lock);	//KLK 2002-045
			return(SUCCESS);
		}

		if (l_sqlcode != ORCL_NO_ERROR && l_count == 0)
		{
			ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"ready_job_curs", sqlmsg, "JOBQ table", NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"Fetch Cursor for ready_job_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=", 
						szret, " ", sqlmsg, NULL);
			//sprintf(szbuff, "Fetch Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
			//			"ready_job_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log (szbuff);
			EXEC SQL CLOSE ready_job_curs;			//KLK 2002-045
			LeaveCriticalSection(&jsnt_sql_lock);	//KLK 2002-045
			return(ERR);
		}

		LeaveCriticalSection(&jsnt_sql_lock); //KLK 2002-045
	}



	// If there are rows, then perform them row by row
	for(l_rownum=0; l_rownum < l_count; l_rownum++)
	{


		memset(&job_q, 0, sizeof(job_q) );

		EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL 
	   	  SELECT 
			status,
			pos,
			name,
			no,
			station,
			date_time_entered,
			date_time_started,
			date_time_completed,
			exit_code,
			station_submitting,
			msg_when_started,
			msg_when_done,
			multi_processing,
			date_time_to_start,
			start_stat,
			must_complete_by,
			c_msg_sent_yn,
			must_start_by,
			s_msg_sent_yn,
			msg_to_operator_yn,
			msg_to,
			priority,
			stn_started,
			num_d,
			d_job,
			d_hrs_back,
			d_cmplt,
			d_last_tested,
			orig_start_stat,
			job_suspended,
			restart,
			job_class,
			base_dir,
			max_job_time_warn,
			debug_mode_yn,
			last_step,
			last_s_name,
			last_g_name,
			submitted_file_name,
			p_msg_sent_yn,
			max_job_time_kill,
			max_c_msg_yn,
			stn_dependancy_yn,
			no_fail_message_yn,
			msg_when_failed,
			spawn_algorithm,
			spawn_parm,
			d_station,
			jsgroup   // WR27164 - Hamsha
		INTO :job_q:job_q_ind
		FROM JOBQ
		WHERE rowid = :l_rowid[l_rownum]
		FOR UPDATE;

		l_sqlcode = sqlca.sqlcode;

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
				"JOBQ", sqlmsg, "no",	NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"Select Failed for JOBQ table on line ", sznum, " - SQLCA.SQLCODE=", 
							szret, " ", sqlmsg, NULL);
			//sprintf(szbuff, "Select Failed for %s on line %ld - SQLCA.SQLCODE=%d, %s", 
			//			"JOBQ table", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log (szbuff);
			return(ERR);
		}
		
		trim_sql_jobq(&job_q);	

		// We have to check this status because another job server may have
		// already picked up this job.
		if(job_q.status[0] == 'R')
		{
			copy_cat(szbuff, "Testing job ", job_q.name, NULL);
			//sprintf(szbuff, "Testing job %s", job_q.name);
			debug_log(szbuff);

			if (strlen(szjsclass) > 0) 
			{
				trimr(job_q.job_class);
				if (szjsclass[0] != job_q.job_class[0]) 
				{
					EXEC SQL ROLLBACK;
					LeaveCriticalSection(&jsnt_sql_lock);
					logit (0, "Job skipped because of class");
					debug_log("Job skipped because of class");
					continue;
				}
			}
	

			/* Make sure operator has released */
			if (job_q.start_stat == 2 || job_q.start_stat == 3) 
			{
				EXEC SQL ROLLBACK;
				LeaveCriticalSection(&jsnt_sql_lock);
				logit(0, "Operator has not released job");
				debug_log("Operator has not released job");
				continue;
			}
	
	
			/* Check Job depenencies */
			if (status = test_j_dep()) 
			{
				if (status == 1) 
				{
					EXEC SQL ROLLBACK;
					LeaveCriticalSection(&jsnt_sql_lock);
					logit(0, "A job dependency still exists");
					debug_log("A job dependency still exists");
					continue;      /* A job dependency still exists */
				}
				EXEC SQL ROLLBACK;
				EXEC SQL CLOSE ready_job_curs;
				LeaveCriticalSection(&jsnt_sql_lock);

				return ERR;
			}
				
			/* Check station dependency */
			trimr((char*)job_q.station);
			if(strlen((char*)job_q.station) > 0) 
			{
				if(strcmp(szjsname, (char*)job_q.station) != 0) 
				{
					EXEC SQL ROLLBACK;
					LeaveCriticalSection(&jsnt_sql_lock);
					debug_log("Job not started because of station dependency");
					continue;
				}
			}
						
			debug_log ("Starting job");
			// if status = 1, another job server is running this job, 
			// if status <> 0, some other error happened
			if (status = start_job (l_rowid[l_rownum]) )  
			{
				EXEC SQL ROLLBACK;
				EXEC SQL CLOSE ready_job_curs;
				LeaveCriticalSection(&jsnt_sql_lock);
				if (status==1) break;	/* Somebody else beat us to is, nothing to do now */
				return ERR;				/* Or - Serious error - get out */
			}
			else
			{
				EXEC SQL CLOSE ready_job_curs; //KLK 2002-045
				LeaveCriticalSection(&jsnt_sql_lock);
				return (1);			// Else, we found a JOB to run, return */
			}
		}	// end of if(job_q.status[0] == 'R')

		EXEC SQL ROLLBACK;
		LeaveCriticalSection(&jsnt_sql_lock);
	}	// end of for loop

	// Nothing to do, close cursor
	EnterCriticalSection(&jsnt_sql_lock);
	EXEC SQL CLOSE ready_job_curs;
	LeaveCriticalSection(&jsnt_sql_lock);


 



	return SUCCESS;
}


/************************ start_job ****************************
*                                                              *
* Description: This function sets up information in the step   *
*  and job queue records in order to start the job.            *
*                                                              *
* Called from check_waiting() function.                        *
*                                                              *
*  Return values:                                              *
*  SUCCESS - Job was started successfully.                     *
*  ERR     - An error occurred while trying to start the job.  *
*  (1)     - Another JSNT grabbed the job & started it before  *
*            we could get ahold of it.                         *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
* Modifiy Date:  12/26/96        By: Andrew Bartels            *
*                                                              *
***************************************************************/
int start_job (char *rowid) 
{
   short int status=0;
   short int start_step=1;
   short int set_drive;
   char szbuff[300];
   //short int tries;
   int   l_sqlcode;
   char  szret[20];
   char  sznum[10];
   char  sqlmsg[80];


 
	EXEC SQL BEGIN DECLARE SECTION;
		short int start_step_no=1;
		//char job_status[2];
		//long job_pos;
		//unsigned char job_name[10];
		char lcl_rowid[25];
	EXEC SQL END DECLARE SECTION;
 

	trimr(job_q.base_dir);
	if (strlen (job_q.base_dir) > 0) 
	{
		_getcwd (curr_dir, _MAX_PATH);   /* get current path  */
		curr_drive = _getdrive ();      /* get current drive */

		if(job_q.base_dir[1] == ':') 
		{
			set_drive = job_q.base_dir[0] - 'A' + 1;
			_chdrive(set_drive);      /* change to the base drive */
		}

		_chdir(job_q.base_dir);         /* change to the base directory */
		base_dir_job = job_q.no;
	}


 
   strcpy(job_q.status, "A");
   if (job_q.multi_processing[0] == '0') 
   {
      strcpy((char*)job_q.station, szjsname);
      base_dir_job = job_q.no;
   }

   strcpy(job_q.stn_dependancy_yn, "Y");

   if(get_system_date_time(job_q.date_time_started) != SUCCESS)
      return(ERR);
 


   /* Temporary Fix to keep job running */
   /* job on job server it started on  KLK 8/11/99 */
   strcpy ((char*)job_q.station, szjsname);
   strcpy ((char*)job_q.stn_started, szjsname); /* update record with server name */

   

 
	memset(&step_q, 0, sizeof(step_q) );

	// NOTE: We don't need to do a critical section here because
	//       this function is called from check_waiting() which
	//       is already doing the critical section for us.
	EXEC SQL SELECT 
		no,
		step,
		s_name,
		status,
		j_name,
		date_time_started,
		date_time_completed,
		exit_code,
		command_line,
		num_d,
		d_step,
		d_cmplt,
		d_last_tested,
		num_a,
		exit_codes_acceptable,
		job_machine,
		d_group,
		group_name,
		same_machine_flag_yn,
		group_first_step_yn,
		skip_yn,
		beg_console_msg,
		beg_suspend_yn,
		end_console_msg,
		end_suspend_yn,
		send_msg,
		run_if_error,
		status_interval
	INTO :step_q:step_q_ind
	FROM STEPQ
	WHERE no = :job_q.no
	AND   step = :start_step_no;

	l_sqlcode = sqlca.sqlcode;

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"STEPQ", sqlmsg, " ", NULL);
		//setxy(0,24);
		_itoa(l_sqlcode, szret, 10);
		_ltoa(job_q.no, sznum, 10);
		copy_cat(szbuff,"No Step 1 in Job ", sznum, " - sqlca.sqlcode=", 
					szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "No Step 1 in Job %ld - sqlca.sqlcode=%d, %s", 
		//			job_q.no, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (1, szbuff);
		debug_log(szbuff);
		return ERR;
	}

	trim_sql_stepq(&step_q);	

 
	

	while(step_q.num_d > 0)         /* while we have steps to run */
	{

 
		start_step_no++;

		memset(&step_q, 0, sizeof(step_q) );

		// NOTE: We don't need to do a critical section here because
		//       this function is called from check_waiting() which
		//       is already doing the critical section for us.
		EXEC SQL SELECT 
			no,
			step,
			s_name,
			status,
			j_name,
			date_time_started,
			date_time_completed,
			exit_code,
			command_line,
			num_d,
			d_step,
			d_cmplt,
			d_last_tested,
			num_a,
			exit_codes_acceptable,
			job_machine,
			d_group,
			group_name,
			same_machine_flag_yn,
			group_first_step_yn,
			skip_yn,
			beg_console_msg,
			beg_suspend_yn,
			end_console_msg,
			end_suspend_yn,
			send_msg,
			run_if_error,
			status_interval
		INTO :step_q:step_q_ind
		FROM STEPQ
		WHERE no = :job_q.no
		AND   step = :start_step_no;

		l_sqlcode = sqlca.sqlcode;

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"STEPQ", sqlmsg, " ", NULL);
			//setxy(0,24);
			logit (1, "No Steps found without dependencies");
			debug_log("No Steps found without dependencies");
			return ERR;
		}

		trim_sql_stepq(&step_q);	

 

	}		// end of while loop


	// Update JOBQ with information from STEPQ
	job_q.last_step = step_q.step;					/* set last step in job record  */
	strcpy ((char*)job_q.last_s_name, (char*)step_q.s_name);      /* set step name in job record  */
	strcpy ((char*)job_q.last_g_name, (char*)step_q.group_name);  /* set group name in job record */


 

	// This row should be locked from the check_waiting() function
	strcpy(lcl_rowid, rowid);


	// NOTE: We don't need to do a critical section here because
	//       this function is called from check_waiting() which
	//       is already doing the critical section for us.

	// NOTE: The SELECT FOR UPDATE is done in the check_waiting() function.
	//       Therefore, it's ok to go ahead and update this table now because this
	//       row is already locked.
	EXEC SQL UPDATE JOBQ
		SET last_step = :job_q.last_step,				/* set last step in job record  */
			last_s_name = :job_q.last_s_name,			/* set step name in job record  */
			last_g_name = :job_q.last_g_name,			/* set group name in job record */
			status      = :job_q.status,
			date_time_started = :job_q.date_time_started,
			stn_started  = :job_q.stn_started,
			station      = :job_q.station
			WHERE 
				ROWID = :lcl_rowid
				AND	 name = :job_q.name
				AND  no   = :job_q.no;

	l_sqlcode = sqlca.sqlcode;

	if(l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EXEC SQL ROLLBACK;
		ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"JOBQ", sqlmsg, " ", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff, "Error during UPDATE of JOBQ table - SQLCA.SQLCODE=", 
					szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "Error during UPDATE of JOBQ table - SQLCA.SQLCODE=%d, %s", 
		//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (0, szbuff);
		debug_log(szbuff);
		return ERR;
	}

	// NOTE: We don't need to do a critical section here because
	//       this function is called from check_waiting() which
	//       is already doing the critical section for us.
	EXEC SQL COMMIT;

	l_sqlcode = sqlca.sqlcode;

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EXEC SQL ROLLBACK;
		ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
				sqlmsg, "JOBQ table", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=", 
					szret, " ", sqlmsg, NULL);			
		//sprintf(szbuff, "ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=%d, %s", 
		//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (0, szbuff);
		debug_log(szbuff);
		return ERR;
	}

	if (job_q.msg_when_started[0] == '1')          /* need to send message that this */
	{
		debug_log ("Sending job begin message");   /* job is starting?             */
		send_begin_msg();
	}

 


   logit (1, "Job Started");
   return SUCCESS;

}


 

void trim_sql_jobq(js_jobq_sql_def *jobq)
{
		trimlr(jobq->status);
		trimlr(jobq->name);	
		trimlr(jobq->station);
		trimlr(jobq->date_time_entered);
		trimlr(jobq->date_time_started);
		trimlr(jobq->date_time_completed);
		trimlr(jobq->station_submitting);
		trimlr(jobq->msg_when_started);			
		trimlr(jobq->msg_when_done);	
		trimlr(jobq->multi_processing);
		trimlr(jobq->date_time_to_start);
		trimlr(jobq->must_complete_by);
		trimlr(jobq->c_msg_sent_yn);
		trimlr(jobq->must_start_by);             
		trimlr(jobq->s_msg_sent_yn);		
		trimlr(jobq->msg_to_operator_yn);
		trimlr(jobq->msg_to);
		trimlr((char*)jobq->stn_started);
		trimlr(jobq->d_job);
		trimlr(jobq->d_hrs_back);
		trimlr((char*)jobq->d_cmplt);
		trimlr(jobq->d_last_tested);
		trimlr(jobq->job_suspended);            
		trimlr(jobq->restart);                   
		trimlr(jobq->job_class);                  
		trimlr(jobq->base_dir);                  
		trimlr(jobq->debug_mode_yn);		     
		trimlr(jobq->last_s_name);	
		trimlr(jobq->last_g_name);				
		trimlr(jobq->submitted_file_name);       
		trimlr(jobq->p_msg_sent_yn);		        
		trimlr(jobq->max_c_msg_yn);		        
		trimlr(jobq->stn_dependancy_yn);		
		trimlr(jobq->no_fail_message_yn);			
		trimlr(jobq->msg_when_failed);			
		trimlr(jobq->d_station);
		trimlr(jobq->jsgroup);  // WR27164 - Hamsha	
				
}

void trim_sql_stepq(js_stepq_sql_def *stepq)
{
		trimlr(stepq->s_name);			
		trimlr(stepq->status);						
		trimlr(stepq->j_name);		
		trimlr(stepq->date_time_started);         
		trimlr(stepq->date_time_completed);       
		trimlr(stepq->command_line);            
		trimlr(stepq->d_step);                   
		trimlr(stepq->d_cmplt);					
		trimlr(stepq->d_last_tested);            
		trimlr(stepq->exit_codes_acceptable);
		trimlr(stepq->job_machine);				
		trimlr(stepq->d_group);					
		trimlr(stepq->group_name);                
		trimlr(stepq->same_machine_flag_yn);		
		trimlr(stepq->group_first_step_yn);		
		trimlr(stepq->skip_yn);				
		trimlr(stepq->beg_console_msg);          
		trimlr(stepq->beg_suspend_yn);			   
		trimlr(stepq->end_console_msg);           
		trimlr(stepq->end_suspend_yn);			
		trimlr(stepq->send_msg);                  
		trimlr(stepq->run_if_error);
}

                                                                                                                                                                                                                                                                                                                                                                             document/set1/SCAN.CPP_3.pdf                                                                        0000644     %g4001001 00000005752 14011436757 013744  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               
/***************************************************************

JSNT
Copyright (C) 1998 Deluxe Electronic Payment Systems

Scan Module

***************************************************************/

#include "jsnt.h"



int scan_file(char *src_file) 
{

    unsigned long exit_code=0L;     /* exit code of command line        */
	//STARTUPINFO si;                  /* STARTUPINFO structure            */
	//PROCESS_INFORMATION pi;          /* PROCESS_INFORMATION structure    */
	struct _stat info;
	int status;
	char process_command[100];
	int fh;
	int tries;
	int ret;
    int capture_screens = 0;	     /* Always 0=NO for file delivery */
    int time_out=0;                  /* Time to wait before terminating child process */
    int status_interval = 1;         /* Seconds to wait before checking          */
						   		     /* again to see if the child process is finished  */



	strcpy(process_command, scan_cmd);
    while (strsub (process_command, "%1", src_file));

	/* This function calls the Win32 API CreateProcess() function .        */
	//memset (&si, 0, sizeof (si));
	//memset (&pi, 0, sizeof (pi));


	//	if (NewProc (process_command, &si, &pi) != 0) return (ERR);
   ret = NewProc (process_command, status_interval, capture_screens, time_out, &exit_code);
   if (ret != PROCESS_EXIT) return ERR;

	
	/* The loop starts and uses the GetExitCodeProcess() function to determine if
	   the child process has terminated or not.  If it has terminated, the
	   exit code of the command line should return in udExitCode             */
	//while (1) {
	//	GetExitCodeProcess (pi.hProcess, &udExitCode);
	//	if (udExitCode != STILL_ACTIVE) {

			/* The child process has terminated, now close the process and thread handles. */
//            CloseHandle (pi.hProcess);   /* close process handle       */
  //          CloseHandle (pi.hThread);    /* close thread handle        */
    //        break;
      //   }
        // Sleep (500);   /* If the task is running, only check on it every half second */
	//}

   //status = (int)udExitCode;
   //if (status != SUCCESS) return (ERR);
   //else {
   //   /* Scan may be successful, but the file could have  */
   //   /* had a virus. The file is moved to a common virus */
   //   /* area if it is infected.  If the source file does */
   //   /* not exist in its original directory, it must     */
   //   /* have had a virus - return ERR                    */
      status = _stat(src_file, &info);
      if (status != SUCCESS) return (ERR);
      else {
         for(tries = 0; tries < 100; tries ++) {
            /* Make sure file was completely closed */
            /* by the SCAN program before continuing*/
            fh = _sopen (src_file, _O_RDONLY | _O_BINARY, _SH_DENYRW);
            if (fh != ERR)  {
               _close (fh);
               break;
            }
            Sleep(500);
         }
         if (tries == 100) return (ERR);
      }
   //}  
   return (SUCCESS);
}

                      document/set1/SCREEN.CPP_3.pdf                                                                      0000644     %g4001001 00000020330 14011436757 014164  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               /***************************************************************

JSNT
Copyright (C) 1998 Deluxe Electronic Payment Systems

Screen I/O Module

***************************************************************/

#include "jsnt.h"

/************************* print_usage *************************
*                                                              *
* Description: Displays the proper usage of the command line   *
*  parameters.                                                 *
*                                                              *
* Creation Date: 06/24/96        By: Mike West                 *
* Modified Date: 03/May/2000     By: Sasidhar D                *
*                                                              *
* Included /NO_STATUS_SCREENS                                  *							
***************************************************************/
void print_usage (void) {
	cls (TX_NORMAL);
	qtextf(2, 6, TX_NORMAL, " %s  Version %s",prog_name, prog_version);
	qtext(2,  8, " Usage:");
	qtext(2,  9, " JSNT  /HELP            - Display this screen");
	qtext(2, 10, "       /CONFIG=         - Full path of JCS Config File");
	qtext(2, 11, "       /JSNAME=         - Job Server name -default is JOBSERV");
	qtext(2, 12, "       /PATH=           - Full path for saving screen snapshots");
	qtext(2, 13, "       /JOBPATH=        - Full path for .JOB files");
	qtext(2, 14, "       /CLASS=          - Process jobs of ONLY this class");
	qtext(2, 15, "       /DEBUG           - Logs information to debug log");
	qtext(2, 16, "       /SCAN_CMD=       - Virus Scan Command if scanning for viruses");
	qtext(2, 17, "       /NO_DELIVERY     - Turns delivery off");
	qtext(2, 18, "       /NO_STATUS_SCREENS-Turns screen capturing off");
	qtext(2, 19, "       /MAX_DELIVERIES= - Max number of simultaneous deliveries");
	exit(1);
}                    

/*********************** deliv_box *****************************
*                                                              *
* Description: Displays the Delivery File box                  *
*                                                              *
* Creation Date: 07/02/96        By: Mike West                 *
*                                                              *
***************************************************************/
void deliv_box (void) {

	SYSTIME st;
	char szbuff[80];
	char month[3];
	char day[3];
	char year[5];
	char hour[3];
	char minute[3];
	char second[3];

	getsystime(&st);


   fmtint(month, st.wMonth, FNLPADZEROS, 2);
   fmtint(day, st.wDay, FNLPADZEROS, 2);
   fmtint(year, st.wYear%100,  FNLPADZEROS, 2);
   fmtint(hour, st.wHour,  FNLPADZEROS, 2);
   fmtint(minute, st.wMinute,  FNLPADZEROS, 2);
   fmtint(second, st.wSecond,  FNLPADZEROS, 2);


	qtextr(5,  0, "");
	qtextr(5,  1, "                                                                    ");
	qtextr(5,  2, "");
	qtextr(5,  3, "                                                                    ");
	qtextr(5,  4, "                                                                    ");
	qtextr(5,  5, "                                                                    ");
	qtextr(5,  6, "                                                                    ");
	qtextr(5,  7, "                                                                    ");
	qtextr(5,  8, "                                                                    ");
	qtextr(5,  9, "                                                                    ");
	qtextr(5, 10, "                                                                    ");
	qtextr(5, 11, "                                                                    ");
	qtextr(5, 12, "                                                                    ");
	qtextr(5, 13, "");

	copy_cat(szbuff, "Found File to Deliver                           ", 
					month, "/", day, "/", year, "  ", hour, ":", minute, ":", second, NULL);
	//sprintf(szbuff, "Found File to Deliver                           %2d/%02d/%02d  %02d:%02d:%02d", 
	//				st.wMonth, st.wDay, st.wYear-1900, st.wHour, st.wMinute, st.wSecond);
	qtextr(6,  1, szbuff);
}

/*********************** paint_box *****************************
*                                                              *
* Description: Displays the IDLE box                           *
*                                                              *
* Creation Date: 06/24/96        By: Mike West                 *
* Modified Date: 12/20/96        By: Andrew Bartels            *
*                                                              *
***************************************************************/
void paint_box_c(void) {
	char tempstr[80];
	char cdir[_MAX_PATH];

	qtext(xpos,ypos,                       "");

	copy_cat(tempstr, "[Job Server: ", szjsname, "]", NULL);
	//sprintf (tempstr, "[Job Server: %s]", szjsname);
	qtext (xpos + (strlen(tempstr)/2 + 1), ypos, tempstr);

//	qtext(xpos,ypos+STATUS_LINE,           "        Waiting for Job or Delivery...     ");
	if(!no_delivery && !no_submit)
		qtext(xpos,ypos+STATUS_LINE,           "        Waiting for Job or Delivery...     ");
	else if (!no_delivery)
		qtext(xpos,ypos+STATUS_LINE,           "        Waiting for Delivery...            ");
	else
		qtext(xpos,ypos+STATUS_LINE,           "        Waiting for Job...                 ");

	qtext(xpos,ypos+2, szdispline3);

	_getcwd(curr_dir, _MAX_PATH);
	uppercase (curr_dir);

	strcpy(cdir, curr_dir);
	if(strlen(cdir) < 36)
		_padl(cdir, ' ', 36);
	else
		cdir[36] = 0;

	copy_cat(tempstr,                      " DIR: ", cdir, " ", NULL);  
	//sprintf (tempstr,					   " DIR: %-36.36s ", curr_dir);
	qtext(xpos,ypos+3, tempstr);

	qtext(xpos,ypos+4,                     "");
	setxy(xpos+30,ypos+2);
}

/*********************** screen_blank **************************
*                                                              *
* Description: Determines when to move the IDLE box and        *
*  where to display it.                                        *
*                                                              *
* Creation Date: 06/24/96        By: Mike West                 *
*                                                              *
***************************************************************/
void screen_blank(void) {
	long t;
	static long last_time=0;
	SYSTIME st;
	
	time(&t);

	if( (t-last_time) > 5)     /* Screen Blanking */
	{   
		last_time = t;
		getsystime(&st);
		xpos=st.wSecond + st.wHsec;
		if(xpos > 35) xpos=35;

		ypos = ypos + 6;        /* clw 5->6 */ 
		if(ypos >= 24) ypos=0;  /* clw 25->24 */
		cls(TX_NORMAL);
		paint_box_c();
	}
}


/********************* display_paused **************************
*                                                              *
* Description: Pauses the Job Server and waits for operator    *
*              response.                                       *
*                                                              *
* Creation Date: 06/24/96        By: Mike West                 *
*                                                              *
***************************************************************/
void display_paused(void)
{
	short int i;
	CHAR_INFO *pCharInfo;
	
/* Save area of screen so we can put it back later.               */
	pCharInfo = (CHAR_INFO*)gettext(0, 0, 26, 5);

	qtext(0,0," JS SUSPENDED ");
	qtext(0,1,"    This Server is      ");
	qtext(0,2,"   SUSPENDED waiting    ");
	qtext(0,3," for Operator Response. ");
	qtext(0,4,"");
	i = _getch();
	if(i==0)
		i = _getch();

/* Put the area of screen back                              */
	puttext(0, 0, 26, 5, pCharInfo);
	free(pCharInfo);
}



void ifsdisplay(char type, char *pname, char *pver, char *text)
{
	qtext(10, 15, text);
	//printf("\n%s",text);
}                                                                                                                                                                                                                                                                                                        document/set1/StackWalk.cpp_3.pdf                                                                   0000644     %g4001001 00000013305 14011436757 015235  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               #include "StackWalk.h"
#include "except.h"

#include "Dbghelp.h"

using namespace std;

#define WIN32_LEAN_AND_MEAN
#define  WORK_AROUND_SRCLINE_BUG
extern int logitwithlocaltime (int log_type, char *msg);

void CStackWalk::InitLogString(std::string tempStr)
{
	strLogString = tempStr;
 
}
 
BOOL __stdcall My_ReadProcessMemory (HANDLE temp, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead)
{
	BOOL bFlag;
	DWORD result;

	HANDLE hProcess;
	int error;
	error = 9;

	DWORD Pid = GetCurrentProcessId();
	hProcess =	OpenProcess(PROCESS_VM_READ,false,Pid);

//	hProcess = GetCurrentProcess();	
//	result =  GetLastError();

	bFlag = ReadProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead); 

	result =  GetLastError();
    return bFlag;
}


void CStackWalk::init()
{
	SymSetOptions(SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS);
	HANDLE hProcess;
	int error;
	hProcess = GetCurrentProcess();	

	if (SymInitialize(hProcess, NULL, TRUE))	
	{
		// Load the modules if necessary
	}
	else
	{
		// SymInitialize failed
		error = GetLastError();
		printf("SymInitialize error: %d\n", error);
		return;
		
	}
	
}

int CStackWalk::symbol(char * buf, unsigned len, unsigned * pdisplacement,DWORD* _address)
{
	if (!len || !buf || 
		IsBadWritePtr(buf, len) ||
		(pdisplacement && IsBadWritePtr(pdisplacement, sizeof(unsigned))))
		return 0;


	BYTE symbol [ 512 ] ;
	PIMAGEHLP_SYMBOL pSym = (PIMAGEHLP_SYMBOL)&symbol;
	memset(pSym, 0, sizeof(symbol)) ;
	pSym->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL) ;
    pSym->MaxNameLength = sizeof(symbol) - sizeof(IMAGEHLP_SYMBOL);

	HANDLE hProc = GetCurrentProcess();
	DWORD displacement = 0;
	int r = SymGetSymFromAddr(hProc, *_address, &displacement, pSym);
	if (!r) return 0;
	if (pdisplacement) 
		*pdisplacement = displacement;

	r = _snprintf(buf, len, "%s()", pSym->Name);
    
	r = r == -1 ? len - 1 : r;
	buf[r] = 0;	
	return r;
}

void CStackWalk::getLineNumber(DWORD pdisplacement1)
{
	
	HANDLE hProcess;
			hProcess = GetCurrentProcess();		
			IMAGEHLP_LINE img_line;
			memset(&img_line, 0, sizeof(IMAGEHLP_LINE));
			img_line.SizeOfStruct = sizeof(IMAGEHLP_LINE);				


	#ifdef WORK_AROUND_SRCLINE_BUG

			DWORD displacement = 0 ;
			while (!SymGetLineFromAddr (hProcess, *m_address - pdisplacement1, &displacement, &img_line))
			{        
				if (100 == ++displacement)
				return ;        
			}
	
			cout << img_line.FileName<< "("  << img_line.LineNumber << ") : ";
			int  ch = '\\';
			char nLineNumber[10];

			char* tt = strrchr(img_line.FileName,ch); 
			tt++;
			
			strLogString.append(tt);
			strLogString.append("  -   ");
			_itoa(img_line.LineNumber,nLineNumber,10);
			strLogString.append(nLineNumber);
			strLogString.append("  -   ");
	
	
		//	if (pdisplacement)    
			pdisplacement = displacement;    
			return ;
	
	#else 
			//
			if(	SymGetLineFromAddr (hProcess, *m_address, &pdisplacement, &img_line))
			{
				cout << img_line.FileName<< "("  << img_line.LineNumber << ") : ";								
			}
			else
			{
				error = GetLastError();
				//printf("Getline error: %d\n", error);
				cout << "Line number 0\n";
				//format(error);
			}	

	#endif 

	//SymCleanup(GetCurrentProcess());

}

bool CStackWalk::Stack_trace(achStructured* pExcep)
{
	pException = pExcep;
	strLogString.append(pException->GetErrText());
	strLogString.append(" ");
	STACKFRAME * m_pframe = new STACKFRAME;

	pctx = e_ptrs->ContextRecord;
	if(!m_pframe) return false;

	memset(m_pframe, 0, sizeof(STACKFRAME));

	// Seems the context varies depending on the processor.. so...

	#ifdef _X86_
    m_pframe->AddrPC.Offset       = pctx->Eip;
    m_pframe->AddrPC.Mode         = AddrModeFlat;
    m_pframe->AddrStack.Offset    = pctx->Esp;
    m_pframe->AddrStack.Mode      = AddrModeFlat;
    m_pframe->AddrFrame.Offset    = pctx->Ebp;
    m_pframe->AddrFrame.Mode      = AddrModeFlat;
    #else
    m_pframe->AddrPC.Offset       = (DWORD)pctx->Fir;
    m_pframe->AddrPC.Mode         = AddrModeFlat;
    m_pframe->AddrReturn.Offset   = (DWORD)pctx->IntRa;
    m_pframe->AddrReturn.Mode     = AddrModeFlat;
    m_pframe->AddrStack.Offset    = (DWORD)pctx->IntSp;
    m_pframe->AddrStack.Mode      = AddrModeFlat;
    m_pframe->AddrFrame.Offset    = (DWORD)pctx->IntFp;
    m_pframe->AddrFrame.Mode      = AddrModeFlat;
    #endif
//	DWORD address;
	init(); // load the symbols first
	pdisplacement = 0;	
	while (stack_next(m_pframe,pctx))
	{
		if(*m_address)
			
			getLineNumber(pdisplacement);
		char buf[256];
		unsigned pdisplacement1 = 0;
		if(symbol(buf, 256, &pdisplacement1,m_address)	)
		{
			cout << "function " << buf << endl;

			strLogString.append(" function ");
			strLogString.append(buf);
			strLogString.append(" ");

		}
		if(strcmp(buf,"main()")==0) break;
	}
	
	SymCleanup(GetCurrentProcess());

	logitwithlocaltime(0,(char*)strLogString.c_str());

	return true;
}
bool CStackWalk::stack_next(STACKFRAME* m_pframe, CONTEXT *m_pctx)
{
	if (!m_pframe || !m_pctx) 
	{		
		return false;
	}		
	
	SetLastError(0);
	HANDLE hProc = GetCurrentProcess();
	BOOL r = StackWalk (IMAGE_FILE_MACHINE_I386,
				//hProc, 
				GetCurrentProcess(), 
				GetCurrentThread(), 
				m_pframe, 
				m_pctx,
				(PREAD_PROCESS_MEMORY_ROUTINE)My_ReadProcessMemory,
				SymFunctionTableAccess,
                SymGetModuleBase,
				0);

	DWORD tt;
	tt= GetLastError();

	if (!r || !m_pframe->AddrFrame.Offset)
	{		
		return false;
	}	

	
	DWORD dwModBase = SymGetModuleBase (hProc, m_pframe->AddrPC.Offset);
	if (!dwModBase) 
	{	
		
		return false;
	}

	m_address =&m_pframe->AddrPC.Offset;	
	return true;
}

                                                                                                                                                                                                                                                                                                                           document/set1/StackWalk.h_1.pdf                                                                     0000644     %g4001001 00000001600 14011436757 014673  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               #ifndef _STACKWALK_H_
#define _STACKWALK_H_

#include <windows.h>
#include <iostream>
#include <malloc.h>
#include <stdlib.h>

#include "Dbghelp.h"

class achStructured;

class CStackWalk
{

public:

	bool Stack_trace(achStructured* pException);
	void InitLogString(std::string tempStr);
	void setExceptionPointer(EXCEPTION_POINTERS *ptr)
		{ e_ptrs = ptr;
		}
	std::string strLogString;
	

private:

	void init();
	int symbol(char * buf, unsigned len, unsigned * pdisplacement,DWORD* m_address);
	bool stack_next(STACKFRAME* m_pframe, CONTEXT *m_pctx);
	void load_module(HANDLE hProcess, HMODULE hMod);
	void getLineNumber(DWORD pdisplacement);
	
	

	DWORD pdisplacement;
	DWORD* m_address;
	CONTEXT *pctx;
	int m_nLineNo;
	char *m_cModuleName;
	char *m_cFileName;
	EXCEPTION_POINTERS* e_ptrs;
	achStructured* pException;

};

#endif //_STACKWALK_H_                                                                                                                                document/set1/STRING.CPP_3.pdf                                                                      0000644     %g4001001 00000035631 14011436757 014225  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               /***************************************************************

JSNT
Copyright (C) 1998 Deluxe Electronic Payment Systems

String Handling Support Functions

***************************************************************/

#include "jsnt.h"

/************************* blnknull ****************************
*                                                              *
* Description: This function will check the passed variable    *
*  to see if the variable is either blank or null.             *
*  It will return 1 if the variable is blank or null and 0     *
*  if has valid characters in it.                              *
*                                                              *
* Creation Date: 06/26/96        By: Mike West                 *
*                                                              *
***************************************************************/
int blnknull (char *chkbuff)
{
   unsigned short int len;

   if (!(len = strlen (chkbuff)))
      return(1);                                            /* Zero length = null */
   while (len--)
   {
      if (!isspace (*chkbuff))
         return 0;                                          /* Got something - not null */
      chkbuff++;
   }
   return 1;                                                /* Was all nulls */
}


/************************ replacevar ***************************
*                                                              *
* Description: This function will look at the filename passed  *
*  and replace any tokens that are in the filename based on    *
*  the table below.                                            *
*                                                              *
*       <mm> - standard month 1-12                             *
*       <m>  - hex month 1-C                                   *
*       <yy> - standard year                                   *
*       <dd> - standard day                                    *
*		<d>  - 1 char day (1-9, A-V)						   *
*       <u>  - 1 character unique identifer 0-Z                *
*       <uu> - 2 character unique identifier 00-ZZ             *
*	   <uuu> - 3 character unique identifier 000-ZZZ           *
*       <p>  - step identifier (initialized to 0)              *
*                                                              *
*  If the path of the file is found, then we can determine     *
*  a unique identifier if the <U> tokens are used.  If the     *
*  path cannot be found, then we cannot determine a unique     *
*  identifier and the <U>'s will be replaced with "0"'s.       *
*                                                              *
*  With the change on 4/22/98, if you try to use a wildcard    *
*  character of '?' along with any of the above tokens, then   *
*  your '?' will be replaced with a 0!                         *
*                                                              *
*                                                              *
* Creation Date: 06/26/96        By: Mike West                 *
* Modified Date: 03/05/97        By: Andrew Bartels            *
* Modified Date: 04/22/98        By: Mike West                 *
*                                                              *
***************************************************************/
void replacevar (char *path, char *filename) {
	SYSTIME st;                     /* System time structure */
    long count;                     /* Unique counter for <U> replacements */
	long hFile;                     /* Handle for _findfirst() */
    char tempstr[50];               /* Temp place for replacement strings */
	char tempfile [_MAX_PATH];      /* Temp file path for <U> replacements */
	struct _stat info2;
	int status;
	struct _finddata_t info;        /* File info for _findfirst */
	
	getsystime(&st);                 /* get current system date & time    */
    uppercase (filename);
	

/* Don't even do any replacement if there are no carets (<) in the filename */
   if(strstr(filename, "<") != NULL)
   {
   /*  Replace all <YYYY> and <YY> year parameters */
	  padlz (_itoa (st.wYear, tempstr, 10), 4);
	  while (strsub (filename, "<YYYY>", tempstr)) ;
	  padlz (_itoa (st.wYear % 100, tempstr, 10), 2);
	  while (strsub (filename, "<YY>", tempstr)) ;

   /*  Replace all <MM> and <M> month parameters */
	  padlz (_itoa (st.wMonth, tempstr, 10),2);
	  while (strsub (filename, "<MM>", tempstr)) ;
	  _itoa (st.wMonth, tempstr, 36);
	  while (strsub (filename, "<M>", tempstr)) ;

   /*  Replace all <DD> and <D> day parameters */
	  padlz (_itoa (st.wDay, tempstr, 10), 2);
	  while (strsub (filename, "<DD>", tempstr)) ;
	  _itoa (st.wDay, tempstr, 36);
	  while (strsub (filename, "<D>", tempstr)) ;

   /*  Replace all <P> parameters */
	  while (strsub (filename, "<P>", "?")) ;
   
   /*  Replace all <U>, <UU>, and <UUU> parameters */
	  if (strstr (filename, "<U")) 
	  {
   
   /*      Look for the directory existing - if not, get out early! */
		 strcpy (tempfile, path);
		 count = strlen (tempfile);
		 if (tempfile[count-1]=='\\') tempfile[count-1] = 0;
		 if ((status = _stat(tempfile, &info2))!=ERR) 
		 {
			   count = 0;
			   do 
			   {
   
				  if (path[strlen(path)-1]=='\\') copy_cat (tempfile, path, filename, NULL);
				  else                            copy_cat (tempfile, path, "\\", filename, NULL);
   
   /*              Replace all <U> parameters */
				  padlz (_ltoa (count, tempstr, 36), 3);
				  uppercase (tempstr);
   
				  if (strstr (tempfile, "<UUU>") && count >= (36L * 36L * 36L)) break;
				  else while (strsub (tempfile, "<UUU>", tempstr));
				  if (strstr (tempfile, "<UU>") && count >= (36L * 36L)) break;
				  else while (strsub (tempfile, "<UU>",  tempstr + 1));
                   if (strstr (tempfile, "<U>") && count >= 36L) break;
				  else while (strsub (tempfile, "<U>",   tempstr + 2));

   /*              Try to locate the filename - if not present, stop & return that filename */
//				  if (status = stat(tempfile, &info2) != 0) 
//					  break;
  				  if ((hFile = _findfirst (tempfile, &info))==ERR) 
					  break;
				  _findclose (hFile);
				  
				  count++;
			   } while (1);

			   _splitpath (tempfile, NULL, NULL, filename, tempstr);   /* Extract FILENAME.EXT */
			   strcat (filename, tempstr);
		 }
      }
	  	  
	  /*  Replace all ? characters (from <P>) with zeros */
	  while (strsub (filename, "?", "0")) ;

	  /*  If we could not find the file path specified,   */
	  /*  then we could not determine a unique identifier */
	  /*  for the file. Therefore, replace all <U>'s with */
	  /*  zeros.                                          */
 	  while (strsub (filename, "<U>", "0")) ;
   	  while (strsub (filename, "<UU>", "00")) ;
   	  while (strsub (filename, "<UUU>", "000")) ;
   }
}


/************************* replwild ****************************
*                                                              *
* Description: This function searches a filename with wild     *
*  cards chars in it (? and *) and replaces these wild cards   *
*  with the char(s) in the Original name.  The returned        *
*  replaced filename is in newname.                            *
*                                                              *
* Note: This function has one caveat, that being the wild card *
*       mask cannot intermingle the '?' and '*' in the same    *
*       base string or extension string.                       *
*       Example:  ?*.ACH <--- NOT VALID                        *
*                 A*.??? <--- VALID!                           *
*                                                              *
* Creation Date: 07/30/96        By: Mike West                 *
*                                                              *
***************************************************************/
void replwild (char *origname, char *wildname, char *newname)
{
   char *origptr;
   char *wildptr;
   char *newptr;

   char strorigname[256], strwildname[256];					/* R150347237-Delivery Editor Enhancement */
   int  origlen, wildlen, position = 0;						/* R150347237-Delivery Editor Enhancement */

   origptr = origname;                                      /* attach pointers to the strings        */
   wildptr = wildname;
   newptr = newname;

   //R150347237-Delivery Editor Enhancement, Start 
   memset(strorigname, 0x00,     sizeof(strorigname));
   memset(strwildname, 0x00,     sizeof(strwildname));

   memcpy(strorigname, origname, sizeof(strorigname));
   memcpy(strwildname, wildname, sizeof(strwildname));

   origlen = strlen(strorigname);
   wildlen = strlen(strwildname);

   //R150347237-Delivery Editor Enhancement, End
   
   memset (newptr, 0, sizeof (newptr));

   while(*wildptr)
   {
      if (*wildptr == '?' || *wildptr == '*')               /* is character in WILDNAME a wild card char? */
      {
         if(*wildptr == '?')                                /* Is this character a wild card '?' */
         {
            if(*origptr)                                    /* If not at End of String? */
               *newptr++ = *origptr++;                      /* copy char from ORIGNAME to NEWNAME */
         }
         else
         {
/*          copy all characters from ORIGNAME to NEWNAME up to the '.' or EOS  */
            while(*origptr)
            {
               if(*origptr == '.')
                  break;
               *newptr++ = *origptr++;
			   position++;									//Increment Position, if wildcard is * and copying the character from source, R150347237-Delivery Editor Enhancement
            }
         }
      }
	  //Added elseif for R150347237-Delivery Editor Enhancement
	  // If wildcard is #, copy character from source on the same positon reading from tailing end.
	  // This wildcard is used, if we want to Prefix text to source name.
	  else if (*wildptr == '#')	
	  {
		  if(wildlen-position <= origlen)
			  *newptr++ = strorigname[origlen-wildlen+position];
	  }
      else
      {
         if(! *wildptr)                                     /* at End of String? */
            break;
         else
         {
            if(*wildptr == '.')                             /* is character in WILDNAME a '.' */
            {
               while(*origptr)
               {
                  if(*origptr == '.')
                  {
                     origptr++;                             /* increment ORIGNAME past its '.' */
                     break;                                 /*   or to EOS, whichever is first */
                  }
                  origptr++;
               }
            }
            *newptr = *wildptr;                             /* copy char from WILDNAME to NEWNAME */
            newptr++;
            if(*wildptr != '.')
            {
               if(! *origptr || *origptr != '.')            /* increment ORIGNAME only if not '.' or EOS */
                  origptr++;
            }
            if(! *wildptr)                                  /* is WILDNAME at EOS      */
               break;
         }
      }
      if(*wildptr)
	  {
         wildptr++;
		 position++;										/* R150347237-Delivery Editor Enhancement */
	  }
   }
    *newptr = 0;                                            /* Added by ABB 12/26/96 */
}


/******************** replace_variables ************************
*                                                              *
* Description: This function the environment variables (%var%) *
*  within the passed string. (Usually the stepq command line)  *
*                                                              *
* Creation Date:  10/30/96        By: Mike West                *
*                                                              *
***************************************************************/
void replace_variables(char *buf)
{
   char *q;
   char *envir;
   char *bufptr;
   char work1[512];
   char work2[512];
   char szbuff[200];

   strcpy(work1, buf);
   bufptr = work1;

   if((bufptr = strchr(work1, '%')) == NULL)                /* do we have any % characters in the string? */
      return;

   while(*bufptr)                                           /* as long as we have a string to work with       */
   {
      q = work2;
      if(*bufptr == '%')
      {

         bufptr++;
         while( (*bufptr != '%') ) *q++ = *bufptr++;
            *q++ = 0;
         bufptr++;

         envir = getenv(work2);                        /* find the variable in the registry environment   */
         if(envir == NULL)
         {
			copy_cat(szbuff, "Warning - Environment variable ", work2, "not in environment", NULL);
            //sprintf(szbuff, "Warning - Environment variable %s not in environment", work2);
            debug_log(szbuff);
            logit (2, szbuff);
            puts("\n");
            puts(szbuff);
            return;
         }

         memmove(work2+1, work2, strlen(work2)+1);   /* shift string over by one byte */
         work2[0] = '%';                             /* insert a % character            */
         strcat(work2, "%");                         /* concatenate a % character      */
         strsub(work1, work2, envir);                /* substitute string with the registry environment */
      }
      bufptr++;
   }
   strcpy(buf, work1);
   return;
}


/**************************** vld_path **************************
*                                                               *
* Description: Validates that the passed path exists            *
*                                                               *
*  Returns:  ERR - Path does not exist                          *
*            SUCCESS - Path exists                              *
*                                                               *
* Creation Date: 10/25/96           By: Mike West               *
* Modified Date: 02/11/99			By: Kellie Kupka            *
****************************************************************/
int vld_path(char *szpath)
{
	struct _stat info;
	int istrlen;
	int ret;
	int trys;
	char tmp[_MAX_PATH];

	istrlen = strlen(szpath);                                // get length of path
	memset(tmp, 0, _MAX_PATH);                               // set tmp variable to nulls
	memcpy(tmp, szpath, istrlen);                            // copy path to tmp variable

	if(tmp[istrlen-1] == '\\')                               // if last char is a '\', then
		tmp[istrlen-1] = '\0';                                // strip it off
   
	/* Try to find the valid path 4 times every    */
	/* 15 seconds for a 60 second period. This     */
	/* was added because sometimes the production  */
	/* path is unavailable for a short time.       */
	trys=1;
	ret = _stat(tmp,&info);
	while (ret != 0 && trys < 4) {
		Sleep(15000);
		ret = _stat(tmp,&info);
		trys++;
	}
	if (ret != 0) return(ERR);
	else  return(SUCCESS);
}





                                                                                                       document/set1/to_3.pdf                                                                              0000644     %g4001001 00000017560 14011436757 013221  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               /***************************************************************

JSNT 
Copyright (C) 1998 Deluxe Electronic Payment Systems

Support Functions - To be put into DDSINT.LIB In The Future

***************************************************************/


#include "jsnt.h"


/*********************** getsystime ****************************
*                                                              *
* Description: Retrieves system date and time.  Stores result  *
*    in a SYSTIME structure.                                   *
*                                                              *
*        typedef struct _SYSTEMTIME                            *
*         {  // st                                             *
*            WORD wYear;                                       *
*            WORD wMonth;                                      *
*            WORD wDayOfWeek;                                  *
*            WORD wDay;                                        *
*            WORD wHour;                                       *
*            WORD wMinute;                                     *
*            WORD wSecond;                                     *
*            WORD wMilliseconds;                               *
*         } SYSTEMTIME;                                        *
*                                                              *
*                                                              *
*    Hundredth's of Seconds value is accurate to within 55ms,  *
*    or approximately 1/18th of a second.                      *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modified Date: 11/03/95        By: Andrew Bartels            *
* Modified Date: 07/10/96        By: Mike West                 *
*        Added WIN32 Console support                           *
* Modified Date: 07/12/96       By; Mike West                  *
*       Changed return result to go to a date/time structure.  *
*                                                              *
***************************************************************/

#ifdef WIN32
void getsystime (struct _SYSTIME *st)
{
   SYSTEMTIME systime;

   GetLocalTime(&systime);
   st->wDayOfWeek = systime.wDayOfWeek;         /* Day of week   Sun=0, Sat = 6 */
   st->wYear      = systime.wYear;              /* Year  (1980-2099) */
   st->wMonth     = systime.wMonth;             /* Month (1-12) */
   st->wDay       = systime.wDay;               /* Day   (1-31) */

/* Time information */
   st->wHour      = systime.wHour;              /* Hour                  (0-23) */
   st->wMinute    = systime.wMinute;            /* Minute                (0-59) */
   st->wSecond    = systime.wSecond;            /* Second                (0-59) */
   st->wHsec      = systime.wMilliseconds / 10; /* Hundredth's of Second (0-99) */
}
#else
void getsystime (struct _SYSTIME *st) {
   union REGS regs;

/* Date information */
   regs.h.ah = 0x2A;
   int86 (0x21, &regs, &regs);
   st->wDayOfWeek)   = regs.h.al;               /* Day of week   Sun=0, Sat = 6 */
#ifdef WATCOM
   st->wYear       = regs.w.cx;                 /* Year  (1980-2099) */
#else
   st->wYear)      = regs.x.cx;
#endif
   st->wMonth      = regs.h.dh;                 /* Month (1-12) */
   st->wDay         = regs.h.dl;                /* Day   (1-31) */

/* Time information */
   regs.h.ah = 0x2C;
   int86 (0x21, &regs,&regs);
   st->wHour      = regs.h.ch;                  /* Hour                  (0-23) */
   st->wMinute      = regs.h.cl;                /* Minute                (0-59) */
   st->wSecond      = regs.h.dh;                /* Second                (0-59) */
   st->wHsec      = regs.h.dl;                  /* Hundredth's of Second (0-99) */
}
#endif


/********************* get_primary_card_addr *******************
*                                                              *
* Description: Gets the IPX address of the first network       *
*   adapter in the machine.  Uses WINSOCK to create a socket   *
*   and bind with IPX.  The user may specify init_sockets=1    *
*   to cause WSAStartup to be called before hand, and          *
*   WSACleanup() to be called afterwards.                      *
*                                                              *
*   Return values may be any valid return from a call to       *
*   WSAGetLastError(), or ERR if there were no network cards   *
*   found.  Return will be SUCCESS if there were no errors,    *
*   and the network address has been returned successfully.    *
*                                                              *
*   Note: Must #include the following MSVC headers:            *
*       <winsock.h>                                            *
*       <wsipx.h>                                              *
*       <wsnwlink.h>                                           *
*                                                              *
* Creation Date: 12/22/95         By: Andrew Bartels           *
*                                                              *
***************************************************************/
//KLK REPLACE WITH TCPIP
//int get_primary_card_addr (ipx_inet_addr *card_addr, char init_sockets) {
//
//   SOCKET s;                       /* Socket handle */
//    SOCKADDR_IPX addr;              /* IPX Socket Address Info */
//    IPX_ADDRESS_DATA ipx_data;      /* Detailed data about IPX connection */
//    int adapter_count, opt_len;     /* Adapter count, option length buffer */
//   WSADATA wsdata;                 /* WinSock info data struct */

/*  Only call WSAStartup if user says it's OK */
//    if (init_sockets) {
//        if (WSAStartup(MAKEWORD (1,1), &wsdata))
//            return WSAGetLastError();
//    }

/*  Create IPX socket, and bind with IPX */
//    s = socket (AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
//    memset (&addr, 0, sizeof (addr));
//    addr.sa_family = AF_IPX;
//    bind (s, (SOCKADDR *) &addr, sizeof (SOCKADDR_IPX));

/*  Determine how many adapters are present */
//    opt_len = sizeof (adapter_count);
//    getsockopt (s, NSPROTO_IPX, IPX_MAX_ADAPTER_NUM,
//        (char *) &adapter_count, &opt_len);

/*  No adapters present - return ERR */
//    if (!adapter_count) {
//        if (init_sockets) WSACleanup();
//        return ERR;
//    }

/*  At least one adapter is present - return it's address */
//    else {
//        ipx_data.adapternum = 0;         /* Get data for first adapter */
//        opt_len = sizeof (ipx_data);
//        getsockopt (s, NSPROTO_IPX, IPX_ADDRESS, (char *) &ipx_data, &opt_len);

/*      Copy network leg number and node address to destination buffers */
//        memcpy (card_addr, ipx_data.netnum, sizeof (*card_addr));
//    }

//    if (init_sockets) WSACleanup();
//    return SUCCESS;
//}
//KLK END REPLACE WITH TCPIP


/************************* str_begend **************************
*                                                              *
* Description: Adds the start and end characters specified to  *
*   the start and end of the string.  The string buffer must   *
*   be large enough to hold two additional characters.         *
*                                                              *
* Creation Date: 05/27/98         By: Andrew Bartels           *
*                                                              *
***************************************************************/
char *str_begend (char *str, char start, char end) {
   int len;

/* Add the starting character to the string */
   len = strlen (str) + 1;
   memmove (str+1, str, len);    /* Memmove guarantees copy in overlapped buffers */
   str[0] = start;

/* Add the ending character */
   str[len]   = end;
   str[len+1] = 0;

   return str;  /* Return original string ptr for nexted function calls */
}                                                                                                                                                document/set2/                                                                                      0000755     %g4001001 00000000000 14277611122 011645  5                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               document/set2/CKEOD.cpp_3.pdf                                                                       0000644     %g4001001 00000340333 14011517351 014171  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               
/* Result Sets Interface */
#ifndef SQL_CRSR
#  define SQL_CRSR
  struct sql_cursor
  {
    unsigned int curocn;
    void *ptr1;
    void *ptr2;
    unsigned int magic;
  };
  typedef struct sql_cursor sql_cursor;
  typedef struct sql_cursor SQL_CURSOR;
#endif /* SQL_CRSR */

/* Thread Safety */
typedef void * sql_context;
typedef void * SQL_CONTEXT;

/* Object support */
struct sqltvn
{
  unsigned char *tvnvsn; 
  unsigned short tvnvsnl; 
  unsigned char *tvnnm;
  unsigned short tvnnml; 
  unsigned char *tvnsnm;
  unsigned short tvnsnml;
};
typedef struct sqltvn sqltvn;

struct sqladts
{
  unsigned int adtvsn; 
  unsigned short adtmode; 
  unsigned short adtnum;  
  sqltvn adttvn[1];       
};
typedef struct sqladts sqladts;

static struct sqladts sqladt = {
  1,0,0,
};

/* Binding to PL/SQL Records */
struct sqltdss
{
  unsigned int tdsvsn; 
  unsigned short tdsnum; 
  unsigned char *tdsval[1]; 
};
typedef struct sqltdss sqltdss;
static struct sqltdss sqltds =
{
  1,
  0,
};

/* File name & Package Name */
struct sqlcxp
{
  unsigned short fillen;
           char  filnam[11];
};
static const struct sqlcxp sqlfpn =
{
    10,
    ".\\CKEOD.pc"
};


static unsigned int sqlctx = 64907;


static struct sqlexd {
   unsigned int   sqlvsn;
   unsigned int   arrsiz;
   unsigned int   iters;
   unsigned int   offset;
   unsigned short selerr;
   unsigned short sqlety;
   unsigned int   occurs;
      const short *cud;
   unsigned char  *sqlest;
      const char  *stmt;
   sqladts *sqladtp;
   sqltdss *sqltdsp;
            void  **sqphsv;
   unsigned int   *sqphsl;
            int   *sqphss;
            void  **sqpind;
            int   *sqpins;
   unsigned int   *sqparm;
   unsigned int   **sqparc;
   unsigned short  *sqpadto;
   unsigned short  *sqptdso;
   unsigned int   sqlcmax;
   unsigned int   sqlcmin;
   unsigned int   sqlcincr;
   unsigned int   sqlctimeout;
   unsigned int   sqlcnowait;
              int   sqfoff;
   unsigned int   sqcmod;
   unsigned int   sqfmod;
   unsigned int   sqlpfmem;
            void  *sqhstv[11];
   unsigned int   sqhstl[11];
            int   sqhsts[11];
            void  *sqindv[11];
            int   sqinds[11];
   unsigned int   sqharm[11];
   unsigned int   *sqharc[11];
   unsigned short  sqadto[11];
   unsigned short  sqtdso[11];
} sqlstm = {13,11};

// Prototypes
extern "C" {
  void sqlcxt (void **, unsigned int *,
               struct sqlexd *, const struct sqlcxp *);
  void sqlcx2t(void **, unsigned int *,
               struct sqlexd *, const struct sqlcxp *);
  void sqlbuft(void **, char *);
  void sqlgs2t(void **, char *);
  void sqlorat(void **, unsigned int *, void *);
}

// Forms Interface
static const int IAPSUCC = 0;
static const int IAPFAIL = 1403;
static const int IAPFTL  = 535;
extern "C" { void sqliem(unsigned char *, signed int *); }

 static const char *sq0001 = 
"select fi_rt ,eod_status  from fi where (active_yn='Y' and wh_status='E')   \
        ";

 static const char *sq0009 = 
"select task_type ,fi_rt ,task_id ,dist_prof_id ,upper(task_name) ,upper(file\
_name) ,upper(run_at_eod_yn) ,proc_opt ,days_past ,dist_ts ,corp_orig_id  from\
 task_sch where ((((fi_rt=:b0 and task_type='R') and run_at_eod_yn='Y') and pr\
oc_status='N') and TO_CHAR(due_dt,'YYYYMMDD')<=:b1)           ";

 static const char *sq0019 = 
"select TO_CHAR(due_dt,'YYYYMMDD') ,run_hhmm  from task_sch where ((fi_rt=:b0\
 and task_type='E') and proc_status='N') order by due_dt,run_hhmm            ";

typedef struct { unsigned short len; unsigned char arr[1]; } VARCHAR;
typedef struct { unsigned short len; unsigned char arr[1]; } varchar;

/* cud (compilation unit data) array */
static const short sqlcud0[] =
{13,4130,178,0,0,
5,0,0,1,84,0,521,66,0,0,0,0,0,1,0,
20,0,0,1,0,0,525,83,0,0,2,0,0,1,0,2,97,0,0,2,97,0,0,
43,0,0,1,0,0,527,102,0,0,0,0,0,1,0,
58,0,0,2,140,0,516,130,0,0,3,2,0,1,0,2,3,0,0,1,97,0,0,1,97,0,0,
85,0,0,3,45,0,517,154,0,0,1,1,0,1,0,1,97,0,0,
104,0,0,4,59,0,517,215,0,0,1,1,0,1,0,1,97,0,0,
123,0,0,5,0,0,541,234,0,0,0,0,0,1,0,
138,0,0,6,59,0,517,271,0,0,1,1,0,1,0,1,97,0,0,
157,0,0,7,59,0,517,282,0,0,1,1,0,1,0,1,97,0,0,
176,0,0,8,0,0,541,306,0,0,0,0,0,1,0,
191,0,0,9,294,0,521,373,0,0,2,2,0,1,0,1,97,0,0,1,97,0,0,
214,0,0,9,0,0,525,390,0,0,11,0,0,1,0,2,97,0,0,2,97,0,0,2,4,0,0,2,4,0,0,2,97,0,
0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,
273,0,0,9,0,0,525,417,0,0,11,0,0,1,0,2,97,0,0,2,97,0,0,2,4,0,0,2,4,0,0,2,97,0,
0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,
332,0,0,9,0,0,527,437,0,0,0,0,0,1,0,
347,0,0,10,45,0,517,491,0,0,1,1,0,1,0,1,97,0,0,
366,0,0,11,0,0,541,510,0,0,0,0,0,1,0,
381,0,0,12,245,0,516,528,0,0,6,4,0,1,0,2,97,0,0,2,97,0,0,1,97,0,0,1,97,0,0,1,
97,0,0,1,97,0,0,
420,0,0,13,207,0,517,567,0,0,5,5,0,1,0,1,97,0,0,1,97,0,0,1,97,0,0,1,97,0,0,1,
97,0,0,
455,0,0,14,0,0,541,593,0,0,0,0,0,1,0,
470,0,0,15,146,0,516,676,0,0,2,1,0,1,0,2,3,0,0,1,97,0,0,
493,0,0,16,106,0,516,699,0,0,2,1,0,1,0,2,3,0,0,1,97,0,0,
516,0,0,17,69,0,516,747,0,0,2,1,0,1,0,2,3,0,0,1,97,0,0,
539,0,0,18,70,0,516,787,0,0,2,1,0,1,0,2,3,0,0,1,97,0,0,
562,0,0,19,153,0,521,873,0,0,1,1,0,1,0,1,97,0,0,
581,0,0,19,0,0,525,890,0,0,2,0,0,1,0,2,97,0,0,2,97,0,0,
604,0,0,19,0,0,527,907,0,0,0,0,0,1,0,
619,0,0,20,220,0,516,926,0,0,4,3,0,1,0,2,3,0,0,1,97,0,0,1,97,0,0,1,97,0,0,
650,0,0,21,106,0,516,964,0,0,3,2,0,1,0,2,3,0,0,1,97,0,0,1,97,0,0,
677,0,0,22,59,0,517,993,0,0,1,1,0,1,0,1,97,0,0,
696,0,0,23,0,0,541,1015,0,0,0,0,0,1,0,
};


/*******************************************************************************
CKEOD.PC -- An ACHOS Program - Module of WATCH.EXE

Copyright (C) 1995, 1998 Deluxe Data Systems, Inc.
Copyright (C) 1997, 1998, 1999 Deluxe Electronic Payent Systems, Inc.

Part of WATCH.EXE which does "End Of Day" processing.*/


/* EXEC SQL BEGIN DECLARE SECTION; */ 

/* This #define PREVENTS the sqlca to be declared as external in sqlca.h */

#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern
#define INCLUDE_AS_EXTERN   extern

/* EXEC SQL END DECLARE SECTION; */ 


/*******************************************************************************/
/* EXEC SQL BEGIN DECLARE SECTION; */ 

      char  g_fi_rt[10];
      char  g_task_name[31];
      char  g_task_id[20];
/* EXEC SQL END DECLARE SECTION; */ 


/*******************************************************************************
   INCLUDES & DEFINES                              
*******************************************************************************/

/* EXEC SQL INCLUDE  "sqlproto.h";
 */ 
#include <sqlcpr.h>

/* EXEC SQL INCLUDE  "sqlca.h";
 */ 
/*
 * $Header: sqlca.h,v 1.3 1994/12/12 19:27:27 jbasu Exp $ sqlca.h 
 */

/* Copyright (c) 1985,1986, 1998 by Oracle Corporation. */
 
/*
NAME
  SQLCA : SQL Communications Area.
FUNCTION
  Contains no code. Oracle fills in the SQLCA with status info
  during the execution of a SQL stmt.
NOTES
  **************************************************************
  ***                                                        ***
  *** This file is SOSD.  Porters must change the data types ***
  *** appropriately on their platform.  See notes/pcport.doc ***
  *** for more information.                                  ***
  ***                                                        ***
  **************************************************************

  If the symbol SQLCA_STORAGE_CLASS is defined, then the SQLCA
  will be defined to have this storage class. For example:
 
    #define SQLCA_STORAGE_CLASS extern
 
  will define the SQLCA as an extern.
 
  If the symbol SQLCA_INIT is defined, then the SQLCA will be
  statically initialized. Although this is not necessary in order
  to use the SQLCA, it is a good pgming practice not to have
  unitialized variables. However, some C compilers/OS's don't
  allow automatic variables to be init'd in this manner. Therefore,
  if you are INCLUDE'ing the SQLCA in a place where it would be
  an automatic AND your C compiler/OS doesn't allow this style
  of initialization, then SQLCA_INIT should be left undefined --
  all others can define SQLCA_INIT if they wish.

  If the symbol SQLCA_NONE is defined, then the SQLCA variable will
  not be defined at all.  The symbol SQLCA_NONE should not be defined
  in source modules that have embedded SQL.  However, source modules
  that have no embedded SQL, but need to manipulate a sqlca struct
  passed in as a parameter, can set the SQLCA_NONE symbol to avoid
  creation of an extraneous sqlca variable.
 
MODIFIED
    lvbcheng   07/31/98 -  long to int
    jbasu      12/12/94 -  Bug 217878: note this is an SOSD file
    losborne   08/11/92 -  No sqlca var if SQLCA_NONE macro set 
  Clare      12/06/84 - Ch SQLCA to not be an extern.
  Clare      10/21/85 - Add initialization.
  Bradbury   01/05/86 - Only initialize when SQLCA_INIT set
  Clare      06/12/86 - Add SQLCA_STORAGE_CLASS option.
*/
 
#ifndef SQLCA
#define SQLCA 1
 
struct   sqlca
         {
         /* ub1 */ char    sqlcaid[8];
         /* b4  */ int     sqlabc;
         /* b4  */ int     sqlcode;
         struct
           {
           /* ub2 */ unsigned short sqlerrml;
           /* ub1 */ char           sqlerrmc[70];
           } sqlerrm;
         /* ub1 */ char    sqlerrp[8];
         /* b4  */ int     sqlerrd[6];
         /* ub1 */ char    sqlwarn[8];
         /* ub1 */ char    sqlext[8];
         };

#ifndef SQLCA_NONE 
#ifdef   SQLCA_STORAGE_CLASS
SQLCA_STORAGE_CLASS struct sqlca sqlca
#else
         struct sqlca sqlca
#endif
 
#ifdef  SQLCA_INIT
         = {
         {'S', 'Q', 'L', 'C', 'A', ' ', ' ', ' '},
         sizeof(struct sqlca),
         0,
         { 0, {0}},
         {'N', 'O', 'T', ' ', 'S', 'E', 'T', ' '},
         {0, 0, 0, 0, 0, 0},
         {0, 0, 0, 0, 0, 0, 0, 0},
         {0, 0, 0, 0, 0, 0, 0, 0}
         }
#endif
         ;
#endif
 
#endif
 
/* end SQLCA */
/* EXEC SQL INCLUDE  "orcltype.h";
 */ 
/***************************************************************

ACHOS Function Library
Copyright (C) 1996 Deluxe Electronic Payment Systems, Inc.

Header Containing TypeDefs for Native ORACLE data types
and function prototypes for ORCLTYPE.LIB.

NOTE:  Programs should use EXEC SQL INCLUDE orcltype;
to include this header AFTER including achosprd.h!

FILE:			ORCLTYPE.H

CREATED:		07/01/96		Troy Clark
MODIFIED:	11/25/96		Troy Clark

***************************************************************/

#ifndef	ORCLTYPE_H_
#define	ORCLTYPE_H_

/***************************************************************
	Typedefs
***************************************************************/
/*
NOTICE:  Any changes made to oracle_date or oracle_varnum typedefs
			must also be made to their re-definition within DDSI.H
			The duplication is required so that DDSI.H does not
			required using oracles pro*c precompiler!
*/

/* EXEC SQL BEGIN DECLARE SECTION; */ 


typedef	struct	oracle_date_tag {
	unsigned char	century;
	unsigned	char	year;
	unsigned	char	month;
	unsigned	char	day;
	unsigned	char	hour;
	unsigned char	minute;
	unsigned char	second;
} oracle_date;

typedef struct oracle_varnum_tag {
	unsigned char	length;			/* # of bytes to follow -- includes expon. */
	unsigned char	exponent;			
	unsigned char	mantissa[20];	/* signif.digits - NO lead/trail zeros */
} oracle_varnum;

/* EXEC SQL TYPE	oracle_date		IS		DATE; */ 

/* EXEC SQL TYPE	oracle_varnum	IS		VARNUM(22); */ 


/* EXEC SQL END DECLARE SECTION; */ 


#endif

#include          "ddsi.h"
#include          "achosprd.h"

/* EXEC SQL INCLUDE watch; /o inserts watch.h into src for Pro*C o/ 
 */ 
/***************************************************************

WATCH.H Header File for WATCH.EXE and it's assoc. sub-programs
Version 1.08.10

Copyright (C) 1995 Deluxe Data Systems, Inc.
Copyright (C) 1997, 1998 Deluxe Electronic Payent Systems, Inc.

Header Containing Prototypes for all functions in the ACHOSPRD.LIB
   FILE:       watch.h
   CREATED:    06/18/1996  Troy Clark
   MODIFIED:   06/18/1996  Troy Clark
   MODIFIED:   05/14/1998  FRNash
***************************************************************/


/***************************************************************
   INCLUDES 
***************************************************************/


/***************************************************************
   TYPEDEFS, DEFINES AND DECLARATIONS
***************************************************************/
#ifndef _WATCH_H_
#define _WATCH_H_

/* EXEC SQL BEGIN DECLARE SECTION; */ 


#define  TSCH_BUF_CNT            100
#define  IOQ_BUF_CNT             100
#define  FSCH_BUF_CNT            100
#define  FI_BUF_CNT              101
#define  MAX_LOOP_CNT            50
#define  MAX_NACHA_CURSOR_CNT    100
#define  MOUSE_TARGET_MIN_X      36
#define  MOUSE_TARGET_MIN_Y      23

#define  MOUSE_TARGET_MAX_X      39
#define  MOUSE_TARGET_MAX_Y      23

#define  blank_line " "
/* 
   Max allowed FI cnt = (FI_BUF_CNT - 1) or 100 
   This makes detecting when more than max allowed FI recs exist easy
   since doing an array fetch only sets sqlca.sqlcode == 0 when it
   fetches exactly the same # of rows as the array size.  Otherwise,
   it will set sqlca.sqlcode = 100 and sqlca.sqlerrd[2] = actual fetch
   cnt.
*/

typedef struct rpt_info_rec_tag {
   char     task_type[2];
   char     fi_rt[10];
   double   task_id;
   double   dist_prof_id;
   char     task_name[31];       /* max len is 30 */
   char     file_name[13];
   char     run_at_eod_yn[2];
   char     proc_opt[101];        /* max len is 100  Increased the size for SLA Report */
   char     dist_ts[16];         /* max len is 15 */
   char     corp_orig_id[11];
} rpt_info_rec_type;

typedef struct watch_tsch_recs_tag {
   char     task_type       [TSCH_BUF_CNT][2];
   char     fi_rt           [TSCH_BUF_CNT][10];
   double   task_id         [TSCH_BUF_CNT];
   double   dist_prof_id    [TSCH_BUF_CNT];
   char     task_name       [TSCH_BUF_CNT][31];  /* max len is 30 */
   char     file_name       [TSCH_BUF_CNT][13];
   char     run_at_eod_yn   [TSCH_BUF_CNT][2];
   char     proc_opt        [TSCH_BUF_CNT][101];  /* max len is 100 */
   int      days_past       [TSCH_BUF_CNT];
   char     dist_ts         [TSCH_BUF_CNT][16];
   char     corp_orig_id    [TSCH_BUF_CNT][11];
} watch_tsch_recs;

typedef struct watch_tsch_ind_recs_tag {
   short    task_type       [TSCH_BUF_CNT];
   short    fi_rt           [TSCH_BUF_CNT];
   short    task_id         [TSCH_BUF_CNT];
   short    dist_prof_id    [TSCH_BUF_CNT];
   short    task_name       [TSCH_BUF_CNT];
   short    file_name       [TSCH_BUF_CNT];
   short    run_at_eod_yn   [TSCH_BUF_CNT];
   short    proc_opt        [TSCH_BUF_CNT];
   short    days_past       [TSCH_BUF_CNT];
   short    dist_ts         [TSCH_BUF_CNT];
   short    corp_orig_id    [TSCH_BUF_CNT];
} watch_tsch_ind_recs;  /* indicators for watch_task_recs */

typedef struct watch_ioq_recs_tag {
   char     file_name      [IOQ_BUF_CNT][13];
   char     recv_ts        [IOQ_BUF_CNT][15];
   char     fi_rt          [IOQ_BUF_CNT][10];
   char     type           [IOQ_BUF_CNT][4];
} watch_ioq_recs;

typedef struct watch_ioq_ind_recs_tag {
   short    file_name      [IOQ_BUF_CNT];
   short    recv_ts        [IOQ_BUF_CNT];
   short    fi_rt          [IOQ_BUF_CNT];
   short    type           [IOQ_BUF_CNT];
} watch_ioq_ind_recs;

typedef struct watch_fsch_recs_tag {
   char     fi_rt          [FSCH_BUF_CNT][10];
   double   file_sch_id    [FSCH_BUF_CNT];
   double   file_id        [FSCH_BUF_CNT];
   char     earliest_ts    [FSCH_BUF_CNT][15];  /* TS is in 'YYYYMMDDHH24MISS' format */
   char     latest_ts      [FSCH_BUF_CNT][15];
} watch_fsch_recs;

typedef struct watch_fsch_ind_recs_tag {
   short    fi_rt          [FSCH_BUF_CNT];
   short    file_sch_id    [FSCH_BUF_CNT];
   short    file_id        [FSCH_BUF_CNT];
   short    earliest_ts    [FSCH_BUF_CNT];
   short    latest_ts      [FSCH_BUF_CNT];
} watch_fsch_ind_recs;

typedef  struct watch_fi_rt_rec_tag {
   char     fi_rt[FSCH_BUF_CNT][10];
} watch_fi_rt_rec;

typedef  struct watch_eod_rec_tag {
   char     fi_rt[FSCH_BUF_CNT][10];
   char     eod_status[FSCH_BUF_CNT][2];
} watch_eod_rec;

typedef  struct watch_eod_ind_rec_tag {
   short    fi_rt[FSCH_BUF_CNT];
   short    eod_status[FSCH_BUF_CNT];
} watch_eod_ind_rec;

typedef  struct g_nacha_file_id_tag 
{
char     fi_rt[MAX_NACHA_CURSOR_CNT][10];
double   nacha_file_id[MAX_NACHA_CURSOR_CNT];
}g_nacha_file_rec;


typedef  struct g_nacha_file_ind_tag 
{
short    fi_rt[MAX_NACHA_CURSOR_CNT];
short    nacha_file_id[MAX_NACHA_CURSOR_CNT];
}g_nacha_file_ind;   

/* Struct Def. for Nacha File Id used in CKTSKSCH.PC (DS)*/

INCLUDE_AS_EXTERN watch_tsch_recs        g_tsch_recs;
INCLUDE_AS_EXTERN watch_tsch_ind_recs    g_tsch_inds;
INCLUDE_AS_EXTERN int                    g_tsch_cnt;
INCLUDE_AS_EXTERN watch_ioq_recs         g_ioq_recs;
INCLUDE_AS_EXTERN watch_ioq_ind_recs     g_ioq_inds;
INCLUDE_AS_EXTERN int                    g_ioq_cnt;
INCLUDE_AS_EXTERN watch_fsch_recs        g_fsch_recs;
INCLUDE_AS_EXTERN watch_fsch_ind_recs    g_fsch_inds;
INCLUDE_AS_EXTERN int                    g_fsch_cnt;
INCLUDE_AS_EXTERN watch_fi_rt_rec        g_fi_rt_rec;


INCLUDE_AS_EXTERN g_nacha_file_rec  g_nacha_file_id;
INCLUDE_AS_EXTERN g_nacha_file_ind  g_nacha_file_id_ind; 
INCLUDE_AS_EXTERN  rpt_info_rec_type rpt_info_rec;
INCLUDE_AS_EXTERN char        g_prn_dt[9];
INCLUDE_AS_EXTERN char        g_prn_time[6];
INCLUDE_AS_EXTERN char        g_cur_dt[9];               /* current date */
INCLUDE_AS_EXTERN char        g_cur_time[5];             /* current time */
INCLUDE_AS_EXTERN char        g_cur_dt_time[14];         /* current date and time */
INCLUDE_AS_EXTERN char*       gpszIFSMsg;
INCLUDE_AS_EXTERN char        g_user_name[81];
INCLUDE_AS_EXTERN char        g_db_name[81];
INCLUDE_AS_EXTERN char        g_orcl_etext_buf[256];
INCLUDE_AS_EXTERN char        g_fi_info[81];
INCLUDE_AS_EXTERN int         g_orcl_etext_len;
INCLUDE_AS_EXTERN int         g_orcl_etext_size;
INCLUDE_AS_EXTERN char        p_fi_rt[10];
INCLUDE_AS_EXTERN char        gs_scratch[81];
INCLUDE_AS_EXTERN char        g_corp_orig_id[11];                 /* psm - 5/08/1997 mod */
INCLUDE_AS_EXTERN int         g_num_fi;
INCLUDE_AS_EXTERN int         g_cur_fi;
INCLUDE_AS_EXTERN int         loop_cnt;                  

/* EXEC SQL END DECLARE SECTION; */ 


/* job path and btrieve path */
INCLUDE_AS_EXTERN  char        job_path[81];        
INCLUDE_AS_EXTERN char        exe_path[81];
INCLUDE_AS_EXTERN char        eod_job_name[81];

/***************************************************************
   FUNCTION PROTOTYPES 
***************************************************************/

/* Functions are listed by source file in order of their appearance */


/* SOURCE FILE:   ckeod.pc       */
void  ck_eod               (void);
void  do_start_eod         (int task_no);
BOOL  do_eod_reports       (char*);
BOOL  do_eod_job           (char*);
int   no_tasks_in_proc     (char*);
int   no_input_in_proc     (char*);
int   no_eod_in_proc       (char*);
BOOL  fail_check           (char *);


/* SOURCE FILE:   ckfildlv.pc       */
void  ck_file_dlvrs        (void);
void  deliver_file         (int ioq_no);


/* SOURCE FILE:   ckfilsch.pc       */
void  ck_file_sch          (void);
void  input_file           (int ioq_no);
int   ioq_set_status       (char *file_name, char *fi_rt, char *status_str);
/* 
   NOTE: ioq_set_status() needs to be put in ACHOSPRD.LIB once tested.
*/
int   file_sch_set_status  (char *fi_rt, double fsch_id, char new_status);
/* 
   NOTE: file_sch_set_status() needs to be put in ACHOSPRD.LIB once tested.
*/
int   id_input_file        (char *rec_one, char *fi_rt, FILE *file_handle, 
                              char * file_name_str, double *file_id,
                              char *reject_yn, int *rec_size);
long  find_one_rec         (FILE* fPointer, int* rec_size, long offset_to_one,
                              char* file_name_str);
int   id_nonnacha_file     (FILE *, char *);
long  one_rec_offset       (FILE *filePtr, char* file_name_str, int *rec_size);
void  log_file             (char *fi_rt, char *file_name, char *recv_ts, 
                              double dwFileID);
int   file_sch_hit         (char *fi_rt, double file_id, double *fsch_id);
void  file_sch_ck_at_risk  (void);
void  file_sch_ck_missed   (void);
void  get_corp_orig_id     (int fsch_no);


/* SOURCE FILE:   cktsksch.pc    */
void  ck_task_sch          (void);
void  do_task_dist         (int task_no);
void  do_task_fpickup      (int task_no);
void  do_task_integ        (int task_no);
void  do_task_report       (void);
void  do_nacha_file        (int task_no);
void  do_task_system       (int task_no);
void  do_group_task        (int task_no); // Added for DR#97-018 -FRN
void    do_task_purge         (int task_no); // Added for DR#97-199 -RMM
void  do_task_extract      (int task_no); // Added for DR#99-018 -SHA
void  do_task_billing      (int task_no); // Added for DR#99-018 -SHA
/* SOURCE FILE:   watch.pc       */
void  build_fi_rec();
void  do_exit              (int exit_value);
void  ck_mouse_quit        (HANDLE hConOut);
void  refresh_fi();
void  watch_events         (HANDLE hStdIn);
void  wr_cur_time();
void  wr_start_time();
void  wr_status(void);
int   submit_job(char* task_fi_rt, char* job_file, char* errstr,  char* arg[22], int arguments);
BOOL WINAPI CtrlHandler    (DWORD dwEvent);


/* SOURCE FILE:   mousehit.c     */
/* [Replaces the ACHOSPRD.LIB version of this function, which doesn't work!] */
short ck_mouse_hitx (HANDLE hConIn,  short min_x, short min_y, short max_x, short max_y);

#endif //_WATCH_H_





/************************** ck_eod *********************************************
* Description:                                                                 *
*   Set the status back.                                                       *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  11/16/1996  By: Dan Jung                                     *
* Modified Date:  06/18/1998  By: Mike West                                    *
* Modified Date:  12/23/1998  By: FRNash & R.Malladi                           *
*******************************************************************************/
void ck_eod(void)
{
   /* EXEC SQL BEGIN DECLARE SECTION; */ 

      watch_eod_rec        fi_recs;
      watch_eod_ind_rec    fi_ind_rec;
      short                num_eod_rpts;
   /* EXEC SQL END DECLARE SECTION; */ 

   int fi_no;
   int num_fi;
   
   paint_task_line(1, "Checking End of Day.....");
   Sleep(2000);         /* delay 1 second */
      
   /* Fetch all info from all active FI records where EOD is in progress */
   /* EXEC SQL DECLARE fi_curs CURSOR FOR    /o declare fi_cursor o/
      SELECT fi_rt, eod_status
        FROM fi 
       WHERE active_yn = 'Y' AND wh_status = 'E'; */ 


   /* EXEC SQL OPEN fi_curs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 0;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = sq0001;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )5;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqcmod = (unsigned int )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

                 /* open cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FI_CURS",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Open FI_CURS cursor Failed!");
      paint_task_line (1, "....Program Exit Code = 10");
      do_exit(10);
   }

   /* EXEC SQL FETCH fi_curs INTO :fi_recs:fi_ind_rec; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 2;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )100;
   sqlstm.offset = (unsigned int  )20;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqfoff = (           int )0;
   sqlstm.sqfmod = (unsigned int )2;
   sqlstm.sqhstv[0] = (         void  *)fi_recs.fi_rt;
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )10;
   sqlstm.sqindv[0] = (         void  *)fi_ind_rec.fi_rt;
   sqlstm.sqinds[0] = (         int  )sizeof(short);
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqharc[0] = (unsigned int   *)0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)fi_recs.eod_status;
   sqlstm.sqhstl[1] = (unsigned int  )2;
   sqlstm.sqhsts[1] = (         int  )2;
   sqlstm.sqindv[1] = (         void  *)fi_ind_rec.eod_status;
   sqlstm.sqinds[1] = (         int  )sizeof(short);
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqharc[1] = (unsigned int   *)0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

 /* fetch records*/
   if ((sqlca.sqlcode != ORCL_NO_ERROR) && (sqlca.sqlcode != ORCL_NOT_FOUND))
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FI_CURS",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Fetch FI_CURS cursor failed in ck_eod()!");
      paint_task_line (1, "....Program Exit Code = 11");
      do_exit(11);
   }

   num_fi = sqlca.sqlerrd[2];       /* save actual # of rows fetched */

   /* EXEC SQL CLOSE fi_curs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 2;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )43;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

         /* close cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FI_CURS",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Close FI_CURS cursor failed in ck_eod()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(12);
   }

   for (fi_no = 0; fi_no < num_fi; fi_no++) 
   {
      /*If nothing is in process or not processed.......*/
      if (no_tasks_in_proc(fi_recs.fi_rt[fi_no]) && no_input_in_proc(fi_recs.fi_rt[fi_no]))
      {
         /* 
            normal tasks (tasks that are not eod reports or eod job) ARE completed,
            prepare to do eod report 
         */
         if (fi_recs.eod_status[fi_no][0] == 'T')
         {
            /* EXEC SQL SELECT count(*) 
            INTO :num_eod_rpts 
            FROM task_sch
            WHERE fi_rt = :fi_recs.fi_rt[fi_no] 
            AND   run_at_eod_yn = 'Y' 
            AND   proc_status = 'N'       
            AND   TO_CHAR(due_dt, 'YYYYMMDD') <= :g_cur_dt; */ 

{
            struct sqlexd sqlstm;
            sqlstm.sqlvsn = 13;
            sqlstm.arrsiz = 3;
            sqlstm.sqladtp = &sqladt;
            sqlstm.sqltdsp = &sqltds;
            sqlstm.stmt = "select count(*)  into :b0  from task_sch where ((\
(fi_rt=:b1 and run_at_eod_yn='Y') and proc_status='N') and TO_CHAR(due_dt,'YYY\
YMMDD')<=:b2)";
            sqlstm.iters = (unsigned int  )1;
            sqlstm.offset = (unsigned int  )58;
            sqlstm.selerr = (unsigned short)1;
            sqlstm.sqlpfmem = (unsigned int  )0;
            sqlstm.cud = sqlcud0;
            sqlstm.sqlest = (unsigned char  *)&sqlca;
            sqlstm.sqlety = (unsigned short)4352;
            sqlstm.occurs = (unsigned int  )0;
            sqlstm.sqhstv[0] = (         void  *)&num_eod_rpts;
            sqlstm.sqhstl[0] = (unsigned int  )sizeof(short);
            sqlstm.sqhsts[0] = (         int  )0;
            sqlstm.sqindv[0] = (         void  *)0;
            sqlstm.sqinds[0] = (         int  )0;
            sqlstm.sqharm[0] = (unsigned int  )0;
            sqlstm.sqadto[0] = (unsigned short )0;
            sqlstm.sqtdso[0] = (unsigned short )0;
            sqlstm.sqhstv[1] = (         void  *)(fi_recs.fi_rt)[fi_no];
            sqlstm.sqhstl[1] = (unsigned int  )10;
            sqlstm.sqhsts[1] = (         int  )0;
            sqlstm.sqindv[1] = (         void  *)0;
            sqlstm.sqinds[1] = (         int  )0;
            sqlstm.sqharm[1] = (unsigned int  )0;
            sqlstm.sqadto[1] = (unsigned short )0;
            sqlstm.sqtdso[1] = (unsigned short )0;
            sqlstm.sqhstv[2] = (         void  *)g_cur_dt;
            sqlstm.sqhstl[2] = (unsigned int  )9;
            sqlstm.sqhsts[2] = (         int  )0;
            sqlstm.sqindv[2] = (         void  *)0;
            sqlstm.sqinds[2] = (         int  )0;
            sqlstm.sqharm[2] = (unsigned int  )0;
            sqlstm.sqadto[2] = (unsigned short )0;
            sqlstm.sqtdso[2] = (unsigned short )0;
            sqlstm.sqphsv = sqlstm.sqhstv;
            sqlstm.sqphsl = sqlstm.sqhstl;
            sqlstm.sqphss = sqlstm.sqhsts;
            sqlstm.sqpind = sqlstm.sqindv;
            sqlstm.sqpins = sqlstm.sqinds;
            sqlstm.sqparm = sqlstm.sqharm;
            sqlstm.sqparc = sqlstm.sqharc;
            sqlstm.sqpadto = sqlstm.sqadto;
            sqlstm.sqptdso = sqlstm.sqtdso;
            sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


            
            if ((sqlca.sqlcode != ORCL_NO_ERROR) && (sqlca.sqlcode != ORCL_NOT_FOUND))
            {
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
               gpszIFSMsg = ifs_fatal("ORC_SELECT",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "(* FROM) TASK_SCH ",
                                       g_orcl_etext_buf, 
                                       g_fi_info,
                                       NULL);
               paint_task_line(0, "Select from TASK_SCH failed in ck_eod()!");
               do_exit(1);
            }

            if (num_eod_rpts > 0)
            {
               /* EXEC SQL UPDATE fi 
               SET   eod_status = 'R'
               WHERE fi_rt = :fi_recs.fi_rt[fi_no]; */ 

{
               struct sqlexd sqlstm;
               sqlstm.sqlvsn = 13;
               sqlstm.arrsiz = 3;
               sqlstm.sqladtp = &sqladt;
               sqlstm.sqltdsp = &sqltds;
               sqlstm.stmt = "update fi  set eod_status='R' where fi_rt=:b0";
               sqlstm.iters = (unsigned int  )1;
               sqlstm.offset = (unsigned int  )85;
               sqlstm.cud = sqlcud0;
               sqlstm.sqlest = (unsigned char  *)&sqlca;
               sqlstm.sqlety = (unsigned short)4352;
               sqlstm.occurs = (unsigned int  )0;
               sqlstm.sqhstv[0] = (         void  *)(fi_recs.fi_rt)[fi_no];
               sqlstm.sqhstl[0] = (unsigned int  )10;
               sqlstm.sqhsts[0] = (         int  )0;
               sqlstm.sqindv[0] = (         void  *)0;
               sqlstm.sqinds[0] = (         int  )0;
               sqlstm.sqharm[0] = (unsigned int  )0;
               sqlstm.sqadto[0] = (unsigned short )0;
               sqlstm.sqtdso[0] = (unsigned short )0;
               sqlstm.sqphsv = sqlstm.sqhstv;
               sqlstm.sqphsl = sqlstm.sqhstl;
               sqlstm.sqphss = sqlstm.sqhsts;
               sqlstm.sqpind = sqlstm.sqindv;
               sqlstm.sqpins = sqlstm.sqinds;
               sqlstm.sqparm = sqlstm.sqharm;
               sqlstm.sqparc = sqlstm.sqharc;
               sqlstm.sqpadto = sqlstm.sqadto;
               sqlstm.sqptdso = sqlstm.sqtdso;
               sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



               if (sqlca.sqlcode != ORCL_NO_ERROR)
               {
                  sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
                  g_orcl_etext_buf[g_orcl_etext_len] = '\0';
                  copy_cat(g_fi_info, "FI: ", fi_recs.fi_rt[fi_no], NULL);
                  gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                          __FILE__, (DWORD) __LINE__, IFS_LOG,
                                          "TASK_SCH",
                                          g_orcl_etext_buf,
                                          g_fi_info,
                                          NULL);
                  paint_task_line(0, "Update TASK_SCH failed in ck_eod()!");
                  paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
                  do_exit(1);
               }
            }
            else
            {
               if (do_eod_job(fi_recs.fi_rt[fi_no]) == FALSE)
               {
                  strcpy(fi_recs.eod_status[fi_no], "N");
               }
            }
         }
      
         /*Do end of day report, check if tasks are in process no - does EOD job */
         if (fi_recs.eod_status[fi_no][0] == 'R')
         {
            /* do eod reports before eod job */
            if (do_eod_reports(fi_recs.fi_rt[fi_no]) == FALSE)
            {
               strcpy(fi_recs.eod_status[fi_no], "N");
            }
            else
            {
               /* eod reports are done, now do eod job */
               if (no_tasks_in_proc(fi_recs.fi_rt[fi_no]))
                  if (do_eod_job(fi_recs.fi_rt[fi_no]) == FALSE)
                  {
                     strcpy(fi_recs.eod_status[fi_no], "N");
                  }
            }
         }
   
         /* eod job is done, update proc_status for the EOD job to 'N' */
         else if (fi_recs.eod_status[fi_no][0] == 'E')
         {  

      // As of today (6/18/1998), there is no need for WATCH to update the TASK_SCH
      // table with the PROC_STATUS for the EOD job.  The EOD job will always have
      // a PROC_STATUS of 'N' (Unprocessed), therefore there is no need to look at
      // the non_recurring_yn column.   JMW 6/18/1998


            /* eod job is done, update wh_status and eod_status */
            strcpy(fi_recs.eod_status[fi_no], "N");

            /* EXEC SQL UPDATE fi SET wh_status = 'U', eod_status = 'N'
                     WHERE fi_rt = :fi_recs.fi_rt[fi_no]; */ 

{
            struct sqlexd sqlstm;
            sqlstm.sqlvsn = 13;
            sqlstm.arrsiz = 3;
            sqlstm.sqladtp = &sqladt;
            sqlstm.sqltdsp = &sqltds;
            sqlstm.stmt = "update fi  set wh_status='U',eod_status='N' where\
 fi_rt=:b0";
            sqlstm.iters = (unsigned int  )1;
            sqlstm.offset = (unsigned int  )104;
            sqlstm.cud = sqlcud0;
            sqlstm.sqlest = (unsigned char  *)&sqlca;
            sqlstm.sqlety = (unsigned short)4352;
            sqlstm.occurs = (unsigned int  )0;
            sqlstm.sqhstv[0] = (         void  *)(fi_recs.fi_rt)[fi_no];
            sqlstm.sqhstl[0] = (unsigned int  )10;
            sqlstm.sqhsts[0] = (         int  )0;
            sqlstm.sqindv[0] = (         void  *)0;
            sqlstm.sqinds[0] = (         int  )0;
            sqlstm.sqharm[0] = (unsigned int  )0;
            sqlstm.sqadto[0] = (unsigned short )0;
            sqlstm.sqtdso[0] = (unsigned short )0;
            sqlstm.sqphsv = sqlstm.sqhstv;
            sqlstm.sqphsl = sqlstm.sqhstl;
            sqlstm.sqphss = sqlstm.sqhsts;
            sqlstm.sqpind = sqlstm.sqindv;
            sqlstm.sqpins = sqlstm.sqinds;
            sqlstm.sqparm = sqlstm.sqharm;
            sqlstm.sqparc = sqlstm.sqharc;
            sqlstm.sqpadto = sqlstm.sqadto;
            sqlstm.sqptdso = sqlstm.sqtdso;
            sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



            if (sqlca.sqlcode != ORCL_NO_ERROR)
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", fi_recs.fi_rt[fi_no], NULL);
               gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "FI",
                                       g_orcl_etext_buf,
                                       g_fi_info,
                                       NULL);
               paint_task_line(0, "Update FI failed in ck_eod()!");
               paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
               do_exit(1);
            }
            
            /* EXEC SQL COMMIT WORK; */ 

{
            struct sqlexd sqlstm;
            sqlstm.sqlvsn = 13;
            sqlstm.arrsiz = 3;
            sqlstm.sqladtp = &sqladt;
            sqlstm.sqltdsp = &sqltds;
            sqlstm.iters = (unsigned int  )1;
            sqlstm.offset = (unsigned int  )123;
            sqlstm.cud = sqlcud0;
            sqlstm.sqlest = (unsigned char  *)&sqlca;
            sqlstm.sqlety = (unsigned short)4352;
            sqlstm.occurs = (unsigned int  )0;
            sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


            if (sqlca.sqlcode != ORCL_NO_ERROR)
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
               ifs_fatal("ORC_COMMIT",
                           __FILE__, (DWORD)__LINE__, IFS_LOG,
                           g_orcl_etext_buf,
                           g_fi_info,
                           NULL);
               paint_task_line(0, "Unable to Commit Changes");
               exit(1);
            }
         }
      }
   }
} /* end ck_eod() */


/*********************** do_start_eod ******************************************
* Description:                                                                 *
*  Making sure nothing for that fi is in progress.  If is in progress, then    *
* don't do eod or eod report.                                                  *
*******************************************************************************/
void do_start_eod(int task_no)
{
   BOOL  b_did_update = FALSE; // 12-23-1998 -FRN

   /* Set FI's wh_status = 'E' (down for eod)  *** Modified 12-23-1998 -FRN ***/
   if (no_tasks_in_proc(g_tsch_recs.fi_rt[task_no]) &&
       no_input_in_proc(g_tsch_recs.fi_rt[task_no]))
   {
         if (fail_check(g_tsch_recs.fi_rt[task_no]) == FALSE)
         {
         /* Nothing is running, ready to do eod reports */
            b_did_update = TRUE;
            /* EXEC SQL UPDATE fi SET wh_status = 'E', eod_status = 'R'
            WHERE  fi_rt = :g_tsch_recs.fi_rt[task_no]; */ 

{
            struct sqlexd sqlstm;
            sqlstm.sqlvsn = 13;
            sqlstm.arrsiz = 3;
            sqlstm.sqladtp = &sqladt;
            sqlstm.sqltdsp = &sqltds;
            sqlstm.stmt = "update fi  set wh_status='E',eod_status='R' where\
 fi_rt=:b0";
            sqlstm.iters = (unsigned int  )1;
            sqlstm.offset = (unsigned int  )138;
            sqlstm.cud = sqlcud0;
            sqlstm.sqlest = (unsigned char  *)&sqlca;
            sqlstm.sqlety = (unsigned short)4352;
            sqlstm.occurs = (unsigned int  )0;
            sqlstm.sqhstv[0] = (         void  *)(g_tsch_recs.fi_rt)[task_no];
            sqlstm.sqhstl[0] = (unsigned int  )10;
            sqlstm.sqhsts[0] = (         int  )0;
            sqlstm.sqindv[0] = (         void  *)0;
            sqlstm.sqinds[0] = (         int  )0;
            sqlstm.sqharm[0] = (unsigned int  )0;
            sqlstm.sqadto[0] = (unsigned short )0;
            sqlstm.sqtdso[0] = (unsigned short )0;
            sqlstm.sqphsv = sqlstm.sqhstv;
            sqlstm.sqphsl = sqlstm.sqhstl;
            sqlstm.sqphss = sqlstm.sqhsts;
            sqlstm.sqpind = sqlstm.sqindv;
            sqlstm.sqpins = sqlstm.sqinds;
            sqlstm.sqparm = sqlstm.sqharm;
            sqlstm.sqparc = sqlstm.sqharc;
            sqlstm.sqpadto = sqlstm.sqadto;
            sqlstm.sqptdso = sqlstm.sqtdso;
            sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


         }
   }
   else
   {
         if (fail_check(g_tsch_recs.fi_rt[task_no]) == FALSE)
         {
         /* there are tasks running, eod_status='T' for waiting for
            tasks to complete */
            b_did_update = TRUE;
            /* EXEC SQL UPDATE fi SET wh_status = 'E', eod_status = 'T'
            WHERE  fi_rt = :g_tsch_recs.fi_rt[task_no]; */ 

{
            struct sqlexd sqlstm;
            sqlstm.sqlvsn = 13;
            sqlstm.arrsiz = 3;
            sqlstm.sqladtp = &sqladt;
            sqlstm.sqltdsp = &sqltds;
            sqlstm.stmt = "update fi  set wh_status='E',eod_status='T' where\
 fi_rt=:b0";
            sqlstm.iters = (unsigned int  )1;
            sqlstm.offset = (unsigned int  )157;
            sqlstm.cud = sqlcud0;
            sqlstm.sqlest = (unsigned char  *)&sqlca;
            sqlstm.sqlety = (unsigned short)4352;
            sqlstm.occurs = (unsigned int  )0;
            sqlstm.sqhstv[0] = (         void  *)(g_tsch_recs.fi_rt)[task_no];
            sqlstm.sqhstl[0] = (unsigned int  )10;
            sqlstm.sqhsts[0] = (         int  )0;
            sqlstm.sqindv[0] = (         void  *)0;
            sqlstm.sqinds[0] = (         int  )0;
            sqlstm.sqharm[0] = (unsigned int  )0;
            sqlstm.sqadto[0] = (unsigned short )0;
            sqlstm.sqtdso[0] = (unsigned short )0;
            sqlstm.sqphsv = sqlstm.sqhstv;
            sqlstm.sqphsl = sqlstm.sqhstl;
            sqlstm.sqphss = sqlstm.sqhsts;
            sqlstm.sqpind = sqlstm.sqindv;
            sqlstm.sqpins = sqlstm.sqinds;
            sqlstm.sqparm = sqlstm.sqharm;
            sqlstm.sqparc = sqlstm.sqharc;
            sqlstm.sqpadto = sqlstm.sqadto;
            sqlstm.sqptdso = sqlstm.sqtdso;
            sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


         }

   }

   if (b_did_update) // 12-23-1998 -FRN
   {
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {     /* Oracle error */
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
         gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "FI",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
         paint_task_line (0, "Update FI failed in do_start_eod()!");
         paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
         do_exit(1);
      }

      /* EXEC SQL COMMIT WORK; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 3;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )176;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

               /* commit update work */
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
         ifs_fatal("ORC_COMMIT",
                     __FILE__, (DWORD)__LINE__, IFS_LOG,
                     g_orcl_etext_buf,
                     g_fi_info,
                     NULL);
         paint_task_line(0, "Unable to Commit Changes");
         exit(1);
      }
   }

} /* end do_start_eod() */


/********************** do_eod_reports *****************************************
* Description:                                                                 *
*     Set FI's eod_status='R'; submits jobs to run EOD Reports.                *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  07/03/1996  By: George Lin                                   *
*******************************************************************************/
BOOL do_eod_reports(char fi_rt[10])
{
   /* EXEC SQL BEGIN DECLARE SECTION; */ 

      watch_tsch_recs      eod_recs;
      watch_tsch_ind_recs  eod_ind_recs;
      char                 l_fi_rt[10];
      int                  task_no;
      int                  cur_tsch_cnt;
   /* EXEC SQL END DECLARE SECTION; */ 

   
   /*
      Select tasks for the fi that are scheduled to run today,
      and whose type = 'R', run_at_eod_yn = 'Y' and proc_status = 'N'.
      Loop thru all tasks calling do_task_reports()
      NOTE: Assumes that the only type of task that can be 
            schedule to run @ eod is a report! Ck it out.
   */

   if ( fail_check(fi_rt) ) 
      return FALSE;

   strcpy(l_fi_rt, fi_rt);
   
   /* EXEC SQL DECLARE ts_curs CURSOR FOR      /o declare cursor o/
      SELECT task_type,
             fi_rt,
             task_id,
             dist_prof_id,
             upper(task_name),
             upper(file_name),
             upper(run_at_eod_yn),
             proc_opt,
             days_past,
             dist_ts,
             corp_orig_id
        FROM task_sch 
       WHERE fi_rt = :l_fi_rt
         AND task_type = 'R'
         AND run_at_eod_yn = 'Y'
         AND proc_status = 'N'
         AND TO_CHAR(due_dt, 'YYYYMMDD') <= :g_cur_dt; */ 


   /* EXEC SQL OPEN ts_curs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 3;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = sq0009;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )191;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqcmod = (unsigned int )0;
   sqlstm.sqhstv[0] = (         void  *)l_fi_rt;
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)g_cur_dt;
   sqlstm.sqhstl[1] = (unsigned int  )9;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

                    /* open cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TS_CURS",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Open TS_CURS cursor failed");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* EXEC SQL FETCH ts_curs INTO :eod_recs:eod_ind_recs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )100;
   sqlstm.offset = (unsigned int  )214;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqfoff = (           int )0;
   sqlstm.sqfmod = (unsigned int )2;
   sqlstm.sqhstv[0] = (         void  *)eod_recs.task_type;
   sqlstm.sqhstl[0] = (unsigned int  )2;
   sqlstm.sqhsts[0] = (         int  )2;
   sqlstm.sqindv[0] = (         void  *)eod_ind_recs.task_type;
   sqlstm.sqinds[0] = (         int  )sizeof(short);
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqharc[0] = (unsigned int   *)0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)eod_recs.fi_rt;
   sqlstm.sqhstl[1] = (unsigned int  )10;
   sqlstm.sqhsts[1] = (         int  )10;
   sqlstm.sqindv[1] = (         void  *)eod_ind_recs.fi_rt;
   sqlstm.sqinds[1] = (         int  )sizeof(short);
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqharc[1] = (unsigned int   *)0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)eod_recs.task_id;
   sqlstm.sqhstl[2] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[2] = (         int  )sizeof(double);
   sqlstm.sqindv[2] = (         void  *)eod_ind_recs.task_id;
   sqlstm.sqinds[2] = (         int  )sizeof(short);
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqharc[2] = (unsigned int   *)0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)eod_recs.dist_prof_id;
   sqlstm.sqhstl[3] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[3] = (         int  )sizeof(double);
   sqlstm.sqindv[3] = (         void  *)eod_ind_recs.dist_prof_id;
   sqlstm.sqinds[3] = (         int  )sizeof(short);
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqharc[3] = (unsigned int   *)0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqhstv[4] = (         void  *)eod_recs.task_name;
   sqlstm.sqhstl[4] = (unsigned int  )31;
   sqlstm.sqhsts[4] = (         int  )31;
   sqlstm.sqindv[4] = (         void  *)eod_ind_recs.task_name;
   sqlstm.sqinds[4] = (         int  )sizeof(short);
   sqlstm.sqharm[4] = (unsigned int  )0;
   sqlstm.sqharc[4] = (unsigned int   *)0;
   sqlstm.sqadto[4] = (unsigned short )0;
   sqlstm.sqtdso[4] = (unsigned short )0;
   sqlstm.sqhstv[5] = (         void  *)eod_recs.file_name;
   sqlstm.sqhstl[5] = (unsigned int  )13;
   sqlstm.sqhsts[5] = (         int  )13;
   sqlstm.sqindv[5] = (         void  *)eod_ind_recs.file_name;
   sqlstm.sqinds[5] = (         int  )sizeof(short);
   sqlstm.sqharm[5] = (unsigned int  )0;
   sqlstm.sqharc[5] = (unsigned int   *)0;
   sqlstm.sqadto[5] = (unsigned short )0;
   sqlstm.sqtdso[5] = (unsigned short )0;
   sqlstm.sqhstv[6] = (         void  *)eod_recs.run_at_eod_yn;
   sqlstm.sqhstl[6] = (unsigned int  )2;
   sqlstm.sqhsts[6] = (         int  )2;
   sqlstm.sqindv[6] = (         void  *)eod_ind_recs.run_at_eod_yn;
   sqlstm.sqinds[6] = (         int  )sizeof(short);
   sqlstm.sqharm[6] = (unsigned int  )0;
   sqlstm.sqharc[6] = (unsigned int   *)0;
   sqlstm.sqadto[6] = (unsigned short )0;
   sqlstm.sqtdso[6] = (unsigned short )0;
   sqlstm.sqhstv[7] = (         void  *)eod_recs.proc_opt;
   sqlstm.sqhstl[7] = (unsigned int  )101;
   sqlstm.sqhsts[7] = (         int  )101;
   sqlstm.sqindv[7] = (         void  *)eod_ind_recs.proc_opt;
   sqlstm.sqinds[7] = (         int  )sizeof(short);
   sqlstm.sqharm[7] = (unsigned int  )0;
   sqlstm.sqharc[7] = (unsigned int   *)0;
   sqlstm.sqadto[7] = (unsigned short )0;
   sqlstm.sqtdso[7] = (unsigned short )0;
   sqlstm.sqhstv[8] = (         void  *)eod_recs.days_past;
   sqlstm.sqhstl[8] = (unsigned int  )sizeof(int);
   sqlstm.sqhsts[8] = (         int  )sizeof(int);
   sqlstm.sqindv[8] = (         void  *)eod_ind_recs.days_past;
   sqlstm.sqinds[8] = (         int  )sizeof(short);
   sqlstm.sqharm[8] = (unsigned int  )0;
   sqlstm.sqharc[8] = (unsigned int   *)0;
   sqlstm.sqadto[8] = (unsigned short )0;
   sqlstm.sqtdso[8] = (unsigned short )0;
   sqlstm.sqhstv[9] = (         void  *)eod_recs.dist_ts;
   sqlstm.sqhstl[9] = (unsigned int  )16;
   sqlstm.sqhsts[9] = (         int  )16;
   sqlstm.sqindv[9] = (         void  *)eod_ind_recs.dist_ts;
   sqlstm.sqinds[9] = (         int  )sizeof(short);
   sqlstm.sqharm[9] = (unsigned int  )0;
   sqlstm.sqharc[9] = (unsigned int   *)0;
   sqlstm.sqadto[9] = (unsigned short )0;
   sqlstm.sqtdso[9] = (unsigned short )0;
   sqlstm.sqhstv[10] = (         void  *)eod_recs.corp_orig_id;
   sqlstm.sqhstl[10] = (unsigned int  )11;
   sqlstm.sqhsts[10] = (         int  )11;
   sqlstm.sqindv[10] = (         void  *)eod_ind_recs.corp_orig_id;
   sqlstm.sqinds[10] = (         int  )sizeof(short);
   sqlstm.sqharm[10] = (unsigned int  )0;
   sqlstm.sqharc[10] = (unsigned int   *)0;
   sqlstm.sqadto[10] = (unsigned short )0;
   sqlstm.sqtdso[10] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

 /*fetch corsor*/
   
   g_tsch_cnt = 0;

   while ((sqlca.sqlcode == ORCL_NO_ERROR || sqlca.sqlcode == ORCL_NOT_FOUND)
            && sqlca.sqlerrd[2] > 0)
   {
      cur_tsch_cnt = sqlca.sqlerrd[2] - g_tsch_cnt;
      g_tsch_cnt = sqlca.sqlerrd[2];   /* save actual # of rows fetched */
      
      /* Processes all tasks fetched into g_tsch_recs buffer
         to call do_task_reports */
      for (task_no = 0; task_no < cur_tsch_cnt; task_no++) 
      {
         strcpy(rpt_info_rec.task_type, eod_recs.task_type[task_no]);
         strcpy(rpt_info_rec.fi_rt, eod_recs.fi_rt[task_no]);
         rpt_info_rec.task_id       = eod_recs.task_id[task_no];
         rpt_info_rec.dist_prof_id  = eod_recs.dist_prof_id[task_no];
         strcpy(rpt_info_rec.task_name, eod_recs.task_name[task_no]);
         strcpy(rpt_info_rec.file_name, eod_recs.file_name[task_no]);
         strcpy(rpt_info_rec.proc_opt, eod_recs.proc_opt[task_no]);
         strcpy(rpt_info_rec.dist_ts,  eod_recs.dist_ts[task_no]);
         do_task_report();
      }

      if (cur_tsch_cnt < TSCH_BUF_CNT)
         break;
      else /* EXEC SQL FETCH ts_curs INTO :eod_recs:eod_ind_recs; */ 

{
           struct sqlexd sqlstm;
           sqlstm.sqlvsn = 13;
           sqlstm.arrsiz = 11;
           sqlstm.sqladtp = &sqladt;
           sqlstm.sqltdsp = &sqltds;
           sqlstm.iters = (unsigned int  )100;
           sqlstm.offset = (unsigned int  )273;
           sqlstm.selerr = (unsigned short)0;
           sqlstm.sqlpfmem = (unsigned int  )0;
           sqlstm.cud = sqlcud0;
           sqlstm.sqlest = (unsigned char  *)&sqlca;
           sqlstm.sqlety = (unsigned short)4352;
           sqlstm.occurs = (unsigned int  )0;
           sqlstm.sqfoff = (           int )0;
           sqlstm.sqfmod = (unsigned int )2;
           sqlstm.sqhstv[0] = (         void  *)eod_recs.task_type;
           sqlstm.sqhstl[0] = (unsigned int  )2;
           sqlstm.sqhsts[0] = (         int  )2;
           sqlstm.sqindv[0] = (         void  *)eod_ind_recs.task_type;
           sqlstm.sqinds[0] = (         int  )sizeof(short);
           sqlstm.sqharm[0] = (unsigned int  )0;
           sqlstm.sqharc[0] = (unsigned int   *)0;
           sqlstm.sqadto[0] = (unsigned short )0;
           sqlstm.sqtdso[0] = (unsigned short )0;
           sqlstm.sqhstv[1] = (         void  *)eod_recs.fi_rt;
           sqlstm.sqhstl[1] = (unsigned int  )10;
           sqlstm.sqhsts[1] = (         int  )10;
           sqlstm.sqindv[1] = (         void  *)eod_ind_recs.fi_rt;
           sqlstm.sqinds[1] = (         int  )sizeof(short);
           sqlstm.sqharm[1] = (unsigned int  )0;
           sqlstm.sqharc[1] = (unsigned int   *)0;
           sqlstm.sqadto[1] = (unsigned short )0;
           sqlstm.sqtdso[1] = (unsigned short )0;
           sqlstm.sqhstv[2] = (         void  *)eod_recs.task_id;
           sqlstm.sqhstl[2] = (unsigned int  )sizeof(double);
           sqlstm.sqhsts[2] = (         int  )sizeof(double);
           sqlstm.sqindv[2] = (         void  *)eod_ind_recs.task_id;
           sqlstm.sqinds[2] = (         int  )sizeof(short);
           sqlstm.sqharm[2] = (unsigned int  )0;
           sqlstm.sqharc[2] = (unsigned int   *)0;
           sqlstm.sqadto[2] = (unsigned short )0;
           sqlstm.sqtdso[2] = (unsigned short )0;
           sqlstm.sqhstv[3] = (         void  *)eod_recs.dist_prof_id;
           sqlstm.sqhstl[3] = (unsigned int  )sizeof(double);
           sqlstm.sqhsts[3] = (         int  )sizeof(double);
           sqlstm.sqindv[3] = (         void  *)eod_ind_recs.dist_prof_id;
           sqlstm.sqinds[3] = (         int  )sizeof(short);
           sqlstm.sqharm[3] = (unsigned int  )0;
           sqlstm.sqharc[3] = (unsigned int   *)0;
           sqlstm.sqadto[3] = (unsigned short )0;
           sqlstm.sqtdso[3] = (unsigned short )0;
           sqlstm.sqhstv[4] = (         void  *)eod_recs.task_name;
           sqlstm.sqhstl[4] = (unsigned int  )31;
           sqlstm.sqhsts[4] = (         int  )31;
           sqlstm.sqindv[4] = (         void  *)eod_ind_recs.task_name;
           sqlstm.sqinds[4] = (         int  )sizeof(short);
           sqlstm.sqharm[4] = (unsigned int  )0;
           sqlstm.sqharc[4] = (unsigned int   *)0;
           sqlstm.sqadto[4] = (unsigned short )0;
           sqlstm.sqtdso[4] = (unsigned short )0;
           sqlstm.sqhstv[5] = (         void  *)eod_recs.file_name;
           sqlstm.sqhstl[5] = (unsigned int  )13;
           sqlstm.sqhsts[5] = (         int  )13;
           sqlstm.sqindv[5] = (         void  *)eod_ind_recs.file_name;
           sqlstm.sqinds[5] = (         int  )sizeof(short);
           sqlstm.sqharm[5] = (unsigned int  )0;
           sqlstm.sqharc[5] = (unsigned int   *)0;
           sqlstm.sqadto[5] = (unsigned short )0;
           sqlstm.sqtdso[5] = (unsigned short )0;
           sqlstm.sqhstv[6] = (         void  *)eod_recs.run_at_eod_yn;
           sqlstm.sqhstl[6] = (unsigned int  )2;
           sqlstm.sqhsts[6] = (         int  )2;
           sqlstm.sqindv[6] = (         void  *)eod_ind_recs.run_at_eod_yn;
           sqlstm.sqinds[6] = (         int  )sizeof(short);
           sqlstm.sqharm[6] = (unsigned int  )0;
           sqlstm.sqharc[6] = (unsigned int   *)0;
           sqlstm.sqadto[6] = (unsigned short )0;
           sqlstm.sqtdso[6] = (unsigned short )0;
           sqlstm.sqhstv[7] = (         void  *)eod_recs.proc_opt;
           sqlstm.sqhstl[7] = (unsigned int  )101;
           sqlstm.sqhsts[7] = (         int  )101;
           sqlstm.sqindv[7] = (         void  *)eod_ind_recs.proc_opt;
           sqlstm.sqinds[7] = (         int  )sizeof(short);
           sqlstm.sqharm[7] = (unsigned int  )0;
           sqlstm.sqharc[7] = (unsigned int   *)0;
           sqlstm.sqadto[7] = (unsigned short )0;
           sqlstm.sqtdso[7] = (unsigned short )0;
           sqlstm.sqhstv[8] = (         void  *)eod_recs.days_past;
           sqlstm.sqhstl[8] = (unsigned int  )sizeof(int);
           sqlstm.sqhsts[8] = (         int  )sizeof(int);
           sqlstm.sqindv[8] = (         void  *)eod_ind_recs.days_past;
           sqlstm.sqinds[8] = (         int  )sizeof(short);
           sqlstm.sqharm[8] = (unsigned int  )0;
           sqlstm.sqharc[8] = (unsigned int   *)0;
           sqlstm.sqadto[8] = (unsigned short )0;
           sqlstm.sqtdso[8] = (unsigned short )0;
           sqlstm.sqhstv[9] = (         void  *)eod_recs.dist_ts;
           sqlstm.sqhstl[9] = (unsigned int  )16;
           sqlstm.sqhsts[9] = (         int  )16;
           sqlstm.sqindv[9] = (         void  *)eod_ind_recs.dist_ts;
           sqlstm.sqinds[9] = (         int  )sizeof(short);
           sqlstm.sqharm[9] = (unsigned int  )0;
           sqlstm.sqharc[9] = (unsigned int   *)0;
           sqlstm.sqadto[9] = (unsigned short )0;
           sqlstm.sqtdso[9] = (unsigned short )0;
           sqlstm.sqhstv[10] = (         void  *)eod_recs.corp_orig_id;
           sqlstm.sqhstl[10] = (unsigned int  )11;
           sqlstm.sqhsts[10] = (         int  )11;
           sqlstm.sqindv[10] = (         void  *)eod_ind_recs.corp_orig_id;
           sqlstm.sqinds[10] = (         int  )sizeof(short);
           sqlstm.sqharm[10] = (unsigned int  )0;
           sqlstm.sqharc[10] = (unsigned int   *)0;
           sqlstm.sqadto[10] = (unsigned short )0;
           sqlstm.sqtdso[10] = (unsigned short )0;
           sqlstm.sqphsv = sqlstm.sqhstv;
           sqlstm.sqphsl = sqlstm.sqhstl;
           sqlstm.sqphss = sqlstm.sqhsts;
           sqlstm.sqpind = sqlstm.sqindv;
           sqlstm.sqpins = sqlstm.sqinds;
           sqlstm.sqparm = sqlstm.sqharm;
           sqlstm.sqparc = sqlstm.sqharc;
           sqlstm.sqpadto = sqlstm.sqadto;
           sqlstm.sqptdso = sqlstm.sqtdso;
           sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   }  /* end of while loop */

   if ((sqlca.sqlcode != ORCL_NO_ERROR) && (sqlca.sqlcode != ORCL_NOT_FOUND))
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TS_CURS",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Fetch TS_CURS failed in do_eod_reports()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* EXEC SQL CLOSE ts_curs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )332;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

          /* close cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR) {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TS_CURS",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Close TS_CURS cursor Failed in do_eod_reports()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(2);
   }

   return TRUE;
} /* end do_eod_reports() */


/************************ do_eod_job *******************************************
* Description:                                                                 *
*     Sets FI's eod_status='E'; submits eod job.                               *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  07/03/1996  By: George Lin                                   *
* Modified Date:  11/04/1996  By: Dan Jung                                     *
*******************************************************************************/
BOOL do_eod_job(char fi_rt[10])
{
   /* EXEC SQL BEGIN DECLARE SECTION; */ 

      char l_fi_rt[10];
   /* EXEC SQL END DECLARE SECTION; */ 

   char  errstr[300];
   char  task_id[20];
   char  submit_errfilestr[512];
   char  job_file[81];
   char  fi_rt_str[30];
   char  msg_text[400];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;


   /*
      Set the eod_status = 'E' (Waiting on EOD Job)
   */

   if ( fail_check(fi_rt) ) 
      return FALSE;

   strcpy(l_fi_rt, fi_rt);

   /* EXEC SQL UPDATE fi SET eod_status = 'E'
      WHERE  fi_rt = :l_fi_rt; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "update fi  set eod_status='E' where fi_rt=:b0";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )347;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)l_fi_rt;
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR) {     /* Oracle error */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", l_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FI",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Update FI failed!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   else
   {
      /* EXEC SQL COMMIT WORK; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 11;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )366;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

      /* commit update work */
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
         ifs_fatal("ORC_COMMIT",
                     __FILE__, (DWORD)__LINE__, IFS_LOG,
                     g_orcl_etext_buf,
                     g_fi_info,
                     NULL);
         paint_task_line(0, "Unable to Commit Changes");
         exit(1);
      }
   }
   /*
       Submit the eod job for the fi
   */
   /* EXEC SQL SELECT task_name, task_id
   INTO :g_task_name, :g_task_id
   FROM task_sch
   WHERE fi_rt = :l_fi_rt
   AND task_type = 'E'
   AND proc_status = 'N'
   AND ((to_char(due_dt, 'YYYYMMDD') = :g_cur_dt 
         AND :g_cur_time >= run_hhmm) OR
          (to_char(due_dt, 'YYYYMMDD') < :g_cur_dt)) 
   AND rownum = 1
   order by due_dt, run_hhmm; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select task_name ,task_id into :b0,:b1  from task_sch wher\
e ((((fi_rt=:b2 and task_type='E') and proc_status='N') and ((to_char(due_dt,'\
YYYYMMDD')=:b3 and :b4>=run_hhmm) or to_char(due_dt,'YYYYMMDD')<:b3)) and rown\
um=1) order by due_dt,run_hhmm ";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )381;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)g_task_name;
   sqlstm.sqhstl[0] = (unsigned int  )31;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)g_task_id;
   sqlstm.sqhstl[1] = (unsigned int  )20;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)l_fi_rt;
   sqlstm.sqhstl[2] = (unsigned int  )10;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)g_cur_dt;
   sqlstm.sqhstl[3] = (unsigned int  )9;
   sqlstm.sqhsts[3] = (         int  )0;
   sqlstm.sqindv[3] = (         void  *)0;
   sqlstm.sqinds[3] = (         int  )0;
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqhstv[4] = (         void  *)g_cur_time;
   sqlstm.sqhstl[4] = (unsigned int  )5;
   sqlstm.sqhsts[4] = (         int  )0;
   sqlstm.sqindv[4] = (         void  *)0;
   sqlstm.sqinds[4] = (         int  )0;
   sqlstm.sqharm[4] = (unsigned int  )0;
   sqlstm.sqadto[4] = (unsigned short )0;
   sqlstm.sqtdso[4] = (unsigned short )0;
   sqlstm.sqhstv[5] = (         void  *)g_cur_dt;
   sqlstm.sqhstl[5] = (unsigned int  )9;
   sqlstm.sqhsts[5] = (         int  )0;
   sqlstm.sqindv[5] = (         void  *)0;
   sqlstm.sqinds[5] = (         int  )0;
   sqlstm.sqharm[5] = (unsigned int  )0;
   sqlstm.sqadto[5] = (unsigned short )0;
   sqlstm.sqtdso[5] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR) /* Oracle error */
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", l_fi_rt, ":", _itoa(sqlca.sqlcode, g_orcl_etext_buf, 10), NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(task_name, task_id FROM) TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Select failed in do_eod_job()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   trimlr(g_task_name);
   trimlr(g_task_id);
   if (g_task_id[strlen(g_task_id)-1] == '.')
      g_task_id[strlen(g_task_id)-1] = '\0';

   copy_cat(job_file, job_path, "\\", g_task_name, NULL);
   copy_cat(fi_rt_str, "%FI_RT%=", l_fi_rt, NULL);
   copy_cat(task_id, "%TASK_ID%=", g_task_id, NULL);

   /* which record has the file_name_str in it??? */
   strcpy(connect_yn, "/DBCONNECT=N");

   /* EXEC SQL UPDATE task_sch set proc_status = ' ' 
      WHERE fi_rt = :l_fi_rt
      AND task_name = :g_task_name
      AND task_type = 'E'
      AND proc_status = 'N'
      AND ((to_char(due_dt, 'YYYYMMDD') = :g_cur_dt 
            AND :g_cur_time >= run_hhmm) OR
            (to_char(due_dt, 'YYYYMMDD') < :g_cur_dt)); */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "update task_sch  set proc_status=' ' where ((((fi_rt=:b0 a\
nd task_name=:b1) and task_type='E') and proc_status='N') and ((to_char(due_dt\
,'YYYYMMDD')=:b2 and :b3>=run_hhmm) or to_char(due_dt,'YYYYMMDD')<:b2))";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )420;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)l_fi_rt;
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)g_task_name;
   sqlstm.sqhstl[1] = (unsigned int  )31;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)g_cur_dt;
   sqlstm.sqhstl[2] = (unsigned int  )9;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)g_cur_time;
   sqlstm.sqhstl[3] = (unsigned int  )5;
   sqlstm.sqhsts[3] = (         int  )0;
   sqlstm.sqindv[3] = (         void  *)0;
   sqlstm.sqinds[3] = (         int  )0;
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqhstv[4] = (         void  *)g_cur_dt;
   sqlstm.sqhstl[4] = (unsigned int  )9;
   sqlstm.sqhsts[4] = (         int  )0;
   sqlstm.sqindv[4] = (         void  *)0;
   sqlstm.sqinds[4] = (         int  )0;
   sqlstm.sqharm[4] = (unsigned int  )0;
   sqlstm.sqadto[4] = (unsigned short )0;
   sqlstm.sqtdso[4] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", l_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Update proc_status = ' ' failed in do_eod_job()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   else 
   {
      /* EXEC SQL COMMIT WORK; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 11;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )455;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
         ifs_fatal("ORC_COMMIT",
                     __FILE__, (DWORD)__LINE__, IFS_LOG,
                     g_orcl_etext_buf,
                     g_fi_info,
                     NULL);
         paint_task_line(0, "Unable to Commit Changes");
         exit(1);
      }
   }
   
   /* submit eod job for end of day, task_id is 0 */

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));


   strcpy(parm[0], connect_yn);		arguments++;
   strcpy(parm[1], fi_rt_str);		arguments++;
   strcpy(parm[2], task_id);		arguments++;

   for(n = 0; n<arguments; n++)
       arg[n] = parm[n];
      
    if (submit_job(l_fi_rt, job_file, errstr, arg, arguments) == ERR)
   {
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_JCSUBMIT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);
      paint_task_line(1, "sql_jcsubmit() failed in do_eod_job()!");
      do_exit(1);
   }


   copy_cat(msg_text, "End of Day job ", g_task_name, " for FI=", 
      l_fi_rt, " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);
         
   paint_proc_info(msg_text);
   paint_proc_info(blank_line);

   return TRUE;

} /* end do_eod_job() */


/********************** no_tasks_in_proc ***************************************
* Description:                                                                 *
*     Counts task recs with proc_status=' ' (InProcess) or proc_status='F'     *
*       (Failed) for the FI and returns TRUE if count = 0 else FALSE.          *
* Returns:                                                                     *
*    Returns TRUE (!=0) when no tasks are "In Process" or "Failed" for fi or   *
*    any files are active or incomplete for building a nacha file.             *
*    Returns FALSE (==0) when there are tasks with a proc_stat of in process   *
*                        or file_status of active or in process.               *                                                 *
*                                                                              *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  07/03/1996  By: George Lin                                   *
* Modified date:  12/04/1996  By: Dan Jung                                     *
* Modified date:  01/05/1998  By: Darcy Sivertson                              *
* Modified Date:  09/01/1998  By: Mike West                                    *
* Modified Date:  04/14/1999  By: Mike West                                    *
*******************************************************************************/
int no_tasks_in_proc(char fi_rt[10])
{
   /* EXEC SQL BEGIN DECLARE SECTION; */ 

   int   n;
   int   m;
   char  l_fi_rt[10];
   /* EXEC SQL END DECLARE SECTION; */ 


  
   strcpy(l_fi_rt, fi_rt);

   /* EXEC SQL SELECT count(*) INTO :n
   FROM task_sch
   WHERE fi_rt = :l_fi_rt
   AND task_type <> 'P' // Dev. Req. 97-199 Requirement
   AND (proc_status = ' ' OR proc_status='F' OR proc_status IS NULL); */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select count(*)  into :b0  from task_sch where ((fi_rt=:b1\
 and task_type<>'P') and ((proc_status=' ' or proc_status='F') or proc_status \
is null ))";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )470;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)&n;
   sqlstm.sqhstl[0] = (unsigned int  )sizeof(int);
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)l_fi_rt;
   sqlstm.sqhstl[1] = (unsigned int  )10;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", l_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(COUNT(*) FROM) TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in no_tasks_in_proc()!");
      paint_task_line(1, "....Program Exit Code 31");
      do_exit(31);
   }


   /* Check to see if any file are active or incomplete */
   /* EXEC SQL SELECT count(*) INTO :m
   FROM     nacha_file_info
   WHERE    fi_rt = :l_fi_rt 
   AND   (file_status = 'A' OR file_status = 'I'); */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select count(*)  into :b0  from nacha_file_info where (fi_\
rt=:b1 and (file_status='A' or file_status='I'))";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )493;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)&m;
   sqlstm.sqhstl[0] = (unsigned int  )sizeof(int);
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)l_fi_rt;
   sqlstm.sqhstl[1] = (unsigned int  )10;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", l_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(COUNT(*) FROM) NACHA_FILE_INFO",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in no_tasks_in_proc()!");
      paint_task_line(1, "....Program Exit Code 30");
      do_exit(30);
   }

   if (n == 0 && m ==0)       /* if no task recs InProcess  */
      return (1);             /*    returns TRUE         */
   else                    /* else                    */
      return (0);             /*    returns FALSE        */
} /* end no_tasks_in_proc() */


/********************** no_input_in_proc ***************************************
* Description:                                                                 *
*     Counts file_sch recs with proc_status=NULL (InProcess) for the FI and    *
* returns TRUE if count = 0 else FALSE.                                        *
* RETURNS:                                                                     *
*  TRUE (!=0) when no file_sch items exit with a proc_stat of "In Process".    *
*  FALSE (0) when file_sch items exist with a proc_stat of "In process".       *
*                                                                              *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  07/03/1996  By: George Lin                                   *
* Modified Date:  12/04/1996  by: Dan Jung                                     *
*******************************************************************************/
int no_input_in_proc(char fi_rt[10])
{
   /* EXEC SQL BEGIN DECLARE SECTION; */ 

      int   n;
      char  l_fi_rt[10];
   /* EXEC SQL END DECLARE SECTION; */ 

   
   strcpy(l_fi_rt, fi_rt);

   /* EXEC SQL SELECT COUNT(*) INTO :n
   FROM ioq 
   WHERE fi_rt = :l_fi_rt AND status = 'AI'; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select count(*)  into :b0  from ioq where (fi_rt=:b1 and s\
tatus='AI')";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )516;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)&n;
   sqlstm.sqhstl[0] = (unsigned int  )sizeof(int);
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)l_fi_rt;
   sqlstm.sqhstl[1] = (unsigned int  )10;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", l_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(COUNT(*) FROM) IOQ",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in no_input_in_proc()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   if (n == 0)       /* if no file sch recs InProcess*/
      return (1);             /*    returns TRUE         */
   else                       /* else                    */
      return (0);             /*    returns FALSE        */
} /* end no_input_in_proc() */


/*********************** no_eod_in_proc ****************************************
* Description:                                                                 *
*     Return 1 if eod is running, else return 0.                               *
* Modified Date:  12/05/1996  By: Dan Jung                                     *
*******************************************************************************/
int no_eod_in_proc(char fi_rt[10])
{
   /* EXEC SQL BEGIN DECLARE SECTION; */ 

      int   n;
      char  l_fi_rt[10];
   /* EXEC SQL END DECLARE SECTION; */ 


   strcpy(l_fi_rt, fi_rt);
   /* see if eod is running */
   /* EXEC SQL SELECT COUNT(*) INTO :n
   FROM fi
   WHERE fi_rt = :l_fi_rt AND wh_status = 'E'; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select count(*)  into :b0  from fi where (fi_rt=:b1 and wh\
_status='E')";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )539;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)&n;
   sqlstm.sqhstl[0] = (unsigned int  )sizeof(int);
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)l_fi_rt;
   sqlstm.sqhstl[1] = (unsigned int  )10;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", l_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(COUNT(*) FROM) FI",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in no_eod_in_proc()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   if (n == 0)
      return 1;
   else
      return 0;
} /* end no_eod_in_proc() */



/*********************** fail_check ********************************************
* Description:                                                                 *
*    This function is called to check if there are any failed jobs that need   *
* to be resubmitted before proceeding with the earliest current EOD task.      *
*    If so, the pending EOD action will be bypassed for the current iteration  *
* through WATCH's main processing loop, allowing any unprocessed past due      *
* tasks or input files to be processed in the usual chronological order before *
* the EOD task.                                                                *
*                                                                              *
*    This situation arises when a 'normal' task has failed, leaving its        *
* TASK_SCH.PROC_STATUS= ' ', thus blocking all EOD tasks.                      *
*                                                                              *
*    Upon manually setting TASK_SCH.PROC_STATUS = 'N' for the failed task,     *
* the failed task will once again become a candidate to run, and should run    *
* BEFORE the EOD action that it had been blocking.                             *
*                                                                              *
*    If the failed task's DUE_DT and RUN_HHMM have not been changed, it will   *
* appear to be 'past due', and thus an immediate candidate to run.             *
*                                                                              *
*    Here we determine whether there are any such 'past due' tasks that were   *
* supposed to run before the scheduled EOD run time, or if any unprocessed     *
* input files were received before the scheduled EOD run time.                 *
*                                                                              *
*    If either such past-due tasks or unprocessed files are found, we just     *
* re-open the FI's warehouse for processing by setting FI.WH_STATUS = 'U',     *
* and FI.EOD_STATUS = 'N' as in the normal warehouse state, then return 'TRUE' *
* to indicate that such a condition was indeed identified.                     *
*                                                                              *
* Creation Date:  06/11/1997  By: Mike West                                    *
* Modified Date:  12/23/1998  By: FRNash & R.Malladi                           *
*******************************************************************************/
BOOL fail_check(char *fi_rt)
{
   /* EXEC SQL BEGIN DECLARE SECTION; */ 

      char  h_fi_rt[10];
      short num_task;
      short num_task_ind;
      int   num_ioq;
      short num_ioq_ind;
      char  eod_due_dt[10];
      char  eod_run_hhmm[10];
      char  eod_runtime[20];
   /* EXEC SQL END DECLARE SECTION; */ 


   /* make fi_rt a host variable */
   strcpy(h_fi_rt, fi_rt);

   /* Find due_dt and run_mmmm for the EARLIEST unprocessed 'EOD Type' task...
      Note that there are now two EOD tasks, the FI's EOD, and EOCD.JOB
      (Added task_type, proc_status, and ORDER BY)
   */
   /* EXEC SQL DECLARE task_sch_cur CURSOR FOR
      SELECT   TO_CHAR(due_dt, 'YYYYMMDD'), run_hhmm 
      FROM     task_sch
      WHERE    fi_rt = :h_fi_rt
      AND      task_type = 'E'
      AND      proc_status = 'N'
      ORDER BY due_dt, run_hhmm; */ 


   /* EXEC SQL OPEN task_sch_cur; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = sq0019;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )562;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqcmod = (unsigned int )0;
   sqlstm.sqhstv[0] = (         void  *)h_fi_rt;
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH_CUR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Open TASK_SCH_CUR cursor Failed!");
      paint_task_line (1, "....Program Exit Code = 10");
      do_exit(10);
   }

   /* EXEC SQL FETCH task_sch_cur INTO :eod_due_dt, :eod_run_hhmm; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )581;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqfoff = (           int )0;
   sqlstm.sqfmod = (unsigned int )2;
   sqlstm.sqhstv[0] = (         void  *)eod_due_dt;
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)eod_run_hhmm;
   sqlstm.sqhstl[1] = (unsigned int  )10;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if ((sqlca.sqlcode != ORCL_NO_ERROR) && (sqlca.sqlcode != ORCL_NOT_FOUND))
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH_CUR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Fetch TASK_SCH_CUR cursor failed in ck_eod()!");
      paint_task_line (1, "....Program Exit Code = 11");
      do_exit(11);
   }

   /* EXEC SQL CLOSE task_sch_cur; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )604;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH_CUR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Close TASK_SCH_CUR failed in ck_eod()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(12);
   }

   /* See if there are any 'vanilla' tasks (not TASK_TYPE='E') due before the */
   /* EOD task that was identified above.                                     */
   /* EXEC SQL
      SELECT COUNT(*) 
      INTO :num_task:num_task_ind
      FROM task_sch
      WHERE fi_rt = :h_fi_rt
      AND   proc_status = 'N'
      AND   task_type <>'E'
      AND task_type <> 'P' // Dev. Req. 97-199 requirement
      AND   TO_CHAR(due_dt, 'YYYYMMDD') <= :eod_due_dt
      AND   run_hhmm <= :eod_run_hhmm
      AND   run_at_eod_yn = 'N'
      AND   ROWNUM = 1; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select count(*)  into :b0:b1  from task_sch where (((((((f\
i_rt=:b2 and proc_status='N') and task_type<>'E') and task_type<>'P') and TO_C\
HAR(due_dt,'YYYYMMDD')<=:b3) and run_hhmm<=:b4) and run_at_eod_yn='N') and ROW\
NUM=1)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )619;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)&num_task;
   sqlstm.sqhstl[0] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)&num_task_ind;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)h_fi_rt;
   sqlstm.sqhstl[1] = (unsigned int  )10;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)eod_due_dt;
   sqlstm.sqhstl[2] = (unsigned int  )10;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)eod_run_hhmm;
   sqlstm.sqhstl[3] = (unsigned int  )10;
   sqlstm.sqhsts[3] = (         int  )0;
   sqlstm.sqindv[3] = (         void  *)0;
   sqlstm.sqinds[3] = (         int  )0;
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

 /* because we don't look at EOD reports and Purge Tasks */

   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__,IFS_LOG,
                              "(COUNT(*) FROM) TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in fail_check()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   
   trimlr(eod_due_dt);
   trimlr(eod_run_hhmm);
   copy_cat(eod_runtime, eod_due_dt, eod_run_hhmm, "00", NULL);
   
   /* IT is possible that some files may be added to IOQ while EOD is waiting */
   /* or running.  So we need to check the recv_ts in IOQ to make sure that   */
   /* we are not re-running a failed file.                                    */
   /* See if there are any unprocessed input files received before the EOD    */
   /* task that was identified above.                                         */

   /* EXEC SQL
      SELECT COUNT(*)
      INTO :num_ioq:num_ioq_ind
      FROM ioq
      WHERE fi_Rt = :h_fi_rt
      AND   status = 'AU'
      AND   recv_ts <= :eod_runtime
      AND   ROWNUM = 1; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select count(*)  into :b0:b1  from ioq where (((fi_Rt=:b2 \
and status='AU') and recv_ts<=:b3) and ROWNUM=1)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )650;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)&num_ioq;
   sqlstm.sqhstl[0] = (unsigned int  )sizeof(int);
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)&num_ioq_ind;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)h_fi_rt;
   sqlstm.sqhstl[1] = (unsigned int  )10;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)eod_runtime;
   sqlstm.sqhstl[2] = (unsigned int  )20;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(COUNT(*) FROM) TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in fail_check()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* If we found either unprocessed tasks or input files that need to be      */
   /* processed before the current EOD task, we just reopen the warehouse for  */
   /* that FI, and those tasks or input files will be handled in due course.   */
   if ((num_task >= 1) || (num_ioq >= 1)) 
   {
      /* EXEC SQL
      UPDATE   fi
      SET      wh_status = 'U',
               eod_status = 'N'
      WHERE    fi_rt = :h_fi_rt; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 11;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.stmt = "update fi  set wh_status='U',eod_status='N' where fi_rt\
=:b0";
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )677;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlstm.sqhstv[0] = (         void  *)h_fi_rt;
      sqlstm.sqhstl[0] = (unsigned int  )10;
      sqlstm.sqhsts[0] = (         int  )0;
      sqlstm.sqindv[0] = (         void  *)0;
      sqlstm.sqinds[0] = (         int  )0;
      sqlstm.sqharm[0] = (unsigned int  )0;
      sqlstm.sqadto[0] = (unsigned short )0;
      sqlstm.sqtdso[0] = (unsigned short )0;
      sqlstm.sqphsv = sqlstm.sqhstv;
      sqlstm.sqphsl = sqlstm.sqhstl;
      sqlstm.sqphss = sqlstm.sqhsts;
      sqlstm.sqpind = sqlstm.sqindv;
      sqlstm.sqpins = sqlstm.sqinds;
      sqlstm.sqparm = sqlstm.sqharm;
      sqlstm.sqparc = sqlstm.sqharc;
      sqlstm.sqpadto = sqlstm.sqadto;
      sqlstm.sqptdso = sqlstm.sqtdso;
      sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


      
      if (sqlca.sqlcode != ORCL_NO_ERROR) // error check added 12-23-1998 -FRN
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
         gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "FI",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
         paint_task_line(0, "Update FI failed in ck_eod()!");
         paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
         do_exit(1);
      }

      /* EXEC SQL COMMIT WORK; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 11;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )696;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

  // commit added 12-23-1998 -FRN
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
         ifs_fatal("ORC_COMMIT",
                     __FILE__, (DWORD)__LINE__, IFS_LOG,
                     g_orcl_etext_buf,
                     g_fi_info,
                     NULL);
         paint_task_line(0, "Unable to Commit Changes");
         exit(1);
      }

      return TRUE;
   }  
   else 
      return FALSE;
} /* end fail_check() */
                                                                                                                                                                                                                                                                                                     document/set2/CKEOD.PC_2.pdf                                                                        0000644     %g4001001 00000123015 14011517332 013703  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               /*******************************************************************************
CKEOD.PC -- An ACHOS Program - Module of WATCH.EXE

Copyright (C) 1995, 1998 Deluxe Data Systems, Inc.
Copyright (C) 1997, 1998, 1999 Deluxe Electronic Payent Systems, Inc.

Part of WATCH.EXE which does "End Of Day" processing.*/


EXEC SQL BEGIN DECLARE SECTION;
/* This #define PREVENTS the sqlca to be declared as external in sqlca.h */

#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern
#define INCLUDE_AS_EXTERN   extern

EXEC SQL END DECLARE SECTION;

/*******************************************************************************/
EXEC SQL BEGIN DECLARE SECTION;
      char  g_fi_rt[10];
      char  g_task_name[31];
      char  g_task_id[20];
EXEC SQL END DECLARE SECTION;

/*******************************************************************************
   INCLUDES & DEFINES                              
*******************************************************************************/

EXEC SQL INCLUDE  "sqlproto.h";
EXEC SQL INCLUDE  "sqlca.h";
EXEC SQL INCLUDE  "orcltype.h";
#include          "ddsi.h"
#include          "achosprd.h"

EXEC SQL INCLUDE watch; /* inserts watch.h into src for Pro*C */ 


/************************** ck_eod *********************************************
* Description:                                                                 *
*   Set the status back.                                                       *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  11/16/1996  By: Dan Jung                                     *
* Modified Date:  06/18/1998  By: Mike West                                    *
* Modified Date:  12/23/1998  By: FRNash & R.Malladi                           *
*******************************************************************************/
void ck_eod(void)
{
   EXEC SQL BEGIN DECLARE SECTION;
      watch_eod_rec        fi_recs;
      watch_eod_ind_rec    fi_ind_rec;
      short                num_eod_rpts;
   EXEC SQL END DECLARE SECTION;
   int fi_no;
   int num_fi;
   
   paint_task_line(1, "Checking End of Day.....");
   Sleep(2000);         /* delay 1 second */
      
   /* Fetch all info from all active FI records where EOD is in progress */
   EXEC SQL DECLARE fi_curs CURSOR FOR    /* declare fi_cursor */
      SELECT fi_rt, eod_status
        FROM fi 
       WHERE active_yn = 'Y' AND wh_status = 'E';

   EXEC SQL OPEN fi_curs;                 /* open cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FI_CURS",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Open FI_CURS cursor Failed!");
      paint_task_line (1, "....Program Exit Code = 10");
      do_exit(10);
   }

   EXEC SQL FETCH fi_curs INTO :fi_recs:fi_ind_rec; /* fetch records*/
   if ((sqlca.sqlcode != ORCL_NO_ERROR) && (sqlca.sqlcode != ORCL_NOT_FOUND))
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FI_CURS",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Fetch FI_CURS cursor failed in ck_eod()!");
      paint_task_line (1, "....Program Exit Code = 11");
      do_exit(11);
   }

   num_fi = sqlca.sqlerrd[2];       /* save actual # of rows fetched */

   EXEC SQL CLOSE fi_curs;         /* close cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FI_CURS",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Close FI_CURS cursor failed in ck_eod()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(12);
   }

   for (fi_no = 0; fi_no < num_fi; fi_no++) 
   {
      /*If nothing is in process or not processed.......*/
      if (no_tasks_in_proc(fi_recs.fi_rt[fi_no]) && no_input_in_proc(fi_recs.fi_rt[fi_no]))
      {
         /* 
            normal tasks (tasks that are not eod reports or eod job) ARE completed,
            prepare to do eod report 
         */
         if (fi_recs.eod_status[fi_no][0] == 'T')
         {
            EXEC SQL SELECT count(*) 
            INTO :num_eod_rpts 
            FROM task_sch
            WHERE fi_rt = :fi_recs.fi_rt[fi_no] 
            AND   run_at_eod_yn = 'Y' 
            AND   proc_status = 'N'       
            AND   TO_CHAR(due_dt, 'YYYYMMDD') <= :g_cur_dt;
            
            if ((sqlca.sqlcode != ORCL_NO_ERROR) && (sqlca.sqlcode != ORCL_NOT_FOUND))
            {
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
               gpszIFSMsg = ifs_fatal("ORC_SELECT",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "(* FROM) TASK_SCH ",
                                       g_orcl_etext_buf, 
                                       g_fi_info,
                                       NULL);
               paint_task_line(0, "Select from TASK_SCH failed in ck_eod()!");
               do_exit(1);
            }

            if (num_eod_rpts > 0)
            {
               EXEC SQL UPDATE fi 
               SET   eod_status = 'R'
               WHERE fi_rt = :fi_recs.fi_rt[fi_no];

               if (sqlca.sqlcode != ORCL_NO_ERROR)
               {
                  sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
                  g_orcl_etext_buf[g_orcl_etext_len] = '\0';
                  copy_cat(g_fi_info, "FI: ", fi_recs.fi_rt[fi_no], NULL);
                  gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                          __FILE__, (DWORD) __LINE__, IFS_LOG,
                                          "TASK_SCH",
                                          g_orcl_etext_buf,
                                          g_fi_info,
                                          NULL);
                  paint_task_line(0, "Update TASK_SCH failed in ck_eod()!");
                  paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
                  do_exit(1);
               }
            }
            else
            {
               if (do_eod_job(fi_recs.fi_rt[fi_no]) == FALSE)
               {
                  strcpy(fi_recs.eod_status[fi_no], "N");
               }
            }
         }
      
         /*Do end of day report, check if tasks are in process no - does EOD job */
         if (fi_recs.eod_status[fi_no][0] == 'R')
         {
            /* do eod reports before eod job */
            if (do_eod_reports(fi_recs.fi_rt[fi_no]) == FALSE)
            {
               strcpy(fi_recs.eod_status[fi_no], "N");
            }
            else
            {
               /* eod reports are done, now do eod job */
               if (no_tasks_in_proc(fi_recs.fi_rt[fi_no]))
                  if (do_eod_job(fi_recs.fi_rt[fi_no]) == FALSE)
                  {
                     strcpy(fi_recs.eod_status[fi_no], "N");
                  }
            }
         }
   
         /* eod job is done, update proc_status for the EOD job to 'N' */
         else if (fi_recs.eod_status[fi_no][0] == 'E')
         {  

      // As of today (6/18/1998), there is no need for WATCH to update the TASK_SCH
      // table with the PROC_STATUS for the EOD job.  The EOD job will always have
      // a PROC_STATUS of 'N' (Unprocessed), therefore there is no need to look at
      // the non_recurring_yn column.   JMW 6/18/1998


            /* eod job is done, update wh_status and eod_status */
            strcpy(fi_recs.eod_status[fi_no], "N");

            EXEC SQL UPDATE fi SET wh_status = 'U', eod_status = 'N'
                     WHERE fi_rt = :fi_recs.fi_rt[fi_no];

            if (sqlca.sqlcode != ORCL_NO_ERROR)
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", fi_recs.fi_rt[fi_no], NULL);
               gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "FI",
                                       g_orcl_etext_buf,
                                       g_fi_info,
                                       NULL);
               paint_task_line(0, "Update FI failed in ck_eod()!");
               paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
               do_exit(1);
            }
            
            EXEC SQL COMMIT WORK;
            if (sqlca.sqlcode != ORCL_NO_ERROR)
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
               ifs_fatal("ORC_COMMIT",
                           __FILE__, (DWORD)__LINE__, IFS_LOG,
                           g_orcl_etext_buf,
                           g_fi_info,
                           NULL);
               paint_task_line(0, "Unable to Commit Changes");
               exit(1);
            }
         }
      }
   }
} /* end ck_eod() */


/*********************** do_start_eod ******************************************
* Description:                                                                 *
*  Making sure nothing for that fi is in progress.  If is in progress, then    *
* don't do eod or eod report.                                                  *
*******************************************************************************/
void do_start_eod(int task_no)
{
   BOOL  b_did_update = FALSE; // 12-23-1998 -FRN

   /* Set FI's wh_status = 'E' (down for eod)  *** Modified 12-23-1998 -FRN ***/
   if (no_tasks_in_proc(g_tsch_recs.fi_rt[task_no]) &&
       no_input_in_proc(g_tsch_recs.fi_rt[task_no]))
   {
         if (fail_check(g_tsch_recs.fi_rt[task_no]) == FALSE)
         {
         /* Nothing is running, ready to do eod reports */
            b_did_update = TRUE;
            EXEC SQL UPDATE fi SET wh_status = 'E', eod_status = 'R'
            WHERE  fi_rt = :g_tsch_recs.fi_rt[task_no];
         }
   }
   else
   {
         if (fail_check(g_tsch_recs.fi_rt[task_no]) == FALSE)
         {
         /* there are tasks running, eod_status='T' for waiting for
            tasks to complete */
            b_did_update = TRUE;
            EXEC SQL UPDATE fi SET wh_status = 'E', eod_status = 'T'
            WHERE  fi_rt = :g_tsch_recs.fi_rt[task_no];
         }

   }

   if (b_did_update) // 12-23-1998 -FRN
   {
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {     /* Oracle error */
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
         gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "FI",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
         paint_task_line (0, "Update FI failed in do_start_eod()!");
         paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
         do_exit(1);
      }

      EXEC SQL COMMIT WORK;               /* commit update work */
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
         ifs_fatal("ORC_COMMIT",
                     __FILE__, (DWORD)__LINE__, IFS_LOG,
                     g_orcl_etext_buf,
                     g_fi_info,
                     NULL);
         paint_task_line(0, "Unable to Commit Changes");
         exit(1);
      }
   }

} /* end do_start_eod() */


/********************** do_eod_reports *****************************************
* Description:                                                                 *
*     Set FI's eod_status='R'; submits jobs to run EOD Reports.                *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  07/03/1996  By: George Lin                                   *
*******************************************************************************/
BOOL do_eod_reports(char fi_rt[10])
{
   EXEC SQL BEGIN DECLARE SECTION;
      watch_tsch_recs      eod_recs;
      watch_tsch_ind_recs  eod_ind_recs;
      char                 l_fi_rt[10];
      int                  task_no;
      int                  cur_tsch_cnt;
   EXEC SQL END DECLARE SECTION;
   
   /*
      Select tasks for the fi that are scheduled to run today,
      and whose type = 'R', run_at_eod_yn = 'Y' and proc_status = 'N'.
      Loop thru all tasks calling do_task_reports()
      NOTE: Assumes that the only type of task that can be 
            schedule to run @ eod is a report! Ck it out.
   */

   if ( fail_check(fi_rt) ) 
      return FALSE;

   strcpy(l_fi_rt, fi_rt);
   
   EXEC SQL DECLARE ts_curs CURSOR FOR      /* declare cursor */
      SELECT task_type,
             fi_rt,
             task_id,
             dist_prof_id,
             upper(task_name),
             upper(file_name),
             upper(run_at_eod_yn),
             proc_opt,
             days_past,
             dist_ts,
             corp_orig_id
        FROM task_sch 
       WHERE fi_rt = :l_fi_rt
         AND task_type = 'R'
         AND run_at_eod_yn = 'Y'
         AND proc_status = 'N'
         AND TO_CHAR(due_dt, 'YYYYMMDD') <= :g_cur_dt;

   EXEC SQL OPEN ts_curs;                    /* open cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TS_CURS",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Open TS_CURS cursor failed");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   EXEC SQL FETCH ts_curs INTO :eod_recs:eod_ind_recs; /*fetch corsor*/
   
   g_tsch_cnt = 0;

   while ((sqlca.sqlcode == ORCL_NO_ERROR || sqlca.sqlcode == ORCL_NOT_FOUND)
            && sqlca.sqlerrd[2] > 0)
   {
      cur_tsch_cnt = sqlca.sqlerrd[2] - g_tsch_cnt;
      g_tsch_cnt = sqlca.sqlerrd[2];   /* save actual # of rows fetched */
      
      /* Processes all tasks fetched into g_tsch_recs buffer
         to call do_task_reports */
      for (task_no = 0; task_no < cur_tsch_cnt; task_no++) 
      {
         strcpy(rpt_info_rec.task_type, eod_recs.task_type[task_no]);
         strcpy(rpt_info_rec.fi_rt, eod_recs.fi_rt[task_no]);
         rpt_info_rec.task_id       = eod_recs.task_id[task_no];
         rpt_info_rec.dist_prof_id  = eod_recs.dist_prof_id[task_no];
         strcpy(rpt_info_rec.task_name, eod_recs.task_name[task_no]);
         strcpy(rpt_info_rec.file_name, eod_recs.file_name[task_no]);
         strcpy(rpt_info_rec.proc_opt, eod_recs.proc_opt[task_no]);
         strcpy(rpt_info_rec.dist_ts,  eod_recs.dist_ts[task_no]);
         do_task_report();
      }

      if (cur_tsch_cnt < TSCH_BUF_CNT)
         break;
      else EXEC SQL FETCH ts_curs INTO :eod_recs:eod_ind_recs;

   }  /* end of while loop */

   if ((sqlca.sqlcode != ORCL_NO_ERROR) && (sqlca.sqlcode != ORCL_NOT_FOUND))
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TS_CURS",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Fetch TS_CURS failed in do_eod_reports()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   EXEC SQL CLOSE ts_curs;          /* close cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR) {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TS_CURS",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Close TS_CURS cursor Failed in do_eod_reports()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(2);
   }

   return TRUE;
} /* end do_eod_reports() */


/************************ do_eod_job *******************************************
* Description:                                                                 *
*     Sets FI's eod_status='E'; submits eod job.                               *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  07/03/1996  By: George Lin                                   *
* Modified Date:  11/04/1996  By: Dan Jung                                     *
*******************************************************************************/
BOOL do_eod_job(char fi_rt[10])
{
   EXEC SQL BEGIN DECLARE SECTION;
      char l_fi_rt[10];
   EXEC SQL END DECLARE SECTION;
   char  errstr[300];
   char  task_id[20];
   char  submit_errfilestr[512];
   char  job_file[81];
   char  fi_rt_str[30];
   char  msg_text[400];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;


   /*
      Set the eod_status = 'E' (Waiting on EOD Job)
   */

   if ( fail_check(fi_rt) ) 
      return FALSE;

   strcpy(l_fi_rt, fi_rt);

   EXEC SQL UPDATE fi SET eod_status = 'E'
      WHERE  fi_rt = :l_fi_rt;

   if (sqlca.sqlcode != ORCL_NO_ERROR) {     /* Oracle error */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", l_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FI",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Update FI failed!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   else
   {
      EXEC SQL COMMIT WORK;      /* commit update work */
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
         ifs_fatal("ORC_COMMIT",
                     __FILE__, (DWORD)__LINE__, IFS_LOG,
                     g_orcl_etext_buf,
                     g_fi_info,
                     NULL);
         paint_task_line(0, "Unable to Commit Changes");
         exit(1);
      }
   }
   /*
       Submit the eod job for the fi
   */
   EXEC SQL SELECT task_name, task_id
   INTO :g_task_name, :g_task_id
   FROM task_sch
   WHERE fi_rt = :l_fi_rt
   AND task_type = 'E'
   AND proc_status = 'N'
   AND ((to_char(due_dt, 'YYYYMMDD') = :g_cur_dt 
         AND :g_cur_time >= run_hhmm) OR
          (to_char(due_dt, 'YYYYMMDD') < :g_cur_dt)) 
   AND rownum = 1
   order by due_dt, run_hhmm;

   if (sqlca.sqlcode != ORCL_NO_ERROR) /* Oracle error */
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", l_fi_rt, ":", _itoa(sqlca.sqlcode, g_orcl_etext_buf, 10), NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(task_name, task_id FROM) TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Select failed in do_eod_job()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   trimlr(g_task_name);
   trimlr(g_task_id);
   if (g_task_id[strlen(g_task_id)-1] == '.')
      g_task_id[strlen(g_task_id)-1] = '\0';

   copy_cat(job_file, job_path, "\\", g_task_name, NULL);
   copy_cat(fi_rt_str, "%FI_RT%=", l_fi_rt, NULL);
   copy_cat(task_id, "%TASK_ID%=", g_task_id, NULL);

   /* which record has the file_name_str in it??? */
   strcpy(connect_yn, "/DBCONNECT=N");

   EXEC SQL UPDATE task_sch set proc_status = ' ' 
      WHERE fi_rt = :l_fi_rt
      AND task_name = :g_task_name
      AND task_type = 'E'
      AND proc_status = 'N'
      AND ((to_char(due_dt, 'YYYYMMDD') = :g_cur_dt 
            AND :g_cur_time >= run_hhmm) OR
            (to_char(due_dt, 'YYYYMMDD') < :g_cur_dt));

   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", l_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Update proc_status = ' ' failed in do_eod_job()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   else 
   {
      EXEC SQL COMMIT WORK;
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
         ifs_fatal("ORC_COMMIT",
                     __FILE__, (DWORD)__LINE__, IFS_LOG,
                     g_orcl_etext_buf,
                     g_fi_info,
                     NULL);
         paint_task_line(0, "Unable to Commit Changes");
         exit(1);
      }
   }
   
   /* submit eod job for end of day, task_id is 0 */

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));


   strcpy(parm[0], connect_yn);		arguments++;
   strcpy(parm[1], fi_rt_str);		arguments++;
   strcpy(parm[2], task_id);		arguments++;

   for(n = 0; n<arguments; n++)
       arg[n] = parm[n];
      
    if (submit_job(l_fi_rt, job_file, errstr, arg, arguments) == ERR)
   {
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_JCSUBMIT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);
      paint_task_line(1, "sql_jcsubmit() failed in do_eod_job()!");
      do_exit(1);
   }


   copy_cat(msg_text, "End of Day job ", g_task_name, " for FI=", 
      l_fi_rt, " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);
         
   paint_proc_info(msg_text);
   paint_proc_info(blank_line);

   return TRUE;

} /* end do_eod_job() */


/********************** no_tasks_in_proc ***************************************
* Description:                                                                 *
*     Counts task recs with proc_status=' ' (InProcess) or proc_status='F'     *
*       (Failed) for the FI and returns TRUE if count = 0 else FALSE.          *
* Returns:                                                                     *
*    Returns TRUE (!=0) when no tasks are "In Process" or "Failed" for fi or   *
*    any files are active or incomplete for building a nacha file.             *
*    Returns FALSE (==0) when there are tasks with a proc_stat of in process   *
*                        or file_status of active or in process.               *                                                 *
*                                                                              *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  07/03/1996  By: George Lin                                   *
* Modified date:  12/04/1996  By: Dan Jung                                     *
* Modified date:  01/05/1998  By: Darcy Sivertson                              *
* Modified Date:  09/01/1998  By: Mike West                                    *
* Modified Date:  04/14/1999  By: Mike West                                    *
*******************************************************************************/
int no_tasks_in_proc(char fi_rt[10])
{
   EXEC SQL BEGIN DECLARE SECTION;
   int   n;
   int   m;
   char  l_fi_rt[10];
   EXEC SQL END DECLARE SECTION;

  
   strcpy(l_fi_rt, fi_rt);

   EXEC SQL SELECT count(*) INTO :n
   FROM task_sch
   WHERE fi_rt = :l_fi_rt
   AND task_type <> 'P' // Dev. Req. 97-199 Requirement
   AND (proc_status = ' ' OR proc_status='F' OR proc_status IS NULL);

   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", l_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(COUNT(*) FROM) TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in no_tasks_in_proc()!");
      paint_task_line(1, "....Program Exit Code 31");
      do_exit(31);
   }


   /* Check to see if any file are active or incomplete */
   EXEC SQL SELECT count(*) INTO :m
   FROM     nacha_file_info
   WHERE    fi_rt = :l_fi_rt 
   AND   (file_status = 'A' OR file_status = 'I');

   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", l_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(COUNT(*) FROM) NACHA_FILE_INFO",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in no_tasks_in_proc()!");
      paint_task_line(1, "....Program Exit Code 30");
      do_exit(30);
   }

   if (n == 0 && m ==0)       /* if no task recs InProcess  */
      return (1);             /*    returns TRUE         */
   else                    /* else                    */
      return (0);             /*    returns FALSE        */
} /* end no_tasks_in_proc() */


/********************** no_input_in_proc ***************************************
* Description:                                                                 *
*     Counts file_sch recs with proc_status=NULL (InProcess) for the FI and    *
* returns TRUE if count = 0 else FALSE.                                        *
* RETURNS:                                                                     *
*  TRUE (!=0) when no file_sch items exit with a proc_stat of "In Process".    *
*  FALSE (0) when file_sch items exist with a proc_stat of "In process".       *
*                                                                              *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  07/03/1996  By: George Lin                                   *
* Modified Date:  12/04/1996  by: Dan Jung                                     *
*******************************************************************************/
int no_input_in_proc(char fi_rt[10])
{
   EXEC SQL BEGIN DECLARE SECTION;
      int   n;
      char  l_fi_rt[10];
   EXEC SQL END DECLARE SECTION;
   
   strcpy(l_fi_rt, fi_rt);

   EXEC SQL SELECT COUNT(*) INTO :n
   FROM ioq 
   WHERE fi_rt = :l_fi_rt AND status = 'AI';

   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", l_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(COUNT(*) FROM) IOQ",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in no_input_in_proc()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   if (n == 0)       /* if no file sch recs InProcess*/
      return (1);             /*    returns TRUE         */
   else                       /* else                    */
      return (0);             /*    returns FALSE        */
} /* end no_input_in_proc() */


/*********************** no_eod_in_proc ****************************************
* Description:                                                                 *
*     Return 1 if eod is running, else return 0.                               *
* Modified Date:  12/05/1996  By: Dan Jung                                     *
*******************************************************************************/
int no_eod_in_proc(char fi_rt[10])
{
   EXEC SQL BEGIN DECLARE SECTION;
      int   n;
      char  l_fi_rt[10];
   EXEC SQL END DECLARE SECTION;

   strcpy(l_fi_rt, fi_rt);
   /* see if eod is running */
   EXEC SQL SELECT COUNT(*) INTO :n
   FROM fi
   WHERE fi_rt = :l_fi_rt AND wh_status = 'E';

   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", l_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(COUNT(*) FROM) FI",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in no_eod_in_proc()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   if (n == 0)
      return 1;
   else
      return 0;
} /* end no_eod_in_proc() */



/*********************** fail_check ********************************************
* Description:                                                                 *
*    This function is called to check if there are any failed jobs that need   *
* to be resubmitted before proceeding with the earliest current EOD task.      *
*    If so, the pending EOD action will be bypassed for the current iteration  *
* through WATCH's main processing loop, allowing any unprocessed past due      *
* tasks or input files to be processed in the usual chronological order before *
* the EOD task.                                                                *
*                                                                              *
*    This situation arises when a 'normal' task has failed, leaving its        *
* TASK_SCH.PROC_STATUS= ' ', thus blocking all EOD tasks.                      *
*                                                                              *
*    Upon manually setting TASK_SCH.PROC_STATUS = 'N' for the failed task,     *
* the failed task will once again become a candidate to run, and should run    *
* BEFORE the EOD action that it had been blocking.                             *
*                                                                              *
*    If the failed task's DUE_DT and RUN_HHMM have not been changed, it will   *
* appear to be 'past due', and thus an immediate candidate to run.             *
*                                                                              *
*    Here we determine whether there are any such 'past due' tasks that were   *
* supposed to run before the scheduled EOD run time, or if any unprocessed     *
* input files were received before the scheduled EOD run time.                 *
*                                                                              *
*    If either such past-due tasks or unprocessed files are found, we just     *
* re-open the FI's warehouse for processing by setting FI.WH_STATUS = 'U',     *
* and FI.EOD_STATUS = 'N' as in the normal warehouse state, then return 'TRUE' *
* to indicate that such a condition was indeed identified.                     *
*                                                                              *
* Creation Date:  06/11/1997  By: Mike West                                    *
* Modified Date:  12/23/1998  By: FRNash & R.Malladi                           *
*******************************************************************************/
BOOL fail_check(char *fi_rt)
{
   EXEC SQL BEGIN DECLARE SECTION;
      char  h_fi_rt[10];
      short num_task;
      short num_task_ind;
      int   num_ioq;
      short num_ioq_ind;
      char  eod_due_dt[10];
      char  eod_run_hhmm[10];
      char  eod_runtime[20];
   EXEC SQL END DECLARE SECTION;

   /* make fi_rt a host variable */
   strcpy(h_fi_rt, fi_rt);

   /* Find due_dt and run_mmmm for the EARLIEST unprocessed 'EOD Type' task...
      Note that there are now two EOD tasks, the FI's EOD, and EOCD.JOB
      (Added task_type, proc_status, and ORDER BY)
   */
   EXEC SQL DECLARE task_sch_cur CURSOR FOR
      SELECT   TO_CHAR(due_dt, 'YYYYMMDD'), run_hhmm 
      FROM     task_sch
      WHERE    fi_rt = :h_fi_rt
      AND      task_type = 'E'
      AND      proc_status = 'N'
      ORDER BY due_dt, run_hhmm;

   EXEC SQL OPEN task_sch_cur;
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH_CUR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Open TASK_SCH_CUR cursor Failed!");
      paint_task_line (1, "....Program Exit Code = 10");
      do_exit(10);
   }

   EXEC SQL FETCH task_sch_cur INTO :eod_due_dt, :eod_run_hhmm;
   if ((sqlca.sqlcode != ORCL_NO_ERROR) && (sqlca.sqlcode != ORCL_NOT_FOUND))
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH_CUR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line (0, "Fetch TASK_SCH_CUR cursor failed in ck_eod()!");
      paint_task_line (1, "....Program Exit Code = 11");
      do_exit(11);
   }

   EXEC SQL CLOSE task_sch_cur;
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH_CUR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Close TASK_SCH_CUR failed in ck_eod()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(12);
   }

   /* See if there are any 'vanilla' tasks (not TASK_TYPE='E') due before the */
   /* EOD task that was identified above.                                     */
   EXEC SQL
      SELECT COUNT(*) 
      INTO :num_task:num_task_ind
      FROM task_sch
      WHERE fi_rt = :h_fi_rt
      AND   proc_status = 'N'
      AND   task_type <>'E'
      AND task_type <> 'P' // Dev. Req. 97-199 requirement
      AND   TO_CHAR(due_dt, 'YYYYMMDD') <= :eod_due_dt
      AND   run_hhmm <= :eod_run_hhmm
      AND   run_at_eod_yn = 'N'
      AND   ROWNUM = 1; /* because we don't look at EOD reports and Purge Tasks */

   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__,IFS_LOG,
                              "(COUNT(*) FROM) TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in fail_check()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   
   trimlr(eod_due_dt);
   trimlr(eod_run_hhmm);
   copy_cat(eod_runtime, eod_due_dt, eod_run_hhmm, "00", NULL);
   
   /* IT is possible that some files may be added to IOQ while EOD is waiting */
   /* or running.  So we need to check the recv_ts in IOQ to make sure that   */
   /* we are not re-running a failed file.                                    */
   /* See if there are any unprocessed input files received before the EOD    */
   /* task that was identified above.                                         */

   EXEC SQL
      SELECT COUNT(*)
      INTO :num_ioq:num_ioq_ind
      FROM ioq
      WHERE fi_Rt = :h_fi_rt
      AND   status = 'AU'
      AND   recv_ts <= :eod_runtime
      AND   ROWNUM = 1;

   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(COUNT(*) FROM) TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in fail_check()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* If we found either unprocessed tasks or input files that need to be      */
   /* processed before the current EOD task, we just reopen the warehouse for  */
   /* that FI, and those tasks or input files will be handled in due course.   */
   if ((num_task >= 1) || (num_ioq >= 1)) 
   {
      EXEC SQL
      UPDATE   fi
      SET      wh_status = 'U',
               eod_status = 'N'
      WHERE    fi_rt = :h_fi_rt;
      
      if (sqlca.sqlcode != ORCL_NO_ERROR) // error check added 12-23-1998 -FRN
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
         gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "FI",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
         paint_task_line(0, "Update FI failed in ck_eod()!");
         paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
         do_exit(1);
      }

      EXEC SQL COMMIT WORK;  // commit added 12-23-1998 -FRN
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
         ifs_fatal("ORC_COMMIT",
                     __FILE__, (DWORD)__LINE__, IFS_LOG,
                     g_orcl_etext_buf,
                     g_fi_info,
                     NULL);
         paint_task_line(0, "Unable to Commit Changes");
         exit(1);
      }

      return TRUE;
   }  
   else 
      return FALSE;
} /* end fail_check() */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   document/set2/CKFILSCH.cpp_3.pdf                                                                    0000644     %g4001001 00000532134 14011517334 014535  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               
/* Result Sets Interface */
#ifndef SQL_CRSR
#  define SQL_CRSR
  struct sql_cursor
  {
    unsigned int curocn;
    void *ptr1;
    void *ptr2;
    unsigned int magic;
  };
  typedef struct sql_cursor sql_cursor;
  typedef struct sql_cursor SQL_CURSOR;
#endif /* SQL_CRSR */

/* Thread Safety */
typedef void * sql_context;
typedef void * SQL_CONTEXT;

/* Object support */
struct sqltvn
{
  unsigned char *tvnvsn; 
  unsigned short tvnvsnl; 
  unsigned char *tvnnm;
  unsigned short tvnnml; 
  unsigned char *tvnsnm;
  unsigned short tvnsnml;
};
typedef struct sqltvn sqltvn;

struct sqladts
{
  unsigned int adtvsn; 
  unsigned short adtmode; 
  unsigned short adtnum;  
  sqltvn adttvn[1];       
};
typedef struct sqladts sqladts;

static struct sqladts sqladt = {
  1,0,0,
};

/* Binding to PL/SQL Records */
struct sqltdss
{
  unsigned int tdsvsn; 
  unsigned short tdsnum; 
  unsigned char *tdsval[1]; 
};
typedef struct sqltdss sqltdss;
static struct sqltdss sqltds =
{
  1,
  0,
};

/* File name & Package Name */
struct sqlcxp
{
  unsigned short fillen;
           char  filnam[14];
};
static const struct sqlcxp sqlfpn =
{
    13,
    ".\\CKFILSCH.pc"
};


static unsigned int sqlctx = 520683;


static struct sqlexd {
   unsigned int   sqlvsn;
   unsigned int   arrsiz;
   unsigned int   iters;
   unsigned int   offset;
   unsigned short selerr;
   unsigned short sqlety;
   unsigned int   occurs;
      const short *cud;
   unsigned char  *sqlest;
      const char  *stmt;
   sqladts *sqladtp;
   sqltdss *sqltdsp;
            void  **sqphsv;
   unsigned int   *sqphsl;
            int   *sqphss;
            void  **sqpind;
            int   *sqpins;
   unsigned int   *sqparm;
   unsigned int   **sqparc;
   unsigned short  *sqpadto;
   unsigned short  *sqptdso;
   unsigned int   sqlcmax;
   unsigned int   sqlcmin;
   unsigned int   sqlcincr;
   unsigned int   sqlctimeout;
   unsigned int   sqlcnowait;
              int   sqfoff;
   unsigned int   sqcmod;
   unsigned int   sqfmod;
   unsigned int   sqlpfmem;
            void  *sqhstv[24];
   unsigned int   sqhstl[24];
            int   sqhsts[24];
            void  *sqindv[24];
            int   sqinds[24];
   unsigned int   sqharm[24];
   unsigned int   *sqharc[24];
   unsigned short  sqadto[24];
   unsigned short  sqtdso[24];
} sqlstm = {13,24};

// Prototypes
extern "C" {
  void sqlcxt (void **, unsigned int *,
               struct sqlexd *, const struct sqlcxp *);
  void sqlcx2t(void **, unsigned int *,
               struct sqlexd *, const struct sqlcxp *);
  void sqlbuft(void **, char *);
  void sqlgs2t(void **, char *);
  void sqlorat(void **, unsigned int *, void *);
}

// Forms Interface
static const int IAPSUCC = 0;
static const int IAPFAIL = 1403;
static const int IAPFTL  = 535;
extern "C" { void sqliem(unsigned char *, signed int *); }

 static const char *sq0001 = 
"select upper(i.file_name) ,TO_CHAR(i.recv_ts,'YYYYMMDDHH24MISS') ,i.fi_rt ,u\
pper(i.type)  from fi f ,ioq i where (((f.fi_rt=i.fi_rt and f.active_yn='Y') a\
nd f.wh_status='U') and i.status='AU') order by recv_ts            ";

 static const char *sq0014 = 
"select fs.file_sch_id  from fi ,file_sch fs where (((((fi.fi_rt=fs.fi_rt and\
 fi.active_yn='Y') and fi.wh_status='U') and fi.fi_rt=:b0) and fs.file_id=:b1)\
 and (fs.override_yn='Y' or (((fs.missed_yn='N' and fs.proc_status='N') and :b\
2>TO_CHAR(fs.earliest_ts,'YYYYMMDDHH24MISS')) and :b2<TO_CHAR(fs.latest_ts,'YY\
YYMMDDHH24MISS'))))           ";

 static const char *sq0015 = 
"select fs.fi_rt ,fs.file_sch_id ,fs.file_id ,TO_CHAR(fs.earliest_ts,'YYYYMMD\
DHH24MISS') ,TO_CHAR(fs.latest_ts,'YYYYMMDDHH24MISS')  from fi ,file_sch fs wh\
ere ((((((fi.fi_rt=fs.fi_rt and fi.active_yn='Y') and fi.wh_status='U') and fs\
.missed_yn='N') and fs.at_risk_yn='N') and fs.proc_status='N') and :b0>TO_CHAR\
(fs.at_risk_ts,'YYYYMMDDHH24MISS')) order by fs.at_risk_ts            ";

 static const char *sq0020 = 
"select fs.fi_rt ,fs.file_sch_id ,fs.file_id ,TO_CHAR(fs.earliest_ts,'YYYYMMD\
DHH24MISS') ,TO_CHAR(fs.latest_ts,'YYYYMMDDHH24MISS')  from fi ,file_sch fs wh\
ere ((((((fi.fi_rt=fs.fi_rt and fi.active_yn='Y') and fi.wh_status='U') and fs\
.missed_yn='N') and fs.at_risk_yn='Y') and fs.proc_status='N') and :b0>TO_CHAR\
(fs.latest_ts,'YYYYMMDDHH24MISS')) order by fs.latest_ts            ";

typedef struct { unsigned short len; unsigned char arr[1]; } VARCHAR;
typedef struct { unsigned short len; unsigned char arr[1]; } varchar;

/* cud (compilation unit data) array */
static const short sqlcud0[] =
{13,4130,178,0,0,
5,0,0,1,221,0,521,80,0,0,0,0,0,1,0,
20,0,0,1,0,0,525,102,0,0,4,0,0,1,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,
51,0,0,1,0,0,525,120,0,0,4,0,0,1,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,
82,0,0,1,0,0,527,140,0,0,0,0,0,1,0,
97,0,0,2,89,0,516,234,0,0,3,1,0,1,0,2,97,0,0,2,97,0,0,1,97,0,0,
124,0,0,3,74,0,517,425,0,0,2,2,0,1,0,1,97,0,0,1,97,0,0,
147,0,0,4,0,0,541,433,0,0,0,0,0,1,0,
162,0,0,5,74,0,517,482,0,0,2,2,0,1,0,1,97,0,0,1,97,0,0,
185,0,0,6,63,0,517,510,0,0,2,2,0,1,0,1,97,0,0,1,97,0,0,
208,0,0,7,0,0,541,519,0,0,0,0,0,1,0,
223,0,0,8,62,0,517,732,0,0,3,3,0,1,0,1,97,0,0,1,97,0,0,1,97,0,0,
250,0,0,9,0,0,541,740,0,0,0,0,0,1,0,
265,0,0,10,89,0,517,797,0,0,2,2,0,1,0,1,97,0,0,1,4,0,0,
288,0,0,11,74,0,517,806,0,0,3,3,0,1,0,1,1,0,0,1,97,0,0,1,4,0,0,
315,0,0,12,0,0,541,815,0,0,0,0,0,1,0,
330,0,0,13,504,0,518,1086,0,0,24,24,0,1,0,1,97,0,0,1,97,0,0,1,97,0,0,1,97,0,0,
1,97,0,0,1,97,0,0,1,97,0,0,1,97,0,0,1,97,0,0,1,97,0,0,1,97,0,0,2,4,0,0,2,97,0,
0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,4,0,0,2,4,0,
0,2,4,0,0,2,97,0,0,
441,0,0,14,340,0,521,1474,0,0,4,4,0,1,0,1,97,0,0,1,4,0,0,1,97,0,0,1,97,0,0,
472,0,0,14,0,0,525,1491,0,0,1,0,0,1,0,2,4,0,0,
491,0,0,14,0,0,527,1495,0,0,0,0,0,1,0,
506,0,0,14,0,0,527,1527,0,0,0,0,0,1,0,
521,0,0,14,0,0,527,1546,0,0,0,0,0,1,0,
536,0,0,15,380,0,521,1634,0,0,1,1,0,1,0,1,97,0,0,
555,0,0,15,0,0,525,1656,0,0,5,0,0,1,0,2,97,0,0,2,4,0,0,2,4,0,0,2,97,0,0,2,97,0,
0,
590,0,0,16,161,0,517,1671,0,0,4,4,0,1,0,1,97,0,0,1,4,0,0,1,4,0,0,1,97,0,0,
621,0,0,17,0,0,541,1696,0,0,0,0,0,1,0,
636,0,0,18,64,0,518,1724,0,0,3,3,0,1,0,2,97,0,0,1,97,0,0,1,97,0,0,
663,0,0,19,64,0,518,1752,0,0,3,3,0,1,0,2,97,0,0,1,97,0,0,1,97,0,0,
690,0,0,15,0,0,525,1800,0,0,5,0,0,1,0,2,97,0,0,2,4,0,0,2,4,0,0,2,97,0,0,2,97,0,
0,
725,0,0,15,0,0,527,1820,0,0,0,0,0,1,0,
740,0,0,20,378,0,521,1883,0,0,1,1,0,1,0,1,97,0,0,
759,0,0,20,0,0,525,1905,0,0,5,0,0,1,0,2,97,0,0,2,4,0,0,2,4,0,0,2,97,0,0,2,97,0,
0,
794,0,0,21,105,0,517,1920,0,0,3,3,0,1,0,1,97,0,0,1,4,0,0,1,4,0,0,
821,0,0,22,0,0,541,1943,0,0,0,0,0,1,0,
836,0,0,20,0,0,525,1964,0,0,5,0,0,1,0,2,97,0,0,2,4,0,0,2,4,0,0,2,97,0,0,2,97,0,
0,
871,0,0,20,0,0,527,1984,0,0,0,0,0,1,0,
886,0,0,23,76,0,516,2013,0,0,3,2,0,1,0,2,97,0,0,1,97,0,0,1,4,0,0,
913,0,0,24,112,0,516,2088,0,0,2,1,0,1,0,2,97,0,0,1,97,0,0,
};


/*******************************************************************************
CKFILSCH.PC -- An ACHOS Program - Module of WATCH.EXE
Version 1.08.10

Copyright (C) 1995, 1998 Deluxe Data Systems, Inc.
Copyright (C) 1997, 1998, 1999 Deluxe Electronic Payent Systems, Inc.

Part of WATCH.EXE which does file input based on the file schedule.
*******************************************************************************/


/*******************************************************************************
   INCLUDES & DEFINES                              
*******************************************************************************/

/* EXEC SQL BEGIN DECLARE SECTION; */ 

/* This #define PREVENTS the sqlca to be declared as external in sqlca.h */
#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern
#define INCLUDE_AS_EXTERN   extern

/* EXEC SQL END DECLARE SECTION; */ 


/* EXEC SQL INCLUDE  "sqlproto.h";
 */ 
#include <sqlcpr.h>

/* EXEC SQL INCLUDE  "sqlca.h";
 */ 
/*
 * $Header: sqlca.h,v 1.3 1994/12/12 19:27:27 jbasu Exp $ sqlca.h 
 */

/* Copyright (c) 1985,1986, 1998 by Oracle Corporation. */
 
/*
NAME
  SQLCA : SQL Communications Area.
FUNCTION
  Contains no code. Oracle fills in the SQLCA with status info
  during the execution of a SQL stmt.
NOTES
  **************************************************************
  ***                                                        ***
  *** This file is SOSD.  Porters must change the data types ***
  *** appropriately on their platform.  See notes/pcport.doc ***
  *** for more information.                                  ***
  ***                                                        ***
  **************************************************************

  If the symbol SQLCA_STORAGE_CLASS is defined, then the SQLCA
  will be defined to have this storage class. For example:
 
    #define SQLCA_STORAGE_CLASS extern
 
  will define the SQLCA as an extern.
 
  If the symbol SQLCA_INIT is defined, then the SQLCA will be
  statically initialized. Although this is not necessary in order
  to use the SQLCA, it is a good pgming practice not to have
  unitialized variables. However, some C compilers/OS's don't
  allow automatic variables to be init'd in this manner. Therefore,
  if you are INCLUDE'ing the SQLCA in a place where it would be
  an automatic AND your C compiler/OS doesn't allow this style
  of initialization, then SQLCA_INIT should be left undefined --
  all others can define SQLCA_INIT if they wish.

  If the symbol SQLCA_NONE is defined, then the SQLCA variable will
  not be defined at all.  The symbol SQLCA_NONE should not be defined
  in source modules that have embedded SQL.  However, source modules
  that have no embedded SQL, but need to manipulate a sqlca struct
  passed in as a parameter, can set the SQLCA_NONE symbol to avoid
  creation of an extraneous sqlca variable.
 
MODIFIED
    lvbcheng   07/31/98 -  long to int
    jbasu      12/12/94 -  Bug 217878: note this is an SOSD file
    losborne   08/11/92 -  No sqlca var if SQLCA_NONE macro set 
  Clare      12/06/84 - Ch SQLCA to not be an extern.
  Clare      10/21/85 - Add initialization.
  Bradbury   01/05/86 - Only initialize when SQLCA_INIT set
  Clare      06/12/86 - Add SQLCA_STORAGE_CLASS option.
*/
 
#ifndef SQLCA
#define SQLCA 1
 
struct   sqlca
         {
         /* ub1 */ char    sqlcaid[8];
         /* b4  */ int     sqlabc;
         /* b4  */ int     sqlcode;
         struct
           {
           /* ub2 */ unsigned short sqlerrml;
           /* ub1 */ char           sqlerrmc[70];
           } sqlerrm;
         /* ub1 */ char    sqlerrp[8];
         /* b4  */ int     sqlerrd[6];
         /* ub1 */ char    sqlwarn[8];
         /* ub1 */ char    sqlext[8];
         };

#ifndef SQLCA_NONE 
#ifdef   SQLCA_STORAGE_CLASS
SQLCA_STORAGE_CLASS struct sqlca sqlca
#else
         struct sqlca sqlca
#endif
 
#ifdef  SQLCA_INIT
         = {
         {'S', 'Q', 'L', 'C', 'A', ' ', ' ', ' '},
         sizeof(struct sqlca),
         0,
         { 0, {0}},
         {'N', 'O', 'T', ' ', 'S', 'E', 'T', ' '},
         {0, 0, 0, 0, 0, 0},
         {0, 0, 0, 0, 0, 0, 0, 0},
         {0, 0, 0, 0, 0, 0, 0, 0}
         }
#endif
         ;
#endif
 
#endif
 
/* end SQLCA */
/* EXEC SQL INCLUDE  "orcltype.h";
 */ 
/***************************************************************

ACHOS Function Library
Copyright (C) 1996 Deluxe Electronic Payment Systems, Inc.

Header Containing TypeDefs for Native ORACLE data types
and function prototypes for ORCLTYPE.LIB.

NOTE:  Programs should use EXEC SQL INCLUDE orcltype;
to include this header AFTER including achosprd.h!

FILE:			ORCLTYPE.H

CREATED:		07/01/96		Troy Clark
MODIFIED:	11/25/96		Troy Clark

***************************************************************/

#ifndef	ORCLTYPE_H_
#define	ORCLTYPE_H_

/***************************************************************
	Typedefs
***************************************************************/
/*
NOTICE:  Any changes made to oracle_date or oracle_varnum typedefs
			must also be made to their re-definition within DDSI.H
			The duplication is required so that DDSI.H does not
			required using oracles pro*c precompiler!
*/

/* EXEC SQL BEGIN DECLARE SECTION; */ 


typedef	struct	oracle_date_tag {
	unsigned char	century;
	unsigned	char	year;
	unsigned	char	month;
	unsigned	char	day;
	unsigned	char	hour;
	unsigned char	minute;
	unsigned char	second;
} oracle_date;

typedef struct oracle_varnum_tag {
	unsigned char	length;			/* # of bytes to follow -- includes expon. */
	unsigned char	exponent;			
	unsigned char	mantissa[20];	/* signif.digits - NO lead/trail zeros */
} oracle_varnum;

/* EXEC SQL TYPE	oracle_date		IS		DATE; */ 

/* EXEC SQL TYPE	oracle_varnum	IS		VARNUM(22); */ 


/* EXEC SQL END DECLARE SECTION; */ 


#endif

#include          "ddsi.h"
#include          "achosprd.h"
#include          "stdlib.h"

/* EXEC SQL INCLUDE watch; /o inserts watch.h into src for Pro*C o/ 
 */ 
/***************************************************************

WATCH.H Header File for WATCH.EXE and it's assoc. sub-programs
Version 1.08.10

Copyright (C) 1995 Deluxe Data Systems, Inc.
Copyright (C) 1997, 1998 Deluxe Electronic Payent Systems, Inc.

Header Containing Prototypes for all functions in the ACHOSPRD.LIB
   FILE:       watch.h
   CREATED:    06/18/1996  Troy Clark
   MODIFIED:   06/18/1996  Troy Clark
   MODIFIED:   05/14/1998  FRNash
***************************************************************/


/***************************************************************
   INCLUDES 
***************************************************************/


/***************************************************************
   TYPEDEFS, DEFINES AND DECLARATIONS
***************************************************************/
#ifndef _WATCH_H_
#define _WATCH_H_

/* EXEC SQL BEGIN DECLARE SECTION; */ 


#define  TSCH_BUF_CNT            100
#define  IOQ_BUF_CNT             100
#define  FSCH_BUF_CNT            100
#define  FI_BUF_CNT              101
#define  MAX_LOOP_CNT            50
#define  MAX_NACHA_CURSOR_CNT    100
#define  MOUSE_TARGET_MIN_X      36
#define  MOUSE_TARGET_MIN_Y      23

#define  MOUSE_TARGET_MAX_X      39
#define  MOUSE_TARGET_MAX_Y      23

#define  blank_line " "
/* 
   Max allowed FI cnt = (FI_BUF_CNT - 1) or 100 
   This makes detecting when more than max allowed FI recs exist easy
   since doing an array fetch only sets sqlca.sqlcode == 0 when it
   fetches exactly the same # of rows as the array size.  Otherwise,
   it will set sqlca.sqlcode = 100 and sqlca.sqlerrd[2] = actual fetch
   cnt.
*/

typedef struct rpt_info_rec_tag {
   char     task_type[2];
   char     fi_rt[10];
   double   task_id;
   double   dist_prof_id;
   char     task_name[31];       /* max len is 30 */
   char     file_name[13];
   char     run_at_eod_yn[2];
   char     proc_opt[101];        /* max len is 100  Increased the size for SLA Report */
   char     dist_ts[16];         /* max len is 15 */
   char     corp_orig_id[11];
} rpt_info_rec_type;

typedef struct watch_tsch_recs_tag {
   char     task_type       [TSCH_BUF_CNT][2];
   char     fi_rt           [TSCH_BUF_CNT][10];
   double   task_id         [TSCH_BUF_CNT];
   double   dist_prof_id    [TSCH_BUF_CNT];
   char     task_name       [TSCH_BUF_CNT][31];  /* max len is 30 */
   char     file_name       [TSCH_BUF_CNT][13];
   char     run_at_eod_yn   [TSCH_BUF_CNT][2];
   char     proc_opt        [TSCH_BUF_CNT][101];  /* max len is 100 */
   int      days_past       [TSCH_BUF_CNT];
   char     dist_ts         [TSCH_BUF_CNT][16];
   char     corp_orig_id    [TSCH_BUF_CNT][11];
} watch_tsch_recs;

typedef struct watch_tsch_ind_recs_tag {
   short    task_type       [TSCH_BUF_CNT];
   short    fi_rt           [TSCH_BUF_CNT];
   short    task_id         [TSCH_BUF_CNT];
   short    dist_prof_id    [TSCH_BUF_CNT];
   short    task_name       [TSCH_BUF_CNT];
   short    file_name       [TSCH_BUF_CNT];
   short    run_at_eod_yn   [TSCH_BUF_CNT];
   short    proc_opt        [TSCH_BUF_CNT];
   short    days_past       [TSCH_BUF_CNT];
   short    dist_ts         [TSCH_BUF_CNT];
   short    corp_orig_id    [TSCH_BUF_CNT];
} watch_tsch_ind_recs;  /* indicators for watch_task_recs */

typedef struct watch_ioq_recs_tag {
   char     file_name      [IOQ_BUF_CNT][13];
   char     recv_ts        [IOQ_BUF_CNT][15];
   char     fi_rt          [IOQ_BUF_CNT][10];
   char     type           [IOQ_BUF_CNT][4];
} watch_ioq_recs;

typedef struct watch_ioq_ind_recs_tag {
   short    file_name      [IOQ_BUF_CNT];
   short    recv_ts        [IOQ_BUF_CNT];
   short    fi_rt          [IOQ_BUF_CNT];
   short    type           [IOQ_BUF_CNT];
} watch_ioq_ind_recs;

typedef struct watch_fsch_recs_tag {
   char     fi_rt          [FSCH_BUF_CNT][10];
   double   file_sch_id    [FSCH_BUF_CNT];
   double   file_id        [FSCH_BUF_CNT];
   char     earliest_ts    [FSCH_BUF_CNT][15];  /* TS is in 'YYYYMMDDHH24MISS' format */
   char     latest_ts      [FSCH_BUF_CNT][15];
} watch_fsch_recs;

typedef struct watch_fsch_ind_recs_tag {
   short    fi_rt          [FSCH_BUF_CNT];
   short    file_sch_id    [FSCH_BUF_CNT];
   short    file_id        [FSCH_BUF_CNT];
   short    earliest_ts    [FSCH_BUF_CNT];
   short    latest_ts      [FSCH_BUF_CNT];
} watch_fsch_ind_recs;

typedef  struct watch_fi_rt_rec_tag {
   char     fi_rt[FSCH_BUF_CNT][10];
} watch_fi_rt_rec;

typedef  struct watch_eod_rec_tag {
   char     fi_rt[FSCH_BUF_CNT][10];
   char     eod_status[FSCH_BUF_CNT][2];
} watch_eod_rec;

typedef  struct watch_eod_ind_rec_tag {
   short    fi_rt[FSCH_BUF_CNT];
   short    eod_status[FSCH_BUF_CNT];
} watch_eod_ind_rec;

typedef  struct g_nacha_file_id_tag 
{
char     fi_rt[MAX_NACHA_CURSOR_CNT][10];
double   nacha_file_id[MAX_NACHA_CURSOR_CNT];
}g_nacha_file_rec;


typedef  struct g_nacha_file_ind_tag 
{
short    fi_rt[MAX_NACHA_CURSOR_CNT];
short    nacha_file_id[MAX_NACHA_CURSOR_CNT];
}g_nacha_file_ind;   

/* Struct Def. for Nacha File Id used in CKTSKSCH.PC (DS)*/

INCLUDE_AS_EXTERN watch_tsch_recs        g_tsch_recs;
INCLUDE_AS_EXTERN watch_tsch_ind_recs    g_tsch_inds;
INCLUDE_AS_EXTERN int                    g_tsch_cnt;
INCLUDE_AS_EXTERN watch_ioq_recs         g_ioq_recs;
INCLUDE_AS_EXTERN watch_ioq_ind_recs     g_ioq_inds;
INCLUDE_AS_EXTERN int                    g_ioq_cnt;
INCLUDE_AS_EXTERN watch_fsch_recs        g_fsch_recs;
INCLUDE_AS_EXTERN watch_fsch_ind_recs    g_fsch_inds;
INCLUDE_AS_EXTERN int                    g_fsch_cnt;
INCLUDE_AS_EXTERN watch_fi_rt_rec        g_fi_rt_rec;


INCLUDE_AS_EXTERN g_nacha_file_rec  g_nacha_file_id;
INCLUDE_AS_EXTERN g_nacha_file_ind  g_nacha_file_id_ind; 
INCLUDE_AS_EXTERN  rpt_info_rec_type rpt_info_rec;
INCLUDE_AS_EXTERN char        g_prn_dt[9];
INCLUDE_AS_EXTERN char        g_prn_time[6];
INCLUDE_AS_EXTERN char        g_cur_dt[9];               /* current date */
INCLUDE_AS_EXTERN char        g_cur_time[5];             /* current time */
INCLUDE_AS_EXTERN char        g_cur_dt_time[14];         /* current date and time */
INCLUDE_AS_EXTERN char*       gpszIFSMsg;
INCLUDE_AS_EXTERN char        g_user_name[81];
INCLUDE_AS_EXTERN char        g_db_name[81];
INCLUDE_AS_EXTERN char        g_orcl_etext_buf[256];
INCLUDE_AS_EXTERN char        g_fi_info[81];
INCLUDE_AS_EXTERN int         g_orcl_etext_len;
INCLUDE_AS_EXTERN int         g_orcl_etext_size;
INCLUDE_AS_EXTERN char        p_fi_rt[10];
INCLUDE_AS_EXTERN char        gs_scratch[81];
INCLUDE_AS_EXTERN char        g_corp_orig_id[11];                 /* psm - 5/08/1997 mod */
INCLUDE_AS_EXTERN int         g_num_fi;
INCLUDE_AS_EXTERN int         g_cur_fi;
INCLUDE_AS_EXTERN int         loop_cnt;                  

/* EXEC SQL END DECLARE SECTION; */ 


/* job path and btrieve path */
INCLUDE_AS_EXTERN  char        job_path[81];        
INCLUDE_AS_EXTERN char        exe_path[81];
INCLUDE_AS_EXTERN char        eod_job_name[81];

/***************************************************************
   FUNCTION PROTOTYPES 
***************************************************************/

/* Functions are listed by source file in order of their appearance */


/* SOURCE FILE:   ckeod.pc       */
void  ck_eod               (void);
void  do_start_eod         (int task_no);
BOOL  do_eod_reports       (char*);
BOOL  do_eod_job           (char*);
int   no_tasks_in_proc     (char*);
int   no_input_in_proc     (char*);
int   no_eod_in_proc       (char*);
BOOL  fail_check           (char *);


/* SOURCE FILE:   ckfildlv.pc       */
void  ck_file_dlvrs        (void);
void  deliver_file         (int ioq_no);


/* SOURCE FILE:   ckfilsch.pc       */
void  ck_file_sch          (void);
void  input_file           (int ioq_no);
int   ioq_set_status       (char *file_name, char *fi_rt, char *status_str);
/* 
   NOTE: ioq_set_status() needs to be put in ACHOSPRD.LIB once tested.
*/
int   file_sch_set_status  (char *fi_rt, double fsch_id, char new_status);
/* 
   NOTE: file_sch_set_status() needs to be put in ACHOSPRD.LIB once tested.
*/
int   id_input_file        (char *rec_one, char *fi_rt, FILE *file_handle, 
                              char * file_name_str, double *file_id,
                              char *reject_yn, int *rec_size);
long  find_one_rec         (FILE* fPointer, int* rec_size, long offset_to_one,
                              char* file_name_str);
int   id_nonnacha_file     (FILE *, char *);
long  one_rec_offset       (FILE *filePtr, char* file_name_str, int *rec_size);
void  log_file             (char *fi_rt, char *file_name, char *recv_ts, 
                              double dwFileID);
int   file_sch_hit         (char *fi_rt, double file_id, double *fsch_id);
void  file_sch_ck_at_risk  (void);
void  file_sch_ck_missed   (void);
void  get_corp_orig_id     (int fsch_no);


/* SOURCE FILE:   cktsksch.pc    */
void  ck_task_sch          (void);
void  do_task_dist         (int task_no);
void  do_task_fpickup      (int task_no);
void  do_task_integ        (int task_no);
void  do_task_report       (void);
void  do_nacha_file        (int task_no);
void  do_task_system       (int task_no);
void  do_group_task        (int task_no); // Added for DR#97-018 -FRN
void    do_task_purge         (int task_no); // Added for DR#97-199 -RMM
void  do_task_extract      (int task_no); // Added for DR#99-018 -SHA
void  do_task_billing      (int task_no); // Added for DR#99-018 -SHA
/* SOURCE FILE:   watch.pc       */
void  build_fi_rec();
void  do_exit              (int exit_value);
void  ck_mouse_quit        (HANDLE hConOut);
void  refresh_fi();
void  watch_events         (HANDLE hStdIn);
void  wr_cur_time();
void  wr_start_time();
void  wr_status(void);
int   submit_job(char* task_fi_rt, char* job_file, char* errstr,  char* arg[22], int arguments);
BOOL WINAPI CtrlHandler    (DWORD dwEvent);


/* SOURCE FILE:   mousehit.c     */
/* [Replaces the ACHOSPRD.LIB version of this function, which doesn't work!] */
short ck_mouse_hitx (HANDLE hConIn,  short min_x, short min_y, short max_x, short max_y);

#endif //_WATCH_H_





long  offset = 0; /* number of bytes read so far in search of the one record*/

/*********************** ck_file_sch *******************************************
* Description:                                                                 *
*  Gets all files from ioq that need to be run thru ACHINPUT and calls         *
* input_file() to process them. It also checks the file_sch for files at_risk  *
* (that are in their late grace period) and warns the FI.  Also, checks the    *
* file for files that missed their schedule and notifies FI.                   *
*                                                                              *
* Creation Date:  06/25/1996  By: Troy Clark                                   *
* Modified Date:  11/18/1996  By: Dan Jung                                     *
* Modified Date:  02/01/1999  By: R.Malladi  Bug Fixes: 90128Hb and 90128I     *
* Modified Date:  02/02/1999  By: FRNash     Bug Fix: 90201Ea                  *
* Modified Date:    03/14/2000  By: Mike West   Dev Req 99-106
*******************************************************************************/
void ck_file_sch(void)
{
   int   ioq_cnt = 0;
   int   ioq_no;                 /* index no for ioq buffers */
   int   cur_ioq_cnt;            /* current IOQ count */

int errcode;
   
   /* display message to screen */
   paint_task_line(1, "Checking IOQ.....");
   Sleep(2000);

   /* Get all files that are available to be input!                           */
   /* EXEC SQL DECLARE ioq_cursor CURSOR FOR   /o declare cursor o/
   SELECT  upper(i.file_name), 
         TO_CHAR(i.recv_ts, 'YYYYMMDDHH24MISS'),
         i.fi_rt, 
         upper(i.type)
         FROM fi f, ioq i
         WHERE f.fi_rt = i.fi_rt 
         AND f.active_yn = 'Y' 
         AND f.wh_status = 'U' 
         AND i.status = 'AU'
         ORDER  BY recv_ts; */ 


   /* Notice that the above select statement performs a join on the FI and    */
   /* ioq table such that only ioq records whose dst_fi_rt matches a FI       *
   /* record's fi_rt where the fi is active and in an "Up" condition are      */
   /* returned. Thus, we don't need to check the fi for a wh_status = 'U'     */
   /* after the fact--it's built into the where clause...                     */

   /* EXEC SQL OPEN ioq_cursor; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 0;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = sq0001;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )5;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqcmod = (unsigned int )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

           /* opens cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "IOQ_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"OPEN CURSOR ioq_cursor failed in ck_file_sch()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* Loop through all files that need to be input, fetching IOQ_BUF_CNT      */
   /* number of records at a time on each pass through the loop.              */
   /* EG. if 200 files need to be input and IOQ_BUF_CNT = 100 then,           */
   /*       it will loop 2 times, fetching & processing 100 on each pass...   */

   /* EXEC SQL FETCH ioq_cursor INTO :g_ioq_recs:g_ioq_inds; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 4;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )100;
   sqlstm.offset = (unsigned int  )20;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqfoff = (           int )0;
   sqlstm.sqfmod = (unsigned int )2;
   sqlstm.sqhstv[0] = (         void  *)g_ioq_recs.file_name;
   sqlstm.sqhstl[0] = (unsigned int  )13;
   sqlstm.sqhsts[0] = (         int  )13;
   sqlstm.sqindv[0] = (         void  *)g_ioq_inds.file_name;
   sqlstm.sqinds[0] = (         int  )sizeof(short);
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqharc[0] = (unsigned int   *)0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)g_ioq_recs.recv_ts;
   sqlstm.sqhstl[1] = (unsigned int  )15;
   sqlstm.sqhsts[1] = (         int  )15;
   sqlstm.sqindv[1] = (         void  *)g_ioq_inds.recv_ts;
   sqlstm.sqinds[1] = (         int  )sizeof(short);
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqharc[1] = (unsigned int   *)0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)g_ioq_recs.fi_rt;
   sqlstm.sqhstl[2] = (unsigned int  )10;
   sqlstm.sqhsts[2] = (         int  )10;
   sqlstm.sqindv[2] = (         void  *)g_ioq_inds.fi_rt;
   sqlstm.sqinds[2] = (         int  )sizeof(short);
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqharc[2] = (unsigned int   *)0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)g_ioq_recs.type;
   sqlstm.sqhstl[3] = (unsigned int  )4;
   sqlstm.sqhsts[3] = (         int  )4;
   sqlstm.sqindv[3] = (         void  *)g_ioq_inds.type;
   sqlstm.sqinds[3] = (         int  )sizeof(short);
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqharc[3] = (unsigned int   *)0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

 /* fetch record */  

   while ((sqlca.sqlcode == ORCL_NOT_FOUND || sqlca.sqlcode == ORCL_NO_ERROR) 
            && sqlca.sqlerrd[2] > 0) 
   {

      /* Save the actual # of ioq file records fetched */
      cur_ioq_cnt = sqlca.sqlerrd[2] - ioq_cnt;
      ioq_cnt = sqlca.sqlerrd[2];

      /* Process all file records fetched into g_ioq_recs buffer */
      for (ioq_no = 0; ioq_no < cur_ioq_cnt; ioq_no++) 
         input_file( ioq_no );

      if (cur_ioq_cnt < IOQ_BUF_CNT)
         break;
      else
         /* Attempt to fetch another buffer full for the next pass */
         /* EXEC SQL FETCH ioq_cursor INTO :g_ioq_recs:g_ioq_inds; */ 

{
         struct sqlexd sqlstm;
         sqlstm.sqlvsn = 13;
         sqlstm.arrsiz = 4;
         sqlstm.sqladtp = &sqladt;
         sqlstm.sqltdsp = &sqltds;
         sqlstm.iters = (unsigned int  )100;
         sqlstm.offset = (unsigned int  )51;
         sqlstm.selerr = (unsigned short)0;
         sqlstm.sqlpfmem = (unsigned int  )0;
         sqlstm.cud = sqlcud0;
         sqlstm.sqlest = (unsigned char  *)&sqlca;
         sqlstm.sqlety = (unsigned short)4352;
         sqlstm.occurs = (unsigned int  )0;
         sqlstm.sqfoff = (           int )0;
         sqlstm.sqfmod = (unsigned int )2;
         sqlstm.sqhstv[0] = (         void  *)g_ioq_recs.file_name;
         sqlstm.sqhstl[0] = (unsigned int  )13;
         sqlstm.sqhsts[0] = (         int  )13;
         sqlstm.sqindv[0] = (         void  *)g_ioq_inds.file_name;
         sqlstm.sqinds[0] = (         int  )sizeof(short);
         sqlstm.sqharm[0] = (unsigned int  )0;
         sqlstm.sqharc[0] = (unsigned int   *)0;
         sqlstm.sqadto[0] = (unsigned short )0;
         sqlstm.sqtdso[0] = (unsigned short )0;
         sqlstm.sqhstv[1] = (         void  *)g_ioq_recs.recv_ts;
         sqlstm.sqhstl[1] = (unsigned int  )15;
         sqlstm.sqhsts[1] = (         int  )15;
         sqlstm.sqindv[1] = (         void  *)g_ioq_inds.recv_ts;
         sqlstm.sqinds[1] = (         int  )sizeof(short);
         sqlstm.sqharm[1] = (unsigned int  )0;
         sqlstm.sqharc[1] = (unsigned int   *)0;
         sqlstm.sqadto[1] = (unsigned short )0;
         sqlstm.sqtdso[1] = (unsigned short )0;
         sqlstm.sqhstv[2] = (         void  *)g_ioq_recs.fi_rt;
         sqlstm.sqhstl[2] = (unsigned int  )10;
         sqlstm.sqhsts[2] = (         int  )10;
         sqlstm.sqindv[2] = (         void  *)g_ioq_inds.fi_rt;
         sqlstm.sqinds[2] = (         int  )sizeof(short);
         sqlstm.sqharm[2] = (unsigned int  )0;
         sqlstm.sqharc[2] = (unsigned int   *)0;
         sqlstm.sqadto[2] = (unsigned short )0;
         sqlstm.sqtdso[2] = (unsigned short )0;
         sqlstm.sqhstv[3] = (         void  *)g_ioq_recs.type;
         sqlstm.sqhstl[3] = (unsigned int  )4;
         sqlstm.sqhsts[3] = (         int  )4;
         sqlstm.sqindv[3] = (         void  *)g_ioq_inds.type;
         sqlstm.sqinds[3] = (         int  )sizeof(short);
         sqlstm.sqharm[3] = (unsigned int  )0;
         sqlstm.sqharc[3] = (unsigned int   *)0;
         sqlstm.sqadto[3] = (unsigned short )0;
         sqlstm.sqtdso[3] = (unsigned short )0;
         sqlstm.sqphsv = sqlstm.sqhstv;
         sqlstm.sqphsl = sqlstm.sqhstl;
         sqlstm.sqphss = sqlstm.sqhsts;
         sqlstm.sqpind = sqlstm.sqindv;
         sqlstm.sqpins = sqlstm.sqinds;
         sqlstm.sqparm = sqlstm.sqharm;
         sqlstm.sqparc = sqlstm.sqharc;
         sqlstm.sqpadto = sqlstm.sqadto;
         sqlstm.sqptdso = sqlstm.sqtdso;
         sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   }  

   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      /* Fetch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "IOQ_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);   
      paint_task_line(0, "Fetch ioq_cursor failed in ck_file_sch()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* EXEC SQL CLOSE ioq_cursor; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 4;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )82;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

   /* closes cursor */

   errcode = sqlca.sqlcode;

   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "IOQ_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"CLOSE CURSOR ioq_cursor failed in ck_file_sch()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   
   /* Identify files that are now in their "Late Grace" period,               */
   /* update their at_risk_yn = 'Y' and send a msg to the fi.                 */
   
   file_sch_ck_at_risk();
   
} /* end ck_file_sch() */


/************************ input_file *******************************************
* Description:                                                                 *
*     Attempts to ID the file in ioq buffer and then sees if the file is       *
* scheduled (expected now).  If so, then it submits an ACHINPUT job.           *
*                                                                              *
* Creation Date:  06/25/1996  By: Troy Clark                                   *
* Modified Date:  07/08/1996  By: George Lin                                   *
* Modified Date:  11/04/1996  By: Dan Jung                                     *
* Modified Date:  10/22/1997  By: Darcy Sivertson                              *
*  Description of modification: Attempts to ID the file in ioq buffer as a     *
*  non_nacha file                                                              *
*******************************************************************************/
void input_file(int ioq_no)
{
   int      identified_nacha_file=0;      /* temp var */
   int      identified_nonnacha_file=0;   /*temp var */
   int      wRecSize;            /* var for record size */
   char     strFName[13];        /* var for file name */
   char     ynRejected;          /* var for file rejected yes or no */
   char     strRecvTS[15];       /* var for file received time stamp */
   double   dwFileSchId;         /* var for file sch id */
   FILE     *filePtr;            /* temp var for file pointer */
   char     errstr[300];         /* error string */
   char     rec_one[95];         /* used to store the file header (record 1) */
   char     msg_text[396];       /* actual message text to post */
   char     tmp_str[350];        /* temporary string */

   char  connect_yn[15];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  fi_rt[17];
   char  file_name_str[300];
   char  file_name[80];
   int   ok_to_submit = 1;
   char  delivery_path[129];
   char  nacha_path[129];
   char  nonnacha_path[129];
   char  command_string[512];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;

   /* EXEC SQL BEGIN DECLARE SECTION; */ 

      char     strRT[10];           /* var for fi rt string */
      double   dwFileId;         /* var for file id */
      char     root_path[129];
      char     input_path[129];
   /* EXEC SQL END DECLARE SECTION; */ 


   /* strFName represents --> g_ioq_recs.file_name[ioq_no]                    */
   /*       and                                                               */
   /* strRT  represents --> g_ioq_recs.fi_rt[ioq_no]                          */

   strcpy(strFName, g_ioq_recs.file_name[ioq_no]); 
   strcpy(strRT,    g_ioq_recs.fi_rt[ioq_no]);     
   strcpy(strRecvTS,g_ioq_recs.recv_ts[ioq_no]);   

   /* set ioq status to "Achinput In-process" */
   if (ioq_set_status(strFName, strRT, "AI") == ERR) 
   {
      paint_task_line(1, "Set ioq status to AI failed in input_file()!");
      do_exit(1);
   }
   
   /* find the path of the input file */
   /* EXEC SQL SELECT upper(js_root_path), upper(input_path)
   INTO :root_path, :input_path
   FROM sys_info 
   WHERE fi_rt = :g_ioq_recs.fi_rt[ioq_no]; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 4;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select upper(js_root_path) ,upper(input_path) into :b0,:b1\
  from sys_info where fi_rt=:b2";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )97;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)root_path;
   sqlstm.sqhstl[0] = (unsigned int  )129;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)input_path;
   sqlstm.sqhstl[1] = (unsigned int  )129;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)(g_ioq_recs.fi_rt)[ioq_no];
   sqlstm.sqhstl[2] = (unsigned int  )10;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_ioq_recs.fi_rt[ioq_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(js_root_path, input_path FROM) SYS_INFO",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select sys_info failed in input_file()! ");
      do_exit(1);
   }

/* Determine if slashes need to be added, and build file name */
   trimlr(root_path);
   trimlr(input_path);

   if (input_path[0] != '\\')
   {
      if (root_path[strlen(root_path) - 1] != '\\')
         strcat(root_path,"\\");
   }
   else
   {
      if (root_path[strlen(root_path) - 1] == '\\')
      {
         root_path[strlen(root_path) - 1] = '\0';
      }
   }

   if (input_path[strlen(input_path) - 1] == '\\')
   {
      input_path[strlen(root_path) - 1] = '\0';
   }

   upch(g_ioq_recs.type[ioq_no]);

   memset(delivery_path, 0, 129);
   memset(nacha_path, 0, 129);
   memset(nonnacha_path, 0, 129);
   memset(command_string, 0, 512);

   copy_cat(delivery_path, root_path, "DELIVERY",NULL);
   copy_cat(nacha_path, root_path, input_path, NULL);
   copy_cat(nonnacha_path, root_path, input_path, "\\", "NONNACHA", NULL);

   trimlr(delivery_path);
   trimlr(nacha_path);
   trimlr(nonnacha_path);

   copy_cat(file_name_str, root_path, input_path, "\\", strFName, NULL);

   dwFileId = 0;
   dwFileSchId = 0;

   /* Open strFName as filePtr */
   filePtr = fopen(file_name_str, "r");

   if (filePtr == NULL)
   {
      gpszIFSMsg = ifs_fatal("FILEOPENR", 
                              __FILE__, (DWORD)__LINE__, IFS_LOG,
                              file_name_str, 
                              _itoa(_doserrno, gs_scratch, 10), 
                              NULL);
      paint_task_line(0, "Fopen failed in input_file()!");
      do_exit(1);
   }
   
   /* try to identify the input file as NON_NACHA*/ 
   identified_nonnacha_file = id_nonnacha_file(filePtr, file_name_str); 

   /* NOTE: id_input_file() sets dwFileID=0 if the file is not idd  */
   if (fclose(filePtr) != OK)   /* close filePtr */
   {
      gpszIFSMsg = ifs_fatal("FILECLOSE", 
                              __FILE__,(DWORD)__LINE__,IFS_LOG,
                              file_name_str, 
                              _itoa(_doserrno, gs_scratch, 10), 
                              NULL);
      paint_task_line(0, "Fclose failed in input_file()!");
      do_exit(1);
   }
   
   if (identified_nonnacha_file == 0) /* file unidentified as a NON-NACHA file*/
   {  
      /* try to identify the input file as NACHA*/    

      filePtr = fopen(file_name_str, "r");

      if (filePtr == NULL)
      {  
         gpszIFSMsg = ifs_fatal("FILEOPENR", 
                                 __FILE__,(DWORD)__LINE__, IFS_LOG,
                                 file_name_str, 
                                 _itoa(_doserrno, gs_scratch, 10), 
                                 NULL);
         paint_task_line(0, "Fopen failed in input_file()!");
         do_exit(1);
      }

      identified_nacha_file = 
      id_input_file(rec_one, strRT, filePtr, file_name_str, &dwFileId, &ynRejected, &wRecSize);

      if (fclose(filePtr) != OK)   /* close filePtr */
      {
         gpszIFSMsg = ifs_fatal("FILECLOSE", 
                                 __FILE__, (DWORD)__LINE__,IFS_LOG,
                                 file_name_str, 
                                 _itoa(_doserrno, gs_scratch, 10), 
                                 NULL);
         paint_task_line(0, "Fclose failed in input_file()!");
         do_exit(1);
      }

      if (!identified_nacha_file) /* file unidentified as NACHA file */
      {
		  //Error message format changed - R120054493-Non NACHA Errors ability to drill
         copy_cat(tmp_str, "<FILENAME-",strFName,">"," The file received could not be identified as a NACHA or a Non-Nacha input file",NULL);
         paint_proc_info(tmp_str);
         paint_proc_info(blank_line);
         if (!post_msg_risk(strRT, NULL, 'E', tmp_str, "OT", -1, -1, -1, -1, -1,4))
         {
            copy_cat(g_fi_info, "FI: ", g_ioq_recs.fi_rt[ioq_no], NULL);
            gpszIFSMsg = ifs_fatal("AOS_WRITE_MSG",
                                    __FILE__, (DWORD) __LINE__, IFS_LOG,
                                    "-1", "E", tmp_str, "OT", "-1", "-1", "-1",
                                    g_fi_info,
                                    NULL);
            paint_task_line(0, "Post_msg_risk failed in input_file()!");
            do_exit(1);
         }

         /* Set files io_queue status to completed */
         if (ioq_set_status (strFName, strRT, "AC") == ERR)
         {
            paint_task_line(0, "Ioq_set_status failed in input_file()!");
            do_exit(1);
         }
         return;
      }
      else  /*file Identified as NACHA file*/
      {
         if (strcmp(g_ioq_recs.type[ioq_no], "ACH") == 0)
         {
            if (ynRejected == 'Y')  /* file set to rejected for special header */
            {  
            /* Set files io_queue status to completed */
               if (ioq_set_status (strFName, strRT, "AC") == ERR)
               {
                  paint_task_line(0, "ioq_set_status failed in input_file()!");
                  do_exit(1);
               }
      
               /*  Send a "File Rejected for Special Header" message to the FI   */
               copy_cat(tmp_str, "File ", file_name_str, " Rejected for Special Header", NULL);
               paint_proc_info(tmp_str);
               paint_proc_info(blank_line);
			   //Error message format changed - R120054493-Non NACHA Errors ability to drill
               copy_cat(msg_text, "<FILENAME-",strFName,">"," ",rec_one, "File Rejected for Special Header", NULL);
               if (!post_msg_risk(strRT, NULL, 'E', msg_text, "OT", -1, -1, -1, -1, -1,4))
               {
                  copy_cat(g_fi_info, "FI: ", g_ioq_recs.fi_rt[ioq_no], NULL);
                  gpszIFSMsg = ifs_fatal("AOS_WRITE_MSG",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "-1", "E", tmp_str, "OT", "-1", "-1", "-1",
                                       g_fi_info,
                                       NULL);
                  paint_task_line(0, "Post_msg_risk failed in input_file()!");
                  do_exit(1);
               }
               return;
            }
         }
         else
         {
            ok_to_submit = 0;
            // Add code to copy the file to the correct directory
            copy_cat(command_string, "copy ", nacha_path, "\\", strFName, " ", delivery_path, "> nul", NULL);
            if (system(command_string) != 0)
            {
               paint_task_line(0, "Copy of Nacha File failed in input_file()!");
               return;
            }

            /* EXEC SQL
               UPDATE   ioq
               SET      type = 'ACH', status = 'AC'
               WHERE    fi_rt = :g_ioq_recs.fi_rt[ioq_no]
               AND      file_name = :g_ioq_recs.file_name[ioq_no]; */ 

{
            struct sqlexd sqlstm;
            sqlstm.sqlvsn = 13;
            sqlstm.arrsiz = 4;
            sqlstm.sqladtp = &sqladt;
            sqlstm.sqltdsp = &sqltds;
            sqlstm.stmt = "update ioq  set type='ACH',status='AC' where (fi_\
rt=:b0 and file_name=:b1)";
            sqlstm.iters = (unsigned int  )1;
            sqlstm.offset = (unsigned int  )124;
            sqlstm.cud = sqlcud0;
            sqlstm.sqlest = (unsigned char  *)&sqlca;
            sqlstm.sqlety = (unsigned short)4352;
            sqlstm.occurs = (unsigned int  )0;
            sqlstm.sqhstv[0] = (         void  *)(g_ioq_recs.fi_rt)[ioq_no];
            sqlstm.sqhstl[0] = (unsigned int  )10;
            sqlstm.sqhsts[0] = (         int  )0;
            sqlstm.sqindv[0] = (         void  *)0;
            sqlstm.sqinds[0] = (         int  )0;
            sqlstm.sqharm[0] = (unsigned int  )0;
            sqlstm.sqadto[0] = (unsigned short )0;
            sqlstm.sqtdso[0] = (unsigned short )0;
            sqlstm.sqhstv[1] = (         void  *)(g_ioq_recs.file_name)[ioq_no];
            sqlstm.sqhstl[1] = (unsigned int  )13;
            sqlstm.sqhsts[1] = (         int  )0;
            sqlstm.sqindv[1] = (         void  *)0;
            sqlstm.sqinds[1] = (         int  )0;
            sqlstm.sqharm[1] = (unsigned int  )0;
            sqlstm.sqadto[1] = (unsigned short )0;
            sqlstm.sqtdso[1] = (unsigned short )0;
            sqlstm.sqphsv = sqlstm.sqhstv;
            sqlstm.sqphsl = sqlstm.sqhstl;
            sqlstm.sqphss = sqlstm.sqhsts;
            sqlstm.sqpind = sqlstm.sqindv;
            sqlstm.sqpins = sqlstm.sqinds;
            sqlstm.sqparm = sqlstm.sqharm;
            sqlstm.sqparc = sqlstm.sqharc;
            sqlstm.sqpadto = sqlstm.sqadto;
            sqlstm.sqptdso = sqlstm.sqtdso;
            sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



            if (sqlca.sqlcode == ORCL_NO_ERROR)
            {  /* if update successful */
               /* EXEC SQL COMMIT WORK; */ 

{
               struct sqlexd sqlstm;
               sqlstm.sqlvsn = 13;
               sqlstm.arrsiz = 4;
               sqlstm.sqladtp = &sqladt;
               sqlstm.sqltdsp = &sqltds;
               sqlstm.iters = (unsigned int  )1;
               sqlstm.offset = (unsigned int  )147;
               sqlstm.cud = sqlcud0;
               sqlstm.sqlest = (unsigned char  *)&sqlca;
               sqlstm.sqlety = (unsigned short)4352;
               sqlstm.occurs = (unsigned int  )0;
               sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


               if (sqlca.sqlcode != ORCL_NO_ERROR)
               {
                  sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
                  g_orcl_etext_buf[g_orcl_etext_len] = '\0';
                  copy_cat(g_fi_info, "FI: ", strRT, NULL);
                  ifs_fatal("ORC_COMMIT",
                              __FILE__, (DWORD)__LINE__, IFS_LOG,
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
                  paint_task_line(0, "Unable to Commit Changes");
                  exit(1);
               }           /* commit update work */
               return;                    
            }
            else
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", strRT, NULL);
               gpszIFSMsg = ifs_warning("ORC_UPDATE",
                                          __FILE__, (DWORD) __LINE__, IFS_LOG,
                                          "IOQ",
                                          g_orcl_etext_buf,
                                          g_fi_info,
                                          NULL);   /* else */
               return;                 
            }
         }
      }
      
   }
   else
   {
      if (strcmp(g_ioq_recs.type[ioq_no], "ACH") == 0)
      {
         ok_to_submit = 0;

         if (identified_nonnacha_file != -1)
         {
            //copy the Non-Nacha File to the correct directory
            copy_cat(command_string, "copy ", nacha_path, "\\", strFName, " ", nonnacha_path, "> nul", NULL);
            if (system(command_string) != 0)
            {
               paint_task_line(0, "Copy of Non-Nacha File failed in input_file()!");
               return;
            }
            
            /* EXEC SQL
               UPDATE   ioq
               SET      type = 'NNF', status = 'AC'
               WHERE    fi_rt = :g_ioq_recs.fi_rt[ioq_no]
               AND      file_name = :g_ioq_recs.file_name[ioq_no]; */ 

{
            struct sqlexd sqlstm;
            sqlstm.sqlvsn = 13;
            sqlstm.arrsiz = 4;
            sqlstm.sqladtp = &sqladt;
            sqlstm.sqltdsp = &sqltds;
            sqlstm.stmt = "update ioq  set type='NNF',status='AC' where (fi_\
rt=:b0 and file_name=:b1)";
            sqlstm.iters = (unsigned int  )1;
            sqlstm.offset = (unsigned int  )162;
            sqlstm.cud = sqlcud0;
            sqlstm.sqlest = (unsigned char  *)&sqlca;
            sqlstm.sqlety = (unsigned short)4352;
            sqlstm.occurs = (unsigned int  )0;
            sqlstm.sqhstv[0] = (         void  *)(g_ioq_recs.fi_rt)[ioq_no];
            sqlstm.sqhstl[0] = (unsigned int  )10;
            sqlstm.sqhsts[0] = (         int  )0;
            sqlstm.sqindv[0] = (         void  *)0;
            sqlstm.sqinds[0] = (         int  )0;
            sqlstm.sqharm[0] = (unsigned int  )0;
            sqlstm.sqadto[0] = (unsigned short )0;
            sqlstm.sqtdso[0] = (unsigned short )0;
            sqlstm.sqhstv[1] = (         void  *)(g_ioq_recs.file_name)[ioq_no];
            sqlstm.sqhstl[1] = (unsigned int  )13;
            sqlstm.sqhsts[1] = (         int  )0;
            sqlstm.sqindv[1] = (         void  *)0;
            sqlstm.sqinds[1] = (         int  )0;
            sqlstm.sqharm[1] = (unsigned int  )0;
            sqlstm.sqadto[1] = (unsigned short )0;
            sqlstm.sqtdso[1] = (unsigned short )0;
            sqlstm.sqphsv = sqlstm.sqhstv;
            sqlstm.sqphsl = sqlstm.sqhstl;
            sqlstm.sqphss = sqlstm.sqhsts;
            sqlstm.sqpind = sqlstm.sqindv;
            sqlstm.sqpins = sqlstm.sqinds;
            sqlstm.sqparm = sqlstm.sqharm;
            sqlstm.sqparc = sqlstm.sqharc;
            sqlstm.sqpadto = sqlstm.sqadto;
            sqlstm.sqptdso = sqlstm.sqtdso;
            sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


         }
         else
         {
			 //Error message format changed - R120054493-Non NACHA Errors ability to drill
            copy_cat(tmp_str,"<FILENAME-",strFName,">"," File ", "cannot be identified because it is Empty or is locked by another process.", NULL);
            paint_proc_info(tmp_str);
            paint_proc_info(blank_line);
            
            strcpy(msg_text, tmp_str);
                        
            if (!post_msg_risk(strRT, NULL, 'E', msg_text, "OT", -1, -1, -1, -1, -1,4))
            {
               copy_cat(g_fi_info, "FI: ", g_ioq_recs.fi_rt[ioq_no], NULL);
               gpszIFSMsg = ifs_fatal("AOS_WRITE_MSG",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "-1", "E", tmp_str, "OT", "-1", "-1", "-1",
                                       g_fi_info,
                                       NULL);
               paint_task_line(0, "Post_msg_risk failed in input_file()!");
               do_exit(1);
            }

            // Write Empty File message to Message Table.
            /* EXEC SQL
               UPDATE   ioq
               SET      status = 'AC'
               WHERE    fi_rt = :g_ioq_recs.fi_rt[ioq_no]
               AND      file_name = :g_ioq_recs.file_name[ioq_no]; */ 

{
            struct sqlexd sqlstm;
            sqlstm.sqlvsn = 13;
            sqlstm.arrsiz = 4;
            sqlstm.sqladtp = &sqladt;
            sqlstm.sqltdsp = &sqltds;
            sqlstm.stmt = "update ioq  set status='AC' where (fi_rt=:b0 and \
file_name=:b1)";
            sqlstm.iters = (unsigned int  )1;
            sqlstm.offset = (unsigned int  )185;
            sqlstm.cud = sqlcud0;
            sqlstm.sqlest = (unsigned char  *)&sqlca;
            sqlstm.sqlety = (unsigned short)4352;
            sqlstm.occurs = (unsigned int  )0;
            sqlstm.sqhstv[0] = (         void  *)(g_ioq_recs.fi_rt)[ioq_no];
            sqlstm.sqhstl[0] = (unsigned int  )10;
            sqlstm.sqhsts[0] = (         int  )0;
            sqlstm.sqindv[0] = (         void  *)0;
            sqlstm.sqinds[0] = (         int  )0;
            sqlstm.sqharm[0] = (unsigned int  )0;
            sqlstm.sqadto[0] = (unsigned short )0;
            sqlstm.sqtdso[0] = (unsigned short )0;
            sqlstm.sqhstv[1] = (         void  *)(g_ioq_recs.file_name)[ioq_no];
            sqlstm.sqhstl[1] = (unsigned int  )13;
            sqlstm.sqhsts[1] = (         int  )0;
            sqlstm.sqindv[1] = (         void  *)0;
            sqlstm.sqinds[1] = (         int  )0;
            sqlstm.sqharm[1] = (unsigned int  )0;
            sqlstm.sqadto[1] = (unsigned short )0;
            sqlstm.sqtdso[1] = (unsigned short )0;
            sqlstm.sqphsv = sqlstm.sqhstv;
            sqlstm.sqphsl = sqlstm.sqhstl;
            sqlstm.sqphss = sqlstm.sqhsts;
            sqlstm.sqpind = sqlstm.sqindv;
            sqlstm.sqpins = sqlstm.sqinds;
            sqlstm.sqparm = sqlstm.sqharm;
            sqlstm.sqparc = sqlstm.sqharc;
            sqlstm.sqpadto = sqlstm.sqadto;
            sqlstm.sqptdso = sqlstm.sqtdso;
            sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


         }

         if (sqlca.sqlcode == ORCL_NO_ERROR)
         {  /* if update successful */
            /* EXEC SQL COMMIT WORK; */ 

{
            struct sqlexd sqlstm;
            sqlstm.sqlvsn = 13;
            sqlstm.arrsiz = 4;
            sqlstm.sqladtp = &sqladt;
            sqlstm.sqltdsp = &sqltds;
            sqlstm.iters = (unsigned int  )1;
            sqlstm.offset = (unsigned int  )208;
            sqlstm.cud = sqlcud0;
            sqlstm.sqlest = (unsigned char  *)&sqlca;
            sqlstm.sqlety = (unsigned short)4352;
            sqlstm.occurs = (unsigned int  )0;
            sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


            if (sqlca.sqlcode != ORCL_NO_ERROR)
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", strRT, NULL);
               ifs_fatal("ORC_COMMIT",
                           __FILE__, (DWORD)__LINE__, IFS_LOG,
                           g_orcl_etext_buf,
                           g_fi_info,
                           NULL);
               paint_task_line(0, "Unable to Commit Changes");
               exit(1);
            }           /* commit update work */
            return;                 
         }
         else
         {
            sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
            g_orcl_etext_buf[g_orcl_etext_len] = '\0';
            copy_cat(g_fi_info, "FI: ", strRT, NULL);
            gpszIFSMsg = ifs_warning("ORC_UPDATE",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "IOQ",
                                       g_orcl_etext_buf,
                                       g_fi_info,
                                       NULL);   /* else */
            return;                 
         }
      }
      else
      {
         if (identified_nonnacha_file == -1)
         {
			 //Error message format changed - R120054493-Non NACHA Errors ability to drill
            copy_cat(tmp_str,"<FILENAME-",strFName,">"," File ", "cannot be identified because it is Empty or is locked by another process.", NULL);
            paint_proc_info(tmp_str);
            paint_proc_info(blank_line);
            
            strcpy(msg_text, tmp_str);
                        
            if (!post_msg_risk(strRT, NULL, 'E', msg_text, "OT", -1, -1, -1, -1, -1,4))
            {
               copy_cat(g_fi_info, "FI: ", g_ioq_recs.fi_rt[ioq_no], NULL);
               gpszIFSMsg = ifs_fatal("AOS_WRITE_MSG",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "-1", "E", tmp_str, "OT", "-1", "-1", "-1",
                                       g_fi_info,
                                       NULL);
               paint_task_line(0, "Post_msg_risk failed in input_file()!");
               do_exit(1);
            }

            ok_to_submit = 0;
         }
      }
   }

   if (ok_to_submit)
   {
      if (strcmp(g_ioq_recs.type[ioq_no], "ACH") == 0)
      {
         if ( !file_sch_hit(strRT, dwFileId, &dwFileSchId) ) 
         {

         }
         else
            dwFileSchId = 0L;       
            /* tells achinput to HOLD THE FILE for a sched violation */
      }

      /* Identified as NACHA file, ORIGFILE.JOB submitted with appropriate parameters, 
      IOQ Status Changed*/
      if (identified_nacha_file)
      {
         copy_cat(file_name, "%FILE%=", strFName, NULL);
         copy_cat(fi_rt, "%FI_RT%=", strRT, NULL);
         copy_cat(job_file, job_path, "\\ORIGFILE.JOB", NULL);
         strcpy(connect_yn, "DBCONNECT=N");

         /* Set files io_queue status to in process */
         if (ioq_set_status(strFName, strRT, "AI") == ERR)
         {
            paint_task_line(0, "ioq_set_status failed in input_file()!");
            do_exit(1);
         }

         /* submit achinput job */
 	     memset(parm, 0, sizeof(parm));
		 memset(arg, 0, sizeof(arg));
         memset(errstr, 0, sizeof(errstr));

	     strcpy(parm[0], connect_yn);	arguments++;
         strcpy(parm[1], fi_rt);		arguments++;
         strcpy(parm[2], file_name);	arguments++;

		 for(n = 0; n<arguments; n++)
			arg[n] = parm[n];

         if (submit_job(strRT, job_file, errstr, arg, arguments) == ERR)
         {
            copy_cat(g_fi_info, "FI: ", strRT, NULL);
            copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
            gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                                    __FILE__, (DWORD) __LINE__, IFS_LOG,
                                    submit_errfilestr,
                                    g_fi_info,
                                    NULL);
            paint_task_line(1, "sql_jcsubmit error in input_file()!");
            do_exit(1);
         }
   
         copy_cat(msg_text,
                  "ORIGFILE.JOB for FI=",
                  strRT,
                  " was submitted at ",
                  g_prn_time,
                  " on ",
                  g_prn_dt,
                  NULL);
         paint_proc_info(msg_text);
         paint_proc_info(blank_line);
      }

      /* Identified as NON-NACHA file, NACHACNV job submitted with            */
      /* appropriate parameters, IOQ Status Changed                           */
      if (identified_nonnacha_file)
      {
         copy_cat(file_name, "%FILE%=", strFName, NULL);
         copy_cat(fi_rt, "%FI_RT%=", strRT, NULL);          
         copy_cat(job_file, job_path, "\\NACHACNV.JOB", NULL);
         strcpy(connect_yn, "DBCONNECT=N");

         /* Set files io_queue status to In Process */
         if (ioq_set_status(strFName, strRT, "AI") == ERR) 
         {
            paint_task_line(0, "ioq_set_status failed in input_file()!");
            do_exit(1);
         }

         /* submit NACHACNV job */
	     memset(parm, 0, sizeof(parm));
		 memset(arg, 0, sizeof(arg));
	     memset(errstr, 0, sizeof(errstr));

	     strcpy(parm[0], connect_yn);	arguments++;
         strcpy(parm[1], fi_rt);		arguments++;
         strcpy(parm[2], file_name);	arguments++;

		 for(n = 0; n<arguments; n++)
			arg[n] = parm[n];

         if (submit_job(strRT, job_file, errstr, arg, arguments) == ERR)
         {
            copy_cat(g_fi_info, "FI: ", strRT, NULL);
            copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
            gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                                    __FILE__, (DWORD) __LINE__, IFS_LOG,
                                    submit_errfilestr,
                                    g_fi_info,
                                    NULL);
            paint_task_line(1, "sql_jcsubmit error in input_file()!");
            do_exit(1);
         }
   
         copy_cat(msg_text,
                  "NACHACNV.JOB for FI=",
                  strRT,
                  " was submitted at ",
                  g_prn_time,
                  " on ", 
                  g_prn_dt,
                  NULL);
      
         paint_proc_info(msg_text);
         paint_proc_info(blank_line);
      }
   }
   else
   {
      /* Set files io_queue status to File Processed */
      if (ioq_set_status(strFName, strRT, "AC") == ERR) 
      {
         paint_task_line(0, "ioq_set_status failed in input_file()!");
         do_exit(1);
      }
   }

   return;
/* There was an unmatched brace here!  See 'FIX FOR UNMATCHED BRACE' above.   */
} /* end input_file() */

/********************* ioq_set_status ******************************************
* Description:                                                                 *
*     Sets the ioq record's status = status_str.                               *
*                                                                              *
* Creation Date:  06/24/1996  By: Troy Clark                                   *
* Modified Date:  07/03/1996  By: George Lin                                   *
*******************************************************************************/
/* NOTE: ioq_set_status() needs to be put in ACHOSPRD.LIB once tested.        */
int ioq_set_status(char *file_name, char *fi_rt, char *status_str)
{
   /* EXEC SQL BEGIN DECLARE SECTION; */ 
 /* declare host variable */
      char  h_file_name[13];     /* file name */
      char  h_fi_rt[10];         /* fi rt */
      char  h_status_str[3];     /* status */
   /* EXEC SQL END DECLARE SECTION; */ 


   strcpy(h_file_name, file_name);  /* copy argument to host variable */
   strcpy(h_fi_rt, fi_rt);
   strcpy(h_status_str, status_str);

   /* update ioq set status to status_str */
   /* EXEC SQL
      UPDATE   ioq
      SET      status = :h_status_str 
      WHERE    file_name = :h_file_name
      AND      fi_rt = :h_fi_rt; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 4;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "update ioq  set status=:b0 where (file_name=:b1 and fi_rt=\
:b2)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )223;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)h_status_str;
   sqlstm.sqhstl[0] = (unsigned int  )3;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)h_file_name;
   sqlstm.sqhstl[1] = (unsigned int  )13;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)h_fi_rt;
   sqlstm.sqhstl[2] = (unsigned int  )10;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode == ORCL_NO_ERROR)
   {  /* if update successful */
      /* EXEC SQL COMMIT WORK; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 4;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )250;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
         ifs_fatal("ORC_COMMIT",
                     __FILE__, (DWORD)__LINE__, IFS_LOG,
                     g_orcl_etext_buf,
                     g_fi_info,
                     NULL);
         paint_task_line(0, "Unable to Commit Changes");
         exit(1);
      }           /* commit update work */
      return (0);    /* return SUCCESS */
   }
   else
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
      gpszIFSMsg = ifs_warning("ORC_UPDATE",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "IOQ",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);                           
      return (ERR);  /* return ERROR */
   }
} /* end ioq_set_status() */


/******************* file_sch_set_status ***************************************
* Description:                                                                 *
*     Set the file_sch records status to value of the char new_status;  if     *
* proc_status gets set to IN_PROCESS, it must also set the at_risk_yn to 'N'.  *
*                                                                              *
* Creation Date:  06/24/1996  By: Troy Clark                                   *
* Modified Date:  07/05/1996  By: George Lin                                   *
*******************************************************************************/
int file_sch_set_status(char *fi_rt, double fsch_id, char new_status)
{
   /* EXEC SQL BEGIN DECLARE SECTION; */ 

      char  h_fi_rt[10];         /* fi rt */
      double h_fsch_id;       /* sch id */
      char  h_new_status;        /* new status */
   /* EXEC SQL END DECLARE SECTION; */ 


   strcpy(h_fi_rt, fi_rt);
   h_new_status = new_status;
   h_fsch_id = fsch_id;

   /* Update the file_sch records proc_status to new_status                   */
   /* Return SUCCESS or ERROR...                                              */

   if (h_new_status == 'Y')
   {
      /* EXEC SQL
         UPDATE   file_sch
         SET      proc_status = 'Y',
                  at_risk_yn  = 'N' 
         WHERE    fi_rt = :h_fi_rt
         AND      file_sch_id = :h_fsch_id; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 4;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.stmt = "update file_sch  set proc_status='Y',at_risk_yn='N' whe\
re (fi_rt=:b0 and file_sch_id=:b1)";
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )265;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlstm.sqhstv[0] = (         void  *)h_fi_rt;
      sqlstm.sqhstl[0] = (unsigned int  )10;
      sqlstm.sqhsts[0] = (         int  )0;
      sqlstm.sqindv[0] = (         void  *)0;
      sqlstm.sqinds[0] = (         int  )0;
      sqlstm.sqharm[0] = (unsigned int  )0;
      sqlstm.sqadto[0] = (unsigned short )0;
      sqlstm.sqtdso[0] = (unsigned short )0;
      sqlstm.sqhstv[1] = (         void  *)&h_fsch_id;
      sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
      sqlstm.sqhsts[1] = (         int  )0;
      sqlstm.sqindv[1] = (         void  *)0;
      sqlstm.sqinds[1] = (         int  )0;
      sqlstm.sqharm[1] = (unsigned int  )0;
      sqlstm.sqadto[1] = (unsigned short )0;
      sqlstm.sqtdso[1] = (unsigned short )0;
      sqlstm.sqphsv = sqlstm.sqhstv;
      sqlstm.sqphsl = sqlstm.sqhstl;
      sqlstm.sqphss = sqlstm.sqhsts;
      sqlstm.sqpind = sqlstm.sqindv;
      sqlstm.sqpins = sqlstm.sqinds;
      sqlstm.sqparm = sqlstm.sqharm;
      sqlstm.sqparc = sqlstm.sqharc;
      sqlstm.sqpadto = sqlstm.sqadto;
      sqlstm.sqptdso = sqlstm.sqtdso;
      sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   }
   else
   {
    /* EXEC SQL
       UPDATE  file_sch
       SET     proc_status = :h_new_status
       WHERE   fi_rt = :h_fi_rt
       AND     file_sch_id = :h_fsch_id; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 4;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.stmt = "update file_sch  set proc_status=:b0 where (fi_rt=:b1 and\
 file_sch_id=:b2)";
    sqlstm.iters = (unsigned