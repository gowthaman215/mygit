                                                         *
***************************************************************/
int is_group_finished(int i, char *save_key)
{
   short int status=0;
   short int first_time=1;
   char szbuff[300];
   //short int tries;
   int l_sqlcode;
   char szret[10];
   char sznum[20];
   char sqlmsg[80];

 
   	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		short int cntr;
		//char d_cmplt;
		unsigned long step_no;		/* Unique Job Number */
		short int step_step_no;     /* Job Step number */
		char step_s_name[10];	
	    char d_step[9];
	/* EXEC SQL END DECLARE SECTION; */ 

  

	//Catch the exception. DRQ 2003 -077 Baskar/Veera
	try
	{

   	EnterCriticalSection(&jsnt_sql_lock);

	/* EXEC SQL DECLARE grp_stepq_curs CURSOR FOR 
	SELECT 
		no,
		step,
		s_name,
		status,
		j_name,
		date_time_started,
		date_time_completed,
		exit_code,
		command_line,
		num_d,
		d_step,
		d_cmplt,
		d_last_tested,
		num_a,
		exit_codes_acceptable,
		job_machine,
		d_group,
		group_name,
		same_machine_flag_yn,
		group_first_step_yn,
		skip_yn,
		beg_console_msg,
		beg_suspend_yn,
		end_console_msg,
		end_suspend_yn,
		send_msg,
		run_if_error,
		status_interval
	FROM
		stepq
	WHERE no = :step_q.no
	//AND d_step >= :step_q.d_step;
	AND group_name >= :d_step; */ 



	//Group Name that the current step is dependent on
	memset(d_step, 0, 9);
	strncpy(d_step, step_q.d_step + (i*9), 8);
	trimr(d_step);


	// Open grp_stepq_curs cursor
	/* EXEC SQL OPEN grp_stepq_curs; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 16;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = sq0071;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )1858;
 sqlstm.selerr = (unsigned short)0;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqcmod = (unsigned int )0;
 sqlstm.sqhstv[0] = (         void  *)&(step_q.no);
 sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)d_step;
 sqlstm.sqhstl[1] = (unsigned int  )9;
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);


	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"grp_stepq_curs", sqlmsg, "STEPQ table", NULL);
		_ltoa((DWORD) __LINE__, sznum, 10);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Open Cursor for grp_stepq_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=",
					szret, " ", sqlmsg, NULL);
		logit (0, szbuff);
		debug_log (szbuff);
		return(-1);
	}

	// Select using step_q.no and step_q.d_step
	memset(&stepq_sql, 0, sizeof(stepq_sql) );
	memset(&stepq_sql_ind, 0, sizeof(stepq_sql_ind) );

	EnterCriticalSection(&jsnt_sql_lock);

	/* EXEC SQL FETCH grp_stepq_curs INTO :stepq_sql:stepq_sql_ind; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 28;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )1881;
 sqlstm.selerr = (unsigned short)0;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqfoff = (           int )0;
 sqlstm.sqfmod = (unsigned int )2;
 sqlstm.sqhstv[0] = (         void  *)&stepq_sql.no;
 sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)&stepq_sql_ind.no;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)&stepq_sql.step;
 sqlstm.sqhstl[1] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)&stepq_sql_ind.step;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqhstv[2] = (         void  *)stepq_sql.s_name;
 sqlstm.sqhstl[2] = (unsigned int  )10;
 sqlstm.sqhsts[2] = (         int  )0;
 sqlstm.sqindv[2] = (         void  *)&stepq_sql_ind.s_name;
 sqlstm.sqinds[2] = (         int  )0;
 sqlstm.sqharm[2] = (unsigned int  )0;
 sqlstm.sqadto[2] = (unsigned short )0;
 sqlstm.sqtdso[2] = (unsigned short )0;
 sqlstm.sqhstv[3] = (         void  *)stepq_sql.status;
 sqlstm.sqhstl[3] = (unsigned int  )2;
 sqlstm.sqhsts[3] = (         int  )0;
 sqlstm.sqindv[3] = (         void  *)&stepq_sql_ind.status;
 sqlstm.sqinds[3] = (         int  )0;
 sqlstm.sqharm[3] = (unsigned int  )0;
 sqlstm.sqadto[3] = (unsigned short )0;
 sqlstm.sqtdso[3] = (unsigned short )0;
 sqlstm.sqhstv[4] = (         void  *)stepq_sql.j_name;
 sqlstm.sqhstl[4] = (unsigned int  )10;
 sqlstm.sqhsts[4] = (         int  )0;
 sqlstm.sqindv[4] = (         void  *)&stepq_sql_ind.j_name;
 sqlstm.sqinds[4] = (         int  )0;
 sqlstm.sqharm[4] = (unsigned int  )0;
 sqlstm.sqadto[4] = (unsigned short )0;
 sqlstm.sqtdso[4] = (unsigned short )0;
 sqlstm.sqhstv[5] = (         void  *)stepq_sql.date_time_started;
 sqlstm.sqhstl[5] = (unsigned int  )15;
 sqlstm.sqhsts[5] = (         int  )0;
 sqlstm.sqindv[5] = (         void  *)&stepq_sql_ind.time_started;
 sqlstm.sqinds[5] = (         int  )0;
 sqlstm.sqharm[5] = (unsigned int  )0;
 sqlstm.sqadto[5] = (unsigned short )0;
 sqlstm.sqtdso[5] = (unsigned short )0;
 sqlstm.sqhstv[6] = (         void  *)stepq_sql.date_time_completed;
 sqlstm.sqhstl[6] = (unsigned int  )15;
 sqlstm.sqhsts[6] = (         int  )0;
 sqlstm.sqindv[6] = (         void  *)&stepq_sql_ind.time_completed;
 sqlstm.sqinds[6] = (         int  )0;
 sqlstm.sqharm[6] = (unsigned int  )0;
 sqlstm.sqadto[6] = (unsigned short )0;
 sqlstm.sqtdso[6] = (unsigned short )0;
 sqlstm.sqhstv[7] = (         void  *)&stepq_sql.exit_code;
 sqlstm.sqhstl[7] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[7] = (         int  )0;
 sqlstm.sqindv[7] = (         void  *)&stepq_sql_ind.exit_code;
 sqlstm.sqinds[7] = (         int  )0;
 sqlstm.sqharm[7] = (unsigned int  )0;
 sqlstm.sqadto[7] = (unsigned short )0;
 sqlstm.sqtdso[7] = (unsigned short )0;
 sqlstm.sqhstv[8] = (         void  *)stepq_sql.command_line;
 sqlstm.sqhstl[8] = (unsigned int  )140;
 sqlstm.sqhsts[8] = (         int  )0;
 sqlstm.sqindv[8] = (         void  *)&stepq_sql_ind.command_line;
 sqlstm.sqinds[8] = (         int  )0;
 sqlstm.sqharm[8] = (unsigned int  )0;
 sqlstm.sqadto[8] = (unsigned short )0;
 sqlstm.sqtdso[8] = (unsigned short )0;
 sqlstm.sqhstv[9] = (         void  *)&stepq_sql.num_d;
 sqlstm.sqhstl[9] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[9] = (         int  )0;
 sqlstm.sqindv[9] = (         void  *)&stepq_sql_ind.num_d;
 sqlstm.sqinds[9] = (         int  )0;
 sqlstm.sqharm[9] = (unsigned int  )0;
 sqlstm.sqadto[9] = (unsigned short )0;
 sqlstm.sqtdso[9] = (unsigned short )0;
 sqlstm.sqhstv[10] = (         void  *)stepq_sql.d_step;
 sqlstm.sqhstl[10] = (unsigned int  )180;
 sqlstm.sqhsts[10] = (         int  )0;
 sqlstm.sqindv[10] = (         void  *)&stepq_sql_ind.d_step;
 sqlstm.sqinds[10] = (         int  )0;
 sqlstm.sqharm[10] = (unsigned int  )0;
 sqlstm.sqadto[10] = (unsigned short )0;
 sqlstm.sqtdso[10] = (unsigned short )0;
 sqlstm.sqhstv[11] = (         void  *)stepq_sql.d_cmplt;
 sqlstm.sqhstl[11] = (unsigned int  )20;
 sqlstm.sqhsts[11] = (         int  )0;
 sqlstm.sqindv[11] = (         void  *)&stepq_sql_ind.d_cmplt;
 sqlstm.sqinds[11] = (         int  )0;
 sqlstm.sqharm[11] = (unsigned int  )0;
 sqlstm.sqadto[11] = (unsigned short )0;
 sqlstm.sqtdso[11] = (unsigned short )0;
 sqlstm.sqhstv[12] = (         void  *)stepq_sql.d_last_tested;
 sqlstm.sqhstl[12] = (unsigned int  )200;
 sqlstm.sqhsts[12] = (         int  )0;
 sqlstm.sqindv[12] = (         void  *)&stepq_sql_ind.d_last_tested;
 sqlstm.sqinds[12] = (         int  )0;
 sqlstm.sqharm[12] = (unsigned int  )0;
 sqlstm.sqadto[12] = (unsigned short )0;
 sqlstm.sqtdso[12] = (unsigned short )0;
 sqlstm.sqhstv[13] = (         void  *)&stepq_sql.num_a;
 sqlstm.sqhstl[13] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[13] = (         int  )0;
 sqlstm.sqindv[13] = (         void  *)&stepq_sql_ind.num_a;
 sqlstm.sqinds[13] = (         int  )0;
 sqlstm.sqharm[13] = (unsigned int  )0;
 sqlstm.sqadto[13] = (unsigned short )0;
 sqlstm.sqtdso[13] = (unsigned short )0;
 sqlstm.sqhstv[14] = (         void  *)stepq_sql.exit_codes_acceptable;
 sqlstm.sqhstl[14] = (unsigned int  )100;
 sqlstm.sqhsts[14] = (         int  )0;
 sqlstm.sqindv[14] = (         void  *)&stepq_sql_ind.exit_codes_acceptable;
 sqlstm.sqinds[14] = (         int  )0;
 sqlstm.sqharm[14] = (unsigned int  )0;
 sqlstm.sqadto[14] = (unsigned short )0;
 sqlstm.sqtdso[14] = (unsigned short )0;
 sqlstm.sqhstv[15] = (         void  *)stepq_sql.job_machine;
 sqlstm.sqhstl[15] = (unsigned int  )10;
 sqlstm.sqhsts[15] = (         int  )0;
 sqlstm.sqindv[15] = (         void  *)&stepq_sql_ind.job_machine;
 sqlstm.sqinds[15] = (         int  )0;
 sqlstm.sqharm[15] = (unsigned int  )0;
 sqlstm.sqadto[15] = (unsigned short )0;
 sqlstm.sqtdso[15] = (unsigned short )0;
 sqlstm.sqhstv[16] = (         void  *)stepq_sql.d_group;
 sqlstm.sqhstl[16] = (unsigned int  )21;
 sqlstm.sqhsts[16] = (         int  )0;
 sqlstm.sqindv[16] = (         void  *)&stepq_sql_ind.d_group;
 sqlstm.sqinds[16] = (         int  )0;
 sqlstm.sqharm[16] = (unsigned int  )0;
 sqlstm.sqadto[16] = (unsigned short )0;
 sqlstm.sqtdso[16] = (unsigned short )0;
 sqlstm.sqhstv[17] = (         void  *)stepq_sql.group_name;
 sqlstm.sqhstl[17] = (unsigned int  )10;
 sqlstm.sqhsts[17] = (         int  )0;
 sqlstm.sqindv[17] = (         void  *)&stepq_sql_ind.group_name;
 sqlstm.sqinds[17] = (         int  )0;
 sqlstm.sqharm[17] = (unsigned int  )0;
 sqlstm.sqadto[17] = (unsigned short )0;
 sqlstm.sqtdso[17] = (unsigned short )0;
 sqlstm.sqhstv[18] = (         void  *)stepq_sql.same_machine_flag_yn;
 sqlstm.sqhstl[18] = (unsigned int  )2;
 sqlstm.sqhsts[18] = (         int  )0;
 sqlstm.sqindv[18] = (         void  *)&stepq_sql_ind.same_machine_flag_yn;
 sqlstm.sqinds[18] = (         int  )0;
 sqlstm.sqharm[18] = (unsigned int  )0;
 sqlstm.sqadto[18] = (unsigned short )0;
 sqlstm.sqtdso[18] = (unsigned short )0;
 sqlstm.sqhstv[19] = (         void  *)stepq_sql.group_first_step_yn;
 sqlstm.sqhstl[19] = (unsigned int  )2;
 sqlstm.sqhsts[19] = (         int  )0;
 sqlstm.sqindv[19] = (         void  *)&stepq_sql_ind.group_first_step_yn;
 sqlstm.sqinds[19] = (         int  )0;
 sqlstm.sqharm[19] = (unsigned int  )0;
 sqlstm.sqadto[19] = (unsigned short )0;
 sqlstm.sqtdso[19] = (unsigned short )0;
 sqlstm.sqhstv[20] = (         void  *)stepq_sql.skip_yn;
 sqlstm.sqhstl[20] = (unsigned int  )2;
 sqlstm.sqhsts[20] = (         int  )0;
 sqlstm.sqindv[20] = (         void  *)&stepq_sql_ind.skip_yn;
 sqlstm.sqinds[20] = (         int  )0;
 sqlstm.sqharm[20] = (unsigned int  )0;
 sqlstm.sqadto[20] = (unsigned short )0;
 sqlstm.sqtdso[20] = (unsigned short )0;
 sqlstm.sqhstv[21] = (         void  *)stepq_sql.beg_console_msg;
 sqlstm.sqhstl[21] = (unsigned int  )81;
 sqlstm.sqhsts[21] = (         int  )0;
 sqlstm.sqindv[21] = (         void  *)&stepq_sql_ind.beg_console_msg;
 sqlstm.sqinds[21] = (         int  )0;
 sqlstm.sqharm[21] = (unsigned int  )0;
 sqlstm.sqadto[21] = (unsigned short )0;
 sqlstm.sqtdso[21] = (unsigned short )0;
 sqlstm.sqhstv[22] = (         void  *)stepq_sql.beg_suspend_yn;
 sqlstm.sqhstl[22] = (unsigned int  )2;
 sqlstm.sqhsts[22] = (         int  )0;
 sqlstm.sqindv[22] = (         void  *)&stepq_sql_ind.beg_suspend_yn;
 sqlstm.sqinds[22] = (         int  )0;
 sqlstm.sqharm[22] = (unsigned int  )0;
 sqlstm.sqadto[22] = (unsigned short )0;
 sqlstm.sqtdso[22] = (unsigned short )0;
 sqlstm.sqhstv[23] = (         void  *)stepq_sql.end_console_msg;
 sqlstm.sqhstl[23] = (unsigned int  )81;
 sqlstm.sqhsts[23] = (         int  )0;
 sqlstm.sqindv[23] = (         void  *)&stepq_sql_ind.end_console_msg;
 sqlstm.sqinds[23] = (         int  )0;
 sqlstm.sqharm[23] = (unsigned int  )0;
 sqlstm.sqadto[23] = (unsigned short )0;
 sqlstm.sqtdso[23] = (unsigned short )0;
 sqlstm.sqhstv[24] = (         void  *)stepq_sql.end_suspend_yn;
 sqlstm.sqhstl[24] = (unsigned int  )2;
 sqlstm.sqhsts[24] = (         int  )0;
 sqlstm.sqindv[24] = (         void  *)&stepq_sql_ind.end_suspend_yn;
 sqlstm.sqinds[24] = (         int  )0;
 sqlstm.sqharm[24] = (unsigned int  )0;
 sqlstm.sqadto[24] = (unsigned short )0;
 sqlstm.sqtdso[24] = (unsigned short )0;
 sqlstm.sqhstv[25] = (         void  *)stepq_sql.send_msg;
 sqlstm.sqhstl[25] = (unsigned int  )81;
 sqlstm.sqhsts[25] = (         int  )0;
 sqlstm.sqindv[25] = (         void  *)&stepq_sql_ind.send_msg;
 sqlstm.sqinds[25] = (         int  )0;
 sqlstm.sqharm[25] = (unsigned int  )0;
 sqlstm.sqadto[25] = (unsigned short )0;
 sqlstm.sqtdso[25] = (unsigned short )0;
 sqlstm.sqhstv[26] = (         void  *)stepq_sql.run_if_error;
 sqlstm.sqhstl[26] = (unsigned int  )65;
 sqlstm.sqhsts[26] = (         int  )0;
 sqlstm.sqindv[26] = (         void  *)&stepq_sql_ind.run_if_error;
 sqlstm.sqinds[26] = (         int  )0;
 sqlstm.sqharm[26] = (unsigned int  )0;
 sqlstm.sqadto[26] = (unsigned short )0;
 sqlstm.sqtdso[26] = (unsigned short )0;
 sqlstm.sqhstv[27] = (         void  *)&stepq_sql.status_interval;
 sqlstm.sqhstl[27] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[27] = (         int  )0;
 sqlstm.sqindv[27] = (         void  *)&stepq_sql_ind.status_interval;
 sqlstm.sqinds[27] = (         int  )0;
 sqlstm.sqharm[27] = (unsigned int  )0;
 sqlstm.sqadto[27] = (unsigned short )0;
 sqlstm.sqtdso[27] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);


	while(1)
	{
		if(first_time)
			first_time=0;
		else
		{	
			// Fetch next
			memset(&stepq_sql, 0, sizeof(stepq_sql) );
			memset(&stepq_sql_ind, 0, sizeof(stepq_sql_ind) );

			EnterCriticalSection(&jsnt_sql_lock);
			/* EXEC SQL FETCH grp_stepq_curs INTO :stepq_sql:stepq_sql_ind; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 28;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )2008;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqfoff = (           int )0;
   sqlstm.sqfmod = (unsigned int )2;
   sqlstm.sqhstv[0] = (         void  *)&stepq_sql.no;
   sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)&stepq_sql_ind.no;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)&stepq_sql.step;
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)&stepq_sql_ind.step;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)stepq_sql.s_name;
   sqlstm.sqhstl[2] = (unsigned int  )10;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)&stepq_sql_ind.s_name;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)stepq_sql.status;
   sqlstm.sqhstl[3] = (unsigned int  )2;
   sqlstm.sqhsts[3] = (         int  )0;
   sqlstm.sqindv[3] = (         void  *)&stepq_sql_ind.status;
   sqlstm.sqinds[3] = (         int  )0;
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqhstv[4] = (         void  *)stepq_sql.j_name;
   sqlstm.sqhstl[4] = (unsigned int  )10;
   sqlstm.sqhsts[4] = (         int  )0;
   sqlstm.sqindv[4] = (         void  *)&stepq_sql_ind.j_name;
   sqlstm.sqinds[4] = (         int  )0;
   sqlstm.sqharm[4] = (unsigned int  )0;
   sqlstm.sqadto[4] = (unsigned short )0;
   sqlstm.sqtdso[4] = (unsigned short )0;
   sqlstm.sqhstv[5] = (         void  *)stepq_sql.date_time_started;
   sqlstm.sqhstl[5] = (unsigned int  )15;
   sqlstm.sqhsts[5] = (         int  )0;
   sqlstm.sqindv[5] = (         void  *)&stepq_sql_ind.time_started;
   sqlstm.sqinds[5] = (         int  )0;
   sqlstm.sqharm[5] = (unsigned int  )0;
   sqlstm.sqadto[5] = (unsigned short )0;
   sqlstm.sqtdso[5] = (unsigned short )0;
   sqlstm.sqhstv[6] = (         void  *)stepq_sql.date_time_completed;
   sqlstm.sqhstl[6] = (unsigned int  )15;
   sqlstm.sqhsts[6] = (         int  )0;
   sqlstm.sqindv[6] = (         void  *)&stepq_sql_ind.time_completed;
   sqlstm.sqinds[6] = (         int  )0;
   sqlstm.sqharm[6] = (unsigned int  )0;
   sqlstm.sqadto[6] = (unsigned short )0;
   sqlstm.sqtdso[6] = (unsigned short )0;
   sqlstm.sqhstv[7] = (         void  *)&stepq_sql.exit_code;
   sqlstm.sqhstl[7] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[7] = (         int  )0;
   sqlstm.sqindv[7] = (         void  *)&stepq_sql_ind.exit_code;
   sqlstm.sqinds[7] = (         int  )0;
   sqlstm.sqharm[7] = (unsigned int  )0;
   sqlstm.sqadto[7] = (unsigned short )0;
   sqlstm.sqtdso[7] = (unsigned short )0;
   sqlstm.sqhstv[8] = (         void  *)stepq_sql.command_line;
   sqlstm.sqhstl[8] = (unsigned int  )140;
   sqlstm.sqhsts[8] = (         int  )0;
   sqlstm.sqindv[8] = (         void  *)&stepq_sql_ind.command_line;
   sqlstm.sqinds[8] = (         int  )0;
   sqlstm.sqharm[8] = (unsigned int  )0;
   sqlstm.sqadto[8] = (unsigned short )0;
   sqlstm.sqtdso[8] = (unsigned short )0;
   sqlstm.sqhstv[9] = (         void  *)&stepq_sql.num_d;
   sqlstm.sqhstl[9] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[9] = (         int  )0;
   sqlstm.sqindv[9] = (         void  *)&stepq_sql_ind.num_d;
   sqlstm.sqinds[9] = (         int  )0;
   sqlstm.sqharm[9] = (unsigned int  )0;
   sqlstm.sqadto[9] = (unsigned short )0;
   sqlstm.sqtdso[9] = (unsigned short )0;
   sqlstm.sqhstv[10] = (         void  *)stepq_sql.d_step;
   sqlstm.sqhstl[10] = (unsigned int  )180;
   sqlstm.sqhsts[10] = (         int  )0;
   sqlstm.sqindv[10] = (         void  *)&stepq_sql_ind.d_step;
   sqlstm.sqinds[10] = (         int  )0;
   sqlstm.sqharm[10] = (unsigned int  )0;
   sqlstm.sqadto[10] = (unsigned short )0;
   sqlstm.sqtdso[10] = (unsigned short )0;
   sqlstm.sqhstv[11] = (         void  *)stepq_sql.d_cmplt;
   sqlstm.sqhstl[11] = (unsigned int  )20;
   sqlstm.sqhsts[11] = (         int  )0;
   sqlstm.sqindv[11] = (         void  *)&stepq_sql_ind.d_cmplt;
   sqlstm.sqinds[11] = (         int  )0;
   sqlstm.sqharm[11] = (unsigned int  )0;
   sqlstm.sqadto[11] = (unsigned short )0;
   sqlstm.sqtdso[11] = (unsigned short )0;
   sqlstm.sqhstv[12] = (         void  *)stepq_sql.d_last_tested;
   sqlstm.sqhstl[12] = (unsigned int  )200;
   sqlstm.sqhsts[12] = (         int  )0;
   sqlstm.sqindv[12] = (         void  *)&stepq_sql_ind.d_last_tested;
   sqlstm.sqinds[12] = (         int  )0;
   sqlstm.sqharm[12] = (unsigned int  )0;
   sqlstm.sqadto[12] = (unsigned short )0;
   sqlstm.sqtdso[12] = (unsigned short )0;
   sqlstm.sqhstv[13] = (         void  *)&stepq_sql.num_a;
   sqlstm.sqhstl[13] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[13] = (         int  )0;
   sqlstm.sqindv[13] = (         void  *)&stepq_sql_ind.num_a;
   sqlstm.sqinds[13] = (         int  )0;
   sqlstm.sqharm[13] = (unsigned int  )0;
   sqlstm.sqadto[13] = (unsigned short )0;
   sqlstm.sqtdso[13] = (unsigned short )0;
   sqlstm.sqhstv[14] = (         void  *)stepq_sql.exit_codes_acceptable;
   sqlstm.sqhstl[14] = (unsigned int  )100;
   sqlstm.sqhsts[14] = (         int  )0;
   sqlstm.sqindv[14] = (         void  *)&stepq_sql_ind.exit_codes_acceptable;
   sqlstm.sqinds[14] = (         int  )0;
   sqlstm.sqharm[14] = (unsigned int  )0;
   sqlstm.sqadto[14] = (unsigned short )0;
   sqlstm.sqtdso[14] = (unsigned short )0;
   sqlstm.sqhstv[15] = (         void  *)stepq_sql.job_machine;
   sqlstm.sqhstl[15] = (unsigned int  )10;
   sqlstm.sqhsts[15] = (         int  )0;
   sqlstm.sqindv[15] = (         void  *)&stepq_sql_ind.job_machine;
   sqlstm.sqinds[15] = (         int  )0;
   sqlstm.sqharm[15] = (unsigned int  )0;
   sqlstm.sqadto[15] = (unsigned short )0;
   sqlstm.sqtdso[15] = (unsigned short )0;
   sqlstm.sqhstv[16] = (         void  *)stepq_sql.d_group;
   sqlstm.sqhstl[16] = (unsigned int  )21;
   sqlstm.sqhsts[16] = (         int  )0;
   sqlstm.sqindv[16] = (         void  *)&stepq_sql_ind.d_group;
   sqlstm.sqinds[16] = (         int  )0;
   sqlstm.sqharm[16] = (unsigned int  )0;
   sqlstm.sqadto[16] = (unsigned short )0;
   sqlstm.sqtdso[16] = (unsigned short )0;
   sqlstm.sqhstv[17] = (         void  *)stepq_sql.group_name;
   sqlstm.sqhstl[17] = (unsigned int  )10;
   sqlstm.sqhsts[17] = (         int  )0;
   sqlstm.sqindv[17] = (         void  *)&stepq_sql_ind.group_name;
   sqlstm.sqinds[17] = (         int  )0;
   sqlstm.sqharm[17] = (unsigned int  )0;
   sqlstm.sqadto[17] = (unsigned short )0;
   sqlstm.sqtdso[17] = (unsigned short )0;
   sqlstm.sqhstv[18] = (         void  *)stepq_sql.same_machine_flag_yn;
   sqlstm.sqhstl[18] = (unsigned int  )2;
   sqlstm.sqhsts[18] = (         int  )0;
   sqlstm.sqindv[18] = (         void  *)&stepq_sql_ind.same_machine_flag_yn;
   sqlstm.sqinds[18] = (         int  )0;
   sqlstm.sqharm[18] = (unsigned int  )0;
   sqlstm.sqadto[18] = (unsigned short )0;
   sqlstm.sqtdso[18] = (unsigned short )0;
   sqlstm.sqhstv[19] = (         void  *)stepq_sql.group_first_step_yn;
   sqlstm.sqhstl[19] = (unsigned int  )2;
   sqlstm.sqhsts[19] = (         int  )0;
   sqlstm.sqindv[19] = (         void  *)&stepq_sql_ind.group_first_step_yn;
   sqlstm.sqinds[19] = (         int  )0;
   sqlstm.sqharm[19] = (unsigned int  )0;
   sqlstm.sqadto[19] = (unsigned short )0;
   sqlstm.sqtdso[19] = (unsigned short )0;
   sqlstm.sqhstv[20] = (         void  *)stepq_sql.skip_yn;
   sqlstm.sqhstl[20] = (unsigned int  )2;
   sqlstm.sqhsts[20] = (         int  )0;
   sqlstm.sqindv[20] = (         void  *)&stepq_sql_ind.skip_yn;
   sqlstm.sqinds[20] = (         int  )0;
   sqlstm.sqharm[20] = (unsigned int  )0;
   sqlstm.sqadto[20] = (unsigned short )0;
   sqlstm.sqtdso[20] = (unsigned short )0;
   sqlstm.sqhstv[21] = (         void  *)stepq_sql.beg_console_msg;
   sqlstm.sqhstl[21] = (unsigned int  )81;
   sqlstm.sqhsts[21] = (         int  )0;
   sqlstm.sqindv[21] = (         void  *)&stepq_sql_ind.beg_console_msg;
   sqlstm.sqinds[21] = (         int  )0;
   sqlstm.sqharm[21] = (unsigned int  )0;
   sqlstm.sqadto[21] = (unsigned short )0;
   sqlstm.sqtdso[21] = (unsigned short )0;
   sqlstm.sqhstv[22] = (         void  *)stepq_sql.beg_suspend_yn;
   sqlstm.sqhstl[22] = (unsigned int  )2;
   sqlstm.sqhsts[22] = (         int  )0;
   sqlstm.sqindv[22] = (         void  *)&stepq_sql_ind.beg_suspend_yn;
   sqlstm.sqinds[22] = (         int  )0;
   sqlstm.sqharm[22] = (unsigned int  )0;
   sqlstm.sqadto[22] = (unsigned short )0;
   sqlstm.sqtdso[22] = (unsigned short )0;
   sqlstm.sqhstv[23] = (         void  *)stepq_sql.end_console_msg;
   sqlstm.sqhstl[23] = (unsigned int  )81;
   sqlstm.sqhsts[23] = (         int  )0;
   sqlstm.sqindv[23] = (         void  *)&stepq_sql_ind.end_console_msg;
   sqlstm.sqinds[23] = (         int  )0;
   sqlstm.sqharm[23] = (unsigned int  )0;
   sqlstm.sqadto[23] = (unsigned short )0;
   sqlstm.sqtdso[23] = (unsigned short )0;
   sqlstm.sqhstv[24] = (         void  *)stepq_sql.end_suspend_yn;
   sqlstm.sqhstl[24] = (unsigned int  )2;
   sqlstm.sqhsts[24] = (         int  )0;
   sqlstm.sqindv[24] = (         void  *)&stepq_sql_ind.end_suspend_yn;
   sqlstm.sqinds[24] = (         int  )0;
   sqlstm.sqharm[24] = (unsigned int  )0;
   sqlstm.sqadto[24] = (unsigned short )0;
   sqlstm.sqtdso[24] = (unsigned short )0;
   sqlstm.sqhstv[25] = (         void  *)stepq_sql.send_msg;
   sqlstm.sqhstl[25] = (unsigned int  )81;
   sqlstm.sqhsts[25] = (         int  )0;
   sqlstm.sqindv[25] = (         void  *)&stepq_sql_ind.send_msg;
   sqlstm.sqinds[25] = (         int  )0;
   sqlstm.sqharm[25] = (unsigned int  )0;
   sqlstm.sqadto[25] = (unsigned short )0;
   sqlstm.sqtdso[25] = (unsigned short )0;
   sqlstm.sqhstv[26] = (         void  *)stepq_sql.run_if_error;
   sqlstm.sqhstl[26] = (unsigned int  )65;
   sqlstm.sqhsts[26] = (         int  )0;
   sqlstm.sqindv[26] = (         void  *)&stepq_sql_ind.run_if_error;
   sqlstm.sqinds[26] = (         int  )0;
   sqlstm.sqharm[26] = (unsigned int  )0;
   sqlstm.sqadto[26] = (unsigned short )0;
   sqlstm.sqtdso[26] = (unsigned short )0;
   sqlstm.sqhstv[27] = (         void  *)&stepq_sql.status_interval;
   sqlstm.sqhstl[27] = (unsigned int  )sizeof(short);
   sqlstm.sqhsts[27] = (         int  )0;
   sqlstm.sqindv[27] = (         void  *)&stepq_sql_ind.status_interval;
   sqlstm.sqinds[27] = (         int  )0;
   sqlstm.sqharm[27] = (unsigned int  )0;
   sqlstm.sqadto[27] = (unsigned short )0;
   sqlstm.sqtdso[27] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



			l_sqlcode = sqlca.sqlcode;
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			LeaveCriticalSection(&jsnt_sql_lock);
		}


		if (l_sqlcode == ORCL_NOT_FOUND)
			break;

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"grp_stepq_curs", sqlmsg, "STEPQ table", NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);	
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"Open Cursor for grp_stepq_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=", 
						szret, " ", sqlmsg, NULL);
			logit (0, szbuff);
			debug_log (szbuff);
			EnterCriticalSection(&jsnt_sql_lock);
			/* EXEC SQL CLOSE grp_stepq_curs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 28;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )2135;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


			LeaveCriticalSection(&jsnt_sql_lock);
			return(-1);
		}

		trim_sql_stepq(&stepq_sql);

		if(stepq_sql.no != job_q.no)
			break;

//		memset(group_name, 0, 9);
//		strncpy(group_name, step_q.d_step + (i*9), 8);
//		strncpy(group_name, step_q.d_step + (i*9), 8);

		trimr(stepq_sql.group_name);

		if(strcmp(d_step, stepq_sql.group_name) != 0 )
			continue;

		if(stepq_sql.status[0] != 'Y' && stepq_sql.status[0] != 'S')
		{
			EnterCriticalSection(&jsnt_sql_lock);

			/* EXEC SQL CLOSE grp_stepq_curs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 28;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )2150;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


			LeaveCriticalSection(&jsnt_sql_lock);

			return(1);
		}
	}


	// Try to Lock the row for updating up to 10 times before Erroring out.
	EnterCriticalSection(&jsnt_sql_lock);

	/* EXEC SQL SELECT
		no,
		step,
		s_name
	INTO :step_no, :step_step_no, :step_s_name
	FROM STEPQ
	WHERE no   = :step_q.no
	AND step   = :step_q.step
	FOR UPDATE; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 28;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = "select no ,step ,s_name into :b0,:b1,:b2  from STEPQ where (\
no=:b3 and step=:b4) for update ";
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2165;
 sqlstm.selerr = (unsigned short)1;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqhstv[0] = (         void  *)&step_no;
 sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)&step_step_no;
 sqlstm.sqhstl[1] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqhstv[2] = (         void  *)step_s_name;
 sqlstm.sqhstl[2] = (unsigned int  )10;
 sqlstm.sqhsts[2] = (         int  )0;
 sqlstm.sqindv[2] = (         void  *)0;
 sqlstm.sqinds[2] = (         int  )0;
 sqlstm.sqharm[2] = (unsigned int  )0;
 sqlstm.sqadto[2] = (unsigned short )0;
 sqlstm.sqtdso[2] = (unsigned short )0;
 sqlstm.sqhstv[3] = (         void  *)&(step_q.no);
 sqlstm.sqhstl[3] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[3] = (         int  )0;
 sqlstm.sqindv[3] = (         void  *)0;
 sqlstm.sqinds[3] = (         int  )0;
 sqlstm.sqharm[3] = (unsigned int  )0;
 sqlstm.sqadto[3] = (unsigned short )0;
 sqlstm.sqtdso[3] = (unsigned short )0;
 sqlstm.sqhstv[4] = (         void  *)&(step_q.step);
 sqlstm.sqhstl[4] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[4] = (         int  )0;
 sqlstm.sqindv[4] = (         void  *)0;
 sqlstm.sqinds[4] = (         int  )0;
 sqlstm.sqharm[4] = (unsigned int  )0;
 sqlstm.sqadto[4] = (unsigned short )0;
 sqlstm.sqtdso[4] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;
			
	if(l_sqlcode != ORCL_NO_ERROR)
	{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			/* EXEC SQL ROLLBACK; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 28;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )2200;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


			/* EXEC SQL CLOSE grp_stepq_curs; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 28;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )2215;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"STEPQ", sqlmsg, "For Update", NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);	
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff, "Error selecting STEPQ in line ", sznum, " sqlca.sqlcode=",
						szret, sqlmsg, NULL);
			logit (2, szbuff);
			debug_log (szbuff);
			return -1;
	}

	cntr = i;
	step_q.d_cmplt[cntr] = '1';

	/* EXEC SQL UPDATE STEPQ
		SET d_cmplt=substr(d_cmplt, :cntr, 1) || '1' || substr(d_cmplt, :cntr, 20 - :cntr)
		WHERE no   = :step_q.no
		AND step   = :step_q.step; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 28;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = "update STEPQ  set d_cmplt=((substr(d_cmplt,:b0,1)||'1')||sub\
str(d_cmplt,:b0,(20-:b0))) where (no=:b3 and step=:b4)";
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2230;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqhstv[0] = (         void  *)&cntr;
 sqlstm.sqhstl[0] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)&cntr;
 sqlstm.sqhstl[1] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqhstv[2] = (         void  *)&cntr;
 sqlstm.sqhstl[2] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[2] = (         int  )0;
 sqlstm.sqindv[2] = (         void  *)0;
 sqlstm.sqinds[2] = (         int  )0;
 sqlstm.sqharm[2] = (unsigned int  )0;
 sqlstm.sqadto[2] = (unsigned short )0;
 sqlstm.sqtdso[2] = (unsigned short )0;
 sqlstm.sqhstv[3] = (         void  *)&(step_q.no);
 sqlstm.sqhstl[3] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[3] = (         int  )0;
 sqlstm.sqindv[3] = (         void  *)0;
 sqlstm.sqinds[3] = (         int  )0;
 sqlstm.sqharm[3] = (unsigned int  )0;
 sqlstm.sqadto[3] = (unsigned short )0;
 sqlstm.sqtdso[3] = (unsigned short )0;
 sqlstm.sqhstv[4] = (         void  *)&(step_q.step);
 sqlstm.sqhstl[4] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[4] = (         int  )0;
 sqlstm.sqindv[4] = (         void  *)0;
 sqlstm.sqinds[4] = (         int  )0;
 sqlstm.sqharm[4] = (unsigned int  )0;
 sqlstm.sqadto[4] = (unsigned short )0;
 sqlstm.sqtdso[4] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;

	if(l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		/* EXEC SQL ROLLBACK; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 28;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )2265;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


		/* EXEC SQL CLOSE grp_stepq_curs; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 28;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )2280;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"STEPQ", sqlmsg, " ", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Error during UPDATE of STEPQ table - SQLCA.SQLCODE=",  
					szret, " ", sqlmsg, NULL);
		logit (2, szbuff);
		debug_log(szbuff);
		return -1;
	}
	
	/* EXEC SQL COMMIT; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 28;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2295;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


	l_sqlcode = sqlca.sqlcode;

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		/* EXEC SQL ROLLBACK; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 28;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )2310;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


		/* EXEC SQL CLOSE grp_stepq_curs; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 28;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )2325;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, sqlmsg, "STEPQ table", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"ERROR: COMMIT after UPDATE of STEPQ table failed: - SQLCA.SQLCODE=",  
					szret, " ", sqlmsg, NULL);
		logit (2, szbuff);
		debug_log(szbuff);
		return -1;
	}


	/* EXEC SQL CLOSE grp_stepq_curs; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 28;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2340;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


	LeaveCriticalSection(&jsnt_sql_lock);

	} // try block
	catch ( achStructured *pExp)
	{
		pExp->getStackTrace();
		delete pExp;
		exit(0);
	}

	catch ( achStackOverFlow  *pExp)
	{
		logitwithlocaltime(0, strcat((LPSTR) pExp->GetErrText().c_str()," in is_group_finished()"));
		delete pExp; 
		exit(-4);
	}



   return(0);
}

/******************* is_same_machine ***************************
*                                                              *
* Description: This function checks to see if this is the same *
*  machine for a group.                                        *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
* Modifiy Date:  07/27/99        By: Mike West                 *
*                                                              *
***************************************************************/
int is_same_machine(void)
{
   short int rc;
   short int status=0;
   char szbuff[300];
   int l_sqlcode;
   char szret[10];
   char sznum[20];
   char sqlmsg[80];


 
	EnterCriticalSection(&jsnt_sql_lock);
   	/* EXEC SQL DECLARE mch_stepq_curs CURSOR FOR 
	SELECT 
		no,
		step,
		s_name,
		status,
		j_name,
		date_time_started,
		date_time_completed,
		exit_code,
		command_line,
		num_d,
		d_step,
		d_cmplt,
		d_last_tested,
		num_a,
		exit_codes_acceptable,
		job_machine,
		d_group,
		group_name,
		same_machine_flag_yn,
		group_first_step_yn,
		skip_yn,
		beg_console_msg,
		beg_suspend_yn,
		end_console_msg,
		end_suspend_yn,
		send_msg,
		run_if_error,
		status_interval
	FROM STEPQ
	WHERE no = :step_q.no
	AND step = :step_q.step
	AND group_name >= :step_q.group_name; */ 


	// Open grp_stepq_curs cursor
	/* EXEC SQL OPEN mch_stepq_curs; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 28;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = sq0078;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2355;
 sqlstm.selerr = (unsigned short)0;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqcmod = (unsigned int )0;
 sqlstm.sqhstv[0] = (         void  *)&(step_q.no);
 sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)&(step_q.step);
 sqlstm.sqhstl[1] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqhstv[2] = (         void  *)(step_q.group_name);
 sqlstm.sqhstl[2] = (unsigned int  )10;
 sqlstm.sqhsts[2] = (         int  )0;
 sqlstm.sqindv[2] = (         void  *)0;
 sqlstm.sqinds[2] = (         int  )0;
 sqlstm.sqharm[2] = (unsigned int  )0;
 sqlstm.sqadto[2] = (unsigned short )0;
 sqlstm.sqtdso[2] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);


	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"mch_stepq_curs", sqlmsg, "STEPQ table", NULL);
		_ltoa((DWORD) __LINE__, sznum, 10);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Open Cursor for mch_stepq_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=",
					szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "Open Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
		//			"mch_stepq_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (2, szbuff);
		debug_log (szbuff);
		return(-1);
	}

	// Select using step_q.no and step_q.d_step
	memset(&stepq_sql, 0, sizeof(stepq_sql) );
	EnterCriticalSection(&jsnt_sql_lock);

	/* EXEC SQL FETCH mch_stepq_curs INTO :stepq_sql:stepq_sql_ind; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 28;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2382;
 sqlstm.selerr = (unsigned short)0;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqfoff = (           int )0;
 sqlstm.sqfmod = (unsigned int )2;
 sqlstm.sqhstv[0] = (         void  *)&stepq_sql.no;
 sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)&stepq_sql_ind.no;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)&stepq_sql.step;
 sqlstm.sqhstl[1] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)&stepq_sql_ind.step;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqhstv[2] = (         void  *)stepq_sql.s_name;
 sqlstm.sqhstl[2] = (unsigned int  )10;
 sqlstm.sqhsts[2] = (         int  )0;
 sqlstm.sqindv[2] = (         void  *)&stepq_sql_ind.s_name;
 sqlstm.sqinds[2] = (         int  )0;
 sqlstm.sqharm[2] = (unsigned int  )0;
 sqlstm.sqadto[2] = (unsigned short )0;
 sqlstm.sqtdso[2] = (unsigned short )0;
 sqlstm.sqhstv[3] = (         void  *)stepq_sql.status;
 sqlstm.sqhstl[3] = (unsigned int  )2;
 sqlstm.sqhsts[3] = (         int  )0;
 sqlstm.sqindv[3] = (         void  *)&stepq_sql_ind.status;
 sqlstm.sqinds[3] = (         int  )0;
 sqlstm.sqharm[3] = (unsigned int  )0;
 sqlstm.sqadto[3] = (unsigned short )0;
 sqlstm.sqtdso[3] = (unsigned short )0;
 sqlstm.sqhstv[4] = (         void  *)stepq_sql.j_name;
 sqlstm.sqhstl[4] = (unsigned int  )10;
 sqlstm.sqhsts[4] = (         int  )0;
 sqlstm.sqindv[4] = (         void  *)&stepq_sql_ind.j_name;
 sqlstm.sqinds[4] = (         int  )0;
 sqlstm.sqharm[4] = (unsigned int  )0;
 sqlstm.sqadto[4] = (unsigned short )0;
 sqlstm.sqtdso[4] = (unsigned short )0;
 sqlstm.sqhstv[5] = (         void  *)stepq_sql.date_time_started;
 sqlstm.sqhstl[5] = (unsigned int  )15;
 sqlstm.sqhsts[5] = (         int  )0;
 sqlstm.sqindv[5] = (         void  *)&stepq_sql_ind.time_started;
 sqlstm.sqinds[5] = (         int  )0;
 sqlstm.sqharm[5] = (unsigned int  )0;
 sqlstm.sqadto[5] = (unsigned short )0;
 sqlstm.sqtdso[5] = (unsigned short )0;
 sqlstm.sqhstv[6] = (         void  *)stepq_sql.date_time_completed;
 sqlstm.sqhstl[6] = (unsigned int  )15;
 sqlstm.sqhsts[6] = (         int  )0;
 sqlstm.sqindv[6] = (         void  *)&stepq_sql_ind.time_completed;
 sqlstm.sqinds[6] = (         int  )0;
 sqlstm.sqharm[6] = (unsigned int  )0;
 sqlstm.sqadto[6] = (unsigned short )0;
 sqlstm.sqtdso[6] = (unsigned short )0;
 sqlstm.sqhstv[7] = (         void  *)&stepq_sql.exit_code;
 sqlstm.sqhstl[7] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[7] = (         int  )0;
 sqlstm.sqindv[7] = (         void  *)&stepq_sql_ind.exit_code;
 sqlstm.sqinds[7] = (         int  )0;
 sqlstm.sqharm[7] = (unsigned int  )0;
 sqlstm.sqadto[7] = (unsigned short )0;
 sqlstm.sqtdso[7] = (unsigned short )0;
 sqlstm.sqhstv[8] = (         void  *)stepq_sql.command_line;
 sqlstm.sqhstl[8] = (unsigned int  )140;
 sqlstm.sqhsts[8] = (         int  )0;
 sqlstm.sqindv[8] = (         void  *)&stepq_sql_ind.command_line;
 sqlstm.sqinds[8] = (         int  )0;
 sqlstm.sqharm[8] = (unsigned int  )0;
 sqlstm.sqadto[8] = (unsigned short )0;
 sqlstm.sqtdso[8] = (unsigned short )0;
 sqlstm.sqhstv[9] = (         void  *)&stepq_sql.num_d;
 sqlstm.sqhstl[9] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[9] = (         int  )0;
 sqlstm.sqindv[9] = (         void  *)&stepq_sql_ind.num_d;
 sqlstm.sqinds[9] = (         int  )0;
 sqlstm.sqharm[9] = (unsigned int  )0;
 sqlstm.sqadto[9] = (unsigned short )0;
 sqlstm.sqtdso[9] = (unsigned short )0;
 sqlstm.sqhstv[10] = (         void  *)stepq_sql.d_step;
 sqlstm.sqhstl[10] = (unsigned int  )180;
 sqlstm.sqhsts[10] = (         int  )0;
 sqlstm.sqindv[10] = (         void  *)&stepq_sql_ind.d_step;
 sqlstm.sqinds[10] = (         int  )0;
 sqlstm.sqharm[10] = (unsigned int  )0;
 sqlstm.sqadto[10] = (unsigned short )0;
 sqlstm.sqtdso[10] = (unsigned short )0;
 sqlstm.sqhstv[11] = (         void  *)stepq_sql.d_cmplt;
 sqlstm.sqhstl[11] = (unsigned int  )20;
 sqlstm.sqhsts[11] = (         int  )0;
 sqlstm.sqindv[11] = (         void  *)&stepq_sql_ind.d_cmplt;
 sqlstm.sqinds[11] = (         int  )0;
 sqlstm.sqharm[11] = (unsigned int  )0;
 sqlstm.sqadto[11] = (unsigned short )0;
 sqlstm.sqtdso[11] = (unsigned short )0;
 sqlstm.sqhstv[12] = (         void  *)stepq_sql.d_last_tested;
 sqlstm.sqhstl[12] = (unsigned int  )200;
 sqlstm.sqhsts[12] = (         int  )0;
 sqlstm.sqindv[12] = (         void  *)&stepq_sql_ind.d_last_tested;
 sqlstm.sqinds[12] = (         int  )0;
 sqlstm.sqharm[12] = (unsigned int  )0;
 sqlstm.sqadto[12] = (unsigned short )0;
 sqlstm.sqtdso[12] = (unsigned short )0;
 sqlstm.sqhstv[13] = (         void  *)&stepq_sql.num_a;
 sqlstm.sqhstl[13] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[13] = (         int  )0;
 sqlstm.sqindv[13] = (         void  *)&stepq_sql_ind.num_a;
 sqlstm.sqinds[13] = (         int  )0;
 sqlstm.sqharm[13] = (unsigned int  )0;
 sqlstm.sqadto[13] = (unsigned short )0;
 sqlstm.sqtdso[13] = (unsigned short )0;
 sqlstm.sqhstv[14] = (         void  *)stepq_sql.exit_codes_acceptable;
 sqlstm.sqhstl[14] = (unsigned int  )100;
 sqlstm.sqhsts[14] = (         int  )0;
 sqlstm.sqindv[14] = (         void  *)&stepq_sql_ind.exit_codes_acceptable;
 sqlstm.sqinds[14] = (         int  )0;
 sqlstm.sqharm[14] = (unsigned int  )0;
 sqlstm.sqadto[14] = (unsigned short )0;
 sqlstm.sqtdso[14] = (unsigned short )0;
 sqlstm.sqhstv[15] = (         void  *)stepq_sql.job_machine;
 sqlstm.sqhstl[15] = (unsigned int  )10;
 sqlstm.sqhsts[15] = (         int  )0;
 sqlstm.sqindv[15] = (         void  *)&stepq_sql_ind.job_machine;
 sqlstm.sqinds[15] = (         int  )0;
 sqlstm.sqharm[15] = (unsigned int  )0;
 sqlstm.sqadto[15] = (unsigned short )0;
 sqlstm.sqtdso[15] = (unsigned short )0;
 sqlstm.sqhstv[16] = (         void  *)stepq_sql.d_group;
 sqlstm.sqhstl[16] = (unsigned int  )21;
 sqlstm.sqhsts[16] = (         int  )0;
 sqlstm.sqindv[16] = (         void  *)&stepq_sql_ind.d_group;
 sqlstm.sqinds[16] = (         int  )0;
 sqlstm.sqharm[16] = (unsigned int  )0;
 sqlstm.sqadto[16] = (unsigned short )0;
 sqlstm.sqtdso[16] = (unsigned short )0;
 sqlstm.sqhstv[17] = (         void  *)stepq_sql.group_name;
 sqlstm.sqhstl[17] = (unsigned int  )10;
 sqlstm.sqhsts[17] = (         int  )0;
 sqlstm.sqindv[17] = (         void  *)&stepq_sql_ind.group_name;
 sqlstm.sqinds[17] = (         int  )0;
 sqlstm.sqharm[17] = (unsigned int  )0;
 sqlstm.sqadto[17] = (unsigned short )0;
 sqlstm.sqtdso[17] = (unsigned short )0;
 sqlstm.sqhstv[18] = (         void  *)stepq_sql.same_machine_flag_yn;
 sqlstm.sqhstl[18] = (unsigned int  )2;
 sqlstm.sqhsts[18] = (         int  )0;
 sqlstm.sqindv[18] = (         void  *)&stepq_sql_ind.same_machine_flag_yn;
 sqlstm.sqinds[18] = (         int  )0;
 sqlstm.sqharm[18] = (unsigned int  )0;
 sqlstm.sqadto[18] = (unsigned short )0;
 sqlstm.sqtdso[18] = (unsigned short )0;
 sqlstm.sqhstv[19] = (         void  *)stepq_sql.group_first_step_yn;
 sqlstm.sqhstl[19] = (unsigned int  )2;
 sqlstm.sqhsts[19] = (         int  )0;
 sqlstm.sqindv[19] = (         void  *)&stepq_sql_ind.group_first_step_yn;
 sqlstm.sqinds[19] = (         int  )0;
 sqlstm.sqharm[19] = (unsigned int  )0;
 sqlstm.sqadto[19] = (unsigned short )0;
 sqlstm.sqtdso[19] = (unsigned short )0;
 sqlstm.sqhstv[20] = (         void  *)stepq_sql.skip_yn;
 sqlstm.sqhstl[20] = (unsigned int  )2;
 sqlstm.sqhsts[20] = (         int  )0;
 sqlstm.sqindv[20] = (         void  *)&stepq_sql_ind.skip_yn;
 sqlstm.sqinds[20] = (         int  )0;
 sqlstm.sqharm[20] = (unsigned int  )0;
 sqlstm.sqadto[20] = (unsigned short )0;
 sqlstm.sqtdso[20] = (unsigned short )0;
 sqlstm.sqhstv[21] = (         void  *)stepq_sql.beg_console_msg;
 sqlstm.sqhstl[21] = (unsigned int  )81;
 sqlstm.sqhsts[21] = (         int  )0;
 sqlstm.sqindv[21] = (         void  *)&stepq_sql_ind.beg_console_msg;
 sqlstm.sqinds[21] = (         int  )0;
 sqlstm.sqharm[21] = (unsigned int  )0;
 sqlstm.sqadto[21] = (unsigned short )0;
 sqlstm.sqtdso[21] = (unsigned short )0;
 sqlstm.sqhstv[22] = (         void  *)stepq_sql.beg_suspend_yn;
 sqlstm.sqhstl[22] = (unsigned int  )2;
 sqlstm.sqhsts[22] = (         int  )0;
 sqlstm.sqindv[22] = (         void  *)&stepq_sql_ind.beg_suspend_yn;
 sqlstm.sqinds[22] = (         int  )0;
 sqlstm.sqharm[22] = (unsigned int  )0;
 sqlstm.sqadto[22] = (unsigned short )0;
 sqlstm.sqtdso[22] = (unsigned short )0;
 sqlstm.sqhstv[23] = (         void  *)stepq_sql.end_console_msg;
 sqlstm.sqhstl[23] = (unsigned int  )81;
 sqlstm.sqhsts[23] = (         int  )0;
 sqlstm.sqindv[23] = (         void  *)&stepq_sql_ind.end_console_msg;
 sqlstm.sqinds[23] = (         int  )0;
 sqlstm.sqharm[23] = (unsigned int  )0;
 sqlstm.sqadto[23] = (unsigned short )0;
 sqlstm.sqtdso[23] = (unsigned short )0;
 sqlstm.sqhstv[24] = (         void  *)stepq_sql.end_suspend_yn;
 sqlstm.sqhstl[24] = (unsigned int  )2;
 sqlstm.sqhsts[24] = (         int  )0;
 sqlstm.sqindv[24] = (         void  *)&stepq_sql_ind.end_suspend_yn;
 sqlstm.sqinds[24] = (         int  )0;
 sqlstm.sqharm[24] = (unsigned int  )0;
 sqlstm.sqadto[24] = (unsigned short )0;
 sqlstm.sqtdso[24] = (unsigned short )0;
 sqlstm.sqhstv[25] = (         void  *)stepq_sql.send_msg;
 sqlstm.sqhstl[25] = (unsigned int  )81;
 sqlstm.sqhsts[25] = (         int  )0;
 sqlstm.sqindv[25] = (         void  *)&stepq_sql_ind.send_msg;
 sqlstm.sqinds[25] = (         int  )0;
 sqlstm.sqharm[25] = (unsigned int  )0;
 sqlstm.sqadto[25] = (unsigned short )0;
 sqlstm.sqtdso[25] = (unsigned short )0;
 sqlstm.sqhstv[26] = (         void  *)stepq_sql.run_if_error;
 sqlstm.sqhstl[26] = (unsigned int  )65;
 sqlstm.sqhsts[26] = (         int  )0;
 sqlstm.sqindv[26] = (         void  *)&stepq_sql_ind.run_if_error;
 sqlstm.sqinds[26] = (         int  )0;
 sqlstm.sqharm[26] = (unsigned int  )0;
 sqlstm.sqadto[26] = (unsigned short )0;
 sqlstm.sqtdso[26] = (unsigned short )0;
 sqlstm.sqhstv[27] = (         void  *)&stepq_sql.status_interval;
 sqlstm.sqhstl[27] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[27] = (         int  )0;
 sqlstm.sqindv[27] = (         void  *)&stepq_sql_ind.status_interval;
 sqlstm.sqinds[27] = (         int  )0;
 sqlstm.sqharm[27] = (unsigned int  )0;
 sqlstm.sqadto[27] = (unsigned short )0;
 sqlstm.sqtdso[27] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);


	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"mch_stepq_curs", sqlmsg, "STEPQ table", NULL);
		_ltoa((DWORD) __LINE__, sznum, 10);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff, "Open Cursor for mch_stepq_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=",
					szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "Open Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
		//			"mch_stepq_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (2, szbuff);
		debug_log (szbuff);
		EnterCriticalSection(&jsnt_sql_lock);

		/* EXEC SQL CLOSE mch_stepq_curs; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 28;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )2509;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


		LeaveCriticalSection(&jsnt_sql_lock);

		return(-1);
	}

	trim_sql_stepq(&stepq_sql);

	if(stepq_sql.group_first_step_yn[0] == 'N')
	{
		EnterCriticalSection(&jsnt_sql_lock);

		/* EXEC SQL CLOSE mch_stepq_curs; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 28;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )2524;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


		LeaveCriticalSection(&jsnt_sql_lock);

		return(-1);
	}

	if(strcmp(stepq_sql.job_machine, szjsname) == 0)
		rc = 1;
	else
		rc = 0;

	EnterCriticalSection(&jsnt_sql_lock);

	/* EXEC SQL CLOSE mch_stepq_curs; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 28;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2539;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


	LeaveCriticalSection(&jsnt_sql_lock);
  

	return(rc);
}


/******************** send_begin_msg ***************************
*                                                              *
* Description: Sends a message to the operator or console when *
*  the job has started.                                        *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
*                                                              *
***************************************************************/
void send_begin_msg(void)
{
   char szbuff[100];

   copy_cat(szbuff, "Job ", job_q.name, " has STARTED.", NULL);
   //sprintf(szbuff, "Job %s has STARTED", job_q.name);
   send_messages(szbuff);
}

/********************** send_end_msg ***************************
*                                                              *
* Description: Sends a message to the operator or console when *
*  the job has ended.                                          *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
*                                                              *
***************************************************************/
void send_end_msg(void)
{
   char szbuff[100];
   char szret[10];

   if(job_q.exit_code == 0)
	  copy_cat(szbuff, "Job ", job_q.name, " Completed Successfully!", NULL);
      //sprintf(szbuff, "Job %s Completed Successfully!", job_q.name);
   else
	  copy_cat(szbuff, "Job ", job_q.name, " FAILED with exit 7code ", szret, NULL);
      //sprintf(szbuff, "Job %s FAILED with exit code %d!", job_q.name, job_q.exit_code);

   send_messages(szbuff);
}

/********************* send_messages ***************************
*                                                              *
* Description: Sends a message to the operator console or      *
*  sends a Novell message.                                     *
*                                                              *
*  Note: The "NOVELL SEND" and "SAM" message options are       *
*    disabled.                                                 *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
*                                                              *
***************************************************************/
void send_messages(char *msg)
{


 
	if(job_q.msg_to_operator_yn[0] == 'Y')
		console_message(msg, 1, job_q.job_class);
  
}

/*********************** submit_msg ****************************
*                                                              *
* Description: This function logs jcsubmit messages to a file. *
*                                                              *
* Creation Date:  08/09/96        By: Mike West                *
*                                                              *
***************************************************************/
void submit_msg(char *msg)
{
   char szbuff[300];

   copy_cat(szbuff, "From JCSUBMIT(): ", msg, NULL);
   //sprintf(szbuff, "From JCSUBMIT(): %s", msg);
   logit(0, szbuff);
   debug_log(szbuff);
}


/*************************** logit *****************************
*                                                              *
* Description: This function logs messages to a file.          *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  06/24/96        By: Mike West                 *
*                                                              *
***************************************************************/
int logit (int log_type, char *msg) {
   char name[80];
   char job_info[100];
   char message[500];
   short int fh;
   char short_name[15];
   char datetime[20];
   char novell_info[100];
   SYSTIME st;

   char month[3];
   char day[3];
   char year[5];
   char decade[3];
   char hour[3];
   char minute[3];
   char second[3];

   char jobq_no[11];
   char jobq_name[10];
   char stepq_step[5];
   char stepq_name[10];
   char stepq_group_name[10];

   char jsname[10];
   char uname[20];
   char netid[20];
   char netpa[20];
   char netsid[20];
   //int  tmp_year;
   
 
   	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		char orcl_sys_date[15];
   	/* EXEC SQL END DECLARE SECTION; */ 

  



 
   if(get_system_date_time(orcl_sys_date) == SUCCESS)
  {
	   move(year,   4, orcl_sys_date,    1);
 	   move(month,  2, orcl_sys_date+4,  1);
   	   move(day,    2, orcl_sys_date+6,  1);
   	   move(hour,   2, orcl_sys_date+8,  1);
   	   move(minute, 2, orcl_sys_date+10, 1);
   	   move(second, 2, orcl_sys_date+12, 1);
   }
   else
   {
	  /*  Format some basic information */
	   getsystime(&st);

		_itoa(st.wMonth, month, 10);
		if(st.wMonth < 10)
			_padl(month, '0', 2);
	
		_itoa(st.wDay, day, 10);
		if(st.wDay < 10)
			_padl(day, '0', 2);
 
//	tmp_year = st.wYear%100;
		_itoa(st.wYear, year, 10);

		_itoa(st.wHour, hour, 10);
		if(st.wHour < 10)
			_padl(hour, '0', 2);

		_itoa(st.wMinute, minute, 10);
		if(st.wMinute < 10)
			_padl(minute, '0', 2);

		_itoa(st.wSecond, second, 10);
		if(st.wSecond < 10)
			_padl(second, '0', 2);
 }
  

   move(decade, 2, year+2, 1);
   copy_cat(datetime, month, "/", day, "/", decade, " ", hour, ":", minute, ":", second, NULL);

   _ltoa(job_q.no, jobq_no, 10);
   _padl(jobq_no, '0', 10);

   strcpy(jobq_name, (char*)job_q.name);
   _padl (jobq_name, ' ', 9);

   _itoa(step_q.step, stepq_step, 10);
   _padl(stepq_step, '0', 4);
   
   strcpy(stepq_name, (char*)step_q.s_name);
   _padl (stepq_name, ' ', 9);
   strcpy(stepq_group_name, step_q.group_name);
   _padl (stepq_group_name, ' ', 9);
   copy_cat(job_info, jobq_no, " ", jobq_name, " ", stepq_step, " ", stepq_name, " ", stepq_group_name, NULL);

   strcpy(jsname, szjsname);
   _padl(jsname, ' ', 8);
   strcpy(uname, user_name);
   _padl(uname, ' ', 10);
   strcpy(netid, network_id_s);
   _padl(netid, ' ', 4);
   strcpy(netpa, network_physical_address);
   _padl(netpa, ' ', 8);
   strcpy(netsid, network_station_id);
   _padl(netsid, ' ', 3);
   copy_cat(novell_info, jsname, " ", uname, " ", netid, ":", netpa, ":", netsid, NULL);

   copy_cat(short_name, year, month, day, ".LOG", NULL);

   if (! strlen(szlogpath)) 
	   strcpy  (name, short_name);
   else 
	   copy_cat(name, szlogpath, short_name, NULL);


/* Attempt to open the file, fh will be ERR if it fails.  On fail display msg */
   fh = _sopen (name, _O_BINARY | _O_RDWR, _SH_DENYNO);

    if (fh == ERR) {                  /* File not present - try to create it */
      fh = _sopen(name, _O_BINARY | _O_RDWR | _O_CREAT, _SH_DENYNO, _S_IWRITE);
      if (fh != ERR) 
	  {
		 copy_cat(message, datetime, "                                               ", novell_info, " File Created\r\n", NULL);
         _write(fh, message, strlen(message));
      }
		// ssv 04/19/04
  	  else
	  {
		/* Write the log to the local machine */
		copy_cat(name, szlocallogpath, short_name, NULL);
		fh = _sopen(name, _O_BINARY | _O_RDWR | _O_CREAT, _SH_DENYNO, _S_IWRITE);
		if (fh != ERR) 
		{
			copy_cat(message, datetime, "                                               ", novell_info, " File Created\r\n", NULL);
			_write(fh, message, strlen(message));
		}

	  }

    }

/* Open attempt failed - show something to screen, & don't do any more I/O calls below */
   if (fh==ERR) 
   {
	   copy_cat(message, "Error opening log file: ", name, NULL);
	   qtext(10, 10, message);
   }

/* On successful open, try to lock the file's first byte */
   else {
      if (_locking (fh, _LK_LOCK, 1L) != SUCCESS) 
	  {
         _close (fh);         /* Lock failed, so close the file handle */
         fh = ERR;           /* Simulate an errored file handle */
		 qtext(10, 10, "Error locking log file!");
      }
   }

   switch (log_type) {
      case 0:     /* General Message */
		  copy_cat(message, datetime, "                                               ", novell_info, " ",
				msg, "\r\n", NULL);
		  break;
      case 1:     /* Job Message */
		  copy_cat(message, datetime, " ", jobq_no, " ", jobq_name, 
					"                          ", novell_info, " ", msg, "\r\n", NULL);
		  break;

      case 2:     /* Step Message */
		  copy_cat(message, datetime, " ", jobq_no, " ", jobq_name, " ", stepq_step, " ", 
					stepq_name, " ", stepq_group_name, " ", novell_info, " ", msg, "\r\n", NULL);
		  break;
   }


/*  When the file handle is valid, write the message to the log file, unlock, & close */
   if (fh == ERR) 
	   qtext(10, 10, message);
   else {
      _lseek (fh, 0L, SEEK_END);
      _write (fh, message, strlen(message));
      _lseek (fh, 0L, SEEK_SET);
      _locking (fh, _LK_UNLCK, 1L);
      _close (fh);
   }
   return SUCCESS;
}


/************************ debug_log ****************************
*                                                              *
* Description: This function will check the passed variable    *
*  to see if the variable is either blank or null.             *
*  It will return 1 if the variable is blank or null and 0     *
*  if has valid characters in it.                              *
*                                                              *
* Creation Date: 06/26/96        By: Mike West                 *
*                                                              *
***************************************************************/
int debug_log(char *msg)
{
   char fname[_MAX_FNAME];
   char basic_info[50];
   char datetime[20];
   char message[500];
   short int fh;
   short int ret;
   char short_name[15];
   struct _stat info;
   static long offset;
   SYSTIME st;

   char month[3];
   char day[3];
   char year[5];
   char decade[3];
   char hour[3];
   char minute[3];
   char second[3];
   char jsname[10];

 
   	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		char orcl_sys_date[15];
   	/* EXEC SQL END DECLARE SECTION; */ 

  



   if(! debug_flag)     /* check for debug_flag set */
      return(0);



 
   if(get_system_date_time(orcl_sys_date) == SUCCESS)
  {
	   move(year,   4, orcl_sys_date,    1);
 	   move(month,  2, orcl_sys_date+4,  1);
   	   move(day,    2, orcl_sys_date+6,  1);
   	   move(hour,   2, orcl_sys_date+8,  1);
   	   move(minute, 2, orcl_sys_date+10, 1);
   	   move(second, 2, orcl_sys_date+12, 1);
   }
   else
   {
	  /*  Format some basic information */
	   getsystime(&st);

		_itoa(st.wMonth, month, 10);
		if(st.wMonth < 10)
			_padl(month, '0', 2);
	
		_itoa(st.wDay, day, 10);
		if(st.wDay < 10)
			_padl(day, '0', 2);
 
		_itoa(st.wYear, year, 10);

		_itoa(st.wHour, hour, 10);
		if(st.wHour < 10)
			_padl(hour, '0', 2);

		_itoa(st.wMinute, minute, 10);
		if(st.wMinute < 10)
			_padl(minute, '0', 2);

		_itoa(st.wSecond, second, 10);
		if(st.wSecond < 10)
			_padl(second, '0', 2);
 }
  

   move(decade, 2, year+2, 1);
   copy_cat(datetime, month, "/", day, "/", decade, " ", hour, ":", minute, ":", second, NULL);


   /* Create debug file name */
   copy_cat(short_name, year, month, day, ".DBG", NULL);


   if(strlen(szlogpath) == 0)
      strcpy(fname, short_name);
   else
	  copy_cat(fname, szlogpath, "\\", short_name, NULL);

   strcpy(jsname, szjsname);
   _padl(jsname, ' ', 8);
   copy_cat(basic_info, datetime, jsname, NULL);

   /* see if the debug file name already exists */
   ret = _stat(fname, &info);
   if(ret != 0)
   {
      fh=_sopen(fname, _O_BINARY | _O_RDWR | _O_CREAT, _SH_DENYNO, _S_IWRITE);
	  copy_cat(message, basic_info, " File Created\r\n", NULL);
      ret=_write(fh,message,strlen(message));
      _close(fh);
   }

   if (fh=_sopen (fname, _O_BINARY | _O_RDWR, _SH_DENYNO)==ERR) 
	   return ERR;
   if (_locking (fh, _LK_LOCK, 1L)) {        /* Lock the file - close & exit if error */
      _close(fh);
      return ERR;
   }

   _lseek (fh, 0L, SEEK_END);
   copy_cat(message, basic_info, " ", msg, "\r\n", NULL);

   _write (fh, message, strlen(message));   /* write message to debug file */
   _lseek (fh, 0L, SEEK_SET);
   _locking(fh, _LK_UNLCK, 1L);              /* Unlock the file */
   _close(fh);
   return SUCCESS;
}



/********************* get_system_date_time ********************
*                                                              *
* Description: Gets the date/time from the database.           *
*                                                              *
* Creation Date: 07/23/99        By: Mike West                 *
*                                                              *
***************************************************************/
 
int get_system_date_time(char *date_time)
{
	char szbuff[300];
	int l_sqlcode;
	int tries;
	char szret[10];
	char sqlmsg[80];

	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		char dt_tm[20];
	/* EXEC SQL END DECLARE SECTION; */ 


	//EnterCriticalSection(&jsnt_sql_lock2);
	EnterCriticalSection(&jsnt_sql_lock);
	for(tries=0; tries < 5; tries++)
	{
		/* EXEC SQL SELECT to_char(sysdate, 'YYYYMMDDHH24MISS')
			INTO :dt_tm
			FROM dual; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 28;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.stmt = "select to_char(sysdate,'YYYYMMDDHH24MISS') into :b0  from d\
ual ";
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )2554;
  sqlstm.selerr = (unsigned short)1;
  sqlstm.sqlpfmem = (unsigned int  )0;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlstm.sqhstv[0] = (         void  *)dt_tm;
  sqlstm.sqhstl[0] = (unsigned int  )20;
  sqlstm.sqhsts[0] = (         int  )0;
  sqlstm.sqindv[0] = (         void  *)0;
  sqlstm.sqinds[0] = (         int  )0;
  sqlstm.sqharm[0] = (unsigned int  )0;
  sqlstm.sqadto[0] = (unsigned short )0;
  sqlstm.sqtdso[0] = (unsigned short )0;
  sqlstm.sqphsv = sqlstm.sqhstv;
  sqlstm.sqphsl = sqlstm.sqhstl;
  sqlstm.sqphss = sqlstm.sqhsts;
  sqlstm.sqpind = sqlstm.sqindv;
  sqlstm.sqpins = sqlstm.sqinds;
  sqlstm.sqparm = sqlstm.sqharm;
  sqlstm.sqparc = sqlstm.sqharc;
  sqlstm.sqpadto = sqlstm.sqadto;
  sqlstm.sqptdso = sqlstm.sqtdso;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



		l_sqlcode = sqlca.sqlcode;
		
		if(l_sqlcode != ORCL_NO_ERROR)
			Sleep(1000);
		else
			break;
	}

	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
    LeaveCriticalSection(&jsnt_sql_lock);


	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"dual", sqlmsg, "Selecting Date/Time in get_system_date_time()", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff, "Error selecting Date/Time from dual in get_system_date_time() - sqlca.sqlcode=", 
					szret, " ", sqlmsg, NULL);
		//sprintf (szbuff, "Error selecting Date/Time from dual in get_system_date_time() - sqlca.sqlcode=%d, %s", 
		//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);

		//	DRQ 2003 -077 Baskar/Veera changed logit to logitwithlocaltime
		//	logit (2, szbuff);
		logitwithlocaltime(2, szbuff);

		debug_log (szbuff);
		return ERR;
	} 

	trimr(dt_tm);
	strcpy(date_time, dt_tm);
	return(SUCCESS);
}
  







/******************** write_status_file ************************
*                                                              *
* Description:  Write step status file                         *
*                                                              *
* Parameters:   right & bottom coordinate values               *
*                                                              *
* This function writes the step files (jobname.xxx).           *
* Returns SUCCESS or ERR.                                      *
*                                                              *
* Creation Date: 17/Apr/2000  By: Sasidhar D & Sabari Girish J *
*                                                              *
***************************************************************/
int write_status_file(unsigned int right, unsigned int bottom)
{
   int  fh, ret;
   int file_there = 0;
   long oldest;
   long offset;
   long longret = 0;
   char name[101], tempstr[101];
   char szbuff[300];          /* message array buffer        */
   struct _stat info;
   struct scr_times
   {
   time_t s_time[2];
   } st;

   if(no_screens) return(0);

/* Example file name: "\DEPS\JCS\some_job.001" or "some_job.001" */
   memset (name, 0x00, sizeof(name));
	if (strlen(szjspath) > 0) {
      strcpy (name, (char *)szjspath);
      //strcat (name, "\\");
      strcat (name, (char *)step_q.j_name);
   }
	else {
      strcpy (name, (char *)step_q.j_name);
   }
   strcat (name, ".");
   memset (tempstr, 0x00, 10);
   _itoa(step_q.step, tempstr, 10);
   padlz(tempstr, 3);
   strcat (name, tempstr);


	ret = _stat (name, &info);
	if (ret == 0) {
		file_there = 1;
		fh = _sopen (name, _O_RDWR | _O_BINARY, _SH_DENYNO);
	}
	else {
		fh = _open (name, _O_CREAT | _O_RDWR | _O_BINARY, _S_IWRITE);
	}
	if (fh == -1) {
		ifs_custerr("FILEOPEN", __FILE__, (DWORD) __LINE__, IFS_LOG, name, " ", " ", NULL);
		copy_cat(szbuff, "call to _(s)open() failed in write_status_file()", NULL);
		logit(2, szbuff);
		debug_log( szbuff );
		return ERR;
	}


    screen_buffer = (char*) gettext(0, 0, right, bottom);
	if( screen_buffer == NULL )
	{
		ifs_custerr("PRO_ERR_TO_USER", __FILE__, (DWORD) __LINE__, IFS_LOG, 
                     " : call to gettext() failed", "", NULL);
		copy_cat(szbuff, "call to gettext() failed in write_status_file()", NULL);
		logit(2, szbuff);
		debug_log( szbuff );
		return ERR;
	}

	if (file_there == 0) {
		ret = _write (fh, (char *) &job_q, sizeof(job_q)); /* 830 bytes */
		ret = _write (fh, (char *) &step_q, sizeof(step_q)); /* 1130 bytes */
		memset (st.s_time, 0x00, sizeof(st));                   /* 4*2  bytes */
		time (&st.s_time[0]);
		ret = _write (fh, (char *) &st, sizeof(st));
		ret = _write (fh, (char*)screen_buffer, scr_buffer_size);
		ret = _write (fh, (char*)screen_buffer, scr_buffer_size);
		_close (fh);                                      /* Total 17968 bytes */
        //klk 9/21/01 
		free( screen_buffer ); 
		return (SUCCESS);
	}

	ret = _write (fh, (char *) &job_q, sizeof(job_q));
	ret = _write (fh, (char *) &step_q, sizeof(step_q));
	offset = ((sizeof(job_q)) + (sizeof(step_q)));
	longret = _lseek (fh, offset, SEEK_SET);
	if (longret == -1) {
      _close (fh);
      //klk 9/21/01 
  	  free( screen_buffer ); 
      sprintf(tempstr, "%ld", offset);
		ifs_custerr("FILESEEK", __FILE__, (DWORD) __LINE__, IFS_LOG, name, tempstr, 
                     " ", " ", NULL);
		copy_cat(szbuff, "call to _lseek() failed in write_status_file()", NULL);
		logit(2, szbuff);
		debug_log( szbuff );
		return ERR;
   }
	ret = _read (fh, (char *) &st, sizeof(st));  

	oldest = 0;
	if (st.s_time[1] < st.s_time[oldest]) oldest = 1;
	time (&st.s_time[oldest]);

	longret = _lseek (fh, offset, SEEK_SET);
   if (longret == -1) {
        _close (fh);   
        //klk 9/21/01 
        free( screen_buffer ); 
	    sprintf(tempstr, "%ld", offset);
		ifs_custerr("FILESEEK", __FILE__, (DWORD) __LINE__, IFS_LOG, name, tempstr, 
                     " ", " ", NULL);
		copy_cat(szbuff, "call to _lseek() failed in write_status_file()", NULL);
		logit(2, szbuff);
		debug_log( szbuff );
		return (ERR);
   }
	ret = _write (fh, (char *) &st, sizeof(st)); 
	offset = ((sizeof(job_q)) + (sizeof(step_q)) + (sizeof(st)) + (oldest*scr_buffer_size));
	longret = _lseek (fh, offset, SEEK_SET);
	if (longret == -1) {
		_close (fh);     
        //klk 9/21/01 
		free( screen_buffer ); 
        sprintf(tempstr, "%ld", offset);
		ifs_custerr("FILESEEK", __FILE__, (DWORD) __LINE__, IFS_LOG, name, tempstr, 
                     " ", " ", NULL);
		copy_cat(szbuff, "call to _lseek() failed in write_status_file()", NULL);
		logit(2, szbuff);
		debug_log( szbuff );
		return (ERR);
   }

	ret = _write (fh, (char*)screen_buffer, scr_buffer_size);
    _close (fh);
    //klk 9/21/01 
	free( screen_buffer ); 

   return (SUCCESS);
}


/******************** date_logic() *****************************
*                                                              *
* Description:  Calculate date in which to spawn a process     *
*                                                              *
* Parameters:   reference to new date & new time               *
*                                                              *
* Creation Date: 05/15/2000  By: Sasidhar D, iDLX              *
*                                                              *
***************************************************************/
int date_logic(char *new_date, char *new_time)
{
    int i,ret;
    int j,k,interval,hr,mn;
    int yy,mm,dd;
    int save_mm;
    int century;
    unsigned int clk[8];
    int year;
    datestring holidays[500];
    char szbuff[100];
    char date_time_to_start[15];


 
   strcpy(date_time_to_start, job_q.date_time_to_start);

  

   //holidays[0] = 0;
   ret=load_holidays(holidays);

	move(szbuff,2,date_time_to_start,1);     /* two digit century */
	century=atoi(szbuff);
	century=century*100;
	move(szbuff+2,2,date_time_to_start+2,1);   /* two digit year */
	yy=atoi(szbuff);
	move(szbuff,2,date_time_to_start+4,1);   /* two digit mm   */
	mm=atoi(szbuff);
	move(szbuff,2,date_time_to_start+6,1);   /* two digit dd   */
	dd=atoi(szbuff);


	switch(job_q.spawn_algorithm) {
		
		case 1:                          /* Tomorrow Next Business Day */
			get_next_business_date(&yy,&mm,&dd, holidays);
			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;
					

			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 2:                          /* Weekly - SAME day next week 
														unless it is not a business day
														then the next business day */
			for(i=0;i<7;i++) 
				get_tomorrows_date(&yy,&mm,&dd);
			ret=is_valid_business_date(yy,mm,dd,holidays);
			if(ret != 0) 
				get_next_business_date(&yy,&mm,&dd,holidays);
			
			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;

			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 3:                          /* Last Business day of next month */
			
			/* Get 1st Day of Next Month */
			save_mm=mm;
			for(;1;) {
				get_next_business_date(&yy,&mm,&dd,holidays);
				if(mm != save_mm) break;
			}
			/* Go until Month changes again */
			save_mm=mm;
			for(;1;) {
				get_next_business_date(&yy,&mm,&dd,holidays);
				if(mm != save_mm) break;
			}
			/* Now back off one business day */
			get_previous_business_date(&yy,&mm,&dd,holidays);
		
			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;
			
			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 4:                          /* First Business day of next month */                      
			/* Get 1st Day of Next Month */
			save_mm=mm;
			for(;1;) {
				get_next_business_date(&yy,&mm,&dd,holidays);
				if(mm != save_mm) break;
			}

			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;

			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 5:                          /* 1st (day-of-week) of month 
														unless it is not a business day
														then the next business day */
			save_mm=mm;
			for(;1;) {
				get_tomorrows_date(&yy,&mm,&dd);
				if(mm != save_mm) break;
			}
			for(;1;) {
				ret=dow(yy,mm,dd);
				if(ret == job_q.spawn_parm) break;
				get_tomorrows_date(&yy,&mm,&dd);
			}
			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;

			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 6:                          /* 2nd (day-of-week) of month 
														unless it is not a business day
														then the next business day */
			save_mm=mm;
			for(;1;) {
				get_tomorrows_date(&yy,&mm,&dd);
				if(mm != save_mm) break;
			}
			for(;1;) {
				ret=dow(yy,mm,dd);
				if(ret == job_q.spawn_parm) break;
				get_tomorrows_date(&yy,&mm,&dd);
			}
			for(i=0;i<7;i++) get_tomorrows_date(&yy,&mm,&dd);
			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;

			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 7:                          /* 3rd (day-of-week) of month 
														unless it is not a business day
														then the next business day */
			save_mm=mm;
			for(;1;) {
				get_tomorrows_date(&yy,&mm,&dd);
				if(mm != save_mm) break;
			}
			for(;1;) {
				ret=dow(yy,mm,dd);
				if(ret == job_q.spawn_parm) break;
				get_tomorrows_date(&yy,&mm,&dd);
			}
			for(i=0;i<7;i++) get_tomorrows_date(&yy,&mm,&dd);
			for(i=0;i<7;i++) get_tomorrows_date(&yy,&mm,&dd);
		
			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;

			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 8:                          /* 4th (day-of-week) of month 
														unless it is not a business day
														then the next business day */
			save_mm=mm;
			for(;1;) {
				get_tomorrows_date(&yy,&mm,&dd);
				if(mm != save_mm) break;
			}
			for(;1;) {
				ret=dow(yy,mm,dd);
				if(ret == job_q.spawn_parm) break;
				get_tomorrows_date(&yy,&mm,&dd);
			}
			for(i=0;i<7;i++) get_tomorrows_date(&yy,&mm,&dd);
			for(i=0;i<7;i++) get_tomorrows_date(&yy,&mm,&dd);
			for(i=0;i<7;i++) get_tomorrows_date(&yy,&mm,&dd);
		
			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;
			
			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 10:                         /* Submit for X Minutes from Now */
			interval=job_q.spawn_parm;
			// move(szbuff,2,job_q.time_to_start,1);
			// hr=atoi(szbuff);
			// move(szbuff,2,job_q.time_to_start+2,1);
			// mn=atoi(szbuff);
			getclk(&(clk[0]));         /* get current system time */
			hr = *(clk+DT_HOUR);       /* hours */
			mn = *(clk+DT_MIN);        /* minutes */
			j=interval % 60;
			k=interval / 60;
			mn+=j;
			if( mn >= 60 ) {
				mn-=60;
				k++;
			}
			j=k / 24;
			k=k % 24;
			hr+=k;
			if( hr >=24 ) {
				hr-=24;
				j++;
			}           
			for(k=0;k<j;k++) {
				get_tomorrows_date(&yy,&mm,&dd);
			}

			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;
			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			sprintf(new_time,"%02d%02d",hr,mn);
			return(0);

		default:
			return(-1);
	}
	return(-1);
}


/***************** load_holidays() *****************************
*                                                              *
* Description:  Loads holidays into a buffer                   *
*                                                              *
* Parameters:   holiday buffer                                 *
*                                                              *
* Creation Date: 02/21/2001  By: Kellie Kupka                  *
*                                                              *
***************************************************************/
int load_holidays(datestring  *holidays)
{

	long holiday_buf_cnt=0, holiday_tot_cnt=0;
	short int n;
    char  tempstr[300];             
	int   l_sqlcode, l_sqlerrd;
	char  sqlmsg[80];
    char  szline[10];
    char  szcode[10];


	/* EXEC SQL DECLARE holiday_curs CURSOR FOR
	SELECT 
		holiday
	FROM
		holidays
	ORDER BY holiday; */ 


	EnterCriticalSection(&jsnt_sql_lock);
	/* EXEC SQL CONTEXT USE :g_ctx; */ 


	// Open HOLIDAY cursor
	/* EXEC SQL OPEN holiday_curs; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 28;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = sq0080;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2573;
 sqlstm.selerr = (unsigned short)0;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqcmod = (unsigned int )0;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


	l_sqlcode = sqlca.sqlcode;

	LeaveCriticalSection(&jsnt_sql_lock);

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"holiday_curs", sqlmsg, "HOLIDAY table", NULL);
		_ltoa((DWORD) __LINE__, szline, 10);
		_itoa(l_sqlcode, szcode, 10);
		copy_cat(tempstr, "Open Cursor for holiday_cursor Failed! on line ", szline, 
							" - SQLCA.SQLCODE=", szcode, " ", sqlmsg, NULL);
		logit (0, tempstr);
		debug_log (tempstr);
		return(-1);
	}

	EnterCriticalSection(&jsnt_sql_lock);

	
	// Select 100 records from HOLIDAY table using HOLIDAY cursor
	memset(&holiday_rec, 0, sizeof(holiday_rec));
	/* EXEC SQL FETCH holiday_curs INTO :holiday_rec; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 28;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )100;
 sqlstm.offset = (unsigned int  )2588;
 sqlstm.selerr = (unsigned short)0;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqfoff = (           int )0;
 sqlstm.sqfmod = (unsigned int )2;
 sqlstm.sqhstv[0] = (         void  *)holiday_rec.holiday;
 sqlstm.sqhstl[0] = (unsigned int  )9;
 sqlstm.sqhsts[0] = (         int  )9;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqharc[0] = (unsigned int   *)0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;

	l_sqlerrd = sqlca.sqlerrd[2];

	LeaveCriticalSection(&jsnt_sql_lock);

	while (((l_sqlcode == ORCL_NOT_FOUND) || (l_sqlcode == ORCL_NO_ERROR))
				&& (l_sqlerrd > 0))
	{
		holiday_buf_cnt = l_sqlerrd - holiday_tot_cnt;	/* Number of new records */
		holiday_tot_cnt = l_sqlerrd;		/* Total records fetched so far */

		/* Copy fetched records to table */
		for (n = 0; n < holiday_buf_cnt; n++)
		{
		      memcpy(holidays[n], holiday_rec.holiday[n], 8);
		}	
	    memset(holidays[n], '\0', 8);



		// if the return cnt from last fetch is less than max fetch, break out of while loop
		if (holiday_buf_cnt < ROWS)
			break; 

		EnterCriticalSection(&jsnt_sql_lock);

		// Else, we need to do another fetch to get the next set of records from the Delivery table
		memset(&holiday_rec, 0, sizeof(holiday_rec));
		/* EXEC SQL FETCH holiday_curs INTO :holiday_rec; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 28;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )100;
  sqlstm.offset = (unsigned int  )2607;
  sqlstm.selerr = (unsigned short)0;
  sqlstm.sqlpfmem = (unsigned int  )0;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlstm.sqfoff = (           int )0;
  sqlstm.sqfmod = (unsigned int )2;
  sqlstm.sqhstv[0] = (         void  *)holiday_rec.holiday;
  sqlstm.sqhstl[0] = (unsigned int  )9;
  sqlstm.sqhsts[0] = (         int  )9;
  sqlstm.sqindv[0] = (         void  *)0;
  sqlstm.sqinds[0] = (         int  )0;
  sqlstm.sqharm[0] = (unsigned int  )0;
  sqlstm.sqharc[0] = (unsigned int   *)0;
  sqlstm.sqadto[0] = (unsigned short )0;
  sqlstm.sqtdso[0] = (unsigned short )0;
  sqlstm.sqphsv = sqlstm.sqhstv;
  sqlstm.sqphsl = sqlstm.sqhstl;
  sqlstm.sqphss = sqlstm.sqhsts;
  sqlstm.sqpind = sqlstm.sqindv;
  sqlstm.sqpins = sqlstm.sqinds;
  sqlstm.sqparm = sqlstm.sqharm;
  sqlstm.sqparc = sqlstm.sqharc;
  sqlstm.sqpadto = sqlstm.sqadto;
  sqlstm.sqptdso = sqlstm.sqtdso;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



		l_sqlcode = sqlca.sqlcode;
		l_sqlerrd = sqlca.sqlerrd[2];

		LeaveCriticalSection(&jsnt_sql_lock);

		if( l_sqlcode == ORCL_NOT_FOUND )
			break;


	}	/* End of while loop */

	if (l_sqlcode == ORCL_NOT_FOUND)
	{
		EnterCriticalSection(&jsnt_sql_lock);

		/* EXEC SQL CLOSE holiday_curs; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 28;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )2626;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



		l_sqlcode = sqlca.sqlcode;

		LeaveCriticalSection(&jsnt_sql_lock);

	}

	if (l_sqlcode != ORCL_NO_ERROR)
	{	
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EnterCriticalSection(&jsnt_sql_lock);

		/* EXEC SQL CLOSE holiday_curs; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 28;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )2641;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
				"holiday_curs", "", " ", sqlmsg, "HOLIDAY table", NULL);
		_ltoa((DWORD) __LINE__, szline, 10);
		_itoa(l_sqlcode, szcode, 10);
		copy_cat(tempstr, "Fetch failed for HOLIDAY_CURS on line ", szline, 
							" - SQLCA.SQLCODE=", szcode, " ", sqlmsg, NULL);
		logit (0, tempstr);
		debug_log (tempstr);
	}
  

	return(0);
}

/********************** job_num_get ****************************
*                                                              *
* Description: Does a SELECT on the sequence generator in      *
*  order to obtain the next job number for this job.		   * 
*                                                              *
* Creation Date: 07/16/99      By: Mike West                   *
*															   *
* Modified Date: 04/24/2000    By: Radha K & Gopal Balaji, iDLX*
*                                                              *
* This function was modified to add IFS messages.              *
***************************************************************/
 
static long job_num_get()
{
	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		unsigned long lJobNum;
	/* EXEC SQL END DECLARE SECTION; */ 

	char errstr[300];
	char sqlmsg[80];

	/* EXEC SQL SELECT seq_job_num.nextval 
		INTO :lJobNum
		FROM dual; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 28;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = "select seq_job_num.nextval  into :b0  from dual ";
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2656;
 sqlstm.selerr = (unsigned short)1;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqhstv[0] = (         void  *)&lJobNum;
 sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}




	if (sqlca.sqlcode != ORCL_NO_ERROR) 
	{
      strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
      ifs_custerr("ORC_SELECT", __FILE__, __LINE__, IFS_LOG, 
         "DUAL", sqlmsg, "Selecting nextval from sequence, SEQ_JOB_NUM", 
            NULL);

		sprintf(errstr, "ERROR: Cannot obtain next Job Number from seq_job_num table.");
		if (submit_error) submit_error(errstr);
		return(-1);
	}

	return(lJobNum);                          //return job number.              
}
  

/********************** submit() *******************************
*                                                              *
* Description:  Spawn (submit) this job at a future calculated *
* date. It re-submits the job & step records for a future      *
* scheduled date & time.                                       *
*                                                              *
* Parameters:   New date & New time values                     *
*                                                              *
* Creation Date: 05/15/2000  By: Sasidhar D, iDLX              *
*                                                              *
***************************************************************/
 
int submit(char *new_date, char *new_time)
{
	int i;
	int job_num;
	int s_first_time=1;
	int l_sqlcode;
	char sqlmsg[80];
   char szline[80], szcode[80];
   char tempstr[150];

	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		char dt_tm[15];
	/* EXEC SQL END DECLARE SECTION; */ 


	job_num = job_num_get();		  /* get next job number from Seqence Generator*/
	if(job_num == 0)  
	{
		return(ERR);
	}

	EnterCriticalSection(&jsnt_sql_lock);

	// Define STEP cursor
	/* EXEC SQL DECLARE step_curs CURSOR FOR
	SELECT 
		no,
		step,
		s_name,
		status,
		j_name,
		date_time_started,
		date_time_completed,
		exit_code,
		command_line,
		num_d,
		d_step,
		d_cmplt,
		d_last_tested,
		num_a,
		exit_codes_acceptable,
		job_machine,
		d_group,
		group_name,
		same_machine_flag_yn,
		group_first_step_yn,
		skip_yn,
		beg_console_msg,
		beg_suspend_yn,
		end_console_msg,
		end_suspend_yn,
		send_msg,
		run_if_error,
		status_interval
	FROM
		STEPQ
	WHERE no = :job_q.no; */ 


	// Open STEP cursor
	/* EXEC SQL OPEN step_curs; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 28;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = sq0082;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2675;
 sqlstm.selerr = (unsigned short)0;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqcmod = (unsigned int )0;
 sqlstm.sqhstv[0] = (         void  *)&(job_q.no);
 sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

	LeaveCriticalSection(&jsnt_sql_lock);

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"step_curs", sqlmsg, "STEPQ table", NULL);
		_ltoa((DWORD) __LINE__, szline, 10);
		_itoa(l_sqlcode, szcode, 10);
		copy_cat(tempstr, "Open Cursor for step_curs Failed! on line ", szline, 
							" - SQLCA.SQLCODE=", szcode, " ", sqlmsg, NULL);
		logit (0, tempstr);
		debug_log (tempstr);
		return(-1);
	}

	memset(&stepq_sql, 0, sizeof(stepq_sql) );
	EnterCriticalSection(&jsnt_sql_lock);

	/* EXEC SQL FETCH step_curs INTO :stepq_sql:stepq_sql_ind; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 28;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )2694;
 sqlstm.selerr = (unsigned short)0;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqfoff = (           int )0;
 sqlstm.sqfmod = (unsigned int )2;
 sqlstm.sqhstv[0] = (         void  *)&stepq_sql.no;
 sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)&stepq_sql_ind.no;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)&stepq_sql.step;
 sqlstm.sqhstl[1] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)&stepq_sql_ind.step;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqhstv[2] = (         void  *)stepq_sql.s_name;
 sqlstm.sqhstl[2] = (unsigned int  )10;
 sqlstm.sqhsts[2] = (         int  )0;
 sqlstm.sqindv[2] = (         void  *)&stepq_sql_ind.s_name;
 sqlstm.sqinds[2] = (         int  )0;
 sqlstm.sqharm[2] = (unsigned int  )0;
 sqlstm.sqadto[2] = (unsigned short )0;
 sqlstm.sqtdso[2] = (unsigned short )0;
 sqlstm.sqhstv[3] = (         void  *)stepq_sql.status;
 sqlstm.sqhstl[3] = (unsigned int  )2;
 sqlstm.sqhsts[3] = (         int  )0;
 sqlstm.sqindv[3] = (         void  *)&stepq_sql_ind.status;
 sqlstm.sqinds[3] = (         int  )0;
 sqlstm.sqharm[3] = (unsigned int  )0;
 sqlstm.sqadto[3] = (unsigned short )0;
 sqlstm.sqtdso[3] = (unsigned short )0;
 sqlstm.sqhstv[4] = (         void  *)stepq_sql.j_name;
 sqlstm.sqhstl[4] = (unsigned int  )10;
 sqlstm.sqhsts[4] = (         int  )0;
 sqlstm.sqindv[4] = (         void  *)&stepq_sql_ind.j_name;
 sqlstm.sqinds[4] = (         int  )0;
 sqlstm.sqharm[4] = (unsigned int  )0;
 sqlstm.sqadto[4] = (unsigned short )0;
 sqlstm.sqtdso[4] = (unsigned short )0;
 sqlstm.sqhstv[5] = (         void  *)stepq_sql.date_time_started;
 sqlstm.sqhstl[5] = (unsigned int  )15;
 sqlstm.sqhsts[5] = (         int  )0;
 sqlstm.sqindv[5] = (         void  *)&stepq_sql_ind.time_started;
 sqlstm.sqinds[5] = (         int  )0;
 sqlstm.sqharm[5] = (unsigned int  )0;
 sqlstm.sqadto[5] = (unsigned short )0;
 sqlstm.sqtdso[5] = (unsigned short )0;
 sqlstm.sqhstv[6] = (         void  *)stepq_sql.date_time_completed;
 sqlstm.sqhstl[6] = (unsigned int  )15;
 sqlstm.sqhsts[6] = (         int  )0;
 sqlstm.sqindv[6] = (         void  *)&stepq_sql_ind.time_completed;
 sqlstm.sqinds[6] = (         int  )0;
 sqlstm.sqharm[6] = (unsigned int  )0;
 sqlstm.sqadto[6] = (unsigned short )0;
 sqlstm.sqtdso[6] = (unsigned short )0;
 sqlstm.sqhstv[7] = (         void  *)&stepq_sql.exit_code;
 sqlstm.sqhstl[7] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[7] = (         int  )0;
 sqlstm.sqindv[7] = (         void  *)&stepq_sql_ind.exit_code;
 sqlstm.sqinds[7] = (         int  )0;
 sqlstm.sqharm[7] = (unsigned int  )0;
 sqlstm.sqadto[7] = (unsigned short )0;
 sqlstm.sqtdso[7] = (unsigned short )0;
 sqlstm.sqhstv[8] = (         void  *)stepq_sql.command_line;
 sqlstm.sqhstl[8] = (unsigned int  )140;
 sqlstm.sqhsts[8] = (         int  )0;
 sqlstm.sqindv[8] = (         void  *)&stepq_sql_ind.command_line;
 sqlstm.sqinds[8] = (         int  )0;
 sqlstm.sqharm[8] = (unsigned int  )0;
 sqlstm.sqadto[8] = (unsigned short )0;
 sqlstm.sqtdso[8] = (unsigned short )0;
 sqlstm.sqhstv[9] = (         void  *)&stepq_sql.num_d;
 sqlstm.sqhstl[9] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[9] = (         int  )0;
 sqlstm.sqindv[9] = (         void  *)&stepq_sql_ind.num_d;
 sqlstm.sqinds[9] = (         int  )0;
 sqlstm.sqharm[9] = (unsigned int  )0;
 sqlstm.sqadto[9] = (unsigned short )0;
 sqlstm.sqtdso[9] = (unsigned short )0;
 sqlstm.sqhstv[10] = (         void  *)stepq_sql.d_step;
 sqlstm.sqhstl[10] = (unsigned int  )180;
 sqlstm.sqhsts[10] = (         int  )0;
 sqlstm.sqindv[10] = (         void  *)&stepq_sql_ind.d_step;
 sqlstm.sqinds[10] = (         int  )0;
 sqlstm.sqharm[10] = (unsigned int  )0;
 sqlstm.sqadto[10] = (unsigned short )0;
 sqlstm.sqtdso[10] = (unsigned short )0;
 sqlstm.sqhstv[11] = (         void  *)stepq_sql.d_cmplt;
 sqlstm.sqhstl[11] = (unsigned int  )20;
 sqlstm.sqhsts[11] = (         int  )0;
 sqlstm.sqindv[11] = (         void  *)&stepq_sql_ind.d_cmplt;
 sqlstm.sqinds[11] = (         int  )0;
 sqlstm.sqharm[11] = (unsigned int  )0;
 sqlstm.sqadto[11] = (unsigned short )0;
 sqlstm.sqtdso[11] = (unsigned short )0;
 sqlstm.sqhstv[12] = (         void  *)stepq_sql.d_last_tested;
 sqlstm.sqhstl[12] = (unsigned int  )200;
 sqlstm.sqhsts[12] = (         int  )0;
 sqlstm.sqindv[12] = (         void  *)&stepq_sql_ind.d_last_tested;
 sqlstm.sqinds[12] = (         int  )0;
 sqlstm.sqharm[12] = (unsigned int  )0;
 sqlstm.sqadto[12] = (unsigned short )0;
 sqlstm.sqtdso[12] = (unsigned short )0;
 sqlstm.sqhstv[13] = (         void  *)&stepq_sql.num_a;
 sqlstm.sqhstl[13] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[13] = (         int  )0;
 sqlstm.sqindv[13] = (         void  *)&stepq_sql_ind.num_a;
 sqlstm.sqinds[13] = (         int  )0;
 sqlstm.sqharm[13] = (unsigned int  )0;
 sqlstm.sqadto[13] = (unsigned short )0;
 sqlstm.sqtdso[13] = (unsigned short )0;
 sqlstm.sqhstv[14] = (         void  *)stepq_sql.exit_codes_acceptable;
 sqlstm.sqhstl[14] = (unsigned int  )100;
 sqlstm.sqhsts[14] = (         int  )0;
 sqlstm.sqindv[14] = (         void  *)&stepq_sql_ind.exit_codes_acceptable;
 sqlstm.sqinds[14] = (         int  )0;
 sqlstm.sqharm[14] = (unsigned int  )0;
 sqlstm.sqadto[14] = (unsigned short )0;
 sqlstm.sqtdso[14] = (unsigned short )0;
 sqlstm.sqhstv[15] = (         void  *)stepq_sql.job_machine;
 sqlstm.sqhstl[15] = (unsigned int  )10;
 sqlstm.sqhsts[15] = (         int  )0;
 sqlstm.sqindv[15] = (         void  *)&stepq_sql_ind.job_machine;
 sqlstm.sqinds[15] = (         int  )0;
 sqlstm.sqharm[15] = (unsigned int  )0;
 sqlstm.sqadto[15] = (unsigned short )0;
 sqlstm.sqtdso[15] = (unsigned short )0;
 sqlstm.sqhstv[16] = (         void  *)stepq_sql.d_group;
 sqlstm.sqhstl[16] = (unsigned int  )21;
 sqlstm.sqhsts[16] = (         int  )0;
 sqlstm.sqindv[16] = (         void  *)&stepq_sql_ind.d_group;
 sqlstm.sqinds[16] = (         int  )0;
 sqlstm.sqharm[16] = (unsigned int  )0;
 sqlstm.sqadto[16] = (unsigned short )0;
 sqlstm.sqtdso[16] = (unsigned short )0;
 sqlstm.sqhstv[17] = (         void  *)stepq_sql.group_name;
 sqlstm.sqhstl[17] = (unsigned int  )10;
 sqlstm.sqhsts[17] = (         int  )0;
 sqlstm.sqindv[17] = (         void  *)&stepq_sql_ind.group_name;
 sqlstm.sqinds[17] = (         int  )0;
 sqlstm.sqharm[17] = (unsigned int  )0;
 sqlstm.sqadto[17] = (unsigned short )0;
 sqlstm.sqtdso[17] = (unsigned short )0;
 sqlstm.sqhstv[18] = (         void  *)stepq_sql.same_machine_flag_yn;
 sqlstm.sqhstl[18] = (unsigned int  )2;
 sqlstm.sqhsts[18] = (         int  )0;
 sqlstm.sqindv[18] = (         void  *)&stepq_sql_ind.same_machine_flag_yn;
 sqlstm.sqinds[18] = (         int  )0;
 sqlstm.sqharm[18] = (unsigned int  )0;
 sqlstm.sqadto[18] = (unsigned short )0;
 sqlstm.sqtdso[18] = (unsigned short )0;
 sqlstm.sqhstv[19] = (         void  *)stepq_sql.group_first_step_yn;
 sqlstm.sqhstl[19] = (unsigned int  )2;
 sqlstm.sqhsts[19] = (         int  )0;
 sqlstm.sqindv[19] = (         void  *)&stepq_sql_ind.group_first_step_yn;
 sqlstm.sqinds[19] = (         int  )0;
 sqlstm.sqharm[19] = (unsigned int  )0;
 sqlstm.sqadto[19] = (unsigned short )0;
 sqlstm.sqtdso[19] = (unsigned short )0;
 sqlstm.sqhstv[20] = (         void  *)stepq_sql.skip_yn;
 sqlstm.sqhstl[20] = (unsigned int  )2;
 sqlstm.sqhsts[20] = (         int  )0;
 sqlstm.sqindv[20] = (         void  *)&stepq_sql_ind.skip_yn;
 sqlstm.sqinds[20] = (         int  )0;
 sqlstm.sqharm[20] = (unsigned int  )0;
 sqlstm.sqadto[20] = (unsigned short )0;
 sqlstm.sqtdso[20] = (unsigned short )0;
 sqlstm.sqhstv[21] = (         void  *)stepq_sql.beg_console_msg;
 sqlstm.sqhstl[21] = (unsigned int  )81;
 sqlstm.sqhsts[21] = (         int  )0;
 sqlstm.sqindv[21] = (         void  *)&stepq_sql_ind.beg_console_msg;
 sqlstm.sqinds[21] = (         int  )0;
 sqlstm.sqharm[21] = (unsigned int  )0;
 sqlstm.sqadto[21] = (unsigned short )0;
 sqlstm.sqtdso[21] = (unsigned short )0;
 sqlstm.sqhstv[22] = (         void  *)stepq_sql.beg_suspend_yn;
 sqlstm.sqhstl[22] = (unsigned int  )2;
 sqlstm.sqhsts[22] = (         int  )0;
 sqlstm.sqindv[22] = (         void  *)&stepq_sql_ind.beg_suspend_yn;
 sqlstm.sqinds[22] = (         int  )0;
 sqlstm.sqharm[22] = (unsigned int  )0;
 sqlstm.sqadto[22] = (unsigned short )0;
 sqlstm.sqtdso[22] = (unsigned short )0;
 sqlstm.sqhstv[23] = (         void  *)stepq_sql.end_console_msg;
 sqlstm.sqhstl[23] = (unsigned int  )81;
 sqlstm.sqhsts[23] = (         int  )0;
 sqlstm.sqindv[23] = (         void  *)&stepq_sql_ind.end_console_msg;
 sqlstm.sqinds[23] = (         int  )0;
 sqlstm.sqharm[23] = (unsigned int  )0;
 sqlstm.sqadto[23] = (unsigned short )0;
 sqlstm.sqtdso[23] = (unsigned short )0;
 sqlstm.sqhstv[24] = (         void  *)stepq_sql.end_suspend_yn;
 sqlstm.sqhstl[24] = (unsigned int  )2;
 sqlstm.sqhsts[24] = (         int  )0;
 sqlstm.sqindv[24] = (         void  *)&stepq_sql_ind.end_suspend_yn;
 sqlstm.sqinds[24] = (         int  )0;
 sqlstm.sqharm[24] = (unsigned int  )0;
 sqlstm.sqadto[24] = (unsigned short )0;
 sqlstm.sqtdso[24] = (unsigned short )0;
 sqlstm.sqhstv[25] = (         void  *)stepq_sql.send_msg;
 sqlstm.sqhstl[25] = (unsigned int  )81;
 sqlstm.sqhsts[25] = (         int  )0;
 sqlstm.sqindv[25] = (         void  *)&stepq_sql_ind.send_msg;
 sqlstm.sqinds[25] = (         int  )0;
 sqlstm.sqharm[25] = (unsigned int  )0;
 sqlstm.sqadto[25] = (unsigned short )0;
 sqlstm.sqtdso[25] = (unsigned short )0;
 sqlstm.sqhstv[26] = (         void  *)stepq_sql.run_if_error;
 sqlstm.sqhstl[26] = (unsigned int  )65;
 sqlstm.sqhsts[26] = (         int  )0;
 sqlstm.sqindv[26] = (         void  *)&stepq_sql_ind.run_if_error;
 sqlstm.sqinds[26] = (         int  )0;
 sqlstm.sqharm[26] = (unsigned int  )0;
 sqlstm.sqadto[26] = (unsigned short )0;
 sqlstm.sqtdso[26] = (unsigned short )0;
 sqlstm.sqhstv[27] = (         void  *)&stepq_sql.status_interval;
 sqlstm.sqhstl[27] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[27] = (         int  )0;
 sqlstm.sqindv[27] = (         void  *)&stepq_sql_ind.status_interval;
 sqlstm.sqinds[27] = (         int  )0;
 sqlstm.sqharm[27] = (unsigned int  )0;
 sqlstm.sqadto[27] = (unsigned short )0;
 sqlstm.sqtdso[27] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}




	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);

   while( l_sqlcode != ORCL_NOT_FOUND )
   {
      if( l_sqlcode != ORCL_NO_ERROR )
	   {
		   ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					   "step_curs", sqlmsg, "STEPQ table", NULL);
		   _ltoa((DWORD) __LINE__, szline, 10);
		   _itoa(l_sqlcode, szcode, 10);
		   copy_cat(tempstr, "Fetch Cursor for step_curs Failed! on line ", szline, 
							   " - SQLCA.SQLCODE=", szcode, " ", sqlmsg, NULL);
		   logit (0, tempstr);
		   debug_log (tempstr);
		   return(-1);
	   }

	    trim_sql_stepq(&stepq_sql);


		stepq_sql.no = job_num;
		strcpy((char*)stepq_sql.status, "N");
		memset(stepq_sql.date_time_started, 0, sizeof(stepq_sql.date_time_started));
		memset(stepq_sql.date_time_completed, 0, sizeof(stepq_sql.date_time_completed));
		stepq_sql.exit_code = 0;
		for(i=0; i < stepq_sql.num_d; i++) 
		{
			stepq_sql.d_cmplt[i] = 0;
			memset(stepq_sql.d_last_tested+(i*10), 0, 10);
		}
		strcpy(stepq_sql.job_machine,"");

      EnterCriticalSection( &jsnt_sql_lock );

   	/* EXEC SQL 
		INSERT into STEPQ VALUES (
			:stepq_sql.no,
			:stepq_sql.step,
			:stepq_sql.s_name,
			:stepq_sql.status,
			:stepq_sql.j_name,
			:stepq_sql.date_time_started,
			:stepq_sql.date_time_completed,
			:stepq_sql.exit_code,
			:stepq_sql.command_line,
			:stepq_sql.num_d,
			:stepq_sql.d_step,
			:stepq_sql.d_cmplt,
			:stepq_sql.d_last_tested,
			:stepq_sql.num_a,
			:stepq_sql.exit_codes_acceptable,
			:stepq_sql.job_machine,
			:stepq_sql.d_group,
			:stepq_sql.group_name,
			:stepq_sql.same_machine_flag_yn,
			:stepq_sql.group_first_step_yn,
			:stepq_sql.skip_yn,
			:stepq_sql.beg_console_msg,
			:stepq_sql.beg_suspend_yn,
			:stepq_sql.end_console_msg,
			:stepq_sql.end_suspend_yn,
			:stepq_sql.send_msg,
			:stepq_sql.run_if_error,
         :stepq_sql.status_interval); */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 28;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.stmt = "insert into STEPQ  values (:b0,:b1,:b2,:b3,:b4,:b5,:b6,:b\
7,:b8,:b9,:b10,:b11,:b12,:b13,:b14,:b15,:b16,:b17,:b18,:b19,:b20,:b21,:b22,:b2\
3,:b24,:b25,:b26,:b27)";
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )2821;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlstm.sqhstv[0] = (         void  *)&(stepq_sql.no);
    sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
    sqlstm.sqhsts[0] = (         int  )0;
    sqlstm.sqindv[0] = (         void  *)0;
    sqlstm.sqinds[0] = (         int  )0;
    sqlstm.sqharm[0] = (unsigned int  )0;
    sqlstm.sqadto[0] = (unsigned short )0;
    sqlstm.sqtdso[0] = (unsigned short )0;
    sqlstm.sqhstv[1] = (         void  *)&(stepq_sql.step);
    sqlstm.sqhstl[1] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[1] = (         int  )0;
    sqlstm.sqindv[1] = (         void  *)0;
    sqlstm.sqinds[1] = (         int  )0;
    sqlstm.sqharm[1] = (unsigned int  )0;
    sqlstm.sqadto[1] = (unsigned short )0;
    sqlstm.sqtdso[1] = (unsigned short )0;
    sqlstm.sqhstv[2] = (         void  *)(stepq_sql.s_name);
    sqlstm.sqhstl[2] = (unsigned int  )10;
    sqlstm.sqhsts[2] = (         int  )0;
    sqlstm.sqindv[2] = (         void  *)0;
    sqlstm.sqinds[2] = (         int  )0;
    sqlstm.sqharm[2] = (unsigned int  )0;
    sqlstm.sqadto[2] = (unsigned short )0;
    sqlstm.sqtdso[2] = (unsigned short )0;
    sqlstm.sqhstv[3] = (         void  *)(stepq_sql.status);
    sqlstm.sqhstl[3] = (unsigned int  )2;
    sqlstm.sqhsts[3] = (         int  )0;
    sqlstm.sqindv[3] = (         void  *)0;
    sqlstm.sqinds[3] = (         int  )0;
    sqlstm.sqharm[3] = (unsigned int  )0;
    sqlstm.sqadto[3] = (unsigned short )0;
    sqlstm.sqtdso[3] = (unsigned short )0;
    sqlstm.sqhstv[4] = (         void  *)(stepq_sql.j_name);
    sqlstm.sqhstl[4] = (unsigned int  )10;
    sqlstm.sqhsts[4] = (         int  )0;
    sqlstm.sqindv[4] = (         void  *)0;
    sqlstm.sqinds[4] = (         int  )0;
    sqlstm.sqharm[4] = (unsigned int  )0;
    sqlstm.sqadto[4] = (unsigned short )0;
    sqlstm.sqtdso[4] = (unsigned short )0;
    sqlstm.sqhstv[5] = (         void  *)(stepq_sql.date_time_started);
    sqlstm.sqhstl[5] = (unsigned int  )15;
    sqlstm.sqhsts[5] = (         int  )0;
    sqlstm.sqindv[5] = (         void  *)0;
    sqlstm.sqinds[5] = (         int  )0;
    sqlstm.sqharm[5] = (unsigned int  )0;
    sqlstm.sqadto[5] = (unsigned short )0;
    sqlstm.sqtdso[5] = (unsigned short )0;
    sqlstm.sqhstv[6] = (         void  *)(stepq_sql.date_time_completed);
    sqlstm.sqhstl[6] = (unsigned int  )15;
    sqlstm.sqhsts[6] = (         int  )0;
    sqlstm.sqindv[6] = (         void  *)0;
    sqlstm.sqinds[6] = (         int  )0;
    sqlstm.sqharm[6] = (unsigned int  )0;
    sqlstm.sqadto[6] = (unsigned short )0;
    sqlstm.sqtdso[6] = (unsigned short )0;
    sqlstm.sqhstv[7] = (         void  *)&(stepq_sql.exit_code);
    sqlstm.sqhstl[7] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[7] = (         int  )0;
    sqlstm.sqindv[7] = (         void  *)0;
    sqlstm.sqinds[7] = (         int  )0;
    sqlstm.sqharm[7] = (unsigned int  )0;
    sqlstm.sqadto[7] = (unsigned short )0;
    sqlstm.sqtdso[7] = (unsigned short )0;
    sqlstm.sqhstv[8] = (         void  *)(stepq_sql.command_line);
    sqlstm.sqhstl[8] = (unsigned int  )140;
    sqlstm.sqhsts[8] = (         int  )0;
    sqlstm.sqindv[8] = (         void  *)0;
    sqlstm.sqinds[8] = (         int  )0;
    sqlstm.sqharm[8] = (unsigned int  )0;
    sqlstm.sqadto[8] = (unsigned short )0;
    sqlstm.sqtdso[8] = (unsigned short )0;
    sqlstm.sqhstv[9] = (         void  *)&(stepq_sql.num_d);
    sqlstm.sqhstl[9] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[9] = (         int  )0;
    sqlstm.sqindv[9] = (         void  *)0;
    sqlstm.sqinds[9] = (         int  )0;
    sqlstm.sqharm[9] = (unsigned int  )0;
    sqlstm.sqadto[9] = (unsigned short )0;
    sqlstm.sqtdso[9] = (unsigned short )0;
    sqlstm.sqhstv[10] = (         void  *)(stepq_sql.d_step);
    sqlstm.sqhstl[10] = (unsigned int  )180;
    sqlstm.sqhsts[10] = (         int  )0;
    sqlstm.sqindv[10] = (         void  *)0;
    sqlstm.sqinds[10] = (         int  )0;
    sqlstm.sqharm[10] = (unsigned int  )0;
    sqlstm.sqadto[10] = (unsigned short )0;
    sqlstm.sqtdso[10] = (unsigned short )0;
    sqlstm.sqhstv[11] = (         void  *)(stepq_sql.d_cmplt);
    sqlstm.sqhstl[11] = (unsigned int  )20;
    sqlstm.sqhsts[11] = (         int  )0;
    sqlstm.sqindv[11] = (         void  *)0;
    sqlstm.sqinds[11] = (         int  )0;
    sqlstm.sqharm[11] = (unsigned int  )0;
    sqlstm.sqadto[11] = (unsigned short )0;
    sqlstm.sqtdso[11] = (unsigned short )0;
    sqlstm.sqhstv[12] = (         void  *)(stepq_sql.d_last_tested);
    sqlstm.sqhstl[12] = (unsigned int  )200;
    sqlstm.sqhsts[12] = (         int  )0;
    sqlstm.sqindv[12] = (         void  *)0;
    sqlstm.sqinds[12] = (         int  )0;
    sqlstm.sqharm[12] = (unsigned int  )0;
    sqlstm.sqadto[12] = (unsigned short )0;
    sqlstm.sqtdso[12] = (unsigned short )0;
    sqlstm.sqhstv[13] = (         void  *)&(stepq_sql.num_a);
    sqlstm.sqhstl[13] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[13] = (         int  )0;
    sqlstm.sqindv[13] = (         void  *)0;
    sqlstm.sqinds[13] = (         int  )0;
    sqlstm.sqharm[13] = (unsigned int  )0;
    sqlstm.sqadto[13] = (unsigned short )0;
    sqlstm.sqtdso[13] = (unsigned short )0;
    sqlstm.sqhstv[14] = (         void  *)(stepq_sql.exit_codes_acceptable);
    sqlstm.sqhstl[14] = (unsigned int  )100;
    sqlstm.sqhsts[14] = (         int  )0;
    sqlstm.sqindv[14] = (         void  *)0;
    sqlstm.sqinds[14] = (         int  )0;
    sqlstm.sqharm[14] = (unsigned int  )0;
    sqlstm.sqadto[14] = (unsigned short )0;
    sqlstm.sqtdso[14] = (unsigned short )0;
    sqlstm.sqhstv[15] = (         void  *)(stepq_sql.job_machine);
    sqlstm.sqhstl[15] = (unsigned int  )10;
    sqlstm.sqhsts[15] = (         int  )0;
    sqlstm.sqindv[15] = (         void  *)0;
    sqlstm.sqinds[15] = (         int  )0;
    sqlstm.sqharm[15] = (unsigned int  )0;
    sqlstm.sqadto[15] = (unsigned short )0;
    sqlstm.sqtdso[15] = (unsigned short )0;
    sqlstm.sqhstv[16] = (         void  *)(stepq_sql.d_group);
    sqlstm.sqhstl[16] = (unsigned int  )21;
    sqlstm.sqhsts[16] = (         int  )0;
    sqlstm.sqindv[16] = (         void  *)0;
    sqlstm.sqinds[16] = (         int  )0;
    sqlstm.sqharm[16] = (unsigned int  )0;
    sqlstm.sqadto[16] = (unsigned short )0;
    sqlstm.sqtdso[16] = (unsigned short )0;
    sqlstm.sqhstv[17] = (         void  *)(stepq_sql.group_name);
    sqlstm.sqhstl[17] = (unsigned int  )10;
    sqlstm.sqhsts[17] = (         int  )0;
    sqlstm.sqindv[17] = (         void  *)0;
    sqlstm.sqinds[17] = (         int  )0;
    sqlstm.sqharm[17] = (unsigned int  )0;
    sqlstm.sqadto[17] = (unsigned short )0;
    sqlstm.sqtdso[17] = (unsigned short )0;
    sqlstm.sqhstv[18] = (         void  *)(stepq_sql.same_machine_flag_yn);
    sqlstm.sqhstl[18] = (unsigned int  )2;
    sqlstm.sqhsts[18] = (         int  )0;
    sqlstm.sqindv[18] = (         void  *)0;
    sqlstm.sqinds[18] = (         int  )0;
    sqlstm.sqharm[18] = (unsigned int  )0;
    sqlstm.sqadto[18] = (unsigned short )0;
    sqlstm.sqtdso[18] = (unsigned short )0;
    sqlstm.sqhstv[19] = (         void  *)(stepq_sql.group_first_step_yn);
    sqlstm.sqhstl[19] = (unsigned int  )2;
    sqlstm.sqhsts[19] = (         int  )0;
    sqlstm.sqindv[19] = (         void  *)0;
    sqlstm.sqinds[19] = (         int  )0;
    sqlstm.sqharm[19] = (unsigned int  )0;
    sqlstm.sqadto[19] = (unsigned short )0;
    sqlstm.sqtdso[19] = (unsigned short )0;
    sqlstm.sqhstv[20] = (         void  *)(stepq_sql.skip_yn);
    sqlstm.sqhstl[20] = (unsigned int  )2;
    sqlstm.sqhsts[20] = (         int  )0;
    sqlstm.sqindv[20] = (         void  *)0;
    sqlstm.sqinds[20] = (         int  )0;
    sqlstm.sqharm[20] = (unsigned int  )0;
    sqlstm.sqadto[20] = (unsigned short )0;
    sqlstm.sqtdso[20] = (unsigned short )0;
    sqlstm.sqhstv[21] = (         void  *)(stepq_sql.beg_console_msg);
    sqlstm.sqhstl[21] = (unsigned int  )81;
    sqlstm.sqhsts[21] = (         int  )0;
    sqlstm.sqindv[21] = (         void  *)0;
    sqlstm.sqinds[21] = (         int  )0;
    sqlstm.sqharm[21] = (unsigned int  )0;
    sqlstm.sqadto[21] = (unsigned short )0;
    sqlstm.sqtdso[21] = (unsigned short )0;
    sqlstm.sqhstv[22] = (         void  *)(stepq_sql.beg_suspend_yn);
    sqlstm.sqhstl[22] = (unsigned int  )2;
    sqlstm.sqhsts[22] = (         int  )0;
    sqlstm.sqindv[22] = (         void  *)0;
    sqlstm.sqinds[22] = (         int  )0;
    sqlstm.sqharm[22] = (unsigned int  )0;
    sqlstm.sqadto[22] = (unsigned short )0;
    sqlstm.sqtdso[22] = (unsigned short )0;
    sqlstm.sqhstv[23] = (         void  *)(stepq_sql.end_console_msg);
    sqlstm.sqhstl[23] = (unsigned int  )81;
    sqlstm.sqhsts[23] = (         int  )0;
    sqlstm.sqindv[23] = (         void  *)0;
    sqlstm.sqinds[23] = (         int  )0;
    sqlstm.sqharm[23] = (unsigned int  )0;
    sqlstm.sqadto[23] = (unsigned short )0;
    sqlstm.sqtdso[23] = (unsigned short )0;
    sqlstm.sqhstv[24] = (         void  *)(stepq_sql.end_suspend_yn);
    sqlstm.sqhstl[24] = (unsigned int  )2;
    sqlstm.sqhsts[24] = (         int  )0;
    sqlstm.sqindv[24] = (         void  *)0;
    sqlstm.sqinds[24] = (         int  )0;
    sqlstm.sqharm[24] = (unsigned int  )0;
    sqlstm.sqadto[24] = (unsigned short )0;
    sqlstm.sqtdso[24] = (unsigned short )0;
    sqlstm.sqhstv[25] = (         void  *)(stepq_sql.send_msg);
    sqlstm.sqhstl[25] = (unsigned int  )81;
    sqlstm.sqhsts[25] = (         int  )0;
    sqlstm.sqindv[25] = (         void  *)0;
    sqlstm.sqinds[25] = (         int  )0;
    sqlstm.sqharm[25] = (unsigned int  )0;
    sqlstm.sqadto[25] = (unsigned short )0;
    sqlstm.sqtdso[25] = (unsigned short )0;
    sqlstm.sqhstv[26] = (         void  *)(stepq_sql.run_if_error);
    sqlstm.sqhstl[26] = (unsigned int  )65;
    sqlstm.sqhsts[26] = (         int  )0;
    sqlstm.sqindv[26] = (         void  *)0;
    sqlstm.sqinds[26] = (         int  )0;
    sqlstm.sqharm[26] = (unsigned int  )0;
    sqlstm.sqadto[26] = (unsigned short )0;
    sqlstm.sqtdso[26] = (unsigned short )0;
    sqlstm.sqhstv[27] = (         void  *)&(stepq_sql.status_interval);
    sqlstm.sqhstl[27] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[27] = (         int  )0;
    sqlstm.sqindv[27] = (         void  *)0;
    sqlstm.sqinds[27] = (         int  )0;
    sqlstm.sqharm[27] = (unsigned int  )0;
    sqlstm.sqadto[27] = (unsigned short )0;
    sqlstm.sqtdso[27] = (unsigned short )0;
    sqlstm.sqphsv = sqlstm.sqhstv;
    sqlstm.sqphsl = sqlstm.sqhstl;
    sqlstm.sqphss = sqlstm.sqhsts;
    sqlstm.sqpind = sqlstm.sqindv;
    sqlstm.sqpins = sqlstm.sqinds;
    sqlstm.sqparm = sqlstm.sqharm;
    sqlstm.sqparc = sqlstm.sqharc;
    sqlstm.sqpadto = sqlstm.sqadto;
    sqlstm.sqptdso = sqlstm.sqtdso;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

  

      l_sqlcode = sqlca.sqlcode;
      strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

      LeaveCriticalSection( &jsnt_sql_lock );

      if ( l_sqlcode != ORCL_NO_ERROR)
      {
         ifs_custerr("ORC_INSERT", __FILE__, __LINE__, IFS_LOG, 
            "STEPQ", "no", " ", sqlmsg, " ", NULL);

         sprintf(tempstr, "ERROR: INSERT of STEPQ table failed: Job Number - %d, Job Name - %s",
                   job_q.no, job_q.name);
         if (submit_error) submit_error(tempstr);
         return(-1);
      }

      EnterCriticalSection( &jsnt_sql_lock );

      /* EXEC SQL COMMIT; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 28;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )2948;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



      l_sqlcode = sqlca.sqlcode;
      strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

      LeaveCriticalSection( &jsnt_sql_lock );

      if( l_sqlcode != ORCL_NO_ERROR )
      {
         ifs_custerr("ORC_COMMIT", __FILE__, __LINE__, IFS_LOG, 
            sqlmsg, "STEPQ table", NULL);

         sprintf(tempstr, 
            "ERROR: COMMIT after insert into STEPQ table failed: Job Number - %d,Job Name - %s",
                  job_q.no, job_q.name);
         if (submit_error) submit_error(tempstr);
         return(-1);
      }

	   EnterCriticalSection(&jsnt_sql_lock);

	   /* EXEC SQL FETCH step_curs INTO :stepq_sql:stepq_sql_ind; */ 

{
    struct sqlexd sqlstm;
    sqlstm.sqlvsn = 13;
    sqlstm.arrsiz = 28;
    sqlstm.sqladtp = &sqladt;
    sqlstm.sqltdsp = &sqltds;
    sqlstm.iters = (unsigned int  )1;
    sqlstm.offset = (unsigned int  )2963;
    sqlstm.selerr = (unsigned short)0;
    sqlstm.sqlpfmem = (unsigned int  )0;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlstm.sqfoff = (           int )0;
    sqlstm.sqfmod = (unsigned int )2;
    sqlstm.sqhstv[0] = (         void  *)&stepq_sql.no;
    sqlstm.sqhstl[0] = (unsigned int  )sizeof(long);
    sqlstm.sqhsts[0] = (         int  )0;
    sqlstm.sqindv[0] = (         void  *)&stepq_sql_ind.no;
    sqlstm.sqinds[0] = (         int  )0;
    sqlstm.sqharm[0] = (unsigned int  )0;
    sqlstm.sqadto[0] = (unsigned short )0;
    sqlstm.sqtdso[0] = (unsigned short )0;
    sqlstm.sqhstv[1] = (         void  *)&stepq_sql.step;
    sqlstm.sqhstl[1] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[1] = (         int  )0;
    sqlstm.sqindv[1] = (         void  *)&stepq_sql_ind.step;
    sqlstm.sqinds[1] = (         int  )0;
    sqlstm.sqharm[1] = (unsigned int  )0;
    sqlstm.sqadto[1] = (unsigned short )0;
    sqlstm.sqtdso[1] = (unsigned short )0;
    sqlstm.sqhstv[2] = (         void  *)stepq_sql.s_name;
    sqlstm.sqhstl[2] = (unsigned int  )10;
    sqlstm.sqhsts[2] = (         int  )0;
    sqlstm.sqindv[2] = (         void  *)&stepq_sql_ind.s_name;
    sqlstm.sqinds[2] = (         int  )0;
    sqlstm.sqharm[2] = (unsigned int  )0;
    sqlstm.sqadto[2] = (unsigned short )0;
    sqlstm.sqtdso[2] = (unsigned short )0;
    sqlstm.sqhstv[3] = (         void  *)stepq_sql.status;
    sqlstm.sqhstl[3] = (unsigned int  )2;
    sqlstm.sqhsts[3] = (         int  )0;
    sqlstm.sqindv[3] = (         void  *)&stepq_sql_ind.status;
    sqlstm.sqinds[3] = (         int  )0;
    sqlstm.sqharm[3] = (unsigned int  )0;
    sqlstm.sqadto[3] = (unsigned short )0;
    sqlstm.sqtdso[3] = (unsigned short )0;
    sqlstm.sqhstv[4] = (         void  *)stepq_sql.j_name;
    sqlstm.sqhstl[4] = (unsigned int  )10;
    sqlstm.sqhsts[4] = (         int  )0;
    sqlstm.sqindv[4] = (         void  *)&stepq_sql_ind.j_name;
    sqlstm.sqinds[4] = (         int  )0;
    sqlstm.sqharm[4] = (unsigned int  )0;
    sqlstm.sqadto[4] = (unsigned short )0;
    sqlstm.sqtdso[4] = (unsigned short )0;
    sqlstm.sqhstv[5] = (         void  *)stepq_sql.date_time_started;
    sqlstm.sqhstl[5] = (unsigned int  )15;
    sqlstm.sqhsts[5] = (         int  )0;
    sqlstm.sqindv[5] = (         void  *)&stepq_sql_ind.time_started;
    sqlstm.sqinds[5] = (         int  )0;
    sqlstm.sqharm[5] = (unsigned int  )0;
    sqlstm.sqadto[5] = (unsigned short )0;
    sqlstm.sqtdso[5] = (unsigned short )0;
    sqlstm.sqhstv[6] = (         void  *)stepq_sql.date_time_completed;
    sqlstm.sqhstl[6] = (unsigned int  )15;
    sqlstm.sqhsts[6] = (         int  )0;
    sqlstm.sqindv[6] = (         void  *)&stepq_sql_ind.time_completed;
    sqlstm.sqinds[6] = (         int  )0;
    sqlstm.sqharm[6] = (unsigned int  )0;
    sqlstm.sqadto[6] = (unsigned short )0;
    sqlstm.sqtdso[6] = (unsigned short )0;
    sqlstm.sqhstv[7] = (         void  *)&stepq_sql.exit_code;
    sqlstm.sqhstl[7] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[7] = (         int  )0;
    sqlstm.sqindv[7] = (         void  *)&stepq_sql_ind.exit_code;
    sqlstm.sqinds[7] = (         int  )0;
    sqlstm.sqharm[7] = (unsigned int  )0;
    sqlstm.sqadto[7] = (unsigned short )0;
    sqlstm.sqtdso[7] = (unsigned short )0;
    sqlstm.sqhstv[8] = (         void  *)stepq_sql.command_line;
    sqlstm.sqhstl[8] = (unsigned int  )140;
    sqlstm.sqhsts[8] = (         int  )0;
    sqlstm.sqindv[8] = (         void  *)&stepq_sql_ind.command_line;
    sqlstm.sqinds[8] = (         int  )0;
    sqlstm.sqharm[8] = (unsigned int  )0;
    sqlstm.sqadto[8] = (unsigned short )0;
    sqlstm.sqtdso[8] = (unsigned short )0;
    sqlstm.sqhstv[9] = (         void  *)&stepq_sql.num_d;
    sqlstm.sqhstl[9] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[9] = (         int  )0;
    sqlstm.sqindv[9] = (         void  *)&stepq_sql_ind.num_d;
    sqlstm.sqinds[9] = (         int  )0;
    sqlstm.sqharm[9] = (unsigned int  )0;
    sqlstm.sqadto[9] = (unsigned short )0;
    sqlstm.sqtdso[9] = (unsigned short )0;
    sqlstm.sqhstv[10] = (         void  *)stepq_sql.d_step;
    sqlstm.sqhstl[10] = (unsigned int  )180;
    sqlstm.sqhsts[10] = (         int  )0;
    sqlstm.sqindv[10] = (         void  *)&stepq_sql_ind.d_step;
    sqlstm.sqinds[10] = (         int  )0;
    sqlstm.sqharm[10] = (unsigned int  )0;
    sqlstm.sqadto[10] = (unsigned short )0;
    sqlstm.sqtdso[10] = (unsigned short )0;
    sqlstm.sqhstv[11] = (         void  *)stepq_sql.d_cmplt;
    sqlstm.sqhstl[11] = (unsigned int  )20;
    sqlstm.sqhsts[11] = (         int  )0;
    sqlstm.sqindv[11] = (         void  *)&stepq_sql_ind.d_cmplt;
    sqlstm.sqinds[11] = (         int  )0;
    sqlstm.sqharm[11] = (unsigned int  )0;
    sqlstm.sqadto[11] = (unsigned short )0;
    sqlstm.sqtdso[11] = (unsigned short )0;
    sqlstm.sqhstv[12] = (         void  *)stepq_sql.d_last_tested;
    sqlstm.sqhstl[12] = (unsigned int  )200;
    sqlstm.sqhsts[12] = (         int  )0;
    sqlstm.sqindv[12] = (         void  *)&stepq_sql_ind.d_last_tested;
    sqlstm.sqinds[12] = (         int  )0;
    sqlstm.sqharm[12] = (unsigned int  )0;
    sqlstm.sqadto[12] = (unsigned short )0;
    sqlstm.sqtdso[12] = (unsigned short )0;
    sqlstm.sqhstv[13] = (         void  *)&stepq_sql.num_a;
    sqlstm.sqhstl[13] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[13] = (         int  )0;
    sqlstm.sqindv[13] = (         void  *)&stepq_sql_ind.num_a;
    sqlstm.sqinds[13] = (         int  )0;
    sqlstm.sqharm[13] = (unsigned int  )0;
    sqlstm.sqadto[13] = (unsigned short )0;
    sqlstm.sqtdso[13] = (unsigned short )0;
    sqlstm.sqhstv[14] = (         void  *)stepq_sql.exit_codes_acceptable;
    sqlstm.sqhstl[14] = (unsigned int  )100;
    sqlstm.sqhsts[14] = (         int  )0;
    sqlstm.sqindv[14] = (         void  *)&stepq_sql_ind.exit_codes_acceptable;
    sqlstm.sqinds[14] = (         int  )0;
    sqlstm.sqharm[14] = (unsigned int  )0;
    sqlstm.sqadto[14] = (unsigned short )0;
    sqlstm.sqtdso[14] = (unsigned short )0;
    sqlstm.sqhstv[15] = (         void  *)stepq_sql.job_machine;
    sqlstm.sqhstl[15] = (unsigned int  )10;
    sqlstm.sqhsts[15] = (         int  )0;
    sqlstm.sqindv[15] = (         void  *)&stepq_sql_ind.job_machine;
    sqlstm.sqinds[15] = (         int  )0;
    sqlstm.sqharm[15] = (unsigned int  )0;
    sqlstm.sqadto[15] = (unsigned short )0;
    sqlstm.sqtdso[15] = (unsigned short )0;
    sqlstm.sqhstv[16] = (         void  *)stepq_sql.d_group;
    sqlstm.sqhstl[16] = (unsigned int  )21;
    sqlstm.sqhsts[16] = (         int  )0;
    sqlstm.sqindv[16] = (         void  *)&stepq_sql_ind.d_group;
    sqlstm.sqinds[16] = (         int  )0;
    sqlstm.sqharm[16] = (unsigned int  )0;
    sqlstm.sqadto[16] = (unsigned short )0;
    sqlstm.sqtdso[16] = (unsigned short )0;
    sqlstm.sqhstv[17] = (         void  *)stepq_sql.group_name;
    sqlstm.sqhstl[17] = (unsigned int  )10;
    sqlstm.sqhsts[17] = (         int  )0;
    sqlstm.sqindv[17] = (         void  *)&stepq_sql_ind.group_name;
    sqlstm.sqinds[17] = (         int  )0;
    sqlstm.sqharm[17] = (unsigned int  )0;
    sqlstm.sqadto[17] = (unsigned short )0;
    sqlstm.sqtdso[17] = (unsigned short )0;
    sqlstm.sqhstv[18] = (         void  *)stepq_sql.same_machine_flag_yn;
    sqlstm.sqhstl[18] = (unsigned int  )2;
    sqlstm.sqhsts[18] = (         int  )0;
    sqlstm.sqindv[18] = (         void  *)&stepq_sql_ind.same_machine_flag_yn;
    sqlstm.sqinds[18] = (         int  )0;
    sqlstm.sqharm[18] = (unsigned int  )0;
    sqlstm.sqadto[18] = (unsigned short )0;
    sqlstm.sqtdso[18] = (unsigned short )0;
    sqlstm.sqhstv[19] = (         void  *)stepq_sql.group_first_step_yn;
    sqlstm.sqhstl[19] = (unsigned int  )2;
    sqlstm.sqhsts[19] = (         int  )0;
    sqlstm.sqindv[19] = (         void  *)&stepq_sql_ind.group_first_step_yn;
    sqlstm.sqinds[19] = (         int  )0;
    sqlstm.sqharm[19] = (unsigned int  )0;
    sqlstm.sqadto[19] = (unsigned short )0;
    sqlstm.sqtdso[19] = (unsigned short )0;
    sqlstm.sqhstv[20] = (         void  *)stepq_sql.skip_yn;
    sqlstm.sqhstl[20] = (unsigned int  )2;
    sqlstm.sqhsts[20] = (         int  )0;
    sqlstm.sqindv[20] = (         void  *)&stepq_sql_ind.skip_yn;
    sqlstm.sqinds[20] = (         int  )0;
    sqlstm.sqharm[20] = (unsigned int  )0;
    sqlstm.sqadto[20] = (unsigned short )0;
    sqlstm.sqtdso[20] = (unsigned short )0;
    sqlstm.sqhstv[21] = (         void  *)stepq_sql.beg_console_msg;
    sqlstm.sqhstl[21] = (unsigned int  )81;
    sqlstm.sqhsts[21] = (         int  )0;
    sqlstm.sqindv[21] = (         void  *)&stepq_sql_ind.beg_console_msg;
    sqlstm.sqinds[21] = (         int  )0;
    sqlstm.sqharm[21] = (unsigned int  )0;
    sqlstm.sqadto[21] = (unsigned short )0;
    sqlstm.sqtdso[21] = (unsigned short )0;
    sqlstm.sqhstv[22] = (         void  *)stepq_sql.beg_suspend_yn;
    sqlstm.sqhstl[22] = (unsigned int  )2;
    sqlstm.sqhsts[22] = (         int  )0;
    sqlstm.sqindv[22] = (         void  *)&stepq_sql_ind.beg_suspend_yn;
    sqlstm.sqinds[22] = (         int  )0;
    sqlstm.sqharm[22] = (unsigned int  )0;
    sqlstm.sqadto[22] = (unsigned short )0;
    sqlstm.sqtdso[22] = (unsigned short )0;
    sqlstm.sqhstv[23] = (         void  *)stepq_sql.end_console_msg;
    sqlstm.sqhstl[23] = (unsigned int  )81;
    sqlstm.sqhsts[23] = (         int  )0;
    sqlstm.sqindv[23] = (         void  *)&stepq_sql_ind.end_console_msg;
    sqlstm.sqinds[23] = (         int  )0;
    sqlstm.sqharm[23] = (unsigned int  )0;
    sqlstm.sqadto[23] = (unsigned short )0;
    sqlstm.sqtdso[23] = (unsigned short )0;
    sqlstm.sqhstv[24] = (         void  *)stepq_sql.end_suspend_yn;
    sqlstm.sqhstl[24] = (unsigned int  )2;
    sqlstm.sqhsts[24] = (         int  )0;
    sqlstm.sqindv[24] = (         void  *)&stepq_sql_ind.end_suspend_yn;
    sqlstm.sqinds[24] = (         int  )0;
    sqlstm.sqharm[24] = (unsigned int  )0;
    sqlstm.sqadto[24] = (unsigned short )0;
    sqlstm.sqtdso[24] = (unsigned short )0;
    sqlstm.sqhstv[25] = (         void  *)stepq_sql.send_msg;
    sqlstm.sqhstl[25] = (unsigned int  )81;
    sqlstm.sqhsts[25] = (         int  )0;
    sqlstm.sqindv[25] = (         void  *)&stepq_sql_ind.send_msg;
    sqlstm.sqinds[25] = (         int  )0;
    sqlstm.sqharm[25] = (unsigned int  )0;
    sqlstm.sqadto[25] = (unsigned short )0;
    sqlstm.sqtdso[25] = (unsigned short )0;
    sqlstm.sqhstv[26] = (         void  *)stepq_sql.run_if_error;
    sqlstm.sqhstl[26] = (unsigned int  )65;
    sqlstm.sqhsts[26] = (         int  )0;
    sqlstm.sqindv[26] = (         void  *)&stepq_sql_ind.run_if_error;
    sqlstm.sqinds[26] = (         int  )0;
    sqlstm.sqharm[26] = (unsigned int  )0;
    sqlstm.sqadto[26] = (unsigned short )0;
    sqlstm.sqtdso[26] = (unsigned short )0;
    sqlstm.sqhstv[27] = (         void  *)&stepq_sql.status_interval;
    sqlstm.sqhstl[27] = (unsigned int  )sizeof(short);
    sqlstm.sqhsts[27] = (         int  )0;
    sqlstm.sqindv[27] = (         void  *)&stepq_sql_ind.status_interval;
    sqlstm.sqinds[27] = (         int  )0;
    sqlstm.sqharm[27] = (unsigned int  )0;
    sqlstm.sqadto[27] = (unsigned short )0;
    sqlstm.sqtdso[27] = (unsigned short )0;
    sqlstm.sqphsv = sqlstm.sqhstv;
    sqlstm.sqphsl = sqlstm.sqhstl;
    sqlstm.sqphss = sqlstm.sqhsts;
    sqlstm.sqpind = sqlstm.sqindv;
    sqlstm.sqpins = sqlstm.sqinds;
    sqlstm.sqparm = sqlstm.sqharm;
    sqlstm.sqparc = sqlstm.sqharc;
    sqlstm.sqpadto = sqlstm.sqadto;
    sqlstm.sqptdso = sqlstm.sqtdso;
    sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	   l_sqlcode = sqlca.sqlcode;
	   strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

	   LeaveCriticalSection(&jsnt_sql_lock);
   }


/* Get System Date & Time */
	memset(dt_tm, 0, sizeof(dt_tm) );

   EnterCriticalSection( &jsnt_sql_lock );

	/* EXEC SQL SELECT to_char(sysdate, 'YYYYMMDDHH24MISS')
		     INTO :dt_tm
			 FROM dual; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 28;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = "select to_char(sysdate,'YYYYMMDDHH24MISS') into :b0  from du\
al ";
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )3090;
 sqlstm.selerr = (unsigned short)1;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqhstv[0] = (         void  *)dt_tm;
 sqlstm.sqhstl[0] = (unsigned int  )15;
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

   LeaveCriticalSection( &jsnt_sql_lock );

	if (sqlca.sqlcode != ORCL_NO_ERROR)
	{
      ifs_custerr("ORC_SELECT", __FILE__, __LINE__, IFS_LOG, 
         "DUAL", sqlmsg, "Selecting Date/Time in submit()", NULL);

		sprintf(tempstr, 
            "ERROR: 1. Cannot get Date/Time from Dual: Job Number - %d, Job Name - %s", 
            job_q.no, job_q.name);
		if (submit_error) submit_error(tempstr);
		return(-1);
	}


	strcpy(job_q.status, "S");
	job_q.no = job_num;
	strcpy(job_q.date_time_entered, dt_tm);
	memset(job_q.date_time_started, 0, sizeof(job_q.date_time_started));
    memset(job_q.date_time_completed, 0, sizeof(job_q.date_time_completed));
	job_q.exit_code=0;
	sprintf(job_q.date_time_to_start, "%s%s", new_date, new_time);
	job_q.start_stat = job_q.orig_start_stat;
	strcpy(job_q.c_msg_sent_yn, "N");
	strcpy(job_q.s_msg_sent_yn, "N");
	strcpy(job_q.msg_when_failed, "0");
	strcpy((char*)job_q.stn_started,"");
	for(i=0; i < job_q.num_d; i++) 
	{
		job_q.d_cmplt[i]=0;
		memset(job_q.d_last_tested+(i*10), 0, 10);
	}
  	if( !strcpy(job_q.stn_dependancy_yn, "N") )
         strcpy(job_q.station,"");

   EnterCriticalSection( &jsnt_sql_lock );

	/* EXEC SQL 
		INSERT into JOBQ VALUES
	(
		:job_q.status,
		:job_q.pos,
		:job_q.name,
		:job_q.no,
		:job_q.station,
		:job_q.date_time_entered,
		:job_q.date_time_started,
		:job_q.date_time_completed,
		:job_q.exit_code,
		:job_q.station_submitting,
		:job_q.msg_when_started,
		:job_q.msg_when_done,
		:job_q.multi_processing,
		:job_q.date_time_to_start,
		:job_q.start_stat,
		:job_q.must_complete_by,
		:job_q.c_msg_sent_yn,
		:job_q.must_start_by,
		:job_q.s_msg_sent_yn,
		:job_q.msg_to_operator_yn,
		:job_q.msg_to,
		:job_q.priority,
		:job_q.stn_started,
		:job_q.num_d,
		:job_q.d_job,
		:job_q.d_hrs_back,
		:job_q.d_cmplt,
		:job_q.d_last_tested,
		:job_q.orig_start_stat,
		:job_q.job_suspended,
		:job_q.restart,
		:job_q.job_class,
		:job_q.base_dir,
		:job_q.max_job_time_warn,
		:job_q.debug_mode_yn,
		:job_q.last_step,
		:job_q.last_s_name,
		:job_q.last_g_name,
		:job_q.submitted_file_name,
		:job_q.p_msg_sent_yn,
		:job_q.max_job_time_kill,
		:job_q.max_c_msg_yn,
		:job_q.stn_dependancy_yn,
		:job_q.no_fail_message_yn,
		:job_q.msg_when_failed,
      :job_q.spawn_algorithm,  
      :job_q.spawn_parm,
	  :job_q.d_station,
	  :job_q.jsgroup); */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 49;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = "insert into JOBQ  values (:b0,:b1,:b2,:b3,:b4,:b5,:b6,:b7,:b\
8,:b9,:b10,:b11,:b12,:b13,:b14,:b15,:b16,:b17,:b18,:b19,:b20,:b21,:b22,:b23,:b\
24,:b25,:b26,:b27,:b28,:b29,:b30,:b31,:b32,:b33,:b34,:b35,:b36,:b37,:b38,:b39,\
:b40,:b41,:b42,:b43,:b44,:b45,:b46,:b47,:b48)";
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )3109;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqhstv[0] = (         void  *)(job_q.status);
 sqlstm.sqhstl[0] = (unsigned int  )2;
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)&(job_q.pos);
 sqlstm.sqhstl[1] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqhstv[2] = (         void  *)(job_q.name);
 sqlstm.sqhstl[2] = (unsigned int  )10;
 sqlstm.sqhsts[2] = (         int  )0;
 sqlstm.sqindv[2] = (         void  *)0;
 sqlstm.sqinds[2] = (         int  )0;
 sqlstm.sqharm[2] = (unsigned int  )0;
 sqlstm.sqadto[2] = (unsigned short )0;
 sqlstm.sqtdso[2] = (unsigned short )0;
 sqlstm.sqhstv[3] = (         void  *)&(job_q.no);
 sqlstm.sqhstl[3] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[3] = (         int  )0;
 sqlstm.sqindv[3] = (         void  *)0;
 sqlstm.sqinds[3] = (         int  )0;
 sqlstm.sqharm[3] = (unsigned int  )0;
 sqlstm.sqadto[3] = (unsigned short )0;
 sqlstm.sqtdso[3] = (unsigned short )0;
 sqlstm.sqhstv[4] = (         void  *)(job_q.station);
 sqlstm.sqhstl[4] = (unsigned int  )10;
 sqlstm.sqhsts[4] = (         int  )0;
 sqlstm.sqindv[4] = (         void  *)0;
 sqlstm.sqinds[4] = (         int  )0;
 sqlstm.sqharm[4] = (unsigned int  )0;
 sqlstm.sqadto[4] = (unsigned short )0;
 sqlstm.sqtdso[4] = (unsigned short )0;
 sqlstm.sqhstv[5] = (         void  *)(job_q.date_time_entered);
 sqlstm.sqhstl[5] = (unsigned int  )15;
 sqlstm.sqhsts[5] = (         int  )0;
 sqlstm.sqindv[5] = (         void  *)0;
 sqlstm.sqinds[5] = (         int  )0;
 sqlstm.sqharm[5] = (unsigned int  )0;
 sqlstm.sqadto[5] = (unsigned short )0;
 sqlstm.sqtdso[5] = (unsigned short )0;
 sqlstm.sqhstv[6] = (         void  *)(job_q.date_time_started);
 sqlstm.sqhstl[6] = (unsigned int  )15;
 sqlstm.sqhsts[6] = (         int  )0;
 sqlstm.sqindv[6] = (         void  *)0;
 sqlstm.sqinds[6] = (         int  )0;
 sqlstm.sqharm[6] = (unsigned int  )0;
 sqlstm.sqadto[6] = (unsigned short )0;
 sqlstm.sqtdso[6] = (unsigned short )0;
 sqlstm.sqhstv[7] = (         void  *)(job_q.date_time_completed);
 sqlstm.sqhstl[7] = (unsigned int  )15;
 sqlstm.sqhsts[7] = (         int  )0;
 sqlstm.sqindv[7] = (         void  *)0;
 sqlstm.sqinds[7] = (         int  )0;
 sqlstm.sqharm[7] = (unsigned int  )0;
 sqlstm.sqadto[7] = (unsigned short )0;
 sqlstm.sqtdso[7] = (unsigned short )0;
 sqlstm.sqhstv[8] = (         void  *)&(job_q.exit_code);
 sqlstm.sqhstl[8] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[8] = (         int  )0;
 sqlstm.sqindv[8] = (         void  *)0;
 sqlstm.sqinds[8] = (         int  )0;
 sqlstm.sqharm[8] = (unsigned int  )0;
 sqlstm.sqadto[8] = (unsigned short )0;
 sqlstm.sqtdso[8] = (unsigned short )0;
 sqlstm.sqhstv[9] = (         void  *)(job_q.station_submitting);
 sqlstm.sqhstl[9] = (unsigned int  )2;
 sqlstm.sqhsts[9] = (         int  )0;
 sqlstm.sqindv[9] = (         void  *)0;
 sqlstm.sqinds[9] = (         int  )0;
 sqlstm.sqharm[9] = (unsigned int  )0;
 sqlstm.sqadto[9] = (unsigned short )0;
 sqlstm.sqtdso[9] = (unsigned short )0;
 sqlstm.sqhstv[10] = (         void  *)(job_q.msg_when_started);
 sqlstm.sqhstl[10] = (unsigned int  )2;
 sqlstm.sqhsts[10] = (         int  )0;
 sqlstm.sqindv[10] = (         void  *)0;
 sqlstm.sqinds[10] = (         int  )0;
 sqlstm.sqharm[10] = (unsigned int  )0;
 sqlstm.sqadto[10] = (unsigned short )0;
 sqlstm.sqtdso[10] = (unsigned short )0;
 sqlstm.sqhstv[11] = (         void  *)(job_q.msg_when_done);
 sqlstm.sqhstl[11] = (unsigned int  )2;
 sqlstm.sqhsts[11] = (         int  )0;
 sqlstm.sqindv[11] = (         void  *)0;
 sqlstm.sqinds[11] = (         int  )0;
 sqlstm.sqharm[11] = (unsigned int  )0;
 sqlstm.sqadto[11] = (unsigned short )0;
 sqlstm.sqtdso[11] = (unsigned short )0;
 sqlstm.sqhstv[12] = (         void  *)(job_q.multi_processing);
 sqlstm.sqhstl[12] = (unsigned int  )2;
 sqlstm.sqhsts[12] = (         int  )0;
 sqlstm.sqindv[12] = (         void  *)0;
 sqlstm.sqinds[12] = (         int  )0;
 sqlstm.sqharm[12] = (unsigned int  )0;
 sqlstm.sqadto[12] = (unsigned short )0;
 sqlstm.sqtdso[12] = (unsigned short )0;
 sqlstm.sqhstv[13] = (         void  *)(job_q.date_time_to_start);
 sqlstm.sqhstl[13] = (unsigned int  )15;
 sqlstm.sqhsts[13] = (         int  )0;
 sqlstm.sqindv[13] = (         void  *)0;
 sqlstm.sqinds[13] = (         int  )0;
 sqlstm.sqharm[13] = (unsigned int  )0;
 sqlstm.sqadto[13] = (unsigned short )0;
 sqlstm.sqtdso[13] = (unsigned short )0;
 sqlstm.sqhstv[14] = (         void  *)&(job_q.start_stat);
 sqlstm.sqhstl[14] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[14] = (         int  )0;
 sqlstm.sqindv[14] = (         void  *)0;
 sqlstm.sqinds[14] = (         int  )0;
 sqlstm.sqharm[14] = (unsigned int  )0;
 sqlstm.sqadto[14] = (unsigned short )0;
 sqlstm.sqtdso[14] = (unsigned short )0;
 sqlstm.sqhstv[15] = (         void  *)(job_q.must_complete_by);
 sqlstm.sqhstl[15] = (unsigned int  )5;
 sqlstm.sqhsts[15] = (         int  )0;
 sqlstm.sqindv[15] = (         void  *)0;
 sqlstm.sqinds[15] = (         int  )0;
 sqlstm.sqharm[15] = (unsigned int  )0;
 sqlstm.sqadto[15] = (unsigned short )0;
 sqlstm.sqtdso[15] = (unsigned short )0;
 sqlstm.sqhstv[16] = (         void  *)(job_q.c_msg_sent_yn);
 sqlstm.sqhstl[16] = (unsigned int  )2;
 sqlstm.sqhsts[16] = (         int  )0;
 sqlstm.sqindv[16] = (         void  *)0;
 sqlstm.sqinds[16] = (         int  )0;
 sqlstm.sqharm[16] = (unsigned int  )0;
 sqlstm.sqadto[16] = (unsigned short )0;
 sqlstm.sqtdso[16] = (unsigned short )0;
 sqlstm.sqhstv[17] = (         void  *)(job_q.must_start_by);
 sqlstm.sqhstl[17] = (unsigned int  )5;
 sqlstm.sqhsts[17] = (         int  )0;
 sqlstm.sqindv[17] = (         void  *)0;
 sqlstm.sqinds[17] = (         int  )0;
 sqlstm.sqharm[17] = (unsigned int  )0;
 sqlstm.sqadto[17] = (unsigned short )0;
 sqlstm.sqtdso[17] = (unsigned short )0;
 sqlstm.sqhstv[18] = (         void  *)(job_q.s_msg_sent_yn);
 sqlstm.sqhstl[18] = (unsigned int  )2;
 sqlstm.sqhsts[18] = (         int  )0;
 sqlstm.sqindv[18] = (         void  *)0;
 sqlstm.sqinds[18] = (         int  )0;
 sqlstm.sqharm[18] = (unsigned int  )0;
 sqlstm.sqadto[18] = (unsigned short )0;
 sqlstm.sqtdso[18] = (unsigned short )0;
 sqlstm.sqhstv[19] = (         void  *)(job_q.msg_to_operator_yn);
 sqlstm.sqhstl[19] = (unsigned int  )2;
 sqlstm.sqhsts[19] = (         int  )0;
 sqlstm.sqindv[19] = (         void  *)0;
 sqlstm.sqinds[19] = (         int  )0;
 sqlstm.sqharm[19] = (unsigned int  )0;
 sqlstm.sqadto[19] = (unsigned short )0;
 sqlstm.sqtdso[19] = (unsigned short )0;
 sqlstm.sqhstv[20] = (         void  *)(job_q.msg_to);
 sqlstm.sqhstl[20] = (unsigned int  )31;
 sqlstm.sqhsts[20] = (         int  )0;
 sqlstm.sqindv[20] = (         void  *)0;
 sqlstm.sqinds[20] = (         int  )0;
 sqlstm.sqharm[20] = (unsigned int  )0;
 sqlstm.sqadto[20] = (unsigned short )0;
 sqlstm.sqtdso[20] = (unsigned short )0;
 sqlstm.sqhstv[21] = (         void  *)&(job_q.priority);
 sqlstm.sqhstl[21] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[21] = (         int  )0;
 sqlstm.sqindv[21] = (         void  *)0;
 sqlstm.sqinds[21] = (         int  )0;
 sqlstm.sqharm[21] = (unsigned int  )0;
 sqlstm.sqadto[21] = (unsigned short )0;
 sqlstm.sqtdso[21] = (unsigned short )0;
 sqlstm.sqhstv[22] = (         void  *)(job_q.stn_started);
 sqlstm.sqhstl[22] = (unsigned int  )10;
 sqlstm.sqhsts[22] = (         int  )0;
 sqlstm.sqindv[22] = (         void  *)0;
 sqlstm.sqinds[22] = (         int  )0;
 sqlstm.sqharm[22] = (unsigned int  )0;
 sqlstm.sqadto[22] = (unsigned short )0;
 sqlstm.sqtdso[22] = (unsigned short )0;
 sqlstm.sqhstv[23] = (         void  *)&(job_q.num_d);
 sqlstm.sqhstl[23] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[23] = (         int  )0;
 sqlstm.sqindv[23] = (         void  *)0;
 sqlstm.sqinds[23] = (         int  )0;
 sqlstm.sqharm[23] = (unsigned int  )0;
 sqlstm.sqadto[23] = (unsigned short )0;
 sqlstm.sqtdso[23] = (unsigned short )0;
 sqlstm.sqhstv[24] = (         void  *)(job_q.d_job);
 sqlstm.sqhstl[24] = (unsigned int  )180;
 sqlstm.sqhsts[24] = (         int  )0;
 sqlstm.sqindv[24] = (         void  *)0;
 sqlstm.sqinds[24] = (         int  )0;
 sqlstm.sqharm[24] = (unsigned int  )0;
 sqlstm.sqadto[24] = (unsigned short )0;
 sqlstm.sqtdso[24] = (unsigned short )0;
 sqlstm.sqhstv[25] = (         void  *)(job_q.d_hrs_back);
 sqlstm.sqhstl[25] = (unsigned int  )100;
 sqlstm.sqhsts[25] = (         int  )0;
 sqlstm.sqindv[25] = (         void  *)0;
 sqlstm.sqinds[25] = (         int  )0;
 sqlstm.sqharm[25] = (unsigned int  )0;
 sqlstm.sqadto[25] = (unsigned short )0;
 sqlstm.sqtdso[25] = (unsigned short )0;
 sqlstm.sqhstv[26] = (         void  *)(job_q.d_cmplt);
 sqlstm.sqhstl[26] = (unsigned int  )20;
 sqlstm.sqhsts[26] = (         int  )0;
 sqlstm.sqindv[26] = (         void  *)0;
 sqlstm.sqinds[26] = (         int  )0;
 sqlstm.sqharm[26] = (unsigned int  )0;
 sqlstm.sqadto[26] = (unsigned short )0;
 sqlstm.sqtdso[26] = (unsigned short )0;
 sqlstm.sqhstv[27] = (         void  *)(job_q.d_last_tested);
 sqlstm.sqhstl[27] = (unsigned int  )200;
 sqlstm.sqhsts[27] = (         int  )0;
 sqlstm.sqindv[27] = (         void  *)0;
 sqlstm.sqinds[27] = (         int  )0;
 sqlstm.sqharm[27] = (unsigned int  )0;
 sqlstm.sqadto[27] = (unsigned short )0;
 sqlstm.sqtdso[27] = (unsigned short )0;
 sqlstm.sqhstv[28] = (         void  *)&(job_q.orig_start_stat);
 sqlstm.sqhstl[28] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[28] = (         int  )0;
 sqlstm.sqindv[28] = (         void  *)0;
 sqlstm.sqinds[28] = (         int  )0;
 sqlstm.sqharm[28] = (unsigned int  )0;
 sqlstm.sqadto[28] = (unsigned short )0;
 sqlstm.sqtdso[28] = (unsigned short )0;
 sqlstm.sqhstv[29] = (         void  *)(job_q.job_suspended);
 sqlstm.sqhstl[29] = (unsigned int  )2;
 sqlstm.sqhsts[29] = (         int  )0;
 sqlstm.sqindv[29] = (         void  *)0;
 sqlstm.sqinds[29] = (         int  )0;
 sqlstm.sqharm[29] = (unsigned int  )0;
 sqlstm.sqadto[29] = (unsigned short )0;
 sqlstm.sqtdso[29] = (unsigned short )0;
 sqlstm.sqhstv[30] = (         void  *)(job_q.restart);
 sqlstm.sqhstl[30] = (unsigned int  )9;
 sqlstm.sqhsts[30] = (         int  )0;
 sqlstm.sqindv[30] = (         void  *)0;
 sqlstm.sqinds[30] = (         int  )0;
 sqlstm.sqharm[30] = (unsigned int  )0;
 sqlstm.sqadto[30] = (unsigned short )0;
 sqlstm.sqtdso[30] = (unsigned short )0;
 sqlstm.sqhstv[31] = (         void  *)(job_q.job_class);
 sqlstm.sqhstl[31] = (unsigned int  )2;
 sqlstm.sqhsts[31] = (         int  )0;
 sqlstm.sqindv[31] = (         void  *)0;
 sqlstm.sqinds[31] = (         int  )0;
 sqlstm.sqharm[31] = (unsigned int  )0;
 sqlstm.sqadto[31] = (unsigned short )0;
 sqlstm.sqtdso[31] = (unsigned short )0;
 sqlstm.sqhstv[32] = (         void  *)(job_q.base_dir);
 sqlstm.sqhstl[32] = (unsigned int  )81;
 sqlstm.sqhsts[32] = (         int  )0;
 sqlstm.sqindv[32] = (         void  *)0;
 sqlstm.sqinds[32] = (         int  )0;
 sqlstm.sqharm[32] = (unsigned int  )0;
 sqlstm.sqadto[32] = (unsigned short )0;
 sqlstm.sqtdso[32] = (unsigned short )0;
 sqlstm.sqhstv[33] = (         void  *)&(job_q.max_job_time_warn);
 sqlstm.sqhstl[33] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[33] = (         int  )0;
 sqlstm.sqindv[33] = (         void  *)0;
 sqlstm.sqinds[33] = (         int  )0;
 sqlstm.sqharm[33] = (unsigned int  )0;
 sqlstm.sqadto[33] = (unsigned short )0;
 sqlstm.sqtdso[33] = (unsigned short )0;
 sqlstm.sqhstv[34] = (         void  *)(job_q.debug_mode_yn);
 sqlstm.sqhstl[34] = (unsigned int  )2;
 sqlstm.sqhsts[34] = (         int  )0;
 sqlstm.sqindv[34] = (         void  *)0;
 sqlstm.sqinds[34] = (         int  )0;
 sqlstm.sqharm[34] = (unsigned int  )0;
 sqlstm.sqadto[34] = (unsigned short )0;
 sqlstm.sqtdso[34] = (unsigned short )0;
 sqlstm.sqhstv[35] = (         void  *)&(job_q.last_step);
 sqlstm.sqhstl[35] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[35] = (         int  )0;
 sqlstm.sqindv[35] = (         void  *)0;
 sqlstm.sqinds[35] = (         int  )0;
 sqlstm.sqharm[35] = (unsigned int  )0;
 sqlstm.sqadto[35] = (unsigned short )0;
 sqlstm.sqtdso[35] = (unsigned short )0;
 sqlstm.sqhstv[36] = (         void  *)(job_q.last_s_name);
 sqlstm.sqhstl[36] = (unsigned int  )10;
 sqlstm.sqhsts[36] = (         int  )0;
 sqlstm.sqindv[36] = (         void  *)0;
 sqlstm.sqinds[36] = (         int  )0;
 sqlstm.sqharm[36] = (unsigned int  )0;
 sqlstm.sqadto[36] = (unsigned short )0;
 sqlstm.sqtdso[36] = (unsigned short )0;
 sqlstm.sqhstv[37] = (         void  *)(job_q.last_g_name);
 sqlstm.sqhstl[37] = (unsigned int  )10;
 sqlstm.sqhsts[37] = (         int  )0;
 sqlstm.sqindv[37] = (         void  *)0;
 sqlstm.sqinds[37] = (         int  )0;
 sqlstm.sqharm[37] = (unsigned int  )0;
 sqlstm.sqadto[37] = (unsigned short )0;
 sqlstm.sqtdso[37] = (unsigned short )0;
 sqlstm.sqhstv[38] = (         void  *)(job_q.submitted_file_name);
 sqlstm.sqhstl[38] = (unsigned int  )13;
 sqlstm.sqhsts[38] = (         int  )0;
 sqlstm.sqindv[38] = (         void  *)0;
 sqlstm.sqinds[38] = (         int  )0;
 sqlstm.sqharm[38] = (unsigned int  )0;
 sqlstm.sqadto[38] = (unsigned short )0;
 sqlstm.sqtdso[38] = (unsigned short )0;
 sqlstm.sqhstv[39] = (         void  *)(job_q.p_msg_sent_yn);
 sqlstm.sqhstl[39] = (unsigned int  )2;
 sqlstm.sqhsts[39] = (         int  )0;
 sqlstm.sqindv[39] = (         void  *)0;
 sqlstm.sqinds[39] = (         int  )0;
 sqlstm.sqharm[39] = (unsigned int  )0;
 sqlstm.sqadto[39] = (unsigned short )0;
 sqlstm.sqtdso[39] = (unsigned short )0;
 sqlstm.sqhstv[40] = (         void  *)&(job_q.max_job_time_kill);
 sqlstm.sqhstl[40] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[40] = (         int  )0;
 sqlstm.sqindv[40] = (         void  *)0;
 sqlstm.sqinds[40] = (         int  )0;
 sqlstm.sqharm[40] = (unsigned int  )0;
 sqlstm.sqadto[40] = (unsigned short )0;
 sqlstm.sqtdso[40] = (unsigned short )0;
 sqlstm.sqhstv[41] = (         void  *)(job_q.max_c_msg_yn);
 sqlstm.sqhstl[41] = (unsigned int  )2;
 sqlstm.sqhsts[41] = (         int  )0;
 sqlstm.sqindv[41] = (         void  *)0;
 sqlstm.sqinds[41] = (         int  )0;
 sqlstm.sqharm[41] = (unsigned int  )0;
 sqlstm.sqadto[41] = (unsigned short )0;
 sqlstm.sqtdso[41] = (unsigned short )0;
 sqlstm.sqhstv[42] = (         void  *)(job_q.stn_dependancy_yn);
 sqlstm.sqhstl[42] = (unsigned int  )2;
 sqlstm.sqhsts[42] = (         int  )0;
 sqlstm.sqindv[42] = (         void  *)0;
 sqlstm.sqinds[42] = (         int  )0;
 sqlstm.sqharm[42] = (unsigned int  )0;
 sqlstm.sqadto[42] = (unsigned short )0;
 sqlstm.sqtdso[42] = (unsigned short )0;
 sqlstm.sqhstv[43] = (         void  *)(job_q.no_fail_message_yn);
 sqlstm.sqhstl[43] = (unsigned int  )2;
 sqlstm.sqhsts[43] = (         int  )0;
 sqlstm.sqindv[43] = (         void  *)0;
 sqlstm.sqinds[43] = (         int  )0;
 sqlstm.sqharm[43] = (unsigned int  )0;
 sqlstm.sqadto[43] = (unsigned short )0;
 sqlstm.sqtdso[43] = (unsigned short )0;
 sqlstm.sqhstv[44] = (         void  *)(job_q.msg_when_failed);
 sqlstm.sqhstl[44] = (unsigned int  )2;
 sqlstm.sqhsts[44] = (         int  )0;
 sqlstm.sqindv[44] = (         void  *)0;
 sqlstm.sqinds[44] = (         int  )0;
 sqlstm.sqharm[44] = (unsigned int  )0;
 sqlstm.sqadto[44] = (unsigned short )0;
 sqlstm.sqtdso[44] = (unsigned short )0;
 sqlstm.sqhstv[45] = (         void  *)&(job_q.spawn_algorithm);
 sqlstm.sqhstl[45] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[45] = (         int  )0;
 sqlstm.sqindv[45] = (         void  *)0;
 sqlstm.sqinds[45] = (         int  )0;
 sqlstm.sqharm[45] = (unsigned int  )0;
 sqlstm.sqadto[45] = (unsigned short )0;
 sqlstm.sqtdso[45] = (unsigned short )0;
 sqlstm.sqhstv[46] = (         void  *)&(job_q.spawn_parm);
 sqlstm.sqhstl[46] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[46] = (         int  )0;
 sqlstm.sqindv[46] = (         void  *)0;
 sqlstm.sqinds[46] = (         int  )0;
 sqlstm.sqharm[46] = (unsigned int  )0;
 sqlstm.sqadto[46] = (unsigned short )0;
 sqlstm.sqtdso[46] = (unsigned short )0;
 sqlstm.sqhstv[47] = (         void  *)(job_q.d_station);
 sqlstm.sqhstl[47] = (unsigned int  )180;
 sqlstm.sqhsts[47] = (         int  )0;
 sqlstm.sqindv[47] = (         void  *)0;
 sqlstm.sqinds[47] = (         int  )0;
 sqlstm.sqharm[47] = (unsigned int  )0;
 sqlstm.sqadto[47] = (unsigned short )0;
 sqlstm.sqtdso[47] = (unsigned short )0;
 sqlstm.sqhstv[48] = (         void  *)(job_q.jsgroup);
 sqlstm.sqhstl[48] = (unsigned int  )10;
 sqlstm.sqhsts[48] = (         int  )0;
 sqlstm.sqindv[48] = (         void  *)0;
 sqlstm.sqinds[48] = (         int  )0;
 sqlstm.sqharm[48] = (unsigned int  )0;
 sqlstm.sqadto[48] = (unsigned short )0;
 sqlstm.sqtdso[48] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 // WR27164 - Hamsha        


      l_sqlcode = sqlca.sqlcode;
      strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

      LeaveCriticalSection( &jsnt_sql_lock );

      if ( l_sqlcode != ORCL_NO_ERROR)
      {
         ifs_custerr("ORC_INSERT", __FILE__, __LINE__, IFS_LOG, 
            "JOBQ", "no", " ", sqlmsg, " ", NULL);

         sprintf(tempstr, "ERROR: INSERT of JOBQ table failed: Job Number - %d, Job Name - %s",
                   job_q.no, job_q.name);
         if (submit_error) submit_error(tempstr);
         return(-1);
      }

      EnterCriticalSection( &jsnt_sql_lock );

      /* EXEC SQL COMMIT; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 49;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )3320;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



      l_sqlcode = sqlca.sqlcode;
      strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

      LeaveCriticalSection( &jsnt_sql_lock );

      if( l_sqlcode != ORCL_NO_ERROR )
      {
         ifs_custerr("ORC_COMMIT", __FILE__, __LINE__, IFS_LOG, 
         sqlmsg, "JOBQ table", NULL);

         sprintf(tempstr, 
            "ERROR: COMMIT after insert into JOBQ table failed: Job Number - %d, Job Name - %s", 
               job_q.no, job_q.name);
         if (submit_error) submit_error(tempstr);
         return(-1);
      }

   return(0);
}
  




/********************** createSocket() *************************
*                                                              *
* Description:  Creates Socket connection with JOBMONNT        *
* If connection is established, sends a String packet as input *
* and waits for a response.                                    *
*                                                              *
* Parameters:   None                                           *
* Returns : ERR                                                *
*           SUCCESS                                            *
*                                                              *
* Creation Date: 06/29/2000  By: Meenakshi P.K, iDLX           *
*                                                              *
***************************************************************/
 
int createSocket()
{
   SOCKET sock;                        /* Socket variable for connecting */
   int nReturnval;                     /* Holds return value of function calls */
   char szErrmsg[250];                 /* String holding error messages */
   char szIfsParm[80];                 /* IFS parameter holding the error number */
   char szMessage[10];                 /* For sending and receiving messages */
   struct sockaddr_in sock_addr;       /* SOCKET address of the job server */
   struct sockaddr_in to_sock_addr;    /* SOCKET address of the destination */
   unsigned long ulAddress;            /* Address */
   int nRetries ;                      /* Number of attempts JSNT makes to connect */
   CHAR_INFO *pCharInfo;               /* To save the screen before displaying the 
                                          paused message */

   WORD   wVersionRequested;           /* The version of windows socket library */
   WSADATA wsaData;                    /* Structure which will receive the sockets
                                          library information */

   sock = NULL;

   /* 
    * Version number of the library required.
    * The high order byte specifies the minor version (revision) number 
    * The low-order byte specifies the major version number. 
    */

   wVersionRequested = MAKEWORD(MAJOR_VERSION, MINOR_VERSION);
   memset(szMessage, 0, sizeof(szMessage));

   /* 
    * Load the Windows sockets library 
    */
   nReturnval = WSAStartup(wVersionRequested, &wsaData);
   if (nReturnval != 0)
   {
      _itoa(nReturnval, szIfsParm, 10);
      copy_cat(szErrmsg, "Unable to Load sockets library, Error code:  ", 
         szIfsParm, NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "WSAStartup", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      return ERR;
   }

   /* 
    * Check whether the right version is loaded 
    */
   if (LOBYTE(wsaData.wVersion) != MAJOR_VERSION || HIBYTE(wsaData.wVersion)
      != MINOR_VERSION)
   {
      WSACleanup();
      copy_cat(szErrmsg, "DLL is not compatible", NULL);
      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "WSAStartup()", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      return ERR;
   }

   /* 
    * Create the socket 
    */
   sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   if (sock == INVALID_SOCKET)
   {
      nReturnval = WSAGetLastError();
      _itoa(nReturnval, szIfsParm, 10);
      copy_cat(szErrmsg, "Unable to create socket, Error Code: ", szIfsParm, 
         NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "socket()", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      WSACleanup();
      return ERR;
   }

   sock_addr.sin_family = AF_INET;
   sock_addr.sin_port = 0;
   sock_addr.sin_addr.s_addr = htonl(INADDR_ANY);

   /* 
    * Bind the socket 
    */
   nReturnval = bind(sock, (const struct sockaddr FAR*)&sock_addr, sizeof(sock_addr));
   if (nReturnval == SOCKET_ERROR)
   {
      nReturnval = WSAGetLastError();
      _itoa(nReturnval, szIfsParm, 10);
      copy_cat(szErrmsg, "Unable to bind socket, Error code:  ", 
         szIfsParm, NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "bind()", szErrmsg ,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      closesocket(sock);
      WSACleanup();
      return ERR;
   }

   /* 
    * Verify if JOBMONNT's IP address is valid 
    */
   ulAddress = inet_addr(szjobmon_ip);
   if( (ulAddress == INADDR_NONE) || (!ulAddress))
   {
      copy_cat(szErrmsg, "Invalid IP address ", szjobmon_ip, NULL);
      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "inet_addr()", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      closesocket(sock);
      WSACleanup();
      return ERR;
   }

   /* 
    * Verify if JOBMONNT's PORT number is valid 
    */
   if(jobmon_port_no < MIN_PORT_NO)
   {
      _itoa(jobmon_port_no, szIfsParm, 10);
      copy_cat(szErrmsg, "Invalid port number ", szIfsParm, NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "connect()", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      closesocket(sock);
      WSACleanup();
      return ERR;
   }

   /* 
    * Create a socket address for JOBMONNT 
    */
   to_sock_addr.sin_family = AF_INET;
   to_sock_addr.sin_port = jobmon_port_no;
   to_sock_addr.sin_addr.s_addr = ulAddress;

   /* 
    * Try to connect to JOBMONNT MAX_RETRIES times 
    */
   for (nRetries = 0; nRetries < MAX_RETRIES; nRetries++)
   {
      nReturnval = connect(sock, (struct sockaddr FAR*)&to_sock_addr, sizeof(to_sock_addr));
      if (nReturnval == 0) 
      {
         break;
      }
      else
      {
         continue;
      }
   }

   /* 
    * Unable to establish connection in MAX_RETRIES attempts. 
    * Hence return ERR 
    */
   if ((nRetries == MAX_RETRIES) && (nReturnval !=0))
   {
      nReturnval = WSAGetLastError();
      _itoa(nReturnval, szIfsParm, 10);
      copy_cat(szErrmsg, "Unable to connect to Jonbmonnt, Error code:  ", 
         szIfsParm, " Network error or JOBMONNT is not running", NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "connect()", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      closesocket(sock);
      WSACleanup();
      return ERR;
   }

   strcpy(szMessage,JSNT_MSG);

   /* 
    * Send a string packet to JOBMONNT 
    */
   nReturnval = send(sock, szMessage, strlen(szMessage),0);
   if (nReturnval == SOCKET_ERROR)
   {
      nReturnval = WSAGetLastError();
      _itoa(nReturnval, szIfsParm, 10);
      copy_cat(szErrmsg, "Unable to send string packet to JOBMONNT, Error code:  ", 
         szIfsParm, NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "send()", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      closesocket(sock);
      WSACleanup();
      return ERR;
   }

   /* 
    * Display the paused message till the acknowledgement is received from JOBMONNT 
    * Save area of screen so we can put it back later.               
    */
   pCharInfo = (CHAR_INFO*)gettext(0, 0, 26, 5);

   qtext(0,0," JS SUSPENDED ");
   qtext(0,1,"    This Server is      ");
   qtext(0,2,"   SUSPENDED waiting    ");
   qtext(0,3," for JOBMONNT Response. ");
   qtext(0,4,"");

   /* 
    * Receive the response sent by JOBMONNT
    */
   memset(szMessage,0,sizeof(szMessage));
   nReturnval = recv(sock,szMessage,sizeof(szMessage), 0);
   if (nReturnval == SOCKET_ERROR)
   {
      nReturnval = WSAGetLastError();
      _itoa(nReturnval, szIfsParm, 10);
      copy_cat(szErrmsg, "Unable to receive string packet from JOBMONNT, Error code:  ", 
         szIfsParm, NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "recv()", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      closesocket(sock);
      WSACleanup();
      return ERR;
   }

   /* 
    * Restore the screen 
    */
   puttext(0, 0, 26, 5, pCharInfo);
   free(pCharInfo);

   /* 
    * Response has been received, hence close the connection 
    */
   nReturnval = closesocket(sock);
   if (nReturnval == SOCKET_ERROR)
   {
      nReturnval = WSAGetLastError();
      _itoa(nReturnval, szIfsParm, 10);
      copy_cat(szErrmsg, "Unable to close socket connection, Error code:  ", 
         szIfsParm, NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "closesocket()", szErrmsg,NULL);      

	   logit (0, szErrmsg);
      debug_log (szErrmsg);
      WSACleanup();
      return ERR;
   }

   /* 
    * Cleanup activities for windows socket library
    */
   WSACleanup();
   
   /* 
    * If the response is positive, return SUCCESS else return ERR 
    */
   if(strcmp(szMessage,POSITIVE_RESPONSE) == 0)
      return SUCCESS;
   else
      return ERR;
}
  

/***********************************************************************
*  Function name  logitwithlocaltime
*  This function writes in to the Log file with local time
*  Baskar/Veera - Nov 21 2003
***********************************************************************/

int logitwithlocaltime (int log_type, char *msg) {
   char name[80];
   char job_info[100];
   char message[500];
   short int fh;
   char short_name[15];
   char datetime[20];
   char novell_info[100];
   SYSTIME st;

   char month[3];
   char day[3];
   char year[5];
   char decade[3];
   char hour[3];
   char minute[3];
   char second[3];

   char jobq_no[11];
   char jobq_name[10];
   char stepq_step[5];
   char stepq_name[10];
   char stepq_group_name[10];

   char jsname[10];
   char uname[20];
   char netid[20];
   char netpa[20];
   char netsid[20];
   //int  tmp_year;
   
	  /*  Format some basic information */
	   getsystime(&st);

		_itoa(st.wMonth, month, 10);
		if(st.wMonth < 10)
			_padl(month, '0', 2);
	
		_itoa(st.wDay, day, 10);
		if(st.wDay < 10)
			_padl(day, '0', 2);
 
//	tmp_year = st.wYear%100;
		_itoa(st.wYear, year, 10);

		_itoa(st.wHour, hour, 10);
		if(st.wHour < 10)
			_padl(hour, '0', 2);

		_itoa(st.wMinute, minute, 10);
		if(st.wMinute < 10)
			_padl(minute, '0', 2);

		_itoa(st.wSecond, second, 10);
		if(st.wSecond < 10)
			_padl(second, '0', 2);
 
  

   move(decade, 2, year+2, 1);
   copy_cat(datetime, month, "/", day, "/", decade, " ", hour, ":", minute, ":", second, NULL);

   _ltoa(job_q.no, jobq_no, 10);
   _padl(jobq_no, '0', 10);

   strcpy(jobq_name, (char*)job_q.name);
   _padl (jobq_name, ' ', 9);

   _itoa(step_q.step, stepq_step, 10);
   _padl(stepq_step, '0', 4);
   
   strcpy(stepq_name, (char*)step_q.s_name);
   _padl (stepq_name, ' ', 9);
   strcpy(stepq_group_name, step_q.group_name);
   _padl (stepq_group_name, ' ', 9);
   copy_cat(job_info, jobq_no, " ", jobq_name, " ", stepq_step, " ", stepq_name, " ", stepq_group_name, NULL);

   strcpy(jsname, szjsname);
   _padl(jsname, ' ', 8);
   strcpy(uname, user_name);
   _padl(uname, ' ', 10);
   strcpy(netid, network_id_s);
   _padl(netid, ' ', 4);
   strcpy(netpa, network_physical_address);
   _padl(netpa, ' ', 8);
   strcpy(netsid, network_station_id);
   _padl(netsid, ' ', 3);
   copy_cat(novell_info, jsname, " ", uname, " ", netid, ":", netpa, ":", netsid, NULL);

   copy_cat(short_name, year, month, day, ".LOG", NULL);

   if (! strlen(szlogpath)) 
	   strcpy  (name, short_name);
   else 
	   copy_cat(name, szlogpath, short_name, NULL);


/* Attempt to open the file, fh will be ERR if it fails.  On fail display msg */
   fh = _sopen (name, _O_BINARY | _O_RDWR, _SH_DENYNO);

    if (fh == ERR) {                  /* File not present - try to create it */
      fh = _sopen(name, _O_BINARY | _O_RDWR | _O_CREAT, _SH_DENYNO, _S_IWRITE);
      if (fh != ERR) 
	  {
		 copy_cat(message, datetime, "                                               ", novell_info, " File Created\r\n", NULL);
         _write(fh, message, strlen(message));
      }
	  else
	  {
		/* Write the log to the local machine */
		// ssv 03/25/04
		copy_cat(name, szlocallogpath, short_name, NULL);
		fh = _sopen(name, _O_BINARY | _O_RDWR | _O_CREAT, _SH_DENYNO, _S_IWRITE);
		if (fh != ERR) 
		{
			copy_cat(message, datetime, "                                               ", novell_info, " File Created\r\n", NULL);
			_write(fh, message, strlen(message));
		}

	  }
    }

/* Open attempt failed - show something to screen, & don't do any more I/O calls below */
   if (fh==ERR) 
   {
	   copy_cat(message, "Error opening log file: ", name, NULL);
	   qtext(10, 10, message);
   }

/* On successful open, try to lock the file's first byte */
   else {
      if (_locking (fh, _LK_LOCK, 1L) != SUCCESS) 
	  {
         _close (fh);         /* Lock failed, so close the file handle */
         fh = ERR;           /* Simulate an errored file handle */
		 qtext(10, 10, "Error locking log file!");
      }
   }


   switch (log_type) {
      case 0:     /* General Message */
		  copy_cat(message, datetime, "                                               ", novell_info, " ",
				msg, "\r\n", NULL);
		  break;
      case 1:     /* Job Message */
		  copy_cat(message, datetime, " ", jobq_no, " ", jobq_name, 
					"                          ", novell_info, " ", msg, "\r\n", NULL);
		  break;

      case 2:     /* Step Message */
		  copy_cat(message, datetime, " ", jobq_no, " ", jobq_name, " ", stepq_step, " ", 
					stepq_name, " ", stepq_group_name, " ", novell_info, " ", msg, "\r\n", NULL);
		  break;
   }


/*  When the file handle is valid, write the message to the log file, unlock, & close */
   if (fh == ERR) 
	   qtext(10, 10, message);
   else {
      _lseek (fh, 0L, SEEK_END);
      _write (fh, message, strlen(message));
      _lseek (fh, 0L, SEEK_SET);
      _locking (fh, _LK_UNLCK, 1L);
      _close (fh);
   }
   return SUCCESS;
}

/***********************************************************************
*  Function name  load_achps_const_recs
*  This function loads records from achps_const with rec_id = 'ALERT'
*  for alert mechanism and those with rec_id = 'EMAIL' to retrieve email
*  configuration
*  Sujatha/Veera - Sep 2 2005
***********************************************************************/
void load_achps_const_recs(void)
{
	
	/* EXEC SQL BEGIN DECLARE SECTION; */ 

	achps_const_sql	l_achps_const_rec;
	achps_const_ind i_achps_const_rec;
	/* EXEC SQL END DECLARE SECTION; */ 


	achps_const_sql *ptrAchpsConstRec;

	/*Get Count of records from ACHPS_CONST which are set up for ALERT*/
	/* EXEC SQL SELECT count(*) INTO :totRec FROM achps_const WHERE rec_id = 'ALERT'; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 49;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = "select count(*)  into :b0  from achps_const where rec_id='AL\
ERT'";
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )3335;
 sqlstm.selerr = (unsigned short)1;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqhstv[0] = (         void  *)&totRec;
 sqlstm.sqhstl[0] = (unsigned int  )sizeof(int);
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


	if(sqlca.sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
		"Select query failed ", "ACHPS_CONST",	NULL);
	}
	

	g_achps_const_recs = (achps_const_sql *)calloc(totRec,sizeof(achps_const_sql));	
	ptrAchpsConstRec  = g_achps_const_recs;
	

	/* EXEC SQL DECLARE achps_const_cur CURSOR FOR
			 SELECT trim(parameter_name), trim(parameter_value), trim(remarks)
			 FROM achps_const WHERE rec_id = 'ALERT'; */ 


	/* EXEC SQL OPEN achps_const_cur; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 49;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = sq0089;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )3354;
 sqlstm.selerr = (unsigned short)0;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqcmod = (unsigned int )0;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


	if(sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
	{
			ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"achps_const_cur", " ACHPS_CONST table", NULL);
	}
	
	/* EXEC SQL FETCH achps_const_cur INTO :l_achps_const_rec :i_achps_const_rec; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 49;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )3369;
 sqlstm.selerr = (unsigned short)0;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqfoff = (           int )0;
 sqlstm.sqfmod = (unsigned int )2;
 sqlstm.sqhstv[0] = (         void  *)l_achps_const_rec.parameter_name;
 sqlstm.sqhstl[0] = (unsigned int  )16;
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)&i_achps_const_rec.parameter_name;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)l_achps_const_rec.parameter_value;
 sqlstm.sqhstl[1] = (unsigned int  )41;
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)&i_achps_const_rec.parameter_value;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqhstv[2] = (         void  *)l_achps_const_rec.remarks;
 sqlstm.sqhstl[2] = (unsigned int  )41;
 sqlstm.sqhsts[2] = (         int  )0;
 sqlstm.sqindv[2] = (         void  *)&i_achps_const_rec.remarks;
 sqlstm.sqinds[2] = (         int  )0;
 sqlstm.sqharm[2] = (unsigned int  )0;
 sqlstm.sqadto[2] = (unsigned short )0;
 sqlstm.sqtdso[2] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


	if(sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
	{
			ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"achps_const_cur", " ACHPS_CONST table", NULL);
	}

	int i = sqlca.sqlcode;	

	while(sqlca.sqlcode == ORCL_NO_ERROR) 
	{
		memcpy(ptrAchpsConstRec,&l_achps_const_rec,sizeof(achps_const_sql));
		ptrAchpsConstRec++;
		/* EXEC SQL FETCH achps_const_cur INTO :l_achps_const_rec :i_achps_const_rec; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 49;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )3396;
  sqlstm.selerr = (unsigned short)0;
  sqlstm.sqlpfmem = (unsigned int  )0;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlstm.sqfoff = (           int )0;
  sqlstm.sqfmod = (unsigned int )2;
  sqlstm.sqhstv[0] = (         void  *)l_achps_const_rec.parameter_name;
  sqlstm.sqhstl[0] = (unsigned int  )16;
  sqlstm.sqhsts[0] = (         int  )0;
  sqlstm.sqindv[0] = (         void  *)&i_achps_const_rec.parameter_name;
  sqlstm.sqinds[0] = (         int  )0;
  sqlstm.sqharm[0] = (unsigned int  )0;
  sqlstm.sqadto[0] = (unsigned short )0;
  sqlstm.sqtdso[0] = (unsigned short )0;
  sqlstm.sqhstv[1] = (         void  *)l_achps_const_rec.parameter_value;
  sqlstm.sqhstl[1] = (unsigned int  )41;
  sqlstm.sqhsts[1] = (         int  )0;
  sqlstm.sqindv[1] = (         void  *)&i_achps_const_rec.parameter_value;
  sqlstm.sqinds[1] = (         int  )0;
  sqlstm.sqharm[1] = (unsigned int  )0;
  sqlstm.sqadto[1] = (unsigned short )0;
  sqlstm.sqtdso[1] = (unsigned short )0;
  sqlstm.sqhstv[2] = (         void  *)l_achps_const_rec.remarks;
  sqlstm.sqhstl[2] = (unsigned int  )41;
  sqlstm.sqhsts[2] = (         int  )0;
  sqlstm.sqindv[2] = (         void  *)&i_achps_const_rec.remarks;
  sqlstm.sqinds[2] = (         int  )0;
  sqlstm.sqharm[2] = (unsigned int  )0;
  sqlstm.sqadto[2] = (unsigned short )0;
  sqlstm.sqtdso[2] = (unsigned short )0;
  sqlstm.sqphsv = sqlstm.sqhstv;
  sqlstm.sqphsl = sqlstm.sqhstl;
  sqlstm.sqphss = sqlstm.sqhsts;
  sqlstm.sqpind = sqlstm.sqindv;
  sqlstm.sqpins = sqlstm.sqinds;
  sqlstm.sqparm = sqlstm.sqharm;
  sqlstm.sqparc = sqlstm.sqharc;
  sqlstm.sqpadto = sqlstm.sqadto;
  sqlstm.sqptdso = sqlstm.sqtdso;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


		if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
		{
			ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"achps_const_cur", " ACHPS_CONST table", NULL);
			break;
		}
      
	}

	/* EXEC SQL CLOSE achps_const_cur; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 49;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )3423;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


	if(sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
	{
			ifs_custerr("ORC_CLOSECRS", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"achps_const_cur", " ACHPS_CONST table", NULL);
	}


}


/***********************************************************************
*  Function name  lookUpAchpsConst
*  This function looks up records from achps_const with rec_id = 'ALERT'
*  for alert mechanism and retrieve the correct record and the max minutes
*  for the process.  
*  Sujatha/Veera - Sep 2 2005
***********************************************************************/
int lookUpAchpsConst(achps_const_def *ptrAchpsConst,char *commandLine)
{
	int n,i,j;
	int cnt=0;
	achps_const_sql* ptrTemp;
	ptrTemp = g_achps_const_recs;
    char processName[13];
	achps_const_def locAchpsConstRec;
	string locCmdLine;
	bool recFound = false;

    
	locCmdLine = commandLine;
	memset(processName,0,sizeof(processName));
	n = locCmdLine.find(" ",0);
	if(n != string::npos)
		strcpy(processName,(locCmdLine.substr(0,n)).c_str());
    
	

	while(cnt < totRec)
	{
		// Get the achps_const record for the current process name by comparing with 
		// the parameter_anme in achps_const record
		if( stricmp(trimlr(ptrTemp->parameter_name),trimlr(processName))==0) 
		{

			//If no commandline option passed
			if( stricmp(trimlr(ptrTemp->remarks),"/NONE")==0 ) 
			{
				//Get process name from parameter_name, max time in minutes from
				// parameter_value, command line options from remarks1 column

				// remark column contains command_line text
				strcpy(locAchpsConstRec.parameter_name,ptrTemp->parameter_name);
				strcpy(locAchpsConstRec.parameter_value,ptrTemp->parameter_value);
				strcpy(locAchpsConstRec.remarks,ptrTemp->remarks);
				recFound = true;
			}
			else 
			{
				/*for every word in remarks
					find word in command_line 
				if not found return record with /none option*/

				string s = commandLine; //command line from stepq
				string r = ptrTemp->remarks; 
				string tmp;

				n = 0; i=0;
				
				while(1)
				{
					n = r.find(" ",n+1);
					if (n == string::npos )
					{
						tmp = r.substr(i,n - i);
						j = s.find(tmp, 0); 
						if (j == string::npos)
							break;
						else
						{
							//copy and return
							strcpy(ptrAchpsConst->parameter_name,ptrTemp->parameter_name);
							strcpy(ptrAchpsConst->parameter_value,ptrTemp->parameter_value);
							strcpy(ptrAchpsConst->remarks,ptrTemp->remarks);
							return 1;
						}
					}

					while(r[n+1]==' ')
						n++;
					
					tmp = r.substr(i,n - i);
					j = s.find(tmp, 0); 
					if (j == string::npos)
						break;
					i=n+1;					
				} //end while(1)
			}
		}
		ptrTemp++;
		cnt++;
	}

	if(recFound)
	{
		strcpy(ptrAchpsConst->parameter_name,locAchpsConstRec.parameter_name);
		strcpy(ptrAchpsConst->parameter_value,locAchpsConstRec.parameter_value);
		strcpy(ptrAchpsConst->remarks,locAchpsConstRec.remarks);
		return 1;
	}

	return 0;
}

/***********************************************************************
*  Function name  sendMail
*  This function executes the stored procedure sendMail to send an 
*  email when a process takes more time than normal.
*  Sujatha/Veera - Sep 2 2005
***********************************************************************/
void sendMail(char *msg)
{
	/* EXEC SQL BEGIN DECLARE SECTION; */ 

	char mesg[458];  // is this enuf or should be equal to msg.msg  size?
	int err_id;
	char err_msg[100];
	char lSender[40];
	char lRecipient[40];
	/* EXEC SQL END DECLARE SECTION; */ 


	char sqlmsg[80];
	strcpy(mesg,msg);

    memset (lSender, 0x00, sizeof(lSender));
	memset (lRecipient, 0x00, sizeof(lRecipient));

	/* EXEC SQL SELECT  parameter_value, remarks 
	INTO    :lSender, :lRecipient
	FROM   achps_const
	WHERE  rec_id = 'EMAIL' and rownum = 1; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 49;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = "select parameter_value ,remarks into :b0,:b1  from achps_con\
st where (rec_id='EMAIL' and rownum=1)";
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )3438;
 sqlstm.selerr = (unsigned short)1;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqhstv[0] = (         void  *)lSender;
 sqlstm.sqhstl[0] = (unsigned int  )40;
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)lRecipient;
 sqlstm.sqhstl[1] = (unsigned int  )40;
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	if (sqlca.sqlcode != ORCL_NO_ERROR) 
	{
      strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
      ifs_custerr("ORC_SELECT", __FILE__, __LINE__, IFS_LOG, 
         "ACHPS_CONST", sqlmsg, "Selecting sender and receiver mail id from achps_const table , ACHPS_CONST", 
            NULL);
     }

   trimlr(lSender);
   trimlr(lRecipient);
	// Execute procedure sendmail with the paramters errid, errmsg and message
	/*** EXEC SQL EXECUTE 
		BEGIN sendmail(:err_id,:err_msg,:mesg);
		END;
	END-EXEC; Naresh to change to sendwebmail***/

       /* EXEC SQL EXECUTE 
		BEGIN SENDMAILWEB(:err_id,:err_msg,:mesg,'',:lSender,:lRecipient,'ACHPS Job ALert');
		END;
	END-EXEC; */ 

{
       struct sqlexd sqlstm;
       sqlstm.sqlvsn = 13;
       sqlstm.arrsiz = 49;
       sqlstm.sqladtp = &sqladt;
       sqlstm.sqltdsp = &sqltds;
       sqlstm.stmt = "begin SENDMAILWEB ( :err_id , :err_msg , :mesg , '' , \
:lSender , :lRecipient , 'ACHPS Job ALert' ) ; END ;";
       sqlstm.iters = (unsigned int  )1;
       sqlstm.offset = (unsigned int  )3461;
       sqlstm.cud = sqlcud0;
       sqlstm.sqlest = (unsigned char  *)&sqlca;
       sqlstm.sqlety = (unsigned short)4352;
       sqlstm.occurs = (unsigned int  )0;
       sqlstm.sqhstv[0] = (         void  *)&err_id;
       sqlstm.sqhstl[0] = (unsigned int  )sizeof(int);
       sqlstm.sqhsts[0] = (         int  )0;
       sqlstm.sqindv[0] = (         void  *)0;
       sqlstm.sqinds[0] = (         int  )0;
       sqlstm.sqharm[0] = (unsigned int  )0;
       sqlstm.sqadto[0] = (unsigned short )0;
       sqlstm.sqtdso[0] = (unsigned short )0;
       sqlstm.sqhstv[1] = (         void  *)err_msg;
       sqlstm.sqhstl[1] = (unsigned int  )100;
       sqlstm.sqhsts[1] = (         int  )0;
       sqlstm.sqindv[1] = (         void  *)0;
       sqlstm.sqinds[1] = (         int  )0;
       sqlstm.sqharm[1] = (unsigned int  )0;
       sqlstm.sqadto[1] = (unsigned short )0;
       sqlstm.sqtdso[1] = (unsigned short )0;
       sqlstm.sqhstv[2] = (         void  *)mesg;
       sqlstm.sqhstl[2] = (unsigned int  )458;
       sqlstm.sqhsts[2] = (         int  )0;
       sqlstm.sqindv[2] = (         void  *)0;
       sqlstm.sqinds[2] = (         int  )0;
       sqlstm.sqharm[2] = (unsigned int  )0;
       sqlstm.sqadto[2] = (unsigned short )0;
       sqlstm.sqtdso[2] = (unsigned short )0;
       sqlstm.sqhstv[3] = (         void  *)lSender;
       sqlstm.sqhstl[3] = (unsigned int  )40;
       sqlstm.sqhsts[3] = (         int  )0;
       sqlstm.sqindv[3] = (         void  *)0;
       sqlstm.sqinds[3] = (         int  )0;
       sqlstm.sqharm[3] = (unsigned int  )0;
       sqlstm.sqadto[3] = (unsigned short )0;
       sqlstm.sqtdso[3] = (unsigned short )0;
       sqlstm.sqhstv[4] = (         void  *)lRecipient;
       sqlstm.sqhstl[4] = (unsigned int  )40;
       sqlstm.sqhsts[4] = (         int  )0;
       sqlstm.sqindv[4] = (         void  *)0;
       sqlstm.sqinds[4] = (         int  )0;
       sqlstm.sqharm[4] = (unsigned int  )0;
       sqlstm.sqadto[4] = (unsigned short )0;
       sqlstm.sqtdso[4] = (unsigned short )0;
       sqlstm.sqphsv = sqlstm.sqhstv;
       sqlstm.sqphsl = sqlstm.sqhstl;
       sqlstm.sqphss = sqlstm.sqhsts;
       sqlstm.sqpind = sqlstm.sqindv;
       sqlstm.sqpins = sqlstm.sqinds;
       sqlstm.sqparm = sqlstm.sqharm;
       sqlstm.sqparc = sqlstm.sqharc;
       sqlstm.sqpadto = sqlstm.sqadto;
       sqlstm.sqptdso = sqlstm.sqtdso;
       sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}

 

	if(sqlca.sqlcode != ORCL_NO_ERROR) 
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		ifs_custerr("ORC_EXECUTE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"SENDMAIL", sqlmsg, " ", NULL);
	}
	if(err_id != 0)
	{
		strcpy(sqlmsg,err_msg);
		ifs_custerr("ORC_EXECUTE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"SENDMAIL", sqlmsg, " ", NULL);
	}

		
}
                                                                                                                                                                                                                                                                                           document/set1/JSNT.H_1.pdf                                                                          0000644     %g4001001 00000022665 14011436757 013543  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               /****************************************************************

JSNT.H
Copyright (C) 1999 - 2000 eFunds Corporation. All Rights Reserved.

Header File

****************************************************************/

#ifndef _JSNT_H
#define _JSNT_H

#include "efds.h"
#include <process.h>

//#include <winbase.h>


/* Macro definitions, enumerations */

#define INTERVAL 10
#define STEP_D_CHECK 5
#define JOB_D_CHECK 60
#define PQ_NAME "PQ.DAT"
#define STEPQ_NAME "STEPQ.DAT"
#define JOBQ_NAME "JOBQ.DAT"
#define MSGQ_NAME "MSGQ.DAT"
#define DELIVERY_NAME "DELIVERY.DAT"
#define LOCKED_NAME "LOCKED.DAT"
#define B_POS 22
#define B_GDR 23
#define STATUS_LINE (1)            /* Line # offset where current status id displayed */
#define EXCL 1
#define SKIP 2
#define DELIVERED 3
#define DELIVER 0
#define MAX_CONNECT_STR		200


#define JSNT_MSG "ACK_YN"
#define POSITIVE_RESPONSE "ACK_Y"
#define MAX_RETRIES 3
#define MIN_PORT_NO 5000
#define MAJOR_VERSION 2
#define MINOR_VERSION 2

/* Return 'Failure' values for external delivery            */
#define  ERR_EX_NONZERO          500
#define  ERR_EX_TIMEOUT          501
#define  ERR_EX_ERRFILE          502
#define  ERR_EX_ENVVARS          503
//NewProc() Defines
#define PROCESS_EXIT 0
#define CREATE_PIPE_ERR 1
#define CREATE_PROCESS_ERR 2
#define CAPTURE_SCREEN_ERR 3
#define TIMEOUT_ERR 4


/* Structure and Typedef's */
	typedef struct delivery {
	    char Delivery_ID[6];         /* Unique ID for this record */
	    char Bank_ID[9];             /* ABA for bank */
	    char Src_File_Spec[128];     /* Source filespec */
	    char Src_Rename_Mask[20];    /* Source rename spec */
	    char Dest_Path[128];         /* Destination path only */
	    char Dest_Rename_Mask[30];   /* Destination file spec */
	    char Move_Flag;              /* M=Move, C=Copy, N=Neither*/
	    char Convert_Flag;           /* A=ASCII, E=EBCIDIC, N=Neither */
		char Job_Path[128];          /* Path & filename of job */
		char Ext_Dist_Flag;          /* Y=external delivery, N=not */
		char Ext_Command[255];       /* External command line */
		char Ext_Error_File[128];    /* External error return file */
		char Ext_Run_On_Error[255];  /* Cmd to run on external error */
		char Ext_Timeout[4];         /* External timeout (minutes) */
		char Ext_Login_ID[30];       /* External login ID */
		char Ext_Password[256];       /* External pwd for login *///I140558110 - DEPSFTP Changes for pwd Encryption- increased 15 to 256
        char Record_Type;            // Record Type 'I'nbound or 'O'utbound
        char Filler1[254];           // Future expansion 
        char Filler2[143];           // Future expansion 

// Added for WR27164 - Hamsha

		char station[10];
		char jsgroup[10];

// End - Hamsha

	} delivery_def;

extern delivery_def delivery;



typedef struct 
{
	DWORD hThread;
	char filefound[150];
	delivery_def delivery;
} thread_rec;


typedef struct _SYSTIME   {
   unsigned int wDayOfWeek;      /* (Sun=0, Sat=6)          */
   unsigned int wYear;           /* (1980-2099)             */
   unsigned int wMonth;          /* (1-12)                  */
   unsigned int wDay;            /* (1-31)                  */
   unsigned int wHour;           /* (0-23)                  */
   unsigned int wMinute;         /* (0-59)                  */
   unsigned int wSecond;         /* (0-59)                  */
   unsigned int wHsec;           /* (0-99)                  */
} SYSTIME;

	/* WR28164 - Ext FTP command - Sujatha/Veera*/
	typedef struct achps_const_struct_tag	{
		char parameter_name[16];
		char parameter_value[41];
		char remarks[41];
	} achps_const_def;
	/* WR28164 - Ext FTP command - Sujatha/Veera*/


/* External Variables */
extern char copyright[50];
extern char prog_name[9];
extern char prog_version[9];

/* Global information */
extern char help_flag;
extern char szjspath[_MAX_PATH];    /* path of btrieve files            */
extern char szjobpath[_MAX_PATH];   /* path of .JOB files               */
extern char szlogpath[_MAX_PATH];   /* path of log files               */
extern char szlocallogpath[_MAX_PATH];   /* path of local log files     */
extern char szjsclass[2];           /* class of this job server         */
extern char szjobmon_ip[16];          /* IP address of Jobmonnt           */
extern char env_buffer[1024];       /* Environment Variable Buffer      */
extern short int jobmon_port_no;    /* Port number of Jobmonnt          */
extern char idle;                   /* idle flag                        */
extern short int now;               /* now flag                         */
extern char debug_flag;        /* debug flag                       */
extern char szdispline3[100];
extern short int xpos;              /* position of x coordinate of the cursor           */
extern short int ypos;              /* position of y coordinate of the cursor           */
extern char no_delivery;       /* no_delivery is flag for delivery or not          */
extern char no_submit;		/* no_submit is flag submission of job not to happen */
extern char station_only;   /* new paraeter WR 28164  sujatha/veera */

extern char szjsname[9];            /* job server name                  */
extern char scan_cmd[100];
extern char config_name[_MAX_PATH];
extern short int job_processing;
extern char no_screens; 		      /* no_screens is flag for capture screens or not */
extern size_t scr_buffer_size;		/* size of the screen buffer */
extern char*  screen_buffer;		/* buffer to capture screen info */
extern short close_step;




extern delivery_def delivery;



/* Network Information */
extern char user_name[48];
extern char server_name[48];
extern char network_station_id[4];
extern char network_physical_address[13];
extern char network_full_address[20];
extern char network_id_s[9];

/* Base directory variables */
extern short int curr_drive;
extern char curr_dir[_MAX_PATH];


extern unsigned long base_dir_job;



/* Thread Variables */
extern short int max_deliveries;       /* max number of jobs and delivery threads to spawn */
extern thread_rec *thread;
extern CRITICAL_SECTION rename_lock;
extern CRITICAL_SECTION submit_lock;
extern CRITICAL_SECTION jsnt_sql_lock;
extern CRITICAL_SECTION env_lock;
extern CRITICAL_SECTION thread_handle_lock;


/* Functions (alphabetical) */
int  blnknull(char *);
int  check_actives(void);
int  check_class(void);
int  check_err_environment (short int thread_id, unsigned long *err_num, char *err_msg);
int  check_err_file (char *filename, unsigned long *err_num, char *err_msg);
int  check_scheduled(void);
int  check_waiting(void);
void clr_ex_env_vars (short int thread_id);
int  close_job();
int  connect_db();
int  console_message(char *, int, char *);
int  convert_file (char *, char);
void create_unique_name (char *, char *, char *, char *);
int  create_lock (char *);
int createSocket();
BOOL WINAPI CtrlHandler (DWORD dwEvent);
int  db_connect (char *connect_str);
void db_connect_str (char *connect_str);
int  delete_lock_file (char *path);
int  debug_log(char *);
int  delete_js(void);
void deliv_box(void);
void display_paused(void);
void ex_replacevars (short int thread_id, char *src_file, char *dst_file, delivery_def *dlv, char *in_buff, unsigned long err_num, char *err_msg);
int  format_novell_info(void);
void get_cmdline(int argc, char *argv[]);
//int  get_primary_card_addr (ipx_inet_addr *card_addr, char init_sockets);
int  get_system_date_time(char *);
int  get_user_name (char *user_name);
void getsystime (struct _SYSTIME *st);
void ifsdisplay(char type, char *pname, char*pver, char *text);
int  is_group_finished(int, char *);
int  is_same_machine();
int  load_holidays(datestring *);
//int  load_net_id(char *, char *);
int  logit(int, char *);
//	DRQ 2003 -077 Baskar/Veera  added a log function with local time
int logitwithlocaltime (int log_type, char *msg);
int  login_js(void);
int  mark_processor_file();
//int  NewProc(char *, STARTUPINFO *, PROCESS_INFORMATION *);
int  NewProc(char *strCommandLine, int StatusInterval, int CaptureScreens, long TimeOut, unsigned long *exit_code);
void paint_box_c(void);
void print_usage(void);
void process_delivery (void * id);
int  process_ex_dlvry (short int thread_id, char *src_file, char *dst_file, delivery_def *dlv);
void process_pipe(char *pipe_buffer);
int  process_task();
void replacevar (char *path, char *filename);
void replace_variables(char *buf);
void replwild(char *, char *, char *);
int  scan_file(char *);
void screen_blank(void);
int  search_delivery(void);
//int  search_delivery(char);		//  WR 28164 sujatha/veera
int  search_queue(void);
void send_begin_msg();
void send_end_msg();
void send_messages(char *msg);
int  start_job(char *);
char *str_begend (char *str, char start, char end);
void submit_msg(char *msg);
int  test_j_dep();
int  test_s_dep();
int  vld_path(char *szpath);
int  wait_process_complete (char *src_file, delivery_def *dlv, PROCESS_INFORMATION *l_lpProcessInformation, unsigned long *err_num, char *err_msg);
int write_status_file(unsigned int right, unsigned int bottom);
int submit(char *new_date, char *new_time);
int date_logic(char *new_date, char *new_time);
long job_num_get();
int get_job_num(void);
void load_achps_const_recs(void);       	/* WR 28164 - Sujatha/Veera */
int lookUpAchpsConst(achps_const_def *,char *);	/* WR 28164 - Sujatha/Veera */
void sendMail(char *); /* WR 28164 - Sujatha/Veera */

#endif  //end JSNT_H                                                                           document/set1/JSNT.PC_2.pdf                                                                         0000644     %g4001001 00000517340 14011436760 013650  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               /****************************************************************

JSNT
Copyright (C) 1999 - 2000 eFunds Corporation. All Rights Reserved.

Main Program Module And Job Processing Functions

****************************************************************/
#define SQLCA_STORAGE_CLASS extern
#define	ORACA_STORAGE_CLASS extern


EXEC SQL INCLUDE	"sqlproto.h";
EXEC SQL INCLUDE	"sqlca.h"; 
EXEC SQL INCLUDE	"sqlda.h";
EXEC SQL INCLUDE	"orcltype.h";
EXEC SQL INCLUDE	"jsnt_sql.h";

#include "JSNT.H"
#include "JSNTSecuredbAccess.h"

LibParams efdsParams = {
   TRUE,
   IFS_DISPLAY
};

sql_context g_ctx;

EXEC SQL BEGIN DECLARE SECTION;
	js_pq_sql_def p_q;
	js_pq_sql_ind_def p_q_ind;

	js_jobq_sql_def job_q;
	js_jobq_sql_ind_def job_q_ind;

	js_stepq_sql_def step_q;
	js_stepq_sql_ind_def step_q_ind;

	js_msgq_sql_def msg_q;

	js_locked_def locked;

	js_holiday_def holiday_rec;

	js_stepq_sql_def stepq_sql;
	js_stepq_sql_ind_def stepq_sql_ind;

	js_jobq_sql_def jobq_sql;
	js_jobq_sql_ind_def jobq_sql_ind;

	js_delivery_sql_def		delivery_recs;
	js_delivery_sql_ind_def	delivery_recs_inds;

	achps_const_sql *g_achps_const_recs;  /* WR 28164 Sujatha/Veera */
	achps_const_sql *g_achps_const_email_recs;  /* WR 28164 Sujatha/Veera */
	int totRec;							  /* WR 28164 Sujatha/Veera */	
	int totEmailRec;					  /* WR 28164 Sujatha/Veera */

EXEC SQL END DECLARE SECTION;

extern void trim_sql_stepq(js_stepq_sql_def *);
extern void trim_sql_jobq(js_jobq_sql_def *);

// Include exception header. The funcitons needs to be removed when 
// we move the code to QA.  DRQ 2003 -077 Baskar/Veera

using namespace std;
#include "except.h"


/***************************** main ****************************
*                                                              *
* Description: JSNT main initialization startup function       *
*                                                              *
*                                                              *
* Creation Date: 06/21/96        By: Mike West                 *
*   Modify Date: 08/05/99        By: Mike West                 *
*                                                              *
***************************************************************/
int main (int argc, char *argv[])
{
   char szbuff[300];          /* message array buffer        */
   char ch;                   /* keystroke pressed           */
   short int ret;             /* return code                 */
   short int badclose=0;
   short int i,threads_running;
   char szmaxdlv[10];


	//	DRQ 2003 -077 Baskar/Veera catching regular and unhandled exceptions
	_set_se_translator(_Translate_Structured_Exception);
   	LPTOP_LEVEL_EXCEPTION_FILTER OrigUnHandler;
	OrigUnHandler = SetUnhandledExceptionFilter(Unhandled_Exception_Filter);


   copy_cat(szbuff, "Loading ", prog_name, " ", prog_version, NULL);
   qtext(10,10,szbuff);
   
   get_cmdline (argc, argv);

   ret = ifs_init (prog_name, prog_version, ifsdisplay);
   if (ret != SUCCESS) 
   exit(2);

   ret = efdsLibrary.initialize(efdsParams);
   RETURN_VAL_IF_TRUE(ret != OK, ERR);



//   copy_cat(szbuff, "Loading ", prog_name, " ", prog_version, NULL);
//   qtext(10,10,szbuff);
//   //printf ("Loading %s %s...\n", prog_name, prog_version);
//   get_cmdline (argc, argv);

   /*  Sets up the Console Control handler routine that will be called */
   /*  if the console closes or if the system is log off or shuts down.*/
   /*  This is so that the process has an opportunity to clean up      */ 
   /*  before termination.                                             */ 
   SetConsoleCtrlHandler((PHANDLER_ROUTINE)CtrlHandler, TRUE);


   memset (&job_q, 0, sizeof (job_q));
   memset (&step_q, 0, sizeof (step_q));


   /* Allocate and Initialize Thread Structure */
   thread = (thread_rec *) calloc (max_deliveries, sizeof(thread_rec));
   if (thread == NULL)  
   {
	   _itoa(max_deliveries, szmaxdlv, 10);
	   copy_cat(szbuff, "Unable to allocate enough memory for ", szmaxdlv, " threads.", NULL);
	   //sprintf(szbuff,"Unable to allocate enough memory for %d threads", max_deliveries);
	   logit (0, szbuff);
	   debug_log (szbuff);
	   exit (2);
   }



   InitializeCriticalSection (&rename_lock);
   InitializeCriticalSection (&submit_lock);
   InitializeCriticalSection (&jsnt_sql_lock);
   InitializeCriticalSection (&env_lock);
   InitializeCriticalSection (&thread_handle_lock);


	EXEC SQL ENABLE THREADS;

	EXEC SQL CONTEXT ALLOCATE :g_ctx;

	EXEC SQL CONTEXT USE :g_ctx;

	if(connect_db() != SUCCESS)
		exit(3);



	if(login_js() != 0)                       /* tell PQ.DAT about this JS              */
	{
		copy_cat(szbuff, "JOB SERVER DOWN!~Job Server ", szjsname, "has gone down.  Check log for reason.", NULL);
        console_message (szbuff, 1, "A");
		exit(4);
	}


    if(format_novell_info() != 0)             /* format and load novell info            */
	{
		copy_cat(szbuff, "JOB SERVER DOWN!~Job Server ", szjsname, "has gone down.  Check log for reason.", NULL);
        console_message (szbuff, 1, "A");
		exit(5);
	}

   submit_error = submit_msg;                /* function to call for jcsubmit msg's    */
   cls(TX_NORMAL);                           /* clear the screen                       */
   paint_box_c();
   logit (0, "Job Server Started");           /* log job server started                 */


	/* WR 28164 - Sujatha/Veera */
	
   load_achps_const_recs();   


/* Start of loop to check things.  First check to see if the ESC key    *
 * has been pressed.  Then check to see if there are any files that     *
 * match the delivery configuration look_for_file parameter.  Then      *
 * check the schedule queue for scheduled jobs, the active queue for    *
 * jobs that are currently running and the waiting queue for jobs that  *
 * need to be run.                                                      */
   while (!badclose) 
   {

/*      Process user keypresses - ESC will exit the program */
      if (_kbhit()) {
         if (!(ch = _getch())) _getch();      /* If extended key, clear remaining char */
         else if (ch==27) {
			 /* Make sure all threads are done before allowing job server to exit */
			 threads_running = 1;
			 while (threads_running == 1) {
				 for (i=0; i < max_deliveries; i++) {
					 if(thread[i].hThread != 0) {
						 threads_running = 1;
						 break;
					 }
					 else threads_running = 0;
				 }
				 if (threads_running == 1){
					Sleep(500);
				 }
			 }
			 logit (0, "ESC Keystroke break");
              break;
         }
      }

/*      Search the queue for things to do */
      if (ret = search_queue()) {             /* non-zero is a possible rror */

         if(ret == -2) {      /* exit from Delivery System */
            logit (0, "Bad Exit from search_delivery()");
			copy_cat(szbuff, "JOB SERVER DOWN!~Job Server ", szjsname, "has gone down.  Check log for reason.", NULL);
            //sprintf(szbuff, "JOB SERVER DOWN!~Job Server %s has gone down.  Check log for reason.", szjsname);
            console_message (szbuff, 1, job_q.job_class);
            break;
         }

         logit (0, "Bad Exit from search_queue()");
		 copy_cat(szbuff, "JOB SERVER DOWN!~Job Server ", szjsname, "has gone down.  Check log for reason.", NULL);
         //sprintf (szbuff, "JOB SERVER DOWN!~Job Server %s has gone down.  Check log for reason.", szjsname);
         console_message (szbuff, 1, job_q.job_class);
         badclose = 1;
         break;
      }

      if (idle) 
		  screen_blank();
   }

  

	delete_js ();            /* delete this job server from the PQ.DAT file */
	logit (0, "Job Server Stopped");
	debug_log ("Job Server Stopped");
	setxy (0,24);
	qtext (0, 24, "Job Server Stopped");

   copy_cat(szbuff, "[", szjsname, "] - EXITED                            ", prog_version, NULL);
   //sprintf (szbuff, "[%s] - EXITED                            %s", szjsname, prog_version);
   SetConsoleTitle (szbuff);


   	EnterCriticalSection(&jsnt_sql_lock);
	// Logoff
	EXEC SQL COMMIT WORK RELEASE;
	// Free the sql context allocated above
	EXEC SQL CONTEXT FREE :g_ctx;
	LeaveCriticalSection(&jsnt_sql_lock);


   DeleteCriticalSection (&jsnt_sql_lock);
   DeleteCriticalSection (&rename_lock);
   DeleteCriticalSection (&submit_lock);
   DeleteCriticalSection (&env_lock);
   DeleteCriticalSection (&thread_handle_lock);



  //klk 9/210/01 free( screen_buffer ); 
   if (badclose)  exit(5);

   return SUCCESS;
}



/************************* get_cmdline  ************************
*                                                              *
* Description: Examines the command-line parameters for        *
*  the program.  Makes sure that the required parameters are   *
*  there.                                                      *
*                                                              *
* Creation Date: 06/24/96        By: Mike West                 *
*                                                              *
***************************************************************/
void get_cmdline(int argc, char *argv[]) {
	int ret, i;
	int line_no;
	//char env_str[1024];	
	//char *path;
	//char temp[1024];

	static cfg_item cfg_params[18] =
	{
		"HELP",              &help_flag,      CF_CHARTRUE,  0, NULL, NULL,
        "JSNAME",            &szjsname,       CF_STRING,    sizeof(szjsname)-1,  NULL, NULL,
        "PATH",              &szjspath,       CF_STRING,    sizeof(szjspath)-1,  NULL, NULL,
		"JOBPATH",           &szjobpath,      CF_STRING,    sizeof(szjobpath)-1, NULL, NULL,
		"CLASS",             &szjsclass,      CF_STRING,    sizeof(szjsclass)-1, NULL, NULL,
		"LOGPATH",		     &szlogpath,      CF_STRING,    sizeof(szlogpath)-1, NULL, NULL,
		"LOCALLOGPATH",		 &szlocallogpath, CF_STRING,	sizeof(szlocallogpath)-1, NULL, NULL,
		"NO_DELIVERY",       &no_delivery,    CF_CHARTRUE,  0, NULL, NULL,
		"NO_SUBMIT",         &no_submit,      CF_CHARTRUE,  0, NULL, NULL,
		"STATION_ONLY",      &station_only,   CF_CHARTRUE,  0, NULL, NULL, //new parameter WR 28164 - sujatha/veera
		"SCAN_CMD",          &scan_cmd,       CF_STRING,    sizeof(scan_cmd)-1,  NULL, NULL,
		"MAX_DELIVERIES",    &max_deliveries, CF_INT32,     0, NULL, NULL,
		"DEBUG",             &debug_flag,     CF_CHARTRUE,  0, NULL, NULL,
		"NO_STATUS_SCREENS", &no_screens,     CF_CHARTRUE,  0, NULL, NULL,
		"CONFIG",            &config_name,    CF_STRING,    sizeof(config_name)-1, NULL, NULL,
		"JOBMONNT_IP",	     &szjobmon_ip,	  CF_STRING,	sizeof(szjobmon_ip) - 1, NULL, NULL,
		"JOBMONNT_PORT_NO",  &jobmon_port_no, CF_INT32,	    0, NULL, NULL,
		"",               0,               0,               0, NULL, NULL,
	};

   /* convert all cmd line parameters to uppercase */
   for(i=0; i<argc; i++)
      _strupr(argv[i]);


	strcpy(szjsname, "JOBSERV"); /* Set Default Job Server Name */

    ret = read_cmdline(argc, (const char **)argv, cfg_params, &line_no);

//int read_cmdline(int argc, const char *argv[], cfg_item *cfg_params, int *param)


	if (ret != CFE_OK || help_flag == 1) 
		print_usage(); /* Display Help and Exit */

	if (strlen(config_name) != 0) {
		ret= read_cfg(config_name, cfg_params, &line_no);
		if (ret != CFE_OK)
			print_usage(); /* Display Help and Exit */
	}

	/* Add backslash to ends of paths if they don't already exist */
	if (strlen(szjspath) != 0) {
		if (szjspath[strlen(szjspath)-1] != '\\') {
			szjspath[strlen(szjspath)] = '\\';
			szjspath[strlen(szjspath)+1] = 0;
		}
	}
	if (strlen(szjobpath) != 0) {
		if (szjobpath[strlen(szjobpath)-1] != '\\') {
			szjobpath[strlen(szjobpath)] = '\\';
			szjobpath[strlen(szjobpath)+1] = 0;
		}
	}
	if (strlen(szlogpath) != 0) {
		if (szlogpath[strlen(szlogpath)-1] != '\\') {
			szlogpath[strlen(szlogpath)] = '\\';
			szlogpath[strlen(szlogpath)+1] = 0;
		}
	}
	if (strlen(szlocallogpath) != 0) {
		if (szlocallogpath[strlen(szlocallogpath)-1] != '\\') {
			szlocallogpath[strlen(szlocallogpath)] = '\\';
			szlocallogpath[strlen(szlocallogpath)+1] = 0;
		}
	}
}



/********************** connect_db *********************************************
* Description:                                                                 *
*   Gets connection string from INI file and then connects to the appropriate  *
* database.                                                                    *
*                                                                              *
* Creation Date:	07/22/1999	By: Mike West                                  *
* Modified Date:					By:                                        *
*******************************************************************************/

int connect_db()
{
	char	dbname[MAX_CONNECT_STR];
	char	username[MAX_CONNECT_STR];
	char	connect_str[MAX_CONNECT_STR];
	char	ifs_info[381];
	char	tempstr[500];
	char    szbuff[100];
	char	temp1[30];
	char	temp2[30];

	EXEC SQL BEGIN DECLARE SECTION;
		long		sqlerrmsg_len = 0;
		long		sqlerrmsg_buf_size = 513;
		char		sqlerrmsg_buf[513];
	EXEC SQL END DECLARE SECTION;

	// Returns the database connect string.
	db_connect_str (connect_str);		/* eg, "SCOTT/TIGER@ORCL" */
	strcpy(tempstr, connect_str);
	parse_substr (tempstr, '/', 1, temp1);
	parse_substr (tempstr, '@', 2, temp2);
	copy_cat(tempstr, temp1, "@", temp2, NULL);
	copy_cat(szbuff, "Connecting to database ", NULL, NULL); // Saravanan 
	qtext (10,15, szbuff);

	// Try to connect to the database
	EnterCriticalSection(&jsnt_sql_lock);

	if (db_connect(connect_str) != OK)
	{
		memset(username, '\0', sizeof(username));
		memset(dbname, '\0', sizeof(dbname));
		strncpy(username, connect_str, strcspn(connect_str, "/"));	
		strcpy(dbname, connect_str + 1 + strcspn(connect_str, "@"));
		sqlglm(sqlerrmsg_buf, (size_t*)&sqlerrmsg_buf_size, (size_t*)&sqlerrmsg_len);
		sqlerrmsg_buf[sqlerrmsg_len] = '\0';
		copy_cat(ifs_info, "Job Server: ", szjsname, NULL);
		ifs_fatal("ORC_CONNECT", __FILE__, (DWORD) __LINE__, IFS_LOG,
		/* <1> = username */		username,
		/* <2> = dbname   */		dbname,
		/* <3> = info	*/			ifs_info,
		/* <4> = ORCL_Msg	*/		sqlerrmsg_buf,
										NULL);

		copy_cat(tempstr, "Username: ", username, " DBName:", dbname, " Job Server:", 
							ifs_info, " Database Msg:", sqlerrmsg_buf, NULL);

		logit (0, tempstr);
		logit (0, "DB_Connect failed!  Job Server Stopped.");
		debug_log ("Job Server Stopped");
		qtext(10,10, "Job Server Stopped");

		sqlca.sqlerrm.sqlerrmc[sqlca.sqlerrm.sqlerrml] = '\0';
		strcpy(tempstr, sqlca.sqlerrm.sqlerrmc);
		logit (0, tempstr);
		debug_log (tempstr);

		LeaveCriticalSection(&jsnt_sql_lock);

		return(ERR);
	}
	else
		qtext(0,16, "Connection to Database Successful");

	LeaveCriticalSection(&jsnt_sql_lock);

	return(SUCCESS);
}


/*********************** db_connect ********************************************
* Description:																	
*		This function attempts to connect to the Oracle Database 
*		and displays a message on the task line as to its success
*     or failure.  It also alters the session to set the default
*		date format to 'YYYYMMDD'.  Returns OK or ERR.
*																               
* Creation Date:	06/04/1996	By: Troy Clark
* Modified Date:	06/10/1996	By: Troy Clark
* Modified Date:	05/08/1998	By: FRNash Added delay after each failed connect.
*******************************************************************************/
int db_connect (char *connect_str)
{
	short		attempts = 1 + DB_CONNECT_RETRIES;	/* # connect attempts */
	int			l_sqlcode;
	
	EXEC SQL BEGIN DECLARE SECTION;
		char	*h_con_str_ptr;
	EXEC SQL END DECLARE SECTION;
	
	if (connect_str == NULL)		return(ERR);
	if (connect_str[0] == '\0')	return(ERR);
	h_con_str_ptr = connect_str;

	EnterCriticalSection(&jsnt_sql_lock);

	while (attempts-- > 0) 
	{
		EXEC SQL CONNECT :h_con_str_ptr;
		l_sqlcode = sqlca.sqlcode;

		if (l_sqlcode == ORCL_NO_ERROR) 
			break;
		Sleep(3000);	/* delay 3 seconds after each failed attempt */
	}

	if (l_sqlcode != ORCL_NO_ERROR) 
	{
		LeaveCriticalSection(&jsnt_sql_lock);
		return(ERR);
	}

	/*
		Set default date format YYYYMMDD (eg. 19961225 = Xmas '96)
		This format will be used by oracle to automatically convert
		char host arrays to/from date on insert/fetch.
	*/
	EXEC SQL ALTER SESSION SET nls_date_format = 'YYYYMMDDHH24MISS';
	l_sqlcode = sqlca.sqlcode;
	LeaveCriticalSection(&jsnt_sql_lock);

	if (l_sqlcode == ORCL_NO_ERROR)
		return(OK);
	else
		return(ERR);
}


/********************** db_connect_str ************************
*															  	               
* Description: Sets the connect_str arg to the database
*					connection string for connecting to the
*					database.  It actually looks up the string
*					from the JCSNT.INI file (it searches for
*					the file in the the directories listed in the
*					system PATH environment variable.  If the PATH
*					is undefined then, it search the current working
*					directory and then the winnt35 directories).
*
*		NOTE:		Caller must ensure that connect_str points
*					to a buffer of at least MAX_CONNECT_STR chars!
*																               
* Creation Date:	06/04/96		By: Troy Clark				         
* Modified Date:	01/08/97		By: Troy Clark			            															                  *
***************************************************************/
void db_connect_str (char *connect_str) 
{//db_connect_str
   connect_str[0] = '\0';//initialize connect string
   char     fpath[_MAX_DRIVE + _MAX_PATH + _MAX_FNAME + _MAX_EXT];   
   char*    fname = "AchosSec.ini";
   char*    sys_path;
   char*    cp;

   //dr00-011
   //create an instance of class SecureDbAccess
   JSNTSecureDbAccess* pEfInstance = new JSNTSecureDbAccess();
   //first try root directory
   //set the member variable to default root directory file name
   pEfInstance->SetFileName(fname);
   try
   {//               
      strcpy(connect_str, const_cast<char*>(pEfInstance->BuildDbConnectString()));
   }//         
   catch (...)
   {//catch
      //file could not be found
      //search path
      sys_path = getenv("PATH");
      if (sys_path != NULL) 
      {//if    
         cp = sys_path;
         while (*cp) 
         {//while
            while (*cp && (*cp != ';'))
            {//while
               cp++;
            }//while
            move(fpath, cp - sys_path, sys_path, 1);
            trimlr(fpath);
            if (fpath[strlen(fpath) - 1] != '\\')
            {//if
               strcat (fpath, "\\");
            }//if
            strcat(fpath, fname);
            //set member variable to new path and name
            pEfInstance->SetFileName(fpath);
            try
            {//               
               strcpy(connect_str, const_cast<char*>(pEfInstance->BuildDbConnectString()));
               break;
            }//         
            catch (...)
            {//
               //error message               
               connect_str[0] = '\0';  //upon failure (DEFAULT VALUE) //taa
               //try again
            }//
            
            if (connect_str[0] != '\0')
            {//if
               break; /* FOUND IT */
            }//if
            sys_path = ++cp;
         }//while
      }//if
      else
      {//else
         connect_str[0] = '\0';
      }//else
   }//catch 
   delete pEfInstance;
}//db_connect_str



/**************************  CtrlHandler ***************************** 
* Description:                                                       * 
*    System generated CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT, and       * 
* CTRL_SHUTDOWN_EVENTs signal when the user closes the console, logs * 
* off, or shuts down the system so that the process has an           * 
* opportunity to clean up before termination.                        * 
*                                                                    * 
* Creation Date:   04/28/1998      By: Mike West                     * 
*********************************************************************/ 
BOOL WINAPI CtrlHandler(DWORD dwEvent)
{
	short int i;
    char szbuff[300];          /* message array buffer        */


	if(dwEvent == CTRL_LOGOFF_EVENT ||
	   dwEvent == CTRL_SHUTDOWN_EVENT ||
	   dwEvent == CTRL_CLOSE_EVENT) {
		for(i = 0; i < max_deliveries; i++) {
			if (thread[i].hThread != 0) {
				return (TRUE);
			}
		}
	}


	delete_js ();            /* delete this job server from the PQ.DAT file */

    sprintf (szbuff, "JOB SERVER DOWN!~Job Server %s has gone down.  User Closed Application.", szjsname);
    console_message (szbuff, 0, job_q.job_class);

	logit (0, "Application Window Closed");
	logit (0, "Job Server Stopped");
	debug_log ("Job Server Stopped");

	return(FALSE);
}


/************************* check_class *************************
*                                                              *
* Description: Ensures the class that is passed on the command *
*  line equals that in the job_q.DAT file.                      *
*                                                              *
* Creation Date: 06/24/96        By: Mike West                 *
*                                                              *
***************************************************************/
int check_class (void) {
   if (strlen(szjsclass) == 0) 
	   return SUCCESS;

   trimr(job_q.job_class);
   if (szjsclass[0] == 
	   job_q.job_class[0]) return SUCCESS;
   return ERR;
}


/************************* login_js ****************************
*                                                              *
* Description: Identify to the PQ.DAT file (Processor Queue)   *
*  or to the PQ table that this JS name is now becoming active.*
*                                                              *
* Creation Date: 06/24/96        By: Mike West                 *
* Modify Date:   07/21/99        By: Mike West                 *
*                                                              *
***************************************************************/
int login_js(void) 
{
	unsigned short int rec_exists;
	unsigned short int ret=0;
	char szbuff[50];
	int l_sqlcode;
	char szret[10];
	char sqlmsg[80];


	EXEC SQL BEGIN DECLARE SECTION;
		char process_name[15];
		char job_server_name[15];
	EXEC SQL END DECLARE SECTION;


	rec_exists = 1;
	strcpy(job_server_name, szjsname);
	
	// Try to find the job server name in the PQ table
	EnterCriticalSection(&jsnt_sql_lock);


	EXEC SQL SELECT proc_name
		INTO :process_name
		FROM PQ
		WHERE proc_name = :job_server_name;

	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);


	if (l_sqlcode == ORCL_NOT_FOUND)
		rec_exists = 0;
	else
	{
		if(l_sqlcode != ORCL_NO_ERROR)
		{
			ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
				"PQ", sqlmsg, "proc_name",	NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff, "Error during SELECT from PQ table - SQLCA.SQLCODE=", 
								szret, " ", sqlmsg, NULL);
			//sprintf(szbuff, "Error during SELECT from PQ table - SQLCA.SQLCODE=%d, %s", 
			//		l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log(szbuff);
			return ERR;
		}
	}


   /* Fill up PQ structure with information about this Job Server */
   memset (&p_q, 0, sizeof (p_q));
   strcpy((char*)p_q.proc_name, szjsname);
   p_q.status = 0;
   p_q.job_num = 0;
   strcpy((char*)p_q.job_name, "IDLE");
   p_q.step_num = 0;
   strcpy((char*)p_q.step_name, "        ");
   strcpy((char*)p_q.must_complete_by, "    ");


   p_q.multi_processing[0] = '0';
   if (!rec_exists) 
	   p_q.job_paused[0] = '0';

//KLK REPLACE WITH TCPIP
//K	if(load_net_id ((char*)p_q.net_node, szbuff) == SUCCESS)
//		memcpy (p_q.net_id, szbuff+4, sizeof (p_q.net_id)); /* Only last 4 chars of network ID */
//	else
//	{
		strcpy((char*)p_q.net_node, "UNKNOWN     "); 
		strcpy((char*)p_q.net_id,   "NONE");
//	}
//KLK END REPLACE WITH TCPIP


   if (rec_exists)
   {
	   // Try to update the PQ table up to 10 times before Erroring out
	   EnterCriticalSection(&jsnt_sql_lock);

	   //for(x=0; x<LOCK_TRIES; x++)
	   //{
		    // Lock this row of the PQ table for updating.
	
			EXEC SQL SELECT proc_name 
				INTO :process_name
				FROM PQ
				WHERE proc_name = :job_server_name
				FOR UPDATE;
				//FOR UPDATE NOWAIT;


			l_sqlcode = sqlca.sqlcode;
		
	   		if(l_sqlcode != ORCL_NO_ERROR)
			{
					strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
					LeaveCriticalSection(&jsnt_sql_lock);

					ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
									"PQ", sqlmsg, "proc_name",	NULL);
					_itoa(l_sqlcode, szret, 10);
					copy_cat(szbuff, "Error during SELECT FOR UPDATE from PQ table - SQLCA.SQLCODE=", 
								szret, sqlmsg, NULL);
					//sprintf(szbuff, "Error during SELECT FOR UPDATE from PQ table - SQLCA.SQLCODE=%d, %s", 
					//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
					logit (0, szbuff);
					debug_log(szbuff);
					return ERR;
			}


	    // Update the PQ table with this information.
		EXEC SQL UPDATE PQ
			SET proc_name  = :p_q.proc_name,
				status     = :p_q.status,
				net_node   = :p_q.net_node,
				job_num    = :p_q.job_num,
				job_name   = :p_q.job_name,
				step_num   = :p_q.step_num,
				step_name  = :p_q.step_name,
				entry_date = :p_q.entry_date,
				start_date = :p_q.start_date,
				must_complete_by = :p_q.must_complete_by,
				multi_processing = :p_q.multi_processing,
				group_name = :p_q.group_name,
				job_class  = :p_q.job_class,
				net_id     = :p_q.net_id,
				job_paused = :p_q.job_paused
			WHERE proc_name = :job_server_name;

			l_sqlcode = sqlca.sqlcode;
	
			if(sqlca.sqlcode != ORCL_NO_ERROR)
			{
				strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
				EXEC SQL ROLLBACK;
				LeaveCriticalSection(&jsnt_sql_lock);

				ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"PQ", sqlmsg, " ", NULL);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff, "Error during UPDATE of PQ table - SQLCA.SQLCODE=",
									szret, sqlmsg, NULL);
				logit (0, szbuff);
				debug_log(szbuff);
				return ERR;
			}
	
			// Commit the update
			EXEC SQL COMMIT;

			l_sqlcode = sqlca.sqlcode;
	
			if (sqlca.sqlcode != ORCL_NO_ERROR)
			{
				strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
				EXEC SQL ROLLBACK;
				LeaveCriticalSection(&jsnt_sql_lock);

				ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						sqlmsg, "PQ table", NULL);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff, "ERROR: COMMIT after UPDATE of PQ table failed: - SQLCA.SQLCODE=",
							szret, sqlmsg, NULL);
				logit (0, szbuff);
				debug_log(szbuff);
				return ERR;
			}
			LeaveCriticalSection(&jsnt_sql_lock);

	}
	else
	{
		// New record, must insert into the PQ table
		EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL INSERT INTO PQ VALUES (
			:p_q.proc_name,
			:p_q.status,
			:p_q.net_node,
			:p_q.job_num,
			:p_q.job_name,
			:p_q.step_num,
			:p_q.step_name,
			:p_q.entry_date,
			:p_q.start_date,
			:p_q.must_complete_by,
			:p_q.multi_processing,
			:p_q.group_name,
			:p_q.job_class,
			:p_q.net_id,
			:p_q.job_paused);

		l_sqlcode = sqlca.sqlcode;
	

   		if(l_sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_INSERT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"PQ", "proc_name", " ", sqlmsg, " ", NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff, "Error during INSERT INTO PQ table - SQLCA.SQLCODE=", 
						szret, sqlmsg, NULL);
			logit (0, szbuff);
			debug_log(szbuff);
			return ERR;
		}

	
		EXEC SQL COMMIT;
		l_sqlcode = sqlca.sqlcode;

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						sqlmsg, "PQ table", NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"ERROR: COMMIT after INSERT into PQ table failed: - SQLCA.SQLCODE=", 
						szret, sqlmsg, NULL);
			logit (0, szbuff);
			debug_log(szbuff);
			return ERR;
		}

		LeaveCriticalSection(&jsnt_sql_lock);

	}

   return SUCCESS;
}


/************************ delete_js ****************************
*                                                              *
* Description: Deletes this Job Server from the PQ.DAT file    *
*  (Processor Queue).                                          *
*                                                              *
* Creation Date: 06/24/96        By: Mike West                 *
*                                                              *
***************************************************************/
int delete_js (void) 
{
   char szbuff[200];
   int  l_sqlcode;
   char szret[10];
   char sqlmsg[80];

	EXEC SQL BEGIN DECLARE SECTION;
		char job_server_name[20];
	EXEC SQL END DECLARE SECTION;



	strcpy (job_server_name, szjsname);     /* key is Job Server name  */

	EnterCriticalSection(&jsnt_sql_lock);

	EXEC SQL DELETE
	   FROM pq
	   WHERE proc_name = :job_server_name;

	l_sqlcode = sqlca.sqlcode;

	if (l_sqlcode == ORCL_NOT_FOUND) /* cannot find Job Server name - that's OK - SUCCESSFUL RETURN */
	{
		LeaveCriticalSection(&jsnt_sql_lock);

		return SUCCESS;
	}

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		LeaveCriticalSection(&jsnt_sql_lock);

		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff, "Error DELETING Job Server ", job_server_name, " from PQ Table - SQLCA.SQLCODE=",
						szret, sqlmsg, NULL);
		logit (0, szbuff);
		debug_log (szbuff);
		return ERR;
	}


	EXEC SQL COMMIT;
	l_sqlcode = sqlca.sqlcode;

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					sqlmsg, "PQ table", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff, "ERROR: COMMIT after DELETE on PQ table failed: - SQLCA.SQLCODE=", 
						szret, sqlmsg, NULL);
		logit (0, szbuff);
		debug_log(szbuff);
		return ERR;
	}

	LeaveCriticalSection(&jsnt_sql_lock);


	return SUCCESS;
}



/************************** NewProc ****************************
*                                                              *
* Description: This function is responsible for creating a     *
*              new child process.  It sets up the STARTUPINFO  *
*              structure on how it wants the child process     *
*              window to look like, then issues the            *
*              CreateProcess() function which runs the child   *
*              process.  Information on whether the child      *
*              process is still active or has terminated is    *
*              in the PROCESS_INFORMATION structure.           *
*                                                              *
* Creation Date: 06/21/96     By: Mike West                    *
* Modified On  : 17/Apr/2000  By: Sasidhar D & Sabari Girish J *
* Descrption: Removed CREATE_NEW_CONSOLE flag from			   *
*             CreateProcess()								   *
*                                                              *
***************************************************************/
int NewProc(char *strCommandLine, int StatusInterval,int CaptureScreens, long TimeOut, unsigned long *exit_code)
{


   STARTUPINFO command_start;
   PROCESS_INFORMATION command_process;
   HANDLE hReadPipe,hWritePipe;
   SECURITY_ATTRIBUTES PipeSA = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};	
   int ret;
   long  start_time, current_time;  /* Time stamp variables for timeout counting */
   long  tout_seconds;              /* Number of seconds to Wait for timeout */
   DWORD error_code; 
   char  *error_message;
   char  tempstr[500];
   char  tempstr2[500];
   int   SleepTime;
   int   right = 80;
   int   bottom = 25;
   char  env_buffer[1024];
   char  env_str[1024];
   unsigned long bytes_read;
   unsigned long bytes_avail;
	/*WR 28164 Sujatha /Veera */
   //char *token;

   achps_const_def achpsConst;
   int maxMinutes;
   bool  alertSent = false;
   /*WR 28164 Sujatha /Veera */

   memset (&command_start, 0, sizeof (command_start));
   memset (&command_process, 0, sizeof (command_process));
   memset (&achpsConst, 0, sizeof (achpsConst));

   command_start.cb = sizeof(STARTUPINFO); /* fill up STARTUPINFO structure  */
   command_start.lpReserved = NULL;
   command_start.lpTitle = NULL;
   command_start.lpReserved2 = NULL;
   command_start.cbReserved2 = 0;
   command_start.lpDesktop = NULL;
   command_start.wShowWindow = SW_SHOWDEFAULT;
   command_start.dwFlags = STARTF_USESHOWWINDOW;


   SleepTime = 1000 * StatusInterval;
 
   if (TimeOut != 0)
   {
      tout_seconds = TimeOut * 60;  /* Cvt timeout from minutes to seconds */
      time (&start_time);
   }

   //WR 28164 Sujatha ,Veera .Using start_time for alert mechanism
   time(&start_time);
	
   //Create Pipe for communicating information from child process to parent	
   ret = CreatePipe(&hReadPipe, &hWritePipe, &PipeSA, 0);
   if (ret == 0)
   {
   	   error_code = GetLastError();
   	   FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, 
		   error_code, MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &error_message, 0, NULL);

	   copy_cat(tempstr,"Process [", strCommandLine, "] failed in CreatePipe(). ", error_message, NULL);  
	   logit (0, tempstr);
	   LocalFree(error_message);
	   return CREATE_PIPE_ERR;
   }

 	EnterCriticalSection(&env_lock);

   //Set PIPE_HANDLE in parent environment so it will be passed to child
   sprintf(env_str,"PIPE_HANDLE=%d",hWritePipe);
   _putenv(env_str);

   //Create Child Process
   ret = CreateProcess(NULL, strCommandLine, NULL, NULL, TRUE, 
	   NORMAL_PRIORITY_CLASS, NULL, NULL,  &command_start, &command_process);
   if (ret == 0)
   {
   	   error_code = GetLastError();
   	   FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, 
		   error_code, MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &error_message, 0, NULL);

	   copy_cat(tempstr,"Process [", strCommandLine, "] failed in CreateProcess. ", error_message, NULL);  
	   logit (0, tempstr);
	   LocalFree(error_message);
	   return CREATE_PROCESS_ERR;
   }

   //Remove PIPE_HANDLE in parent environment 
   strcpy(env_str,"PIPE_HANDLE=");
   _putenv(env_str);

   LeaveCriticalSection(&env_lock);



   while (1) 
   {
	   if (CaptureScreens == 1) 
	   {
			if( write_status_file(right, bottom) != SUCCESS )
			{
				ifs_custerr("PRO_ERR_TO_USER", __FILE__, (DWORD) __LINE__, IFS_LOG, 
                  " : call to write_status_file() failed", "",  NULL);
				copy_cat(tempstr, "call to write_status_file() failed in NewProc()", NULL);
				logit(2, tempstr);
				debug_log( tempstr );
			    CloseHandle(hReadPipe);
				CloseHandle(hWritePipe);
				CloseHandle(command_process.hThread);
				CloseHandle(command_process.hProcess);
				return CAPTURE_SCREEN_ERR;
			}
	   }

   	   if (TimeOut != 0)
	   {
          time(&current_time);
          if (tout_seconds && start_time + tout_seconds < current_time) {
             TerminateProcess (command_process.hProcess, 0);
			 copy_cat(tempstr,"Process [", strCommandLine, "] Timed out after ", _itoa(TimeOut,tempstr2, 10), " minutes.", NULL);
			 logit(0, tempstr);
 		     debug_log( tempstr );
	 	     CloseHandle(hReadPipe);
			 CloseHandle(hWritePipe);
			 CloseHandle(command_process.hThread);
			 CloseHandle(command_process.hProcess);
             return TIMEOUT_ERR;
         }

	   }


      GetExitCodeProcess (command_process.hProcess, (LPDWORD) exit_code);

      if (*exit_code != STILL_ACTIVE) 
      {
		//The child process has terminated, now close the process and thread handles. */
         qtextf (0, 13, TX_NORMAL, "2. Exit Code = %ld", *exit_code);
         break;
      }
	  
	  if(lookUpAchpsConst(&achpsConst,strCommandLine))
	  {
			maxMinutes = atoi(achpsConst.parameter_value);
			time(&current_time);
//Shankar modified for alert message sent immediately WR28164 10/18/2005

			if (( (start_time + (maxMinutes*60)) < current_time) && (!alertSent) )
			{
				sprintf(tempstr,"Step %s is executing longer than the maximum minutes %d",strCommandLine,maxMinutes);
				console_message(tempstr,1,job_q.job_class);
				sendMail(tempstr);
				alertSent = true;
			}	
	  }
		
      Sleep (SleepTime);
  }

  CloseHandle(hWritePipe);
  CloseHandle(command_process.hThread);
  CloseHandle(command_process.hProcess);
   
  PeekNamedPipe(hReadPipe, env_buffer, sizeof(env_buffer)-1, &bytes_read, &bytes_avail, NULL);

  if (bytes_read != 0)
  {
	  ReadFile(hReadPipe, env_buffer, bytes_avail, &bytes_read, NULL);
  	  memcpy(tempstr, &env_buffer, bytes_read);
	  tempstr[bytes_read + 1] = '\0';
	  process_pipe(tempstr);
  }
  CloseHandle(hReadPipe);


   return(PROCESS_EXIT);
   

}


/********************* console_message *************************
*                                                              *
* Description: Enters a message into operator message facility *
*                                                              *
* Creation Date: 06/24/96        By: Mike West                 *
*                                                              *
***************************************************************/
int console_message(char *msg, int response_required, char *clas) 
{
	int l_sqlcode;
	char szbuff[300];
	char szret[10];
	char sqlmsg[80];
   char clss[5];


   strcpy(clss, clas);

	if(get_system_date_time(msg_q.message_time) != SUCCESS)
		return(ERR);

	_itoa(response_required, (char *)msg_q.must_release, 10);

//KLK REPLACE WITH TCPIP
//   if(load_net_id ((char*)msg_q.release_net_node, (char*)msg_q.release_net_id) != SUCCESS)
//   {
	   strcpy((char*)msg_q.release_net_node, "UNKNOWN     ");
	   strcpy((char*)msg_q.release_net_id, "NONE");
//   }
//KLK END REPLACE WITH TCPIP


   /* If the clss if null or blank, put something in there */
   if (clss[0] == 0 || clss[0] == 32)
	   strcpy(clss, "A");

   strcpy ((char*)msg_q.msg_class,clss);

   strcpy ((char*)msg_q.sender_js, szjsname);

   if (job_q.name[0] == 0 || job_q.name[0] == 32)
		strcpy((char*)msg_q.sender_job, "UNKNOWN");
   else
		strcpy ((char*)msg_q.sender_job, (char*)job_q.name);

   if (strlen (msg) >= sizeof(msg_q.msg)) 
	   msg[sizeof(msg_q.msg)-1]=0;

   strcpy ((char*)msg_q.msg, msg);



	EnterCriticalSection(&jsnt_sql_lock);

    EXEC SQL INSERT into MSGQ values (
	   :msg_q.message_time,
	   :msg_q.release_net_id,
	   :msg_q.release_net_node,
	   :msg_q.must_release,
	   :msg_q.msg_class,
	   :msg_q.sender_js,
	   :msg_q.sender_job,
	   :msg_q.msg);

	l_sqlcode = sqlca.sqlcode;

	if(l_sqlcode != ORCL_NO_ERROR && l_sqlcode != ORCL_NOT_FOUND)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_INSERT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"MSGQ", " ", " ", sqlmsg, " ", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Error during INSERT INTO MSQ table - SQLCA.SQLCODE=", 
						szret, " ", sqlmsg, NULL); 
		logit (2, szbuff);
		debug_log(szbuff);
		return ERR;
	}


	EXEC SQL COMMIT;

	l_sqlcode = sqlca.sqlcode;

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					sqlmsg, "MSGQ table", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"ERROR: COMMIT after INSERT into MSQ table failed: - SQLCA.SQLCODE=", 
					szret, " ", sqlmsg, NULL);
		logit (2, szbuff);
		debug_log(szbuff);
		return ERR;
	}

	LeaveCriticalSection(&jsnt_sql_lock);

   return SUCCESS;
}


/*********************** process_task **************************
*                                                              *
* Description: This function starts another task from the      *
*  command line variable for each step in the step_q.DAT file.  *
*  It also processes the step and updates the PQ.DAT file      *
*  with pertinent step information.                            *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
*                                                              *
* Modifiy Date:  14/APR/2000     By: Sasidhar D & Sabari Girish*
* Description: Included the screen capture logic.              *
*                                                              *
* Modify Date: 07/10/2000        By: Meenakshi P.K, iDLX       *
* Description: Included a call to createSocket() for the       *
* CONSOLE_MESSAGE_SUSPEND option                               *
***************************************************************/
int process_task(void) 
{
   short int i, ret=0;
   long start, end;
   char exit_info[50];
   char szbuff[500];
   unsigned long exit_code;     /* exit code of command line        */
   //short int tries;
   int	l_sqlcode;
   char stepq_name[10];
   char jobq_name[10];
   char tempstr[100];
   char szret[10];
   char sznum[20];
   char sqlmsg[80];
   HANDLE hOutput = 0;			      /* handle to console output screen */
   int capture_screens = 1; 	      /* Always 1=YES for file jobs */
   int time_out = 0;                  /* Time to wait before terminating child process */
   unsigned int right = 0;
   unsigned int bottom = 0;
   CONSOLE_SCREEN_BUFFER_INFO csbi;
   COORD coord;
   SMALL_RECT rect;

   	EXEC SQL BEGIN DECLARE SECTION;
		unsigned long step_no;		/* Unique Job Number */
		short int step_step_no;     /* Job Step number */
		char step_s_name[9];	
		char job_status[2];			/* A=Active, H=On Hold R=Ready S=Scheduled Y=Completed */
		long job_pos;               /* Position in Queue */
		char job_name[9];
		unsigned char pq_proc_name[9];	/* Name of Job Server */
		short int pq_status; 
	EXEC SQL END DECLARE SECTION;



/*   send message if it exists  */
   idle=0;

	memcpy (stepq_name, step_q.s_name, sizeof (step_q.s_name));
    stepq_name[9] = 0;
    trimlr (stepq_name);

    memcpy (jobq_name, step_q.j_name, sizeof (step_q.j_name));
    jobq_name[9] = 0;
    trimlr (jobq_name);
	copy_cat(tempstr, "[", szjsname, "] - ", jobq_name, ":", stepq_name, NULL);
    SetConsoleTitle (tempstr);                  /* set the console title       */

   trimr(step_q.send_msg);
   if (strlen(step_q.send_msg) > 0) 
	   send_messages(step_q.send_msg);

/*  Update Step File */

   strcpy(step_q.status, "A");
   if(get_system_date_time(step_q.date_time_started) != SUCCESS)
      return(ERR);


   strcpy ((char*)step_q.job_machine, szjsname);   /* JS name                 */
   replace_variables (step_q.command_line);
   trimr(step_q.command_line);

   debug_log ("Updating StepQ record");


	// Try to Lock the row in this table for updating up to 10 times before Erroring out.
	EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL SELECT
			no,
			step,
			s_name
		INTO :step_no, :step_step_no, :step_s_name	
		FROM STEPQ
		WHERE no   = :job_q.no
		AND   j_name = :step_q.j_name
		AND   s_name = :step_q.s_name
		AND   step = :step_q.step
		FOR UPDATE;


		l_sqlcode = sqlca.sqlcode;

	
		if(l_sqlcode != ORCL_NO_ERROR)
		{
				strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
				LeaveCriticalSection(&jsnt_sql_lock);

				ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"STEPQ", sqlmsg, " ", NULL);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff, "Error selecting STEPQ for Update - sqlca.sqlcode=", 
							szret, sqlmsg, NULL);
				logit (0, szbuff);
				debug_log (szbuff);
				return ERR;
		}

	EXEC SQL UPDATE STEPQ
		SET	status = :step_q.status,				/* A=Active						*/
			date_time_started = :step_q.date_time_started,    /* Time this step was started	*/
			job_machine = :step_q.job_machine,		/* JS name						*/
			command_line = :step_q.command_line		/* Command line					*/
		WHERE no   = :step_q.no
		AND j_name   = :step_q.j_name
		AND   s_name = :step_q.s_name
		AND   step = :step_q.step;

	l_sqlcode = sqlca.sqlcode;

	if(l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EXEC SQL ROLLBACK;
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, "STEPQ", sqlmsg, " ", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Error during UPDATE of STEPQ table - Rolling Back: - SQLCA.SQLCODE=", 
						szret, " ", sqlmsg, NULL);
		logit (0, szbuff);
		debug_log(szbuff);
		return ERR;
	}
		

	EXEC SQL COMMIT;

	l_sqlcode = sqlca.sqlcode;

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EXEC SQL ROLLBACK;
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					sqlmsg, "STEPQ table", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff, "ERROR: COMMIT after UPDATE of STEPQ table failed - Rolling Back: - SQLCA.SQLCODE=", 
					szret, sqlmsg, NULL);
		logit (0, szbuff);
		debug_log(szbuff);
		return ERR;
	}
	LeaveCriticalSection(&jsnt_sql_lock);




/*  Update processor (PQ) file with what I am Doing */
   debug_log ("Updating Processor record");


/* Enter in some information into the PQ.DAT file                    */
   p_q.status = 1;                   /* 0=Idle, 1=Busy          */
   p_q.job_num = job_q.no;
   p_q.step_num = step_q.step;
   strcpy ((char*)p_q.job_name, (char*)job_q.name);
   strcpy ((char*)p_q.step_name, (char*)step_q.s_name);
   strcpy ((char*)p_q.group_name, (char*)step_q.group_name);
   strcpy ((char*)p_q.must_complete_by, (char*)job_q.must_complete_by);
   strcpy ((char*)p_q.job_class, (char*)job_q.job_class);


    strcpy (p_q.multi_processing, job_q.multi_processing);    /* 0=No mulitprocessing, 1=Multiprocessing */

	if(get_system_date_time(p_q.start_date) != SUCCESS)
		return(ERR);

	strcpy(p_q.entry_date, job_q.date_time_entered);

	trimr(step_q.beg_console_msg);
	if ((strlen(step_q.beg_console_msg) > 0) && (step_q.beg_suspend_yn[0]=='Y'))
      strcpy(p_q.job_paused, "1");




	// Try to Lock the row for updating up to 10 times before Erroring out.
	EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL SELECT
			proc_name,
			status
		INTO :pq_proc_name, :pq_status
		FROM PQ
		WHERE proc_name = :p_q.proc_name
		FOR UPDATE;

		l_sqlcode = sqlca.sqlcode;
			
		if(l_sqlcode != ORCL_NO_ERROR)
		{
				strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
				LeaveCriticalSection(&jsnt_sql_lock);

				ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"PQ", sqlmsg, " ", NULL);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff, "Error selecting PQ for Update - sqlca.sqlcode=", 
							szret, sqlmsg, NULL);
				logit (0, szbuff);
				debug_log (szbuff);
				return ERR;
		}

	EXEC SQL UPDATE PQ
		SET	status = :p_q.status,						/* 0=Idle, 1=Busy          */
			job_num = :p_q.job_num,
			step_num = :p_q.step_num,
			multi_processing = :p_q.multi_processing,   /* 0=No mulitprocessing, 1=Multiprocessing */
			job_name = :p_q.job_name,
			step_name = :p_q.step_name,
			group_name = :p_q.group_name,
			must_complete_by = :p_q.must_complete_by,
			job_class = :p_q.job_class,
			job_paused = :p_q.job_paused,
			start_date = :p_q.start_date,
			entry_date = :p_q.entry_date
		WHERE proc_name = :p_q.proc_name;

	l_sqlcode = sqlca.sqlcode;

	if(l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EXEC SQL ROLLBACK;
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"PQ", sqlmsg, " ", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Error during UPDATE of PQ table - Rolling Back: - SQLCA.SQLCODE=", 
					szret, sqlmsg, NULL);
		logit (0, szbuff);
		debug_log(szbuff);
		return ERR;
	}

	EXEC SQL COMMIT;
	l_sqlcode = sqlca.sqlcode;


	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EXEC SQL ROLLBACK;
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					sqlmsg, "PQ table", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"ERROR: COMMIT after UPDATE of PQ table failed - Rolling Back: - SQLCA.SQLCODE=", 
						szret, sqlmsg, NULL);
		logit (0, szbuff);
		debug_log(szbuff);
		return ERR;
	}

	LeaveCriticalSection(&jsnt_sql_lock);



/*  Check for Beginning Message to Operator */

   trimr(step_q.beg_console_msg);
   if(strlen(step_q.beg_console_msg) > 0)   /* send begin message to operator */
   {
      if (step_q.beg_suspend_yn[0]=='Y')       /* suspend JS until operator says okay */
	  {
         console_message(step_q.beg_console_msg, 1, job_q.job_class);
            if (createSocket() != SUCCESS)
               display_paused();
      }
      else 
		  console_message(step_q.beg_console_msg, 0, job_q.job_class);
   }

   cls(TX_NORMAL);

   if (step_q.skip_yn[0]=='Y')                    /* are we supposed to skip this step? */
   {
      ret = 0;
      debug_log("Step Skipped due to Restart");
      exit_code = 0;
   }
   else 
   {
      copy_cat(szbuff, "Step Started ", step_q.command_line, NULL);
      logit (2, szbuff);
      time (&start);
      debug_log ("Performing Task");


   if( !no_screens )
   {
   /* get current console handle */
      hOutput = (HANDLE) GetStdHandle ((unsigned long) STD_OUTPUT_HANDLE);
      if( hOutput == INVALID_HANDLE_VALUE )
      {
         ifs_custerr("PRO_ERR_TO_USER", __FILE__, (DWORD) __LINE__, IFS_LOG, 
                  " : call to GetStdHandle() failed", "",  NULL);
         copy_cat(szbuff, "call to GetStdHandle() failed in process_task()", NULL);
         logit(2, szbuff);
         debug_log( szbuff );
         return ERR;
      }

   /* Identify what could be the maximum size of the console for the current attributes */
	    coord = GetLargestConsoleWindowSize( hOutput );
	    if( !coord.X && !coord.Y )
	    {
         ifs_custerr("PRO_ERR_TO_USER", __FILE__, (DWORD) __LINE__, IFS_LOG, 
                  " : call to GetLargestConsoleWindowSize() failed", "",  NULL);
         copy_cat(szbuff, "call to GetLargestConsoleWindowSize() failed in process_task()", 
                     NULL);
         logit(2, szbuff);
         debug_log( szbuff );
         return ERR;
	    }

	    if( coord.X < 80 || coord.Y < 25 )
	    {
         ifs_custerr("PRO_ERR_TO_USER", __FILE__, (DWORD) __LINE__, IFS_LOG, 
                  " : Current Console Settings are NOT Proper", "",  NULL);
         copy_cat(szbuff, "Current Console Settings are NOT Proper", NULL);
         logit(2, szbuff);
         debug_log( szbuff );
         return ERR;
	    }

   /*  Get the current console screen buffer information */
       if( !GetConsoleScreenBufferInfo( hOutput, &csbi ) )
	    {
         ifs_custerr("PRO_ERR_TO_USER", __FILE__, (DWORD) __LINE__, IFS_LOG, 
                  " : call to GetConsoleScreenBufferInfo() failed", "",  NULL);
         copy_cat(szbuff, "call to GetConsoleScreenBufferInfo() failed in process_task()", 
                        NULL);
         logit(2, szbuff);
         debug_log( szbuff );
         return ERR;
	    }

/* Set the console screen buffer size to maximum possible window size only if the current 
   screen buffer size is less than the maximum possible window size */
       if( csbi.dwSize.X * csbi.dwSize.Y * sizeof(CHAR_INFO) <
            coord.X * coord.Y * sizeof(CHAR_INFO) )
       {
      /* Set the console screen buffer size to maximum */
	       if( !SetConsoleScreenBufferSize(hOutput, coord) )
	       {
            ifs_custerr("PRO_ERR_TO_USER", __FILE__, (DWORD) __LINE__, IFS_LOG, 
                     " : call to SetConsoleScreenBufferSize() failed", "",  NULL);
            copy_cat(szbuff, "call to SetConsoleScreenBufferSize() failed in process_task()", 
                           NULL);
            logit(2, szbuff);
            debug_log( szbuff );
            return ERR;
	       }
       }

   /* Set the console window size to 80x25 */
	    rect.Bottom = 25-1;
	    rect.Left = 0;
	    rect.Right = 80-1;
	    rect.Top = 0;
	    if( !SetConsoleWindowInfo(hOutput, TRUE, &rect) )
	    {
         ifs_custerr("PRO_ERR_TO_USER", __FILE__, (DWORD) __LINE__, IFS_LOG, 
                  " : call to SetConsoleWindowInfo() failed", "",  NULL);
         copy_cat(szbuff, "call to SetConsoleWindowInfo() failed in process_task()", NULL);
         logit(2, szbuff);
         debug_log( szbuff );
         return ERR;
	    }

   /* Capture screen for only 80x25 */
      right = 80; 
      bottom = 25;

   /* calculate the size of the screen buffer */
      scr_buffer_size = right * bottom * sizeof(CHAR_INFO);
   }


   ret = NewProc (step_q.command_line, step_q.status_interval, capture_screens, time_out, &exit_code);
   if (ret == CAPTURE_SCREEN_ERR) return ERR;
   if (ret != PROCESS_EXIT) exit_code = 9999;

      debug_log ("Returned From Task");
      time (&end);                  /* Log the end of this step   */
	  _ltoa(end-start, sznum, 10);
	  _ltoa(exit_code, szret, 10);
	  copy_cat(exit_info, "Step Ended Exit: ", szret, " Step Time: ", sznum, NULL);
      logit (2, exit_info);
      debug_log ("Task finished");
   }


/*  Check for Ending Message to Operator */
   trimr(step_q.end_console_msg);
   if (strlen(step_q.end_console_msg) > 0)    /* send end message to operator? */
   {
	  _ltoa(exit_code, szret, 10);
	  copy_cat(szbuff, step_q.end_console_msg, "~Exit Code: ", szret, NULL);

      if (step_q.end_suspend_yn[0]=='Y')          /* do we need to pause after this step? */
	  {
         console_message (szbuff, 1, job_q.job_class);
         mark_processor_file ();
         display_paused ();
      }
      else 
		  console_message(szbuff, 0, job_q.job_class);
   }


   if (job_q.debug_mode_yn[0]=='Y') 
   {
      _ltoa(exit_code, szret, 10);
	  copy_cat(szbuff, "JOB DEBUG: Job: ", job_q.name, " Step: ", step_q.s_name,
						" in Group: ", step_q.group_name, " Completed. ~Exit Code: ", szret, 
						"~Job Server Now Paused, Press F10 for Job to Continue!", NULL);
      console_message (szbuff, 1, job_q.job_class);
      mark_processor_file ();
      display_paused ();
   }


   qtext(10, 6, "Updating Job Files . . .");

/*  When done update step record */
   debug_log ("Updating step file");


   strcpy(step_q.status, "Y");

   if(get_system_date_time(step_q.date_time_completed) != SUCCESS)
      return(ERR);

   
   step_q.exit_code = (short int) exit_code;   /* exit code of command line   */

   if (exit_code)                       /* is this exit code under the list of  */
   {
      for(i=0; i < step_q.num_a; i++)    /*  acceptable exit codes?          */
	  {
         if((short int) exit_code == step_q.exit_codes_acceptable[i]) 
		 {
            step_q.exit_code = 0;
            break;
         }
      }
   }


	// Try to Lock the row for updating up to 10 times before Erroring out.
	EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL SELECT
			no,
			step,
			s_name
		INTO :step_no, :step_step_no, :step_s_name	
		FROM STEPQ
		WHERE no   = :job_q.no
		AND   step   = :step_q.step
		AND   j_name = :step_q.j_name
		FOR UPDATE;

		l_sqlcode = sqlca.sqlcode;
			
		if(l_sqlcode != ORCL_NO_ERROR)
		{
				strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
				LeaveCriticalSection(&jsnt_sql_lock);

				ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"STEPQ", sqlmsg, " ", NULL);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff, "Error selecting STEPQ for Update - sqlca.sqlcode=",
							szret, " ", sqlmsg, NULL);
				logit (0, szbuff);
				debug_log (szbuff);
				return ERR;
		}

	EXEC SQL UPDATE STEPQ
		SET	status = :step_q.status,					/* Y=Complete                  */
			date_time_completed = :step_q.date_time_completed,
			exit_code = :step_q.exit_code				/* exit code of command line   */
		WHERE no   = :job_q.no
		AND   step   = :step_q.step
		AND   j_name = :step_q.j_name;

	l_sqlcode = sqlca.sqlcode;

	if(l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EXEC SQL ROLLBACK;
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, "STEPQ", sqlmsg, " ", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff, "Error during UPDATE of STEPQ table - Rolling Back: - SQLCA.SQLCODE=", 
					szret, " ", sqlmsg, NULL);
		logit (0, szbuff);
		debug_log(szbuff);
		return ERR;
	}

	EXEC SQL COMMIT;
	l_sqlcode = sqlca.sqlcode;

	if (sqlca.sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EXEC SQL ROLLBACK;
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, sqlmsg, "STEPQ table", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff, "ERROR: COMMIT after UPDATE of STEPQ table failed - Rolling Back: - SQLCA.SQLCODE=", 
							szret, " ", sqlmsg, NULL);
		logit (0, szbuff);
		debug_log(szbuff);
		return ERR;
	}

	LeaveCriticalSection(&jsnt_sql_lock);


	_itoa(step_q.no, szret, 10);
	copy_cat(szbuff, " Job #: ", szret, "  Name: ", step_q.j_name, NULL);
	qtext(10,8, szbuff);

	_itoa(step_q.step, szret, 10);
	copy_cat(szbuff, "Step #: ", szret, "  Name: ", step_q.s_name, NULL);
	qtext(10,9, szbuff);

	copy_cat(szbuff, " Group: ", step_q.group_name, NULL);
	qtext(10,10, szbuff);

	_ltoa(exit_code, szret, 10);
	copy_cat(szbuff, "Exit Code: ", szret, NULL);
	qtext(10, 12, szbuff);

	
   //printf("\n Job #: %d  Name: %s", step_q.no, step_q.j_name);
   //printf("\nStep #: %d  Name: %s", step_q.step, step_q.s_name);
   //printf("\n Group: %s", step_q.group_name);
   //printf("\n\nExit code: %d", udExitCode);


   if (step_q.skip_yn[0]=='Y') 
	   //printf("\nTHIS STEP WAS SKIPPED - Due to RESTART");
	   qtext(10, 10, "THIS STEP WAS SKIPPED - Due to RESTART");


   /* Check exit code of step - if the step failed, the whole job has fails */
   if (step_q.exit_code)
   {
      debug_log("Updating Job File");
	  job_processing = 0;

	  // Send message to MSGQ table that Job Failed
	  _ltoa(exit_code, szret, 10);
	  copy_cat(szbuff, "Job ", step_q.j_name, " Failed on Step ", step_q.s_name,
				" with Exit Code ", szret, NULL);
	  //sprintf(szbuff, "Job %s Failed on Step %s with Exit Code %d", 
	  //			step_q.j_name, step_q.s_name, udExitCode);
     if( job_q.msg_when_failed[0] == '1' )
	   console_message(szbuff, 1, job_q.job_class);




	  strcpy(job_q.status, "Y");
      if(get_system_date_time(job_q.date_time_completed) != SUCCESS)
         return(ERR);

      job_q.exit_code = step_q.exit_code;   /* exit code of step goes to job exit code */



		// Try to Lock the row for updating up to 10 times before Erroring out.
	    EnterCriticalSection(&jsnt_sql_lock);				

		//for(tries=0; tries < LOCK_TRIES; tries++)
		//{
			EXEC SQL SELECT 
				status,
				pos,
				name
			INTO :job_status, job_pos, job_name
			FROM JOBQ
			WHERE no   = :job_q.no
			AND   name = :step_q.j_name
			FOR UPDATE;
			//FOR UPDATE NOWAIT;

			l_sqlcode = sqlca.sqlcode;
							
			if(l_sqlcode != ORCL_NO_ERROR)
			{
		//		if(tries < LOCK_TRIES)
		//			Sleep(1000);
		//		else
		//		{
					strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
					LeaveCriticalSection(&jsnt_sql_lock);

					ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, "JOBQ", sqlmsg, " ", NULL);
					_itoa(l_sqlcode, szret, 10);
					copy_cat(szbuff, "Error selecting JOBQ for Update - sqlca.sqlcode=", 
								szret, " ", sqlmsg, NULL);
					//sprintf (szbuff, "Error selecting JOBQ for Update - sqlca.sqlcode=%d, %s", 
					//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
					logit (2, szbuff);
					debug_log (szbuff);
					return ERR;
		//		} 
			}
		//	break;
		//}

		EXEC SQL UPDATE JOBQ
			SET status = :job_q.status,					/* Y=Complete                 */
				date_time_completed = :job_q.date_time_completed, /* Time job completed-failed. */
				exit_code = :job_q.exit_code		   /* exit code of step goes to job exit code */
				WHERE no  = :job_q.no
				AND name = :step_q.j_name;

		l_sqlcode = sqlca.sqlcode;

		if(l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			EXEC SQL ROLLBACK;
			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
							"JOBQ", sqlmsg, " ", NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"Error during UPDATE of JOBQ table - SQLCA.SQLCODE = ", 
						szret, " ", sqlmsg, NULL);
			//sprintf(szbuff, "Error during UPDATE of JOBQ table - SQLCA.SQLCODE = %d, %s", 
			//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log(szbuff);
			return ERR;
		}
	
		EXEC SQL COMMIT;
		l_sqlcode = sqlca.sqlcode;

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			EXEC SQL ROLLBACK;
			LeaveCriticalSection(&jsnt_sql_lock);
			ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						sqlmsg, "JOBQ table", NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=", 
						szret, " ", sqlmsg, NULL);
			//sprintf(szbuff, "ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=%d, %s", 
			//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log(szbuff);
			return ERR;
		}

		LeaveCriticalSection(&jsnt_sql_lock);


	  _itoa(job_q.exit_code, szret, 10);
	  copy_cat(szbuff, "Job ", job_q.name, " FAILED with Exit Code ", szret, NULL);
      //sprintf(szbuff, "Job %s FAILED with exit code %d", job_q.name, job_q.exit_code);

	  //Flag to not send a console message on a failed job is set to NO
	  //So that means we do want to send a console message
      if(job_q.no_fail_message_yn[0] == 'N')   
		console_message(szbuff, 1, job_q.job_class);

      if(job_q.msg_when_failed[0] == '1')
         send_messages(szbuff);


	  /* New code added - DR 98-291 - jmw 4/9/1999 */
	  // Put new code here to see if there is another program to run
	  // when the stepq program errored out.   
	  if (strlen(step_q.run_if_error) > 0)		/* run the error program for this step */
	  {
		logit(1, "Error Program Starting");
		time(&start);
		debug_log("Performing Error Program");
		//memset(&si, 0, sizeof(si) );
		//memset(&pi, 0, sizeof(pi) );
        exit_code = 0;
 
        //Create Pipe for communicating information from child process to parent	
        //CreatePipe(&hReadPipe, &hWritePipe, &PipeSA, 0);

       //Set PIPE_HANDLE in parent environment so it will be passed to child
       //sprintf(env_str,"PIPE_HANDLE=%d",hWritePipe);
       //_putenv(env_str);

       //Create child pocess
	   //if (NewProc(step_q.run_if_error, &si, &pi)) udExitCode = 9999;
       ret = NewProc (step_q.run_if_error, step_q.status_interval, capture_screens, time_out, &exit_code);
	   if (ret == CAPTURE_SCREEN_ERR) return(ERR);
       if (ret != PROCESS_EXIT) exit_code = 9999;
 
       //Remove PIPE_HANDLE in parent environment 
       //sprintf(env_str,"PIPE_HANDLE=",hWritePipe);
       //_putenv(env_str);

   /* implement the screen capture logic */
   /* The loop starts and uses the GetExitCodeProcess() function to determine if
      the child process has terminated or not.  If it has terminated, the
      exit code of the command line should return in udExitCode             */
//      while ( udExitCode != 9999 ) 
      //{
         //if( write_status_file(right, bottom) != SUCCESS )
         //{
            //ifs_custerr("PRO_ERR_TO_USER", __FILE__, (DWORD) __LINE__, IFS_LOG, 
                     //" : call to write_status_file() failed", "",  NULL);
            //copy_cat(szbuff, "call to write_status_file() failed in process_task()", NULL);
            //logit(2, szbuff);
            //debug_log( szbuff );
            //return ERR;
         //}

         //GetExitCodeProcess (pi.hProcess, &udExitCode);
         //if (udExitCode != STILL_ACTIVE) 
         //{
   /*       The child process has terminated, now close the process and thread handles. */
   //         qtextf (0, 13, TX_NORMAL, "2. udExitCode = %d", udExitCode);
//            CloseHandle (pi.hProcess);   /* close process handle       */
            //CloseHandle (pi.hThread);    /* close thread handle        */
            //break;
         //}


   /*		Capture screen for every <step_q.status_interval> seconds	*/
         //Sleep (1000 * step_q.status_interval);
      //}


      //ReadFile(&hReadPipe, env_buffer, 1023, &bytes_read, NULL);
	  //CloseHandle(&hReadPipe);
  	  //CloseHandle(&hWritePipe);

		debug_log("Returned from Error Program");
		time(&end);
		_ltoa(end-start, sznum, 10);
		_ltoa(exit_code, szret, 10);
		copy_cat(exit_info, "Exit: ", szret, "  Step Time: ", sznum, NULL);
		//sprintf(exit_info, "Exit: %03d Step Time: %5ld", udExitCode, end-start);
		logit(2, exit_info);
		debug_log("Error Program Finished");
	  }

      debug_log("Job complete");
   }

   memset (&job_q, 0, sizeof(job_q));        /* reset structure with nulls       */
   memset (&step_q, 0, sizeof(step_q));
   return SUCCESS;
}


/****************** processor_pipe ****************************
*                                                              *
* Description: This function reads the information from the    *
* pipe.                                                        *
*                                                              *
* Creation Date: 02/05/01        By: Kellie Kupka              *
* Modifiy Date:  ??/??/??        By:                           *
*                                                              *
***************************************************************/
void process_pipe(char *pipe_buffer)
{

	char line [200];		/* Buffer to hold a .CFG line as it is parsed */
	int len;				/* Temp string length var */
	unsigned int offset;	/*	Holds current offset into .CFG during processing */
	char *cp;				/* Temp string pointers */
	int var_num;            /* Pipe Variable Number */

	char pipe_var[3][15] = {"ENVVAR","CHGDIR",""};

	offset = 0;
	while (getline_buf_all (pipe_buffer, line, strlen(pipe_buffer), &offset) == SUCCESS) 
	{
		trimlr (line);
		/* Go through the possible params until we match or get to the end */
		var_num = 0;
		while (pipe_var[var_num]) 
		{
			len = strlen (pipe_var[var_num]);

			/* Look for a matching parameter */
			if (_strnicmp (pipe_var[var_num], line, len)==0 &&
				(!line[len] || line[len]=='=' || isspace (line[len]))) 
			{

				/* On a match, look for an = sign */			
				cp = line + len;
				while (isspace (*cp)) cp++;
				if (*cp=='=') {

					/* On EQUAL sign (=) convert & store in the variable specified */				
					cp++;
					while (isspace (*cp)) cp++;
				}
				switch(var_num)
				{
					case 0:
						_putenv(cp);
						break;

					case 1:
 				        _chdir(cp);
						break;

					default:
						break;
				}
				break;
			}
			var_num++;
		}
	}
}

/****************** mark_processor_file ************************
*                                                              *
* Description: This function updates the PQ job_paused field   *
*  to TRUE.                                                    *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
* Modifiy Date:  07/23/99        By: Mike West                 *
*                                                              *
***************************************************************/
int mark_processor_file(void) 
{
   char szbuff[300];
   //short int tries;
   int l_sqlcode;
   char szret[10];
   char sqlmsg[80];

	EXEC SQL BEGIN DECLARE SECTION;
		char job_server_name[20];
	EXEC SQL END DECLARE SECTION;


	strcpy (job_server_name, szjsname);

	// Try to Lock the row for updating up to 10 times before Erroring out.
	EnterCriticalSection(&jsnt_sql_lock);

	//for(tries=0; tries < LOCK_TRIES; tries++)
	//{
		memset(&p_q, 0, sizeof(p_q) );
		EXEC SQL SELECT
			proc_name,
			status,
			net_node,
			job_num,
			job_name,
			step_num,
			step_name,
			entry_date,
			start_date,
			must_complete_by,
			multi_processing,
			group_name,
			job_class,
			net_id,
			job_paused
		INTO :p_q:p_q_ind
		FROM PQ
		WHERE proc_name = :job_server_name
		FOR UPDATE;
		//FOR UPDATE NOWAIT;

		l_sqlcode = sqlca.sqlcode;
					
		if(l_sqlcode != ORCL_NO_ERROR)
		{
	//		if(tries < LOCK_TRIES)
	//			Sleep(1000);
	//		else
	//		{
				strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
				LeaveCriticalSection(&jsnt_sql_lock);

				ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"PQ", sqlmsg, "For Update", NULL);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff, "Error selecting PQ for Update - sqlca.sqlcode=", 
						szret, sqlmsg, NULL);
				//sprintf (szbuff, "Error selecting PQ for Update - sqlca.sqlcode=%d, %s", 
				//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
				logit (2, szbuff);
				debug_log (szbuff);
				return ERR;
	//		} 
		}
	//	break;
	//}

	strcpy(p_q.job_paused, "1");

	EXEC SQL UPDATE PQ
		SET	job_paused = :p_q.job_paused
		WHERE proc_name = :job_server_name;

	l_sqlcode = sqlca.sqlcode;

	if(l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EXEC SQL ROLLBACK;
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"PQ", sqlmsg, " ", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff, "Error during UPDATE of PQ table - Rolling Back: - SQLCA.SQLCODE=", 
					szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "Error during UPDATE of PQ table - Rolling Back: - SQLCA.SQLCODE=%d, %s", 
		//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (2, szbuff);
		debug_log(szbuff);
		return ERR;
	}
		

	EXEC SQL COMMIT;
	l_sqlcode = sqlca.sqlcode;

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EXEC SQL ROLLBACK;
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, sqlmsg, "PQ table", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"ERROR: COMMIT after UPDATE of PQ table failed - Rolling Back: - SQLCA.SQLCODE=", 
					szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "ERROR: COMMIT after UPDATE of PQ table failed - Rolling Back: - SQLCA.SQLCODE=%d, %s", 
		//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (2, szbuff);
		debug_log(szbuff);
		return ERR;
	}

	LeaveCriticalSection(&jsnt_sql_lock);



   return SUCCESS;
}


/*********************** close_job *****************************
*                                                              *
* Description: This function closes the current (Active) job   *
*  now that it is finished.                                    *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
* Modifiy Date:  07/26/99        By: Mike West                 *
* Modifiy Date:  05/15/2000      By: Sasidhar D, iDLX          *
*                                                              *
* The code for re-submitting job record & step records (if     *
* spawn_algorithm is present) is added.                        *
***************************************************************/
int close_job(void) 
{
   char szbuff[300];
   //short int tries;
   int l_sqlcode;
   char szret[10];
   char sqlmsg[80];
   char new_date[9],new_time[7];
   short int ret;


   	EXEC SQL BEGIN DECLARE SECTION;
		char job_status[2];			/* A=Active, H=On Hold R=Ready S=Scheduled Y=Completed */
		long job_pos;               /* Position in Queue */
		char job_name[10];
	EXEC SQL END DECLARE SECTION;


   job_q.exit_code = 0;



	if(get_system_date_time(job_q.date_time_completed) != SUCCESS)
		return(ERR);

   	// Try to Lock the row for updating up to 10 times before Erroring out.
	EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL SELECT 
			status,
			pos,
			name
		INTO :job_status, :job_pos, :job_name
		FROM JOBQ
		WHERE no   = :job_q.no
		AND   name = :job_q.name
		FOR UPDATE;
		//FOR UPDATE NOWAIT;

		l_sqlcode = sqlca.sqlcode;
					
		if(l_sqlcode != ORCL_NO_ERROR)
		{
				strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
				LeaveCriticalSection(&jsnt_sql_lock);

				ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"JOBQ", sqlmsg, "For Update", NULL);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff, "Error selecting JOBQ for Update - sqlca.sqlcode=", 
							szret, sqlmsg, NULL);
				//sprintf (szbuff, "Error selecting JOBQ for Update - sqlca.sqlcode=%d, %s", 
				//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
				logit (2, szbuff);
				debug_log (szbuff);
				return ERR;
		}


	strcpy(job_q.status, "Y");           /* Y=Job completed */

	EXEC SQL UPDATE JOBQ
		SET status = :job_q.status,						/* Y=Job completed */
			date_time_completed = :job_q.date_time_completed,     /* get time job completed */
			exit_code = :job_q.exit_code
		WHERE name = :job_q.name
		AND   no   = :job_q.no;

	l_sqlcode = sqlca.sqlcode;

	if(l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EXEC SQL ROLLBACK;
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"JOBQ", sqlmsg, " ", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Error during UPDATE of JOBQ table - SQLCA.SQLCODE=", 
						szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "Error during UPDATE of JOBQ table - SQLCA.SQLCODE=%d, %s", 
		//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (0, szbuff);
		debug_log(szbuff);
		return ERR;
	}
	
	EXEC SQL COMMIT;
	l_sqlcode = sqlca.sqlcode;
	
	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EXEC SQL ROLLBACK;
		LeaveCriticalSection(&jsnt_sql_lock);
		ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					sqlmsg, "JOBQ table", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff, "ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=",
					szret, sqlmsg, NULL);
		//sprintf(szbuff, "ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=%d, %s", 
		//			sqlca.sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (0, szbuff);
		debug_log(szbuff);
		return ERR;
	}
	LeaveCriticalSection(&jsnt_sql_lock);

   if(job_q.msg_when_done[0] == '1')       /* do we need to tell anybody? */
   {
      debug_log("Sending end message");
      send_end_msg();
   }

   job_processing = 0;				/* reset job is processing flag */
   logit (1, "Job Ended");			/* log Job Ended message */

	/* Spawn new task? */
	if(job_q.spawn_algorithm > 0) {
		ret=date_logic(new_date,new_time);
		if(ret == 0) {
			debug_log("Job submitting new Task");
			ret=submit(new_date,new_time);      
			if(ret != 0)
			{
				sprintf(szbuff,"Error spawning new task - return code = %d", ret);
				logit(0,szbuff);
				debug_log(szbuff);
				return(-1);
			}
			logit(0,"Job submitted new Task");
		}
	}

   trimr(job_q.base_dir);
   if (strlen (job_q.base_dir))		/* change back to our original */
   {
      _chdrive(curr_drive);			/* drive and directory.       */
      _chdir(curr_dir);
   }

   base_dir_job = 0;
//   idle = 0;

   memset(&job_q, 0, sizeof(job_q));
   memset(&step_q, 0, sizeof(step_q));
   return SUCCESS;
}


/*********************** test_j_dep ****************************
*                                                              *
* Description: This function tests job dependencies.           *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
* Modifiy Date:  05/16/2000      By: Sasidhar D, iDLX          *
*                                                              *
* Modified to check job dependency for ORACLE                                                             *
***************************************************************/
int test_j_dep(void) 
{
   short int status=0;
   long hivalue=0x7FFFFFFF;
   unsigned short len = 4;
   time_t tim, tim1;
	short int i;
   unsigned long hrs_back;

	long last_tested;
   char szbuff[300], t_str[20], tmp_str[20];
   long l_sqlcode;
   char szret[10];
   char sznum[20];
   char sqlmsg[80];
   unsigned short yyyy, mm, dd, hh, mi, ss;
   struct tm tm_j_cmplt;
   time_t tim_j_cmplt;
   unsigned short dep_flag = 0;     // dependency flag

   EXEC SQL BEGIN DECLARE SECTION;
      unsigned long job_no;
      char job_name[10];
      char d_job[10];
      char d_station[10];
  	  short int cntr;
      char job_status[2];
      short job_exit_code;
      unsigned char job_d_cmplt[20];
      char job_date_time_completed[15];
      char job_d_last_tested[200];
   EXEC SQL END DECLARE SECTION;


   time(&tim);



   /* Get system date & time in 'time_t' format */
   if( get_system_date_time(tmp_str) != SUCCESS )
      return ERR;

   sscanf(tmp_str, "%4d%2d%2d%2d%2d%2d", 
               &yyyy, &mm, &dd, &hh, &mi, &ss);
   tm_j_cmplt.tm_sec = ss;
   tm_j_cmplt.tm_min = mi;
   tm_j_cmplt.tm_hour = hh;
   tm_j_cmplt.tm_mday = dd;
   tm_j_cmplt.tm_mon = mm;
   tm_j_cmplt.tm_year = yyyy - 1900;
   tm_j_cmplt.tm_isdst = 0;

   if( (tim=mktime(&tm_j_cmplt)) == -1 )
   {
      sprintf(szbuff, "%s, File: %s, Line: %d", 
         "call to mktime() failed in test_j_dep()..", __FILE__, __LINE__);
      logit(2, szbuff);
      debug_log(szbuff);
      return ERR;
   }

   dep_flag = 0;


	for(i=0; i< job_q.num_d; i++)
	{
		if(job_q.d_cmplt[i] && job_q.d_cmplt[i] != ' ')
			continue;

		_ltoa(tim, t_str, 10);
		memset(tmp_str, 0, 20);
		strncpy(tmp_str, job_q.d_last_tested + (i*10), 10);

		if(strncmp(t_str, tmp_str, strlen(t_str)) < 0)
			return(1);


		memset(d_job, 0, 10);
		memcpy(d_job, job_q.d_job + (i*9), 9 );

		memset(d_station, 0, 10);
		memcpy(d_station, job_q.d_station + (i*9), 9 );

		cntr = i;

		EnterCriticalSection(&jsnt_sql_lock);


		EXEC SQL DECLARE job_curs CURSOR FOR
      SELECT
		 no,
	     name,
         status
        //exit_code,
        //date_time_completed
		//INTO :job_no, :job_name, :job_status, :job_exit_code, :job_date_time_completed
		FROM JOBQ
		WHERE name =  :d_job
		AND station = decode(:d_station, NULL, station, :d_station);

      EXEC SQL OPEN job_curs;

		l_sqlcode = sqlca.sqlcode;
      LeaveCriticalSection( &jsnt_sql_lock );

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
 			ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"JOBQ", sqlmsg, "For Open Cursor job_curs", NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff, "Error opening job_curs cursor of JOBQ in line ", sznum, 
                     " - sqlca.sqlcode=", szret, " ", sqlmsg, NULL);
			logit (2, szbuff);
			debug_log (szbuff);
			return -1;
		} 

      EnterCriticalSection(&jsnt_sql_lock);
      
      EXEC SQL FETCH job_curs 
         INTO :job_no, :job_name, :job_status;  //, :job_exit_code, :job_date_time_completed;
		
      l_sqlcode = sqlca.sqlcode;
      LeaveCriticalSection( &jsnt_sql_lock );


      if( l_sqlcode == ORCL_NOT_FOUND )
         return 1;

      while( l_sqlcode != ORCL_NOT_FOUND )
      {
			if (l_sqlcode != ORCL_NO_ERROR)
			{
				strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
 				ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
							"JOBQ", sqlmsg, "For Fetch", NULL);
				_ltoa((DWORD) __LINE__, sznum, 10);
				_itoa(l_sqlcode, szret, 10);
				copy_cat(szbuff, "Error Fetching from job_curs(JOBQ) in line ", sznum, 
                        " - sqlca.sqlcode=", szret, " ", sqlmsg, NULL);
				logit (2, szbuff);
				debug_log (szbuff);
				return -1;
			} 

 		 trimlr(job_name);

         if( job_status[0] == 'Y' ) 
	      {

            EnterCriticalSection(&jsnt_sql_lock);
		      EXEC SQL SELECT
               exit_code,
               date_time_completed
		      INTO :job_exit_code, :job_date_time_completed
		      FROM JOBQ
		      WHERE no = :job_no
            AND name = :job_name
            AND status = :job_status;

            l_sqlcode = sqlca.sqlcode;
            LeaveCriticalSection( &jsnt_sql_lock );
		      if (l_sqlcode != ORCL_NO_ERROR)
		      {
			      strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
 			      ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						      "JOBQ", sqlmsg, "For Select", NULL);
			      _ltoa((DWORD) __LINE__, sznum, 10);
			      _itoa(l_sqlcode, szret, 10);
			      copy_cat(szbuff, "Error Selecting from JOBQ in line ", sznum, 
                           " - sqlca.sqlcode=", szret, " ", sqlmsg, NULL);
			      logit (2, szbuff);
			      debug_log (szbuff);
			      return -1;
		      } 

            if( job_exit_code )
		      {
               strncpy(tmp_str, job_q.d_hrs_back + (i*5), 5);
               hrs_back = (unsigned long)atol( tmp_str );
               tim1 = tim - ( (long) hrs_back * 60L * 60L);

               sscanf(job_date_time_completed, "%4d%2d%2d%2d%2d%2d", 
                           &yyyy, &mm, &dd, &hh, &mi, &ss);
               tm_j_cmplt.tm_sec = ss;
               tm_j_cmplt.tm_min = mi;
               tm_j_cmplt.tm_hour = hh;
               tm_j_cmplt.tm_mday = dd;
               tm_j_cmplt.tm_mon = mm;
               tm_j_cmplt.tm_year = yyyy - 1900;
               tm_j_cmplt.tm_isdst = 0;

               if( (tim_j_cmplt=mktime(&tm_j_cmplt)) == -1 )
               {
                  sprintf(szbuff, "%s, File: %s, Line: %d", 
                     "call to mktime() failed in test_j_dep()..", __FILE__, __LINE__);
                  logit(2, szbuff);
                  debug_log(szbuff);
                  return ERR;
               }

               if(tim_j_cmplt < tim1) 
			      {
                  EnterCriticalSection(&jsnt_sql_lock);
                  EXEC SQL SELECT
                        no,
                        name
   //                     d_cmplt
                     INTO :job_no, :job_name    //, :job_d_cmplt
                     FROM JOBQ
			         WHERE no  = :job_no
                     AND name  = :d_job
                     AND status = 'Y'
                     FOR UPDATE;

                  l_sqlcode = sqlca.sqlcode;
                  LeaveCriticalSection(&jsnt_sql_lock);

			         if (l_sqlcode != ORCL_NO_ERROR)
			         {
				         strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
                     EnterCriticalSection( &jsnt_sql_lock );
				         EXEC SQL ROLLBACK;
				         LeaveCriticalSection(&jsnt_sql_lock);

				         ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
							         "JOBQ", sqlmsg, "For Update", NULL);
				         _ltoa((DWORD) __LINE__, sznum, 10);
				         _itoa(l_sqlcode, szret, 10);
				         copy_cat(szbuff, "Error selecting JOBQ For Update in line ", sznum, 
                                 " - sqlca.sqlcode=", szret, " ", sqlmsg, NULL);
				         logit (2, szbuff);
				         debug_log (szbuff);
				         return -1;
			         } 

                  job_d_cmplt[i] = '1';

                  EnterCriticalSection( &jsnt_sql_lock );
		            EXEC SQL UPDATE JOBQ
			            SET d_cmplt = :job_d_cmplt
			            WHERE no   = :job_no
                        AND name   = :d_job
                        AND status = 'Y';

		            l_sqlcode = sqlca.sqlcode;
                  LeaveCriticalSection( &jsnt_sql_lock );

		            if (l_sqlcode != ORCL_NO_ERROR)
		            {
			            strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
                     EnterCriticalSection( &jsnt_sql_lock );
			            EXEC SQL ROLLBACK;
			            LeaveCriticalSection(&jsnt_sql_lock);
			            ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						            "JOBQ", sqlmsg, "For Update", NULL);
			            _ltoa((DWORD) __LINE__, sznum, 10);
			            _itoa(l_sqlcode, szret, 10);
			            copy_cat(szbuff, "Error updating JOBQ in line ", sznum, " - sqlca.sqlcode=",
						            szret, sqlmsg, NULL);		
			            logit (2, szbuff);
			            debug_log (szbuff);
			            return -1;
		            } 
               }
               else        // dependency exists, dependent job failed
               {
                  dep_flag = 1;
                  break;
               }
            }
         }
         else     // dependency exists, dependent job is not yet completed
         {
            dep_flag = 1;
            break;
         }

         EnterCriticalSection(&jsnt_sql_lock);

         EXEC SQL FETCH job_curs 
            INTO :job_no, :job_name, :job_status;  //:job_exit_code, :job_date_time_completed;

		   l_sqlcode = sqlca.sqlcode;
         LeaveCriticalSection( &jsnt_sql_lock );

      }  // end of while()


      if( !dep_flag )
         continue;

		cntr = i;
		time(&last_tested);
		_ltoa(last_tested, tmp_str, 10);
        strcpy(job_d_last_tested + (i*10), tmp_str);

		EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL SELECT
			no,
			name
//         d_last_tested
		INTO :job_no, :job_name //, :job_d_last_tested
		FROM JOBQ
		WHERE no = :job_no
        AND name   = :d_job
		FOR UPDATE;

		l_sqlcode = sqlca.sqlcode;
        LeaveCriticalSection(&jsnt_sql_lock);

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
         EnterCriticalSection(&jsnt_sql_lock);
			EXEC SQL ROLLBACK;
			LeaveCriticalSection(&jsnt_sql_lock);
			ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"JOBQ", sqlmsg, "For Update", NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff, "Error selecting JOBQ in line ", sznum, " - sqlca.sqlcode=",
						szret, sqlmsg, NULL);		
			logit (2, szbuff);
			debug_log (szbuff);
			return -1;
		} 


      EnterCriticalSection(&jsnt_sql_lock);
		EXEC SQL UPDATE JOBQ
			SET d_last_tested = :job_d_last_tested
			WHERE no = :job_no
            AND name   = :d_job;

		l_sqlcode = sqlca.sqlcode;
      LeaveCriticalSection(&jsnt_sql_lock);

		if(l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
         EnterCriticalSection(&jsnt_sql_lock);
			EXEC SQL ROLLBACK;
			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"JOBQ", sqlmsg, " ", NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff, "Error during UPDATE of JOBQ table - SQLCA.SQLCODE=",
						szret, " ", sqlmsg, NULL);		
			logit (0, szbuff);
			debug_log(szbuff);
			return ERR;
		}
	
      EnterCriticalSection(&jsnt_sql_lock);
		EXEC SQL COMMIT;
		l_sqlcode = sqlca.sqlcode;
      LeaveCriticalSection(&jsnt_sql_lock);

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
         EnterCriticalSection(&jsnt_sql_lock);
			EXEC SQL ROLLBACK;
			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						sqlmsg, "JOBQ table", NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=", 
						szret, sqlmsg, NULL);		
			logit (0, szbuff);
			debug_log(szbuff);
			return ERR;
		}
		return(1);
   }     // end of for()
  

   return SUCCESS;
}


/*********************** test_s_dep ****************************
*                                                              *
* Description: This function tests step dependencies.          *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
* Modifiy Date:  07/27/99        By: Mike West                 *
*                                                              *
***************************************************************/
int test_s_dep(void)
{
   short int status, i;
   unsigned char save_key[10];
   char szbuff[300], t_str[20], tmp_str[20];
   long t;
   int l_sqlcode;
   char szret[10];
   char sznum[20];
   char sqlmsg[80];

	long last_tested;


   	EXEC SQL BEGIN DECLARE SECTION;
		unsigned long step_no;		/* Unique Job Number */
		short int step_step_no;     /* Job Step number */
		char step_s_name[9];	
		char d_step[15];
		short int cntr;
		char d_last_tested[11];
	EXEC SQL END DECLARE SECTION;

	//Starting of try blocak - DRQ 2003 -077 Baskar/Veera
	try
	{

	time(&t);
	for(i=0; i< step_q.num_d; i++)
	{
		if(step_q.d_cmplt[i] && step_q.d_cmplt[i] != ' ')
			continue;

		_ltoa(t, t_str, 10);
		memset(tmp_str, 0, 20);
		strncpy(tmp_str, step_q.d_last_tested + (i*10), 10);

		if(strncmp(t_str, tmp_str, strlen(t_str)) < 0)
//      if(t < (step_q.d_last_tested[i]+STEP_D_CHECK) )
			return(1);

		if(step_q.d_group[i] == '1')
		{
			status = is_group_finished(i, (char*)save_key); /* -1=Error 0=Ready 1=Not Ready */
			if(status == -1)
	            return(-1);
			if(status == 0)
	            continue;
		}
		else
		{
	//			memset(step_q_key+2, 0, 11);  //job_q.no
	//			move(step_q_key+2, strlen(step_q.d_step[i]), step_q.d_step[i], 1);
			memset(d_step, 0, 10);
			memcpy(d_step, step_q.d_step + (i*9), sizeof(d_step) );
			cntr = i;

			EnterCriticalSection(&jsnt_sql_lock);

			EXEC SQL SELECT
				no,
				step,
				s_name
			INTO :step_no, :step_step_no, :step_s_name
			FROM STEPQ
			WHERE no   = :job_q.no
			AND   substr(d_step, :cntr*9, 9) = :d_step
			FOR UPDATE;
			//FOR UPDATE NOWAIT;

			l_sqlcode = sqlca.sqlcode;

			
			if (l_sqlcode == ORCL_NOT_FOUND)
			{
				EXEC SQL ROLLBACK;
				LeaveCriticalSection(&jsnt_sql_lock);

				continue;
			}
			else
			{
				if (l_sqlcode != ORCL_NO_ERROR)
				{
					strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
					EXEC SQL ROLLBACK;
					LeaveCriticalSection(&jsnt_sql_lock);

					ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
								"STEPQ", sqlmsg, "For Update", NULL);
					_ltoa((DWORD) __LINE__, sznum, 10);
					_itoa(l_sqlcode, szret, 10);
					copy_cat(szbuff, "Error selecting STEPQ For Update in line ", sznum, " - sqlca.sqlcode=", 
								szret, " ", sqlmsg, NULL);
					//sprintf (szbuff, "Error selecting STEPQ For Update in line %ld - sqlca.sqlcode=%d, %s",
					//			__LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
					logit (2, szbuff);
					debug_log (szbuff);
					return -1;
				} 
			}


			if(step_q.status[0] == 'Y')    /* Y=Step Completed */
			{
	            step_q.d_cmplt[i] = '1';
			
				EXEC SQL UPDATE STEPQ
					SET d_cmplt=substr(d_cmplt, :cntr, 1) || '1' || substr(d_cmplt, :cntr+1, 20-:cntr+1)
					WHERE no   = :job_q.no
					AND   substr(j_name, :cntr*9, 9) = :d_step;

				l_sqlcode = sqlca.sqlcode;

				if(l_sqlcode != ORCL_NO_ERROR)
				{
					strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
					EXEC SQL ROLLBACK;
					LeaveCriticalSection(&jsnt_sql_lock);

					ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
								"STEPQ", sqlmsg, " ", NULL);
					_itoa(l_sqlcode, szret, 10);
					copy_cat(szbuff,"Error during UPDATE of STEPQ table - SQLCA.SQLCODE=", 
								szret, " ", sqlmsg, NULL);
					//sprintf(szbuff, "Error during UPDATE of STEPQ table - SQLCA.SQLCODE=%d, %s", 
					//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
					logit (0, szbuff);
					debug_log(szbuff);
					return ERR;
				}
		

				EXEC SQL COMMIT;
				l_sqlcode = sqlca.sqlcode;

				if (l_sqlcode != ORCL_NO_ERROR)
				{
					strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
					EXEC SQL ROLLBACK;
					LeaveCriticalSection(&jsnt_sql_lock);

					ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
									sqlmsg, "STEPQ table", NULL);
					_itoa(l_sqlcode, szret, 10);
					copy_cat(szbuff,"ERROR: COMMIT after UPDATE of STEPQ table failed: - SQLCA.SQLCODE=",  
								szret, " ", sqlmsg, NULL);
					//sprintf(szbuff, "ERROR: COMMIT after UPDATE of STEPQ table failed: - SQLCA.SQLCODE=%d, %s", 
					//				l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
					logit (0, szbuff);
					debug_log(szbuff);
					return ERR;
				}
			}
			LeaveCriticalSection(&jsnt_sql_lock);

		}
	
		cntr = i;
		time(&last_tested);
		_ltoa(last_tested, d_last_tested, 10);
//		memcpy(step_q.d_last_tested + (i * 10), d_last_tested, 10);

		EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL SELECT
			no,
			step,
			s_name
		INTO :step_no, :step_step_no, :step_s_name
		FROM STEPQ
		WHERE no   = :job_q.no
		AND step   = :step_q.step
		FOR UPDATE;
		//FOR UPDATE NOWAIT;

		l_sqlcode = sqlca.sqlcode;

		
		if (l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			EXEC SQL ROLLBACK;
			LeaveCriticalSection(&jsnt_sql_lock);
			ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"STEPQ", sqlmsg, "For Update", NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff, "Error selecting STEPQ in line ", sznum, " - sqlca.sqlcode=",
						szret, sqlmsg, NULL);		
			//sprintf (szbuff, "Error selecting STEPQ in line %ld - sqlca.sqlcode=%ld, %s", 
			//			__LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (2, szbuff);
			debug_log (szbuff);
			return -1;
		} 


		EXEC SQL UPDATE STEPQ
			SET d_last_tested=substr(d_last_tested, :cntr*10, 10) || :d_last_tested || substr(d_last_tested, :cntr+10, 200 - (:cntr + 10))
			WHERE no   = :job_q.no
			AND step   = :step_q.step;

		l_sqlcode = sqlca.sqlcode;

		if(l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			EXEC SQL ROLLBACK;
			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"STEPQ", sqlmsg, " ", NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff, "Error during UPDATE of STEPQ table - SQLCA.SQLCODE=",
						szret, " ", sqlmsg, NULL);		
			//sprintf(szbuff, "Error during UPDATE of STEPQ table - SQLCA.SQLCODE=%d, %s", 
			//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log(szbuff);
			return ERR;
		}
	
		EXEC SQL COMMIT;
		l_sqlcode = sqlca.sqlcode;

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			EXEC SQL ROLLBACK;
			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						sqlmsg, "STEPQ table", NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"ERROR: COMMIT after UPDATE of STEPQ table failed: - SQLCA.SQLCODE=", 
						szret, sqlmsg, NULL);		
			//sprintf(szbuff, "ERROR: COMMIT after UPDATE of STEPQ table failed: - SQLCA.SQLCODE=%d, %s", 
			//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log(szbuff);
			return ERR;
		}
		LeaveCriticalSection(&jsnt_sql_lock);

		return(1);
	}

		
	} // try block
	catch ( achStructured *pExp)
	{
		pExp->getStackTrace();
		delete pExp;
		exit(-4);
	}
	catch ( achStackOverFlow  *pExp)
	{
		logitwithlocaltime(0, strcat((LPSTR) pExp->GetErrText().c_str()," in test_s_dep()"));
		delete pExp; 
		exit(-4);
	}


  
  

	return(0);
}

/******************* is_group_finished *************************
*                                                              *
* Description: This function checks to see if the current      *
*  group is finished.                                          *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
*                                                              *
***************************************************************/
int is_group_finished(int i, char *save_key)
{
   short int status=0;
   short int first_time=1;
   char szbuff[300];
   //short int tries;
   int l_sqlcode;
   char szret[10];
   char sznum[20];
   char sqlmsg[80];

 
   	EXEC SQL BEGIN DECLARE SECTION;
		short int cntr;
		//char d_cmplt;
		unsigned long step_no;		/* Unique Job Number */
		short int step_step_no;     /* Job Step number */
		char step_s_name[10];	
	    char d_step[9];
	EXEC SQL END DECLARE SECTION;
  

	//Catch the exception. DRQ 2003 -077 Baskar/Veera
	try
	{

   	EnterCriticalSection(&jsnt_sql_lock);

	EXEC SQL DECLARE grp_stepq_curs CURSOR FOR 
	SELECT 
		no,
		step,
		s_name,
		status,
		j_name,
		date_time_started,
		date_time_completed,
		exit_code,
		command_line,
		num_d,
		d_step,
		d_cmplt,
		d_last_tested,
		num_a,
		exit_codes_acceptable,
		job_machine,
		d_group,
		group_name,
		same_machine_flag_yn,
		group_first_step_yn,
		skip_yn,
		beg_console_msg,
		beg_suspend_yn,
		end_console_msg,
		end_suspend_yn,
		send_msg,
		run_if_error,
		status_interval
	FROM
		stepq
	WHERE no = :step_q.no
	//AND d_step >= :step_q.d_step;
	AND group_name >= :d_step;


	//Group Name that the current step is dependent on
	memset(d_step, 0, 9);
	strncpy(d_step, step_q.d_step + (i*9), 8);
	trimr(d_step);


	// Open grp_stepq_curs cursor
	EXEC SQL OPEN grp_stepq_curs;

	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);


	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"grp_stepq_curs", sqlmsg, "STEPQ table", NULL);
		_ltoa((DWORD) __LINE__, sznum, 10);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Open Cursor for grp_stepq_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=",
					szret, " ", sqlmsg, NULL);
		logit (0, szbuff);
		debug_log (szbuff);
		return(-1);
	}

	// Select using step_q.no and step_q.d_step
	memset(&stepq_sql, 0, sizeof(stepq_sql) );
	memset(&stepq_sql_ind, 0, sizeof(stepq_sql_ind) );

	EnterCriticalSection(&jsnt_sql_lock);

	EXEC SQL FETCH grp_stepq_curs INTO :stepq_sql:stepq_sql_ind;

	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);


	while(1)
	{
		if(first_time)
			first_time=0;
		else
		{	
			// Fetch next
			memset(&stepq_sql, 0, sizeof(stepq_sql) );
			memset(&stepq_sql_ind, 0, sizeof(stepq_sql_ind) );

			EnterCriticalSection(&jsnt_sql_lock);
			EXEC SQL FETCH grp_stepq_curs INTO :stepq_sql:stepq_sql_ind;

			l_sqlcode = sqlca.sqlcode;
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			LeaveCriticalSection(&jsnt_sql_lock);
		}


		if (l_sqlcode == ORCL_NOT_FOUND)
			break;

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"grp_stepq_curs", sqlmsg, "STEPQ table", NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);	
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"Open Cursor for grp_stepq_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=", 
						szret, " ", sqlmsg, NULL);
			logit (0, szbuff);
			debug_log (szbuff);
			EnterCriticalSection(&jsnt_sql_lock);
			EXEC SQL CLOSE grp_stepq_curs;
			LeaveCriticalSection(&jsnt_sql_lock);
			return(-1);
		}

		trim_sql_stepq(&stepq_sql);

		if(stepq_sql.no != job_q.no)
			break;

//		memset(group_name, 0, 9);
//		strncpy(group_name, step_q.d_step + (i*9), 8);
//		strncpy(group_name, step_q.d_step + (i*9), 8);

		trimr(stepq_sql.group_name);

		if(strcmp(d_step, stepq_sql.group_name) != 0 )
			continue;

		if(stepq_sql.status[0] != 'Y' && stepq_sql.status[0] != 'S')
		{
			EnterCriticalSection(&jsnt_sql_lock);

			EXEC SQL CLOSE grp_stepq_curs;
			LeaveCriticalSection(&jsnt_sql_lock);

			return(1);
		}
	}


	// Try to Lock the row for updating up to 10 times before Erroring out.
	EnterCriticalSection(&jsnt_sql_lock);

	EXEC SQL SELECT
		no,
		step,
		s_name
	INTO :step_no, :step_step_no, :step_s_name
	FROM STEPQ
	WHERE no   = :step_q.no
	AND step   = :step_q.step
	FOR UPDATE;

	l_sqlcode = sqlca.sqlcode;
			
	if(l_sqlcode != ORCL_NO_ERROR)
	{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			EXEC SQL ROLLBACK;
			EXEC SQL CLOSE grp_stepq_curs;
			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"STEPQ", sqlmsg, "For Update", NULL);
			_ltoa((DWORD) __LINE__, sznum, 10);	
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff, "Error selecting STEPQ in line ", sznum, " sqlca.sqlcode=",
						szret, sqlmsg, NULL);
			logit (2, szbuff);
			debug_log (szbuff);
			return -1;
	}

	cntr = i;
	step_q.d_cmplt[cntr] = '1';

	EXEC SQL UPDATE STEPQ
		SET d_cmplt=substr(d_cmplt, :cntr, 1) || '1' || substr(d_cmplt, :cntr, 20 - :cntr)
		WHERE no   = :step_q.no
		AND step   = :step_q.step;

	l_sqlcode = sqlca.sqlcode;

	if(l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EXEC SQL ROLLBACK;
		EXEC SQL CLOSE grp_stepq_curs;
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"STEPQ", sqlmsg, " ", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Error during UPDATE of STEPQ table - SQLCA.SQLCODE=",  
					szret, " ", sqlmsg, NULL);
		logit (2, szbuff);
		debug_log(szbuff);
		return -1;
	}
	
	EXEC SQL COMMIT;
	l_sqlcode = sqlca.sqlcode;

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EXEC SQL ROLLBACK;
		EXEC SQL CLOSE grp_stepq_curs;
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, sqlmsg, "STEPQ table", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"ERROR: COMMIT after UPDATE of STEPQ table failed: - SQLCA.SQLCODE=",  
					szret, " ", sqlmsg, NULL);
		logit (2, szbuff);
		debug_log(szbuff);
		return -1;
	}


	EXEC SQL CLOSE grp_stepq_curs;
	LeaveCriticalSection(&jsnt_sql_lock);

	} // try block
	catch ( achStructured *pExp)
	{
		pExp->getStackTrace();
		delete pExp;
		exit(0);
	}

	catch ( achStackOverFlow  *pExp)
	{
		logitwithlocaltime(0, strcat((LPSTR) pExp->GetErrText().c_str()," in is_group_finished()"));
		delete pExp; 
		exit(-4);
	}



   return(0);
}

/******************* is_same_machine ***************************
*                                                              *
* Description: This function checks to see if this is the same *
*  machine for a group.                                        *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
* Modifiy Date:  07/27/99        By: Mike West                 *
*                                                              *
***************************************************************/
int is_same_machine(void)
{
   short int rc;
   short int status=0;
   char szbuff[300];
   int l_sqlcode;
   char szret[10];
   char sznum[20];
   char sqlmsg[80];


 
	EnterCriticalSection(&jsnt_sql_lock);
   	EXEC SQL DECLARE mch_stepq_curs CURSOR FOR 
	SELECT 
		no,
		step,
		s_name,
		status,
		j_name,
		date_time_started,
		date_time_completed,
		exit_code,
		command_line,
		num_d,
		d_step,
		d_cmplt,
		d_last_tested,
		num_a,
		exit_codes_acceptable,
		job_machine,
		d_group,
		group_name,
		same_machine_flag_yn,
		group_first_step_yn,
		skip_yn,
		beg_console_msg,
		beg_suspend_yn,
		end_console_msg,
		end_suspend_yn,
		send_msg,
		run_if_error,
		status_interval
	FROM STEPQ
	WHERE no = :step_q.no
	AND step = :step_q.step
	AND group_name >= :step_q.group_name;

	// Open grp_stepq_curs cursor
	EXEC SQL OPEN mch_stepq_curs;

	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);


	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"mch_stepq_curs", sqlmsg, "STEPQ table", NULL);
		_ltoa((DWORD) __LINE__, sznum, 10);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Open Cursor for mch_stepq_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=",
					szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "Open Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
		//			"mch_stepq_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (2, szbuff);
		debug_log (szbuff);
		return(-1);
	}

	// Select using step_q.no and step_q.d_step
	memset(&stepq_sql, 0, sizeof(stepq_sql) );
	EnterCriticalSection(&jsnt_sql_lock);

	EXEC SQL FETCH mch_stepq_curs INTO :stepq_sql:stepq_sql_ind;

	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);


	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"mch_stepq_curs", sqlmsg, "STEPQ table", NULL);
		_ltoa((DWORD) __LINE__, sznum, 10);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff, "Open Cursor for mch_stepq_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=",
					szret, " ", sqlmsg, NULL);
		//sprintf(szbuff, "Open Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
		//			"mch_stepq_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (2, szbuff);
		debug_log (szbuff);
		EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL CLOSE mch_stepq_curs;
		LeaveCriticalSection(&jsnt_sql_lock);

		return(-1);
	}

	trim_sql_stepq(&stepq_sql);

	if(stepq_sql.group_first_step_yn[0] == 'N')
	{
		EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL CLOSE mch_stepq_curs;
		LeaveCriticalSection(&jsnt_sql_lock);

		return(-1);
	}

	if(strcmp(stepq_sql.job_machine, szjsname) == 0)
		rc = 1;
	else
		rc = 0;

	EnterCriticalSection(&jsnt_sql_lock);

	EXEC SQL CLOSE mch_stepq_curs;
	LeaveCriticalSection(&jsnt_sql_lock);
  

	return(rc);
}


/******************** send_begin_msg ***************************
*                                                              *
* Description: Sends a message to the operator or console when *
*  the job has started.                                        *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
*                                                              *
***************************************************************/
void send_begin_msg(void)
{
   char szbuff[100];

   copy_cat(szbuff, "Job ", job_q.name, " has STARTED.", NULL);
   //sprintf(szbuff, "Job %s has STARTED", job_q.name);
   send_messages(szbuff);
}

/********************** send_end_msg ***************************
*                                                              *
* Description: Sends a message to the operator or console when *
*  the job has ended.                                          *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
*                                                              *
***************************************************************/
void send_end_msg(void)
{
   char szbuff[100];
   char szret[10];

   if(job_q.exit_code == 0)
	  copy_cat(szbuff, "Job ", job_q.name, " Completed Successfully!", NULL);
      //sprintf(szbuff, "Job %s Completed Successfully!", job_q.name);
   else
	  copy_cat(szbuff, "Job ", job_q.name, " FAILED with exit 7code ", szret, NULL);
      //sprintf(szbuff, "Job %s FAILED with exit code %d!", job_q.name, job_q.exit_code);

   send_messages(szbuff);
}

/********************* send_messages ***************************
*                                                              *
* Description: Sends a message to the operator console or      *
*  sends a Novell message.                                     *
*                                                              *
*  Note: The "NOVELL SEND" and "SAM" message options are       *
*    disabled.                                                 *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
*                                                              *
***************************************************************/
void send_messages(char *msg)
{


 
	if(job_q.msg_to_operator_yn[0] == 'Y')
		console_message(msg, 1, job_q.job_class);
  
}

/*********************** submit_msg ****************************
*                                                              *
* Description: This function logs jcsubmit messages to a file. *
*                                                              *
* Creation Date:  08/09/96        By: Mike West                *
*                                                              *
***************************************************************/
void submit_msg(char *msg)
{
   char szbuff[300];

   copy_cat(szbuff, "From JCSUBMIT(): ", msg, NULL);
   //sprintf(szbuff, "From JCSUBMIT(): %s", msg);
   logit(0, szbuff);
   debug_log(szbuff);
}


/*************************** logit *****************************
*                                                              *
* Description: This function logs messages to a file.          *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  06/24/96        By: Mike West                 *
*                                                              *
***************************************************************/
int logit (int log_type, char *msg) {
   char name[80];
   char job_info[100];
   char message[500];
   short int fh;
   char short_name[15];
   char datetime[20];
   char novell_info[100];
   SYSTIME st;

   char month[3];
   char day[3];
   char year[5];
   char decade[3];
   char hour[3];
   char minute[3];
   char second[3];

   char jobq_no[11];
   char jobq_name[10];
   char stepq_step[5];
   char stepq_name[10];
   char stepq_group_name[10];

   char jsname[10];
   char uname[20];
   char netid[20];
   char netpa[20];
   char netsid[20];
   //int  tmp_year;
   
 
   	EXEC SQL BEGIN DECLARE SECTION;
		char orcl_sys_date[15];
   	EXEC SQL END DECLARE SECTION;
  



 
   if(get_system_date_time(orcl_sys_date) == SUCCESS)
  {
	   move(year,   4, orcl_sys_date,    1);
 	   move(month,  2, orcl_sys_date+4,  1);
   	   move(day,    2, orcl_sys_date+6,  1);
   	   move(hour,   2, orcl_sys_date+8,  1);
   	   move(minute, 2, orcl_sys_date+10, 1);
   	   move(second, 2, orcl_sys_date+12, 1);
   }
   else
   {
	  /*  Format some basic information */
	   getsystime(&st);

		_itoa(st.wMonth, month, 10);
		if(st.wMonth < 10)
			_padl(month, '0', 2);
	
		_itoa(st.wDay, day, 10);
		if(st.wDay < 10)
			_padl(day, '0', 2);
 
//	tmp_year = st.wYear%100;
		_itoa(st.wYear, year, 10);

		_itoa(st.wHour, hour, 10);
		if(st.wHour < 10)
			_padl(hour, '0', 2);

		_itoa(st.wMinute, minute, 10);
		if(st.wMinute < 10)
			_padl(minute, '0', 2);

		_itoa(st.wSecond, second, 10);
		if(st.wSecond < 10)
			_padl(second, '0', 2);
 }
  

   move(decade, 2, year+2, 1);
   copy_cat(datetime, month, "/", day, "/", decade, " ", hour, ":", minute, ":", second, NULL);

   _ltoa(job_q.no, jobq_no, 10);
   _padl(jobq_no, '0', 10);

   strcpy(jobq_name, (char*)job_q.name);
   _padl (jobq_name, ' ', 9);

   _itoa(step_q.step, stepq_step, 10);
   _padl(stepq_step, '0', 4);
   
   strcpy(stepq_name, (char*)step_q.s_name);
   _padl (stepq_name, ' ', 9);
   strcpy(stepq_group_name, step_q.group_name);
   _padl (stepq_group_name, ' ', 9);
   copy_cat(job_info, jobq_no, " ", jobq_name, " ", stepq_step, " ", stepq_name, " ", stepq_group_name, NULL);

   strcpy(jsname, szjsname);
   _padl(jsname, ' ', 8);
   strcpy(uname, user_name);
   _padl(uname, ' ', 10);
   strcpy(netid, network_id_s);
   _padl(netid, ' ', 4);
   strcpy(netpa, network_physical_address);
   _padl(netpa, ' ', 8);
   strcpy(netsid, network_station_id);
   _padl(netsid, ' ', 3);
   copy_cat(novell_info, jsname, " ", uname, " ", netid, ":", netpa, ":", netsid, NULL);

   copy_cat(short_name, year, month, day, ".LOG", NULL);

   if (! strlen(szlogpath)) 
	   strcpy  (name, short_name);
   else 
	   copy_cat(name, szlogpath, short_name, NULL);


/* Attempt to open the file, fh will be ERR if it fails.  On fail display msg */
   fh = _sopen (name, _O_BINARY | _O_RDWR, _SH_DENYNO);

    if (fh == ERR) {                  /* File not present - try to create it */
      fh = _sopen(name, _O_BINARY | _O_RDWR | _O_CREAT, _SH_DENYNO, _S_IWRITE);
      if (fh != ERR) 
	  {
		 copy_cat(message, datetime, "                                               ", novell_info, " File Created\r\n", NULL);
         _write(fh, message, strlen(message));
      }
		// ssv 04/19/04
  	  else
	  {
		/* Write the log to the local machine */
		copy_cat(name, szlocallogpath, short_name, NULL);
		fh = _sopen(name, _O_BINARY | _O_RDWR | _O_CREAT, _SH_DENYNO, _S_IWRITE);
		if (fh != ERR) 
		{
			copy_cat(message, datetime, "                                               ", novell_info, " File Created\r\n", NULL);
			_write(fh, message, strlen(message));
		}

	  }

    }

/* Open attempt failed - show something to screen, & don't do any more I/O calls below */
   if (fh==ERR) 
   {
	   copy_cat(message, "Error opening log file: ", name, NULL);
	   qtext(10, 10, message);
   }

/* On successful open, try to lock the file's first byte */
   else {
      if (_locking (fh, _LK_LOCK, 1L) != SUCCESS) 
	  {
         _close (fh);         /* Lock failed, so close the file handle */
         fh = ERR;           /* Simulate an errored file handle */
		 qtext(10, 10, "Error locking log file!");
      }
   }

   switch (log_type) {
      case 0:     /* General Message */
		  copy_cat(message, datetime, "                                               ", novell_info, " ",
				msg, "\r\n", NULL);
		  break;
      case 1:     /* Job Message */
		  copy_cat(message, datetime, " ", jobq_no, " ", jobq_name, 
					"                          ", novell_info, " ", msg, "\r\n", NULL);
		  break;

      case 2:     /* Step Message */
		  copy_cat(message, datetime, " ", jobq_no, " ", jobq_name, " ", stepq_step, " ", 
					stepq_name, " ", stepq_group_name, " ", novell_info, " ", msg, "\r\n", NULL);
		  break;
   }


/*  When the file handle is valid, write the message to the log file, unlock, & close */
   if (fh == ERR) 
	   qtext(10, 10, message);
   else {
      _lseek (fh, 0L, SEEK_END);
      _write (fh, message, strlen(message));
      _lseek (fh, 0L, SEEK_SET);
      _locking (fh, _LK_UNLCK, 1L);
      _close (fh);
   }
   return SUCCESS;
}


/************************ debug_log ****************************
*                                                              *
* Description: This function will check the passed variable    *
*  to see if the variable is either blank or null.             *
*  It will return 1 if the variable is blank or null and 0     *
*  if has valid characters in it.                              *
*                                                              *
* Creation Date: 06/26/96        By: Mike West                 *
*                                                              *
***************************************************************/
int debug_log(char *msg)
{
   char fname[_MAX_FNAME];
   char basic_info[50];
   char datetime[20];
   char message[500];
   short int fh;
   short int ret;
   char short_name[15];
   struct _stat info;
   static long offset;
   SYSTIME st;

   char month[3];
   char day[3];
   char year[5];
   char decade[3];
   char hour[3];
   char minute[3];
   char second[3];
   char jsname[10];

 
   	EXEC SQL BEGIN DECLARE SECTION;
		char orcl_sys_date[15];
   	EXEC SQL END DECLARE SECTION;
  



   if(! debug_flag)     /* check for debug_flag set */
      return(0);



 
   if(get_system_date_time(orcl_sys_date) == SUCCESS)
  {
	   move(year,   4, orcl_sys_date,    1);
 	   move(month,  2, orcl_sys_date+4,  1);
   	   move(day,    2, orcl_sys_date+6,  1);
   	   move(hour,   2, orcl_sys_date+8,  1);
   	   move(minute, 2, orcl_sys_date+10, 1);
   	   move(second, 2, orcl_sys_date+12, 1);
   }
   else
   {
	  /*  Format some basic information */
	   getsystime(&st);

		_itoa(st.wMonth, month, 10);
		if(st.wMonth < 10)
			_padl(month, '0', 2);
	
		_itoa(st.wDay, day, 10);
		if(st.wDay < 10)
			_padl(day, '0', 2);
 
		_itoa(st.wYear, year, 10);

		_itoa(st.wHour, hour, 10);
		if(st.wHour < 10)
			_padl(hour, '0', 2);

		_itoa(st.wMinute, minute, 10);
		if(st.wMinute < 10)
			_padl(minute, '0', 2);

		_itoa(st.wSecond, second, 10);
		if(st.wSecond < 10)
			_padl(second, '0', 2);
 }
  

   move(decade, 2, year+2, 1);
   copy_cat(datetime, month, "/", day, "/", decade, " ", hour, ":", minute, ":", second, NULL);


   /* Create debug file name */
   copy_cat(short_name, year, month, day, ".DBG", NULL);


   if(strlen(szlogpath) == 0)
      strcpy(fname, short_name);
   else
	  copy_cat(fname, szlogpath, "\\", short_name, NULL);

   strcpy(jsname, szjsname);
   _padl(jsname, ' ', 8);
   copy_cat(basic_info, datetime, jsname, NULL);

   /* see if the debug file name already exists */
   ret = _stat(fname, &info);
   if(ret != 0)
   {
      fh=_sopen(fname, _O_BINARY | _O_RDWR | _O_CREAT, _SH_DENYNO, _S_IWRITE);
	  copy_cat(message, basic_info, " File Created\r\n", NULL);
      ret=_write(fh,message,strlen(message));
      _close(fh);
   }

   if (fh=_sopen (fname, _O_BINARY | _O_RDWR, _SH_DENYNO)==ERR) 
	   return ERR;
   if (_locking (fh, _LK_LOCK, 1L)) {        /* Lock the file - close & exit if error */
      _close(fh);
      return ERR;
   }

   _lseek (fh, 0L, SEEK_END);
   copy_cat(message, basic_info, " ", msg, "\r\n", NULL);

   _write (fh, message, strlen(message));   /* write message to debug file */
   _lseek (fh, 0L, SEEK_SET);
   _locking(fh, _LK_UNLCK, 1L);              /* Unlock the file */
   _close(fh);
   return SUCCESS;
}



/********************* get_system_date_time ********************
*                                                              *
* Description: Gets the date/time from the database.           *
*                                                              *
* Creation Date: 07/23/99        By: Mike West                 *
*                                                              *
***************************************************************/
 
int get_system_date_time(char *date_time)
{
	char szbuff[300];
	int l_sqlcode;
	int tries;
	char szret[10];
	char sqlmsg[80];

	EXEC SQL BEGIN DECLARE SECTION;
		char dt_tm[20];
	EXEC SQL END DECLARE SECTION;

	//EnterCriticalSection(&jsnt_sql_lock2);
	EnterCriticalSection(&jsnt_sql_lock);
	for(tries=0; tries < 5; tries++)
	{
		EXEC SQL SELECT to_char(sysdate, 'YYYYMMDDHH24MISS')
			INTO :dt_tm
			FROM dual;

		l_sqlcode = sqlca.sqlcode;
		
		if(l_sqlcode != ORCL_NO_ERROR)
			Sleep(1000);
		else
			break;
	}

	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
    LeaveCriticalSection(&jsnt_sql_lock);


	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"dual", sqlmsg, "Selecting Date/Time in get_system_date_time()", NULL);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff, "Error selecting Date/Time from dual in get_system_date_time() - sqlca.sqlcode=", 
					szret, " ", sqlmsg, NULL);
		//sprintf (szbuff, "Error selecting Date/Time from dual in get_system_date_time() - sqlca.sqlcode=%d, %s", 
		//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);

		//	DRQ 2003 -077 Baskar/Veera changed logit to logitwithlocaltime
		//	logit (2, szbuff);
		logitwithlocaltime(2, szbuff);

		debug_log (szbuff);
		return ERR;
	} 

	trimr(dt_tm);
	strcpy(date_time, dt_tm);
	return(SUCCESS);
}
  







/******************** write_status_file ************************
*                                                              *
* Description:  Write step status file                         *
*                                                              *
* Parameters:   right & bottom coordinate values               *
*                                                              *
* This function writes the step files (jobname.xxx).           *
* Returns SUCCESS or ERR.                                      *
*                                                              *
* Creation Date: 17/Apr/2000  By: Sasidhar D & Sabari Girish J *
*                                                              *
***************************************************************/
int write_status_file(unsigned int right, unsigned int bottom)
{
   int  fh, ret;
   int file_there = 0;
   long oldest;
   long offset;
   long longret = 0;
   char name[101], tempstr[101];
   char szbuff[300];          /* message array buffer        */
   struct _stat info;
   struct scr_times
   {
   time_t s_time[2];
   } st;

   if(no_screens) return(0);

/* Example file name: "\DEPS\JCS\some_job.001" or "some_job.001" */
   memset (name, 0x00, sizeof(name));
	if (strlen(szjspath) > 0) {
      strcpy (name, (char *)szjspath);
      //strcat (name, "\\");
      strcat (name, (char *)step_q.j_name);
   }
	else {
      strcpy (name, (char *)step_q.j_name);
   }
   strcat (name, ".");
   memset (tempstr, 0x00, 10);
   _itoa(step_q.step, tempstr, 10);
   padlz(tempstr, 3);
   strcat (name, tempstr);


	ret = _stat (name, &info);
	if (ret == 0) {
		file_there = 1;
		fh = _sopen (name, _O_RDWR | _O_BINARY, _SH_DENYNO);
	}
	else {
		fh = _open (name, _O_CREAT | _O_RDWR | _O_BINARY, _S_IWRITE);
	}
	if (fh == -1) {
		ifs_custerr("FILEOPEN", __FILE__, (DWORD) __LINE__, IFS_LOG, name, " ", " ", NULL);
		copy_cat(szbuff, "call to _(s)open() failed in write_status_file()", NULL);
		logit(2, szbuff);
		debug_log( szbuff );
		return ERR;
	}


    screen_buffer = (char*) gettext(0, 0, right, bottom);
	if( screen_buffer == NULL )
	{
		ifs_custerr("PRO_ERR_TO_USER", __FILE__, (DWORD) __LINE__, IFS_LOG, 
                     " : call to gettext() failed", "", NULL);
		copy_cat(szbuff, "call to gettext() failed in write_status_file()", NULL);
		logit(2, szbuff);
		debug_log( szbuff );
		return ERR;
	}

	if (file_there == 0) {
		ret = _write (fh, (char *) &job_q, sizeof(job_q)); /* 830 bytes */
		ret = _write (fh, (char *) &step_q, sizeof(step_q)); /* 1130 bytes */
		memset (st.s_time, 0x00, sizeof(st));                   /* 4*2  bytes */
		time (&st.s_time[0]);
		ret = _write (fh, (char *) &st, sizeof(st));
		ret = _write (fh, (char*)screen_buffer, scr_buffer_size);
		ret = _write (fh, (char*)screen_buffer, scr_buffer_size);
		_close (fh);                                      /* Total 17968 bytes */
        //klk 9/21/01 
		free( screen_buffer ); 
		return (SUCCESS);
	}

	ret = _write (fh, (char *) &job_q, sizeof(job_q));
	ret = _write (fh, (char *) &step_q, sizeof(step_q));
	offset = ((sizeof(job_q)) + (sizeof(step_q)));
	longret = _lseek (fh, offset, SEEK_SET);
	if (longret == -1) {
      _close (fh);
      //klk 9/21/01 
  	  free( screen_buffer ); 
      sprintf(tempstr, "%ld", offset);
		ifs_custerr("FILESEEK", __FILE__, (DWORD) __LINE__, IFS_LOG, name, tempstr, 
                     " ", " ", NULL);
		copy_cat(szbuff, "call to _lseek() failed in write_status_file()", NULL);
		logit(2, szbuff);
		debug_log( szbuff );
		return ERR;
   }
	ret = _read (fh, (char *) &st, sizeof(st));  

	oldest = 0;
	if (st.s_time[1] < st.s_time[oldest]) oldest = 1;
	time (&st.s_time[oldest]);

	longret = _lseek (fh, offset, SEEK_SET);
   if (longret == -1) {
        _close (fh);   
        //klk 9/21/01 
        free( screen_buffer ); 
	    sprintf(tempstr, "%ld", offset);
		ifs_custerr("FILESEEK", __FILE__, (DWORD) __LINE__, IFS_LOG, name, tempstr, 
                     " ", " ", NULL);
		copy_cat(szbuff, "call to _lseek() failed in write_status_file()", NULL);
		logit(2, szbuff);
		debug_log( szbuff );
		return (ERR);
   }
	ret = _write (fh, (char *) &st, sizeof(st)); 
	offset = ((sizeof(job_q)) + (sizeof(step_q)) + (sizeof(st)) + (oldest*scr_buffer_size));
	longret = _lseek (fh, offset, SEEK_SET);
	if (longret == -1) {
		_close (fh);     
        //klk 9/21/01 
		free( screen_buffer ); 
        sprintf(tempstr, "%ld", offset);
		ifs_custerr("FILESEEK", __FILE__, (DWORD) __LINE__, IFS_LOG, name, tempstr, 
                     " ", " ", NULL);
		copy_cat(szbuff, "call to _lseek() failed in write_status_file()", NULL);
		logit(2, szbuff);
		debug_log( szbuff );
		return (ERR);
   }

	ret = _write (fh, (char*)screen_buffer, scr_buffer_size);
    _close (fh);
    //klk 9/21/01 
	free( screen_buffer ); 

   return (SUCCESS);
}


/******************** date_logic() *****************************
*                                                              *
* Description:  Calculate date in which to spawn a process     *
*                                                              *
* Parameters:   reference to new date & new time               *
*                                                              *
* Creation Date: 05/15/2000  By: Sasidhar D, iDLX              *
*                                                              *
***************************************************************/
int date_logic(char *new_date, char *new_time)
{
    int i,ret;
    int j,k,interval,hr,mn;
    int yy,mm,dd;
    int save_mm;
    int century;
    unsigned int clk[8];
    int year;
    datestring holidays[500];
    char szbuff[100];
    char date_time_to_start[15];


 
   strcpy(date_time_to_start, job_q.date_time_to_start);

  

   //holidays[0] = 0;
   ret=load_holidays(holidays);

	move(szbuff,2,date_time_to_start,1);     /* two digit century */
	century=atoi(szbuff);
	century=century*100;
	move(szbuff+2,2,date_time_to_start+2,1);   /* two digit year */
	yy=atoi(szbuff);
	move(szbuff,2,date_time_to_start+4,1);   /* two digit mm   */
	mm=atoi(szbuff);
	move(szbuff,2,date_time_to_start+6,1);   /* two digit dd   */
	dd=atoi(szbuff);


	switch(job_q.spawn_algorithm) {
		
		case 1:                          /* Tomorrow Next Business Day */
			get_next_business_date(&yy,&mm,&dd, holidays);
			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;
					

			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 2:                          /* Weekly - SAME day next week 
														unless it is not a business day
														then the next business day */
			for(i=0;i<7;i++) 
				get_tomorrows_date(&yy,&mm,&dd);
			ret=is_valid_business_date(yy,mm,dd,holidays);
			if(ret != 0) 
				get_next_business_date(&yy,&mm,&dd,holidays);
			
			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;

			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 3:                          /* Last Business day of next month */
			
			/* Get 1st Day of Next Month */
			save_mm=mm;
			for(;1;) {
				get_next_business_date(&yy,&mm,&dd,holidays);
				if(mm != save_mm) break;
			}
			/* Go until Month changes again */
			save_mm=mm;
			for(;1;) {
				get_next_business_date(&yy,&mm,&dd,holidays);
				if(mm != save_mm) break;
			}
			/* Now back off one business day */
			get_previous_business_date(&yy,&mm,&dd,holidays);
		
			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;
			
			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 4:                          /* First Business day of next month */                      
			/* Get 1st Day of Next Month */
			save_mm=mm;
			for(;1;) {
				get_next_business_date(&yy,&mm,&dd,holidays);
				if(mm != save_mm) break;
			}

			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;

			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 5:                          /* 1st (day-of-week) of month 
														unless it is not a business day
														then the next business day */
			save_mm=mm;
			for(;1;) {
				get_tomorrows_date(&yy,&mm,&dd);
				if(mm != save_mm) break;
			}
			for(;1;) {
				ret=dow(yy,mm,dd);
				if(ret == job_q.spawn_parm) break;
				get_tomorrows_date(&yy,&mm,&dd);
			}
			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;

			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 6:                          /* 2nd (day-of-week) of month 
														unless it is not a business day
														then the next business day */
			save_mm=mm;
			for(;1;) {
				get_tomorrows_date(&yy,&mm,&dd);
				if(mm != save_mm) break;
			}
			for(;1;) {
				ret=dow(yy,mm,dd);
				if(ret == job_q.spawn_parm) break;
				get_tomorrows_date(&yy,&mm,&dd);
			}
			for(i=0;i<7;i++) get_tomorrows_date(&yy,&mm,&dd);
			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;

			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 7:                          /* 3rd (day-of-week) of month 
														unless it is not a business day
														then the next business day */
			save_mm=mm;
			for(;1;) {
				get_tomorrows_date(&yy,&mm,&dd);
				if(mm != save_mm) break;
			}
			for(;1;) {
				ret=dow(yy,mm,dd);
				if(ret == job_q.spawn_parm) break;
				get_tomorrows_date(&yy,&mm,&dd);
			}
			for(i=0;i<7;i++) get_tomorrows_date(&yy,&mm,&dd);
			for(i=0;i<7;i++) get_tomorrows_date(&yy,&mm,&dd);
		
			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;

			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 8:                          /* 4th (day-of-week) of month 
														unless it is not a business day
														then the next business day */
			save_mm=mm;
			for(;1;) {
				get_tomorrows_date(&yy,&mm,&dd);
				if(mm != save_mm) break;
			}
			for(;1;) {
				ret=dow(yy,mm,dd);
				if(ret == job_q.spawn_parm) break;
				get_tomorrows_date(&yy,&mm,&dd);
			}
			for(i=0;i<7;i++) get_tomorrows_date(&yy,&mm,&dd);
			for(i=0;i<7;i++) get_tomorrows_date(&yy,&mm,&dd);
			for(i=0;i<7;i++) get_tomorrows_date(&yy,&mm,&dd);
		
			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;
			
			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			strcpy(new_time,date_time_to_start+8);
			return(0);

		case 10:                         /* Submit for X Minutes from Now */
			interval=job_q.spawn_parm;
			// move(szbuff,2,job_q.time_to_start,1);
			// hr=atoi(szbuff);
			// move(szbuff,2,job_q.time_to_start+2,1);
			// mn=atoi(szbuff);
			getclk(&(clk[0]));         /* get current system time */
			hr = *(clk+DT_HOUR);       /* hours */
			mn = *(clk+DT_MIN);        /* minutes */
			j=interval % 60;
			k=interval / 60;
			mn+=j;
			if( mn >= 60 ) {
				mn-=60;
				k++;
			}
			j=k / 24;
			k=k % 24;
			hr+=k;
			if( hr >=24 ) {
				hr-=24;
				j++;
			}           
			for(k=0;k<j;k++) {
				get_tomorrows_date(&yy,&mm,&dd);
			}

			if (( yy - century ) == 100 ) 
				year = 00;
			else
				year = yy - century ;
			sprintf(new_date,"%02d%02d%02d%02d",century/100,year,mm,dd);
			sprintf(new_time,"%02d%02d",hr,mn);
			return(0);

		default:
			return(-1);
	}
	return(-1);
}


/***************** load_holidays() *****************************
*                                                              *
* Description:  Loads holidays into a buffer                   *
*                                                              *
* Parameters:   holiday buffer                                 *
*                                                              *
* Creation Date: 02/21/2001  By: Kellie Kupka                  *
*                                                              *
***************************************************************/
int load_holidays(datestring  *holidays)
{

	long holiday_buf_cnt=0, holiday_tot_cnt=0;
	short int n;
    char  tempstr[300];             
	int   l_sqlcode, l_sqlerrd;
	char  sqlmsg[80];
    char  szline[10];
    char  szcode[10];


	EXEC SQL DECLARE holiday_curs CURSOR FOR
	SELECT 
		holiday
	FROM
		holidays
	ORDER BY holiday;

	EnterCriticalSection(&jsnt_sql_lock);
	EXEC SQL CONTEXT USE :g_ctx;

	// Open HOLIDAY cursor
	EXEC SQL OPEN holiday_curs;
	l_sqlcode = sqlca.sqlcode;

	LeaveCriticalSection(&jsnt_sql_lock);

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"holiday_curs", sqlmsg, "HOLIDAY table", NULL);
		_ltoa((DWORD) __LINE__, szline, 10);
		_itoa(l_sqlcode, szcode, 10);
		copy_cat(tempstr, "Open Cursor for holiday_cursor Failed! on line ", szline, 
							" - SQLCA.SQLCODE=", szcode, " ", sqlmsg, NULL);
		logit (0, tempstr);
		debug_log (tempstr);
		return(-1);
	}

	EnterCriticalSection(&jsnt_sql_lock);

	
	// Select 100 records from HOLIDAY table using HOLIDAY cursor
	memset(&holiday_rec, 0, sizeof(holiday_rec));
	EXEC SQL FETCH holiday_curs INTO :holiday_rec;

	l_sqlcode = sqlca.sqlcode;

	l_sqlerrd = sqlca.sqlerrd[2];

	LeaveCriticalSection(&jsnt_sql_lock);

	while (((l_sqlcode == ORCL_NOT_FOUND) || (l_sqlcode == ORCL_NO_ERROR))
				&& (l_sqlerrd > 0))
	{
		holiday_buf_cnt = l_sqlerrd - holiday_tot_cnt;	/* Number of new records */
		holiday_tot_cnt = l_sqlerrd;		/* Total records fetched so far */

		/* Copy fetched records to table */
		for (n = 0; n < holiday_buf_cnt; n++)
		{
		      memcpy(holidays[n], holiday_rec.holiday[n], 8);
		}	
	    memset(holidays[n], '\0', 8);



		// if the return cnt from last fetch is less than max fetch, break out of while loop
		if (holiday_buf_cnt < ROWS)
			break; 

		EnterCriticalSection(&jsnt_sql_lock);

		// Else, we need to do another fetch to get the next set of records from the Delivery table
		memset(&holiday_rec, 0, sizeof(holiday_rec));
		EXEC SQL FETCH holiday_curs INTO :holiday_rec;

		l_sqlcode = sqlca.sqlcode;
		l_sqlerrd = sqlca.sqlerrd[2];

		LeaveCriticalSection(&jsnt_sql_lock);

		if( l_sqlcode == ORCL_NOT_FOUND )
			break;


	}	/* End of while loop */

	if (l_sqlcode == ORCL_NOT_FOUND)
	{
		EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL CLOSE holiday_curs;

		l_sqlcode = sqlca.sqlcode;

		LeaveCriticalSection(&jsnt_sql_lock);

	}

	if (l_sqlcode != ORCL_NO_ERROR)
	{	
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		EnterCriticalSection(&jsnt_sql_lock);

		EXEC SQL CLOSE holiday_curs;
		LeaveCriticalSection(&jsnt_sql_lock);

		ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
				"holiday_curs", "", " ", sqlmsg, "HOLIDAY table", NULL);
		_ltoa((DWORD) __LINE__, szline, 10);
		_itoa(l_sqlcode, szcode, 10);
		copy_cat(tempstr, "Fetch failed for HOLIDAY_CURS on line ", szline, 
							" - SQLCA.SQLCODE=", szcode, " ", sqlmsg, NULL);
		logit (0, tempstr);
		debug_log (tempstr);
	}
  

	return(0);
}

/********************** job_num_get ****************************
*                                                              *
* Description: Does a SELECT on the sequence generator in      *
*  order to obtain the next job number for this job.		   * 
*                                                              *
* Creation Date: 07/16/99      By: Mike West                   *
*															   *
* Modified Date: 04/24/2000    By: Radha K & Gopal Balaji, iDLX*
*                                                              *
* This function was modified to add IFS messages.              *
***************************************************************/
 
static long job_num_get()
{
	EXEC SQL BEGIN DECLARE SECTION;
		unsigned long lJobNum;
	EXEC SQL END DECLARE SECTION;
	char errstr[300];
	char sqlmsg[80];

	EXEC SQL SELECT seq_job_num.nextval 
		INTO :lJobNum
		FROM dual;


	if (sqlca.sqlcode != ORCL_NO_ERROR) 
	{
      strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
      ifs_custerr("ORC_SELECT", __FILE__, __LINE__, IFS_LOG, 
         "DUAL", sqlmsg, "Selecting nextval from sequence, SEQ_JOB_NUM", 
            NULL);

		sprintf(errstr, "ERROR: Cannot obtain next Job Number from seq_job_num table.");
		if (submit_error) submit_error(errstr);
		return(-1);
	}

	return(lJobNum);                          //return job number.              
}
  

/********************** submit() *******************************
*                                                              *
* Description:  Spawn (submit) this job at a future calculated *
* date. It re-submits the job & step records for a future      *
* scheduled date & time.                                       *
*                                                              *
* Parameters:   New date & New time values                     *
*                                                              *
* Creation Date: 05/15/2000  By: Sasidhar D, iDLX              *
*                                                              *
***************************************************************/
 
int submit(char *new_date, char *new_time)
{
	int i;
	int job_num;
	int s_first_time=1;
	int l_sqlcode;
	char sqlmsg[80];
   char szline[80], szcode[80];
   char tempstr[150];

	EXEC SQL BEGIN DECLARE SECTION;
		char dt_tm[15];
	EXEC SQL END DECLARE SECTION;

	job_num = job_num_get();		  /* get next job number from Seqence Generator*/
	if(job_num == 0)  
	{
		return(ERR);
	}

	EnterCriticalSection(&jsnt_sql_lock);

	// Define STEP cursor
	EXEC SQL DECLARE step_curs CURSOR FOR
	SELECT 
		no,
		step,
		s_name,
		status,
		j_name,
		date_time_started,
		date_time_completed,
		exit_code,
		command_line,
		num_d,
		d_step,
		d_cmplt,
		d_last_tested,
		num_a,
		exit_codes_acceptable,
		job_machine,
		d_group,
		group_name,
		same_machine_flag_yn,
		group_first_step_yn,
		skip_yn,
		beg_console_msg,
		beg_suspend_yn,
		end_console_msg,
		end_suspend_yn,
		send_msg,
		run_if_error,
		status_interval
	FROM
		STEPQ
	WHERE no = :job_q.no;

	// Open STEP cursor
	EXEC SQL OPEN step_curs;

	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

	LeaveCriticalSection(&jsnt_sql_lock);

	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"step_curs", sqlmsg, "STEPQ table", NULL);
		_ltoa((DWORD) __LINE__, szline, 10);
		_itoa(l_sqlcode, szcode, 10);
		copy_cat(tempstr, "Open Cursor for step_curs Failed! on line ", szline, 
							" - SQLCA.SQLCODE=", szcode, " ", sqlmsg, NULL);
		logit (0, tempstr);
		debug_log (tempstr);
		return(-1);
	}

	memset(&stepq_sql, 0, sizeof(stepq_sql) );
	EnterCriticalSection(&jsnt_sql_lock);

	EXEC SQL FETCH step_curs INTO :stepq_sql:stepq_sql_ind;


	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);

   while( l_sqlcode != ORCL_NOT_FOUND )
   {
      if( l_sqlcode != ORCL_NO_ERROR )
	   {
		   ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					   "step_curs", sqlmsg, "STEPQ table", NULL);
		   _ltoa((DWORD) __LINE__, szline, 10);
		   _itoa(l_sqlcode, szcode, 10);
		   copy_cat(tempstr, "Fetch Cursor for step_curs Failed! on line ", szline, 
							   " - SQLCA.SQLCODE=", szcode, " ", sqlmsg, NULL);
		   logit (0, tempstr);
		   debug_log (tempstr);
		   return(-1);
	   }

	    trim_sql_stepq(&stepq_sql);


		stepq_sql.no = job_num;
		strcpy((char*)stepq_sql.status, "N");
		memset(stepq_sql.date_time_started, 0, sizeof(stepq_sql.date_time_started));
		memset(stepq_sql.date_time_completed, 0, sizeof(stepq_sql.date_time_completed));
		stepq_sql.exit_code = 0;
		for(i=0; i < stepq_sql.num_d; i++) 
		{
			stepq_sql.d_cmplt[i] = 0;
			memset(stepq_sql.d_last_tested+(i*10), 0, 10);
		}
		strcpy(stepq_sql.job_machine,"");

      EnterCriticalSection( &jsnt_sql_lock );

   	EXEC SQL 
		INSERT into STEPQ VALUES (
			:stepq_sql.no,
			:stepq_sql.step,
			:stepq_sql.s_name,
			:stepq_sql.status,
			:stepq_sql.j_name,
			:stepq_sql.date_time_started,
			:stepq_sql.date_time_completed,
			:stepq_sql.exit_code,
			:stepq_sql.command_line,
			:stepq_sql.num_d,
			:stepq_sql.d_step,
			:stepq_sql.d_cmplt,
			:stepq_sql.d_last_tested,
			:stepq_sql.num_a,
			:stepq_sql.exit_codes_acceptable,
			:stepq_sql.job_machine,
			:stepq_sql.d_group,
			:stepq_sql.group_name,
			:stepq_sql.same_machine_flag_yn,
			:stepq_sql.group_first_step_yn,
			:stepq_sql.skip_yn,
			:stepq_sql.beg_console_msg,
			:stepq_sql.beg_suspend_yn,
			:stepq_sql.end_console_msg,
			:stepq_sql.end_suspend_yn,
			:stepq_sql.send_msg,
			:stepq_sql.run_if_error,
         :stepq_sql.status_interval);  

      l_sqlcode = sqlca.sqlcode;
      strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

      LeaveCriticalSection( &jsnt_sql_lock );

      if ( l_sqlcode != ORCL_NO_ERROR)
      {
         ifs_custerr("ORC_INSERT", __FILE__, __LINE__, IFS_LOG, 
            "STEPQ", "no", " ", sqlmsg, " ", NULL);

         sprintf(tempstr, "ERROR: INSERT of STEPQ table failed: Job Number - %d, Job Name - %s",
                   job_q.no, job_q.name);
         if (submit_error) submit_error(tempstr);
         return(-1);
      }

      EnterCriticalSection( &jsnt_sql_lock );

      EXEC SQL COMMIT;

      l_sqlcode = sqlca.sqlcode;
      strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

      LeaveCriticalSection( &jsnt_sql_lock );

      if( l_sqlcode != ORCL_NO_ERROR )
      {
         ifs_custerr("ORC_COMMIT", __FILE__, __LINE__, IFS_LOG, 
            sqlmsg, "STEPQ table", NULL);

         sprintf(tempstr, 
            "ERROR: COMMIT after insert into STEPQ table failed: Job Number - %d,Job Name - %s",
                  job_q.no, job_q.name);
         if (submit_error) submit_error(tempstr);
         return(-1);
      }

	   EnterCriticalSection(&jsnt_sql_lock);

	   EXEC SQL FETCH step_curs INTO :stepq_sql:stepq_sql_ind;

	   l_sqlcode = sqlca.sqlcode;
	   strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

	   LeaveCriticalSection(&jsnt_sql_lock);
   }


/* Get System Date & Time */
	memset(dt_tm, 0, sizeof(dt_tm) );

   EnterCriticalSection( &jsnt_sql_lock );

	EXEC SQL SELECT to_char(sysdate, 'YYYYMMDDHH24MISS')
		     INTO :dt_tm
			 FROM dual;

	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

   LeaveCriticalSection( &jsnt_sql_lock );

	if (sqlca.sqlcode != ORCL_NO_ERROR)
	{
      ifs_custerr("ORC_SELECT", __FILE__, __LINE__, IFS_LOG, 
         "DUAL", sqlmsg, "Selecting Date/Time in submit()", NULL);

		sprintf(tempstr, 
            "ERROR: 1. Cannot get Date/Time from Dual: Job Number - %d, Job Name - %s", 
            job_q.no, job_q.name);
		if (submit_error) submit_error(tempstr);
		return(-1);
	}


	strcpy(job_q.status, "S");
	job_q.no = job_num;
	strcpy(job_q.date_time_entered, dt_tm);
	memset(job_q.date_time_started, 0, sizeof(job_q.date_time_started));
    memset(job_q.date_time_completed, 0, sizeof(job_q.date_time_completed));
	job_q.exit_code=0;
	sprintf(job_q.date_time_to_start, "%s%s", new_date, new_time);
	job_q.start_stat = job_q.orig_start_stat;
	strcpy(job_q.c_msg_sent_yn, "N");
	strcpy(job_q.s_msg_sent_yn, "N");
	strcpy(job_q.msg_when_failed, "0");
	strcpy((char*)job_q.stn_started,"");
	for(i=0; i < job_q.num_d; i++) 
	{
		job_q.d_cmplt[i]=0;
		memset(job_q.d_last_tested+(i*10), 0, 10);
	}
  	if( !strcpy(job_q.stn_dependancy_yn, "N") )
         strcpy(job_q.station,"");

   EnterCriticalSection( &jsnt_sql_lock );

	EXEC SQL 
		INSERT into JOBQ VALUES
	(
		:job_q.status,
		:job_q.pos,
		:job_q.name,
		:job_q.no,
		:job_q.station,
		:job_q.date_time_entered,
		:job_q.date_time_started,
		:job_q.date_time_completed,
		:job_q.exit_code,
		:job_q.station_submitting,
		:job_q.msg_when_started,
		:job_q.msg_when_done,
		:job_q.multi_processing,
		:job_q.date_time_to_start,
		:job_q.start_stat,
		:job_q.must_complete_by,
		:job_q.c_msg_sent_yn,
		:job_q.must_start_by,
		:job_q.s_msg_sent_yn,
		:job_q.msg_to_operator_yn,
		:job_q.msg_to,
		:job_q.priority,
		:job_q.stn_started,
		:job_q.num_d,
		:job_q.d_job,
		:job_q.d_hrs_back,
		:job_q.d_cmplt,
		:job_q.d_last_tested,
		:job_q.orig_start_stat,
		:job_q.job_suspended,
		:job_q.restart,
		:job_q.job_class,
		:job_q.base_dir,
		:job_q.max_job_time_warn,
		:job_q.debug_mode_yn,
		:job_q.last_step,
		:job_q.last_s_name,
		:job_q.last_g_name,
		:job_q.submitted_file_name,
		:job_q.p_msg_sent_yn,
		:job_q.max_job_time_kill,
		:job_q.max_c_msg_yn,
		:job_q.stn_dependancy_yn,
		:job_q.no_fail_message_yn,
		:job_q.msg_when_failed,
      :job_q.spawn_algorithm,  
      :job_q.spawn_parm,
	  :job_q.d_station,
	  :job_q.jsgroup); // WR27164 - Hamsha        


      l_sqlcode = sqlca.sqlcode;
      strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

      LeaveCriticalSection( &jsnt_sql_lock );

      if ( l_sqlcode != ORCL_NO_ERROR)
      {
         ifs_custerr("ORC_INSERT", __FILE__, __LINE__, IFS_LOG, 
            "JOBQ", "no", " ", sqlmsg, " ", NULL);

         sprintf(tempstr, "ERROR: INSERT of JOBQ table failed: Job Number - %d, Job Name - %s",
                   job_q.no, job_q.name);
         if (submit_error) submit_error(tempstr);
         return(-1);
      }

      EnterCriticalSection( &jsnt_sql_lock );

      EXEC SQL COMMIT;

      l_sqlcode = sqlca.sqlcode;
      strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);

      LeaveCriticalSection( &jsnt_sql_lock );

      if( l_sqlcode != ORCL_NO_ERROR )
      {
         ifs_custerr("ORC_COMMIT", __FILE__, __LINE__, IFS_LOG, 
         sqlmsg, "JOBQ table", NULL);

         sprintf(tempstr, 
            "ERROR: COMMIT after insert into JOBQ table failed: Job Number - %d, Job Name - %s", 
               job_q.no, job_q.name);
         if (submit_error) submit_error(tempstr);
         return(-1);
      }

   return(0);
}
  




/********************** createSocket() *************************
*                                                              *
* Description:  Creates Socket connection with JOBMONNT        *
* If connection is established, sends a String packet as input *
* and waits for a response.                                    *
*                                                              *
* Parameters:   None                                           *
* Returns : ERR                                                *
*           SUCCESS                                            *
*                                                              *
* Creation Date: 06/29/2000  By: Meenakshi P.K, iDLX           *
*                                                              *
***************************************************************/
 
int createSocket()
{
   SOCKET sock;                        /* Socket variable for connecting */
   int nReturnval;                     /* Holds return value of function calls */
   char szErrmsg[250];                 /* String holding error messages */
   char szIfsParm[80];                 /* IFS parameter holding the error number */
   char szMessage[10];                 /* For sending and receiving messages */
   struct sockaddr_in sock_addr;       /* SOCKET address of the job server */
   struct sockaddr_in to_sock_addr;    /* SOCKET address of the destination */
   unsigned long ulAddress;            /* Address */
   int nRetries ;                      /* Number of attempts JSNT makes to connect */
   CHAR_INFO *pCharInfo;               /* To save the screen before displaying the 
                                          paused message */

   WORD   wVersionRequested;           /* The version of windows socket library */
   WSADATA wsaData;                    /* Structure which will receive the sockets
                                          library information */

   sock = NULL;

   /* 
    * Version number of the library required.
    * The high order byte specifies the minor version (revision) number 
    * The low-order byte specifies the major version number. 
    */

   wVersionRequested = MAKEWORD(MAJOR_VERSION, MINOR_VERSION);
   memset(szMessage, 0, sizeof(szMessage));

   /* 
    * Load the Windows sockets library 
    */
   nReturnval = WSAStartup(wVersionRequested, &wsaData);
   if (nReturnval != 0)
   {
      _itoa(nReturnval, szIfsParm, 10);
      copy_cat(szErrmsg, "Unable to Load sockets library, Error code:  ", 
         szIfsParm, NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "WSAStartup", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      return ERR;
   }

   /* 
    * Check whether the right version is loaded 
    */
   if (LOBYTE(wsaData.wVersion) != MAJOR_VERSION || HIBYTE(wsaData.wVersion)
      != MINOR_VERSION)
   {
      WSACleanup();
      copy_cat(szErrmsg, "DLL is not compatible", NULL);
      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "WSAStartup()", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      return ERR;
   }

   /* 
    * Create the socket 
    */
   sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   if (sock == INVALID_SOCKET)
   {
      nReturnval = WSAGetLastError();
      _itoa(nReturnval, szIfsParm, 10);
      copy_cat(szErrmsg, "Unable to create socket, Error Code: ", szIfsParm, 
         NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "socket()", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      WSACleanup();
      return ERR;
   }

   sock_addr.sin_family = AF_INET;
   sock_addr.sin_port = 0;
   sock_addr.sin_addr.s_addr = htonl(INADDR_ANY);

   /* 
    * Bind the socket 
    */
   nReturnval = bind(sock, (const struct sockaddr FAR*)&sock_addr, sizeof(sock_addr));
   if (nReturnval == SOCKET_ERROR)
   {
      nReturnval = WSAGetLastError();
      _itoa(nReturnval, szIfsParm, 10);
      copy_cat(szErrmsg, "Unable to bind socket, Error code:  ", 
         szIfsParm, NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "bind()", szErrmsg ,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      closesocket(sock);
      WSACleanup();
      return ERR;
   }

   /* 
    * Verify if JOBMONNT's IP address is valid 
    */
   ulAddress = inet_addr(szjobmon_ip);
   if( (ulAddress == INADDR_NONE) || (!ulAddress))
   {
      copy_cat(szErrmsg, "Invalid IP address ", szjobmon_ip, NULL);
      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "inet_addr()", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      closesocket(sock);
      WSACleanup();
      return ERR;
   }

   /* 
    * Verify if JOBMONNT's PORT number is valid 
    */
   if(jobmon_port_no < MIN_PORT_NO)
   {
      _itoa(jobmon_port_no, szIfsParm, 10);
      copy_cat(szErrmsg, "Invalid port number ", szIfsParm, NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "connect()", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      closesocket(sock);
      WSACleanup();
      return ERR;
   }

   /* 
    * Create a socket address for JOBMONNT 
    */
   to_sock_addr.sin_family = AF_INET;
   to_sock_addr.sin_port = jobmon_port_no;
   to_sock_addr.sin_addr.s_addr = ulAddress;

   /* 
    * Try to connect to JOBMONNT MAX_RETRIES times 
    */
   for (nRetries = 0; nRetries < MAX_RETRIES; nRetries++)
   {
      nReturnval = connect(sock, (struct sockaddr FAR*)&to_sock_addr, sizeof(to_sock_addr));
      if (nReturnval == 0) 
      {
         break;
      }
      else
      {
         continue;
      }
   }

   /* 
    * Unable to establish connection in MAX_RETRIES attempts. 
    * Hence return ERR 
    */
   if ((nRetries == MAX_RETRIES) && (nReturnval !=0))
   {
      nReturnval = WSAGetLastError();
      _itoa(nReturnval, szIfsParm, 10);
      copy_cat(szErrmsg, "Unable to connect to Jonbmonnt, Error code:  ", 
         szIfsParm, " Network error or JOBMONNT is not running", NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "connect()", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      closesocket(sock);
      WSACleanup();
      return ERR;
   }

   strcpy(szMessage,JSNT_MSG);

   /* 
    * Send a string packet to JOBMONNT 
    */
   nReturnval = send(sock, szMessage, strlen(szMessage),0);
   if (nReturnval == SOCKET_ERROR)
   {
      nReturnval = WSAGetLastError();
      _itoa(nReturnval, szIfsParm, 10);
      copy_cat(szErrmsg, "Unable to send string packet to JOBMONNT, Error code:  ", 
         szIfsParm, NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "send()", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      closesocket(sock);
      WSACleanup();
      return ERR;
   }

   /* 
    * Display the paused message till the acknowledgement is received from JOBMONNT 
    * Save area of screen so we can put it back later.               
    */
   pCharInfo = (CHAR_INFO*)gettext(0, 0, 26, 5);

   qtext(0,0," JS SUSPENDED ");
   qtext(0,1,"    This Server is      ");
   qtext(0,2,"   SUSPENDED waiting    ");
   qtext(0,3," for JOBMONNT Response. ");
   qtext(0,4,"");

   /* 
    * Receive the response sent by JOBMONNT
    */
   memset(szMessage,0,sizeof(szMessage));
   nReturnval = recv(sock,szMessage,sizeof(szMessage), 0);
   if (nReturnval == SOCKET_ERROR)
   {
      nReturnval = WSAGetLastError();
      _itoa(nReturnval, szIfsParm, 10);
      copy_cat(szErrmsg, "Unable to receive string packet from JOBMONNT, Error code:  ", 
         szIfsParm, NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "recv()", szErrmsg,NULL);      

      logit (0, szErrmsg);
      debug_log (szErrmsg);
      closesocket(sock);
      WSACleanup();
      return ERR;
   }

   /* 
    * Restore the screen 
    */
   puttext(0, 0, 26, 5, pCharInfo);
   free(pCharInfo);

   /* 
    * Response has been received, hence close the connection 
    */
   nReturnval = closesocket(sock);
   if (nReturnval == SOCKET_ERROR)
   {
      nReturnval = WSAGetLastError();
      _itoa(nReturnval, szIfsParm, 10);
      copy_cat(szErrmsg, "Unable to close socket connection, Error code:  ", 
         szIfsParm, NULL);

      ifs_warning("PRO_WINSOCK", __FILE__, __LINE__,IFS_NODISPLAY,\
         "closesocket()", szErrmsg,NULL);      

	   logit (0, szErrmsg);
      debug_log (szErrmsg);
      WSACleanup();
      return ERR;
   }

   /* 
    * Cleanup activities for windows socket library
    */
   WSACleanup();
   
   /* 
    * If the response is positive, return SUCCESS else return ERR 
    */
   if(strcmp(szMessage,POSITIVE_RESPONSE) == 0)
      return SUCCESS;
   else
      return ERR;
}
  

/***********************************************************************
*  Function name  logitwithlocaltime
*  This function writes in to the Log file with local time
*  Baskar/Veera - Nov 21 2003
***********************************************************************/

int logitwithlocaltime (int log_type, char *msg) {
   char name[80];
   char job_info[100];
   char message[500];
   short int fh;
   char short_name[15];
   char datetime[20];
   char novell_info[100];
   SYSTIME st;

   char month[3];
   char day[3];
   char year[5];
   char decade[3];
   char hour[3];
   char minute[3];
   char second[3];

   char jobq_no[11];
   char jobq_name[10];
   char stepq_step[5];
   char stepq_name[10];
   char stepq_group_name[10];

   char jsname[10];
   char uname[20];
   char netid[20];
   char netpa[20];
   char netsid[20];
   //int  tmp_year;
   
	  /*  Format some basic information */
	   getsystime(&st);

		_itoa(st.wMonth, month, 10);
		if(st.wMonth < 10)
			_padl(month, '0', 2);
	
		_itoa(st.wDay, day, 10);
		if(st.wDay < 10)
			_padl(day, '0', 2);
 
//	tmp_year = st.wYear%100;
		_itoa(st.wYear, year, 10);

		_itoa(st.wHour, hour, 10);
		if(st.wHour < 10)
			_padl(hour, '0', 2);

		_itoa(st.wMinute, minute, 10);
		if(st.wMinute < 10)
			_padl(minute, '0', 2);

		_itoa(st.wSecond, second, 10);
		if(st.wSecond < 10)
			_padl(second, '0', 2);
 
  

   move(decade, 2, year+2, 1);
   copy_cat(datetime, month, "/", day, "/", decade, " ", hour, ":", minute, ":", second, NULL);

   _ltoa(job_q.no, jobq_no, 10);
   _padl(jobq_no, '0', 10);

   strcpy(jobq_name, (char*)job_q.name);
   _padl (jobq_name, ' ', 9);

   _itoa(step_q.step, stepq_step, 10);
   _padl(stepq_step, '0', 4);
   
   strcpy(stepq_name, (char*)step_q.s_name);
   _padl (stepq_name, ' ', 9);
   strcpy(stepq_group_name, step_q.group_name);
   _padl (stepq_group_name, ' ', 9);
   copy_cat(job_info, jobq_no, " ", jobq_name, " ", stepq_step, " ", stepq_name, " ", stepq_group_name, NULL);

   strcpy(jsname, szjsname);
   _padl(jsname, ' ', 8);
   strcpy(uname, user_name);
   _padl(uname, ' ', 10);
   strcpy(netid, network_id_s);
   _padl(netid, ' ', 4);
   strcpy(netpa, network_physical_address);
   _padl(netpa, ' ', 8);
   strcpy(netsid, network_station_id);
   _padl(netsid, ' ', 3);
   copy_cat(novell_info, jsname, " ", uname, " ", netid, ":", netpa, ":", netsid, NULL);

   copy_cat(short_name, year, month, day, ".LOG", NULL);

   if (! strlen(szlogpath)) 
	   strcpy  (name, short_name);
   else 
	   copy_cat(name, szlogpath, short_name, NULL);


/* Attempt to open the file, fh will be ERR if it fails.  On fail display msg */
   fh = _sopen (name, _O_BINARY | _O_RDWR, _SH_DENYNO);

    if (fh == ERR) {                  /* File not present - try to create it */
      fh = _sopen(name, _O_BINARY | _O_RDWR | _O_CREAT, _SH_DENYNO, _S_IWRITE);
      if (fh != ERR) 
	  {
		 copy_cat(message, datetime, "                                               ", novell_info, " File Created\r\n", NULL);
         _write(fh, message, strlen(message));
      }
	  else
	  {
		/* Write the log to the local machine */
		// ssv 03/25/04
		copy_cat(name, szlocallogpath, short_name, NULL);
		fh = _sopen(name, _O_BINARY | _O_RDWR | _O_CREAT, _SH_DENYNO, _S_IWRITE);
		if (fh != ERR) 
		{
			copy_cat(message, datetime, "                                               ", novell_info, " File Created\r\n", NULL);
			_write(fh, message, strlen(message));
		}

	  }
    }

/* Open attempt failed - show something to screen, & don't do any more I/O calls below */
   if (fh==ERR) 
   {
	   copy_cat(message, "Error opening log file: ", name, NULL);
	   qtext(10, 10, message);
   }

/* On successful open, try to lock the file's first byte */
   else {
      if (_locking (fh, _LK_LOCK, 1L) != SUCCESS) 
	  {
         _close (fh);         /* Lock failed, so close the file handle */
         fh = ERR;           /* Simulate an errored file handle */
		 qtext(10, 10, "Error locking log file!");
      }
   }


   switch (log_type) {
      case 0:     /* General Message */
		  copy_cat(message, datetime, "                                               ", novell_info, " ",
				msg, "\r\n", NULL);
		  break;
      case 1:     /* Job Message */
		  copy_cat(message, datetime, " ", jobq_no, " ", jobq_name, 
					"                          ", novell_info, " ", msg, "\r\n", NULL);
		  break;

      case 2:     /* Step Message */
		  copy_cat(message, datetime, " ", jobq_no, " ", jobq_name, " ", stepq_step, " ", 
					stepq_name, " ", stepq_group_name, " ", novell_info, " ", msg, "\r\n", NULL);
		  break;
   }


/*  When the file handle is valid, write the message to the log file, unlock, & close */
   if (fh == ERR) 
	   qtext(10, 10, message);
   else {
      _lseek (fh, 0L, SEEK_END);
      _write (fh, message, strlen(message));
      _lseek (fh, 0L, SEEK_SET);
      _locking (fh, _LK_UNLCK, 1L);
      _close (fh);
   }
   return SUCCESS;
}

/***********************************************************************
*  Function name  load_achps_const_recs
*  This function loads records from achps_const with rec_id = 'ALERT'
*  for alert mechanism and those with rec_id = 'EMAIL' to retrieve email
*  configuration
*  Sujatha/Veera - Sep 2 2005
***********************************************************************/
void load_achps_const_recs(void)
{
	
	EXEC SQL BEGIN DECLARE SECTION;
	achps_const_sql	l_achps_const_rec;
	achps_const_ind i_achps_const_rec;
	EXEC SQL END DECLARE SECTION;

	achps_const_sql *ptrAchpsConstRec;

	/*Get Count of records from ACHPS_CONST which are set up for ALERT*/
	EXEC SQL SELECT count(*) INTO :totRec FROM achps_const WHERE rec_id = 'ALERT';
	if(sqlca.sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
		"Select query failed ", "ACHPS_CONST",	NULL);
	}
	

	g_achps_const_recs = (achps_const_sql *)calloc(totRec,sizeof(achps_const_sql));	
	ptrAchpsConstRec  = g_achps_const_recs;
	

	EXEC SQL DECLARE achps_const_cur CURSOR FOR
			 SELECT trim(parameter_name), trim(parameter_value), trim(remarks)
			 FROM achps_const WHERE rec_id = 'ALERT';

	EXEC SQL OPEN achps_const_cur;
	if(sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
	{
			ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"achps_const_cur", " ACHPS_CONST table", NULL);
	}
	
	EXEC SQL FETCH achps_const_cur INTO :l_achps_const_rec :i_achps_const_rec;
	if(sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
	{
			ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"achps_const_cur", " ACHPS_CONST table", NULL);
	}

	int i = sqlca.sqlcode;	

	while(sqlca.sqlcode == ORCL_NO_ERROR) 
	{
		memcpy(ptrAchpsConstRec,&l_achps_const_rec,sizeof(achps_const_sql));
		ptrAchpsConstRec++;
		EXEC SQL FETCH achps_const_cur INTO :l_achps_const_rec :i_achps_const_rec;
		if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
		{
			ifs_custerr("ORC_FETCH", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"achps_const_cur", " ACHPS_CONST table", NULL);
			break;
		}
      
	}

	EXEC SQL CLOSE achps_const_cur;
	if(sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
	{
			ifs_custerr("ORC_CLOSECRS", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"achps_const_cur", " ACHPS_CONST table", NULL);
	}


}


/***********************************************************************
*  Function name  lookUpAchpsConst
*  This function looks up records from achps_const with rec_id = 'ALERT'
*  for alert mechanism and retrieve the correct record and the max minutes
*  for the process.  
*  Sujatha/Veera - Sep 2 2005
***********************************************************************/
int lookUpAchpsConst(achps_const_def *ptrAchpsConst,char *commandLine)
{
	int n,i,j;
	int cnt=0;
	achps_const_sql* ptrTemp;
	ptrTemp = g_achps_const_recs;
    char processName[13];
	achps_const_def locAchpsConstRec;
	string locCmdLine;
	bool recFound = false;

    
	locCmdLine = commandLine;
	memset(processName,0,sizeof(processName));
	n = locCmdLine.find(" ",0);
	if(n != string::npos)
		strcpy(processName,(locCmdLine.substr(0,n)).c_str());
    
	

	while(cnt < totRec)
	{
		// Get the achps_const record for the current process name by comparing with 
		// the parameter_anme in achps_const record
		if( stricmp(trimlr(ptrTemp->parameter_name),trimlr(processName))==0) 
		{

			//If no commandline option passed
			if( stricmp(trimlr(ptrTemp->remarks),"/NONE")==0 ) 
			{
				//Get process name from parameter_name, max time in minutes from
				// parameter_value, command line options from remarks1 column

				// remark column contains command_line text
				strcpy(locAchpsConstRec.parameter_name,ptrTemp->parameter_name);
				strcpy(locAchpsConstRec.parameter_value,ptrTemp->parameter_value);
				strcpy(locAchpsConstRec.remarks,ptrTemp->remarks);
				recFound = true;
			}
			else 
			{
				/*for every word in remarks
					find word in command_line 
				if not found return record with /none option*/

				string s = commandLine; //command line from stepq
				string r = ptrTemp->remarks; 
				string tmp;

				n = 0; i=0;
				
				while(1)
				{
					n = r.find(" ",n+1);
					if (n == string::npos )
					{
						tmp = r.substr(i,n - i);
						j = s.find(tmp, 0); 
						if (j == string::npos)
							break;
						else
						{
							//copy and return
							strcpy(ptrAchpsConst->parameter_name,ptrTemp->parameter_name);
							strcpy(ptrAchpsConst->parameter_value,ptrTemp->parameter_value);
							strcpy(ptrAchpsConst->remarks,ptrTemp->remarks);
							return 1;
						}
					}

					while(r[n+1]==' ')
						n++;
					
					tmp = r.substr(i,n - i);
					j = s.find(tmp, 0); 
					if (j == string::npos)
						break;
					i=n+1;					
				} //end while(1)
			}
		}
		ptrTemp++;
		cnt++;
	}

	if(recFound)
	{
		strcpy(ptrAchpsConst->parameter_name,locAchpsConstRec.parameter_name);
		strcpy(ptrAchpsConst->parameter_value,locAchpsConstRec.parameter_value);
		strcpy(ptrAchpsConst->remarks,locAchpsConstRec.remarks);
		return 1;
	}

	return 0;
}

/***********************************************************************
*  Function name  sendMail
*  This function executes the stored procedure sendMail to send an 
*  email when a process takes more time than normal.
*  Sujatha/Veera - Sep 2 2005
***********************************************************************/
void sendMail(char *msg)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char mesg[458];  // is this enuf or should be equal to msg.msg  size?
	int err_id;
	char err_msg[100];
	char lSender[40];
	char lRecipient[40];
	EXEC SQL END DECLARE SECTION;

	char sqlmsg[80];
	strcpy(mesg,msg);

    memset (lSender, 0x00, sizeof(lSender));
	memset (lRecipient, 0x00, sizeof(lRecipient));

	EXEC SQL SELECT  parameter_value, remarks 
	INTO    :lSender, :lRecipient
	FROM   achps_const
	WHERE  rec_id = 'EMAIL' and rownum = 1;

	if (sqlca.sqlcode != ORCL_NO_ERROR) 
	{
      strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
      ifs_custerr("ORC_SELECT", __FILE__, __LINE__, IFS_LOG, 
         "ACHPS_CONST", sqlmsg, "Selecting sender and receiver mail id from achps_const table , ACHPS_CONST", 
            NULL);
     }

   trimlr(lSender);
   trimlr(lRecipient);
	// Execute procedure sendmail with the paramters errid, errmsg and message
	/*** EXEC SQL EXECUTE 
		BEGIN sendmail(:err_id,:err_msg,:mesg);
		END;
	END-EXEC; Naresh to change to sendwebmail***/

       EXEC SQL EXECUTE 
		BEGIN SENDMAILWEB(:err_id,:err_msg,:mesg,'',:lSender,:lRecipient,'ACHPS Job ALert');
		END;
	END-EXEC; 

	if(sqlca.sqlcode != ORCL_NO_ERROR) 
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		ifs_custerr("ORC_EXECUTE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"SENDMAIL", sqlmsg, " ", NULL);
	}
	if(err_id != 0)
	{
		strcpy(sqlmsg,err_msg);
		ifs_custerr("ORC_EXECUTE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"SENDMAIL", sqlmsg, " ", NULL);
	}

		
}
                                                                                                                                                                                                                                                                                                document/set1/JSNTSecureDbAccess.cpp_3.pdf                                                          0000644     %g4001001 00000025536 14011436757 016677  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               //JSNTSecureDbAccess.cpp
//preprocessor directives
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

#include "JSNTSecureDbAccess.h"

//-----------------------------------------------------------------------------

//function definition
JSNTSecureDbAccess::JSNTSecureDbAccess(void)//constructor
{//   

}//

//-----------------------------------------------------------------------------
JSNTSecureDbAccess::JSNTSecureDbAccess(const char* pszFileName)//constructor override
{//
   m_FileName = pszFileName;

}//

//-----------------------------------------------------------------------------

JSNTSecureDbAccess::~JSNTSecureDbAccess()//destructor
{//
   
}//

//-----------------------------------------------------------------------------
void JSNTSecureDbAccess::SetFileName(const char* pszFileName)
{//
   m_FileName = pszFileName;   

}//
//-----------------------------------------------------------------------------
void JSNTSecureDbAccess::ReadParseFile(void)
{//
   //read and parse ini file 
   FILE*       fp          = NULL;//file pointer
   const int   BLOCKSIZE   = 200;//max block size 
   const int   RECORD_LENGTH = 196;//the length of the 
   const int   SUB_STR     = 194;
   char        szLineBuffer[BLOCKSIZE];//line buffer

   string      stBuffer;//string created for std::substr m_function
   int         nCount = 0;//counter to ensure that all the records are read
   
   //open file in read only text mode   
   //a null pointer value indicates an error. 
   fp = fopen(m_FileName.c_str(), "r + t");

   if (fp != NULL)
   {//   
      //read each record of the file
      while (fgets(szLineBuffer, BLOCKSIZE, fp) != NULL)//fetch one line at a time
      {//if
         stBuffer = szLineBuffer;//make char array into a std::string for substr m_function
         int nLength = stBuffer.size();//length of string
         //determine if record meets encryption criteria ie..logon, password, server
         switch (stBuffer[0])
         {//switch
            case ('A'):
               //found logon record/string
               if (stBuffer[1] == '=' && nLength == RECORD_LENGTH)//must be 196 bytes long or error off
               {//if
                  m_stLine3Logon = stBuffer.substr(2, SUB_STR).c_str();
                  nCount++;
                  break;
               }//if
            case ('B'):            
               //found password record/string
               if (stBuffer[1] == '=' && nLength == RECORD_LENGTH)//must be 196 bytes long or error off
               {//if
                  m_stLine4Password = stBuffer.substr(2, SUB_STR).c_str();
                  nCount++;
                  break;
               }//if
            case ('C'):
               //found server record/string
               if (stBuffer[1] == '=' && nLength == RECORD_LENGTH)//must be 196 bytes long or error off
               {//if
                  m_stLine5Server = stBuffer.substr(2, SUB_STR).c_str();
                  nCount++;
                  break;
               }//if
         
         }//switch
      }//while
      fclose(fp);
   }//if
   
   //final check to see if all three records where found
   if (nCount != 3)//found all the required records...logon, password, server
   {//if
      //error in finding all required records
      m_stDb_Connenct[0] = '\0';//set connect string to zero
      
   }//if
   return;

}//
//-----------------------------------------------------------------------------
const char* JSNTSecureDbAccess::BuildDbConnectString(void) 
{//
   try
   {//try 
      //perform read/parse encrypted file
      ReadParseFile();
      //decrypt logon string
      m_stLogon      = DecryptString(m_stLine3Logon.c_str());
      //decrypt password string
      m_stPassword   = DecryptString(m_stLine4Password.c_str());
      //decrypt server sting
      m_stServer     = DecryptString(m_stLine5Server.c_str());
      //concatinate logon/password@server
      BuildCatString(); 
   }//try
   catch (...)
   {//catch
      //throw "Unexpected Error";      
      throw 1;
      
   }//catch
   //return connection string
   return m_stDb_Connenct.c_str();
}//

//-----------------------------------------------------------------------------

const char* JSNTSecureDbAccess::GetPasswordString(void)
{//
   return m_stPassword.c_str();

}//
//-----------------------------------------------------------------------------

const char* JSNTSecureDbAccess::GetLogonString(void)
{//
   return m_stLogon.c_str();

}//
//-----------------------------------------------------------------------------

const char* JSNTSecureDbAccess::GetServerString(void)
{//
   return m_stServer.c_str();

}//
//-----------------------------------------------------------------------------

const char* JSNTSecureDbAccess::GetConnectString(void)//return m_st_Db_Connect
{//
   //currently not being used
   return m_stDb_Connenct.c_str();
}//
//-----------------------------------------------------------------------------

void JSNTSecureDbAccess::BuildCatString(void)//concatinate logon/password@server
{//
   //build one string logon/password@server
   m_stDb_Connenct = m_stLogon + "/" + m_stPassword + "@" + m_stServer;
   
}//
//-----------------------------------------------------------------------------

char* JSNTSecureDbAccess::DecryptString(const char* stEncripted)
{//
   long      lPos       = 0;
   long      lSeqwrap   = 0;
   long      lDc        = 0;
   long      lStart     = 0;

   static string   stChar;
   static string   stDecryptedText;
   static string   stExtendedText;
   
   const string   stSequence = "Deluxe Electronic Payment Systems - ACH O/S";
   stDecryptedText = "";
   stExtendedText = "";

   //begin decrypting string check first character
   stChar = stEncripted[0];//first character   
   switch (stChar[0])
   {//switch
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
         //convert the character to a long
         lStart = atol(stChar.c_str());         
         break;
      case 'a':
         lStart = 10;
         break;
      case 'b':
         lStart = 11;
         break;
      case 'c':
         lStart = 12;
         break;
      case 'd':
         lStart = 13;
         break;
      case 'e':
         lStart = 14;
         break;
      case 'f':
         lStart = 15;   
         break;
   }//switch

   //remove 'f' from string starting at index 1
   for (lPos = 1; lPos <= strlen(stEncripted); lPos++)
   {//for
         stChar = stEncripted[lPos];
         if (stChar[0] != 'f')
         {//if
               stExtendedText = stExtendedText + stChar;
         }//if
   }//for
   //determine length of the deluxe sequence string used as primer in decyption
   lSeqwrap = stSequence.length();
   //now that the 'f' has been removed perform decryption on each character
   for (lPos = 0; (lPos < (stExtendedText.length() /  3 - 1)); lPos++)        
   {//for 
      //substring 3 characters
      string stTest = stExtendedText.substr((lPos * 3),  3);
      //converts 3 character string into a long
      lDc = convert_to_number(stTest.c_str());
      //add 256 to number
      lDc = (lDc + 256);
      //modular
      string stSeq2 = stSequence.substr(((lPos + lStart) % lSeqwrap), 1);     
      lDc = lDc - stSeq2[0];      
      lDc = lDc % 256;

      //convert long to string
      stChar = lDc;
      if (stChar[0] == '\\')
      {//if
         break;
      }//if
      //decrypted character to decrypted string
      stDecryptedText = stDecryptedText + stChar;
   
   }//for 
   return (char*)stDecryptedText.c_str();

}//
//-----------------------------------------------------------------------------

int JSNTSecureDbAccess::convert_to_number(const char* strStr)
{//conver_to_number
   int      nHigh = 0;
   int      nMid  = 0;
   int      nLow  = 0;
   //convert each character to a specific number
   switch (strStr[0])//first character
   {//switch
      case '0':
         nHigh = 0;
         break;
      case '1':
         nHigh = 225;
         break;
      case '2':
         nHigh = 450;
         break;
      case '3':
         nHigh = 675;
         break;
      case '4':
         nHigh = 900;
         break;
      case '5':
         nHigh = 1125;
         break;
      case '6':
         nHigh = 1350;
         break;
      case '7':
         nHigh = 1575;
         break;
      case '8':
         nHigh = 1800;
         break;
      case '9':
         nHigh = 2025;
         break;
      case 'a':
         nHigh = 2250;
         break;
      case 'b':
         nHigh = 2475;
         break;
      case 'c':
         nHigh = 2700;
         break;
      case 'd':
         nHigh = 2925;
         break;
      case 'e':
         nHigh = 3150;
         break;

   }//switch

   switch (strStr[1])//second character
   {//
  
      case '0':
         nMid = 0;
         break;
      case '1':
         nMid = 15;
         break;
      case '2':
         nMid = 30;
         break;
      case '3':
         nMid = 45;
         break;
      case '4':
         nMid = 60;
         break;
      case '5':
         nMid = 75;
         break;
      case '6':
         nMid = 90;
         break;
      case '7':
         nMid = 105;
         break;
      case '8':
         nMid = 120;
         break;
      case '9':
         nMid = 135;
         break;
      case 'a':
         nMid = 150;
         break;
      case 'b':
         nMid = 165;
         break;
      case 'c':
         nMid = 180;
         break;
      case 'd':
         nMid = 195;
         break;
      case 'e':
         nMid = 210;
         break;
   }//switch

   switch (strStr[2])//third character
   {//switch
      case '0':
         nLow = 0;
         break;
      case '1':
         nLow = 1;
         break;
      case '2':
         nLow = 2;
         break;
      case '3':
         nLow = 3;
         break;
      case '4':
         nLow = 4;
         break;
      case '5':
         nLow = 5;
         break;
      case '6':
         nLow = 6;
         break;
      case '7':
         nLow = 7;
         break;
      case '8':
         nLow = 8;
         break;
      case '9':
         nLow = 9;
         break;
      case 'a':
         nLow = 10;
         break;
      case 'b':
         nLow = 11;
         break;
      case 'c':
         nLow = 12;
         break;
      case 'd':
         nLow = 13;
         break;
      case 'e':
         nLow = 14;
         break;      
   }//switch   
   //add the number together and return it
   return nLow + nMid + nHigh;

}//conver_to_number
//-----------------------------------------------------------------------------
                                                                                                                                                                  document/set1/JSNTSecureDbAccess.h_1.pdf                                                            0000644     %g4001001 00000002737 14011436757 016340  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               //JSNTSecureDbAccess.h
//specification file

#ifndef _JSNTSECUREDBACCESS_H_
#define _JSNTSECUREDBACCESS_H_

#include <string>
using namespace std;

class JSNTSecureDbAccess
{//
public:   
   JSNTSecureDbAccess(void);//constructor
   JSNTSecureDbAccess(const char* pszFileName);//an override constructor
   ~JSNTSecureDbAccess();//destructor   

   const char* BuildDbConnectString(void); 
   const char* GetConnectString(void);//return m_st_Db_Connect;
   const char* GetPasswordString(void);
   const char* GetLogonString(void);
   const char* GetServerString(void);  
   void SetFileName(const char* pszFileName);

   
private:
   //private member variables
   string m_stDb_Connenct;//db connection string
   string m_FileName;//path and filename

   //encrypted strings
   string m_stLine3Logon;//encryped logon string
   string m_stLine4Password;//encryped password string
   string m_stLine5Server;//encryped server name string

   //decryped strings
   string m_stLogon; //decrypted logon string
   string m_stPassword;//decryped password string
   string m_stServer;//decryped server name string
   
   //private member functions
   void  ReadParseFile(void);//read and parse file
   char* DecryptString(const char* pszInput);//decrypt a string
   int   convert_to_number(const char* strStr);//convert a string to a number
   void  BuildCatString(void);//concatinate logon/password@server

protected:
};//

#endif//_JSNTSECUREDBACCESS_H_




                                 document/set1/JSNT_1.pdf                                                                            0000644     %g4001001 00000037674 14011436757 013363  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               /****************************************************************

js_SQL.H
Copyright (C) 1999 - 2000 eFunds Corporation. All Rights Reserved.

Header File for Database table definitions

****************************************************************/

#ifndef JSNT_SQL_H
#define JSNT_SQL_H


/* Oracle Errors -- Only Very Common Ones */
#define ORCL_NOT_FOUND		1403
#define ORCL_NO_ERROR		0
#define ORCL_DUPLICATE		-1

/* Database connection info */
#define DB_CONNECT_RETRIES	100
#define LOCK_TRIES 10
#define MAX_GROUPS_TO_RUN 10


	EXEC SQL BEGIN DECLARE SECTION;
		extern sql_context g_ctx;
	EXEC SQL END DECLARE SECTION;


	EXEC SQL BEGIN DECLARE SECTION;

	#define ROWS 100

/*************************************************************************
*  SQL JCS Job File		   
************************************************************************ */
typedef struct js_job_sql_record {
	char status[2];						/* A=Active, H=On Hold R=Ready S=Scheduled Y=Completed */
	long pos;                           /* Position in Queue */
	
	//Increased the length by one character to hold '\0' - Srini 26Aug2004
	//char name[9];						/* Job Name */
	char name[10];						/* Job Name */

	unsigned long no;					/* Unique Job Number */

	//Increased the length by one character to hold '\0' - Srini 26Aug2004
	//char station[9];					/* Station network adapter depdcy */
	  char station[10];					/* Station network adapter depdcy */ 

	/* Status Fields */
	char date_time_entered[15];         /* Time job submitted */
	char date_time_started[15];         /* Time job Started */
	char date_time_completed[15];       /* Time job Ended */
	short int exit_code;                /* 0 if successful, 99 if cancelled */
	char station_submitting[2];			/* Connection # of Station submitting job */
	char msg_when_started[2];			/* 0=Do not send message, 1=Send message */
	char msg_when_done[2];				/* SAME flags as above */
	char multi_processing[2];           /* 0=No Multiprocessing, 1=Multiprocess */
	
	/* Submission Fields */
	char date_time_to_start[15];        /* Date the job should start YYYYMMDDHHMISS */
	short int start_stat;               /* 0=Run 1=On Hold 2=Prompt operator 3=Both */
	char must_complete_by[5];           /* Error msg if not completed by */
	char c_msg_sent_yn[2];				/* Flag if error message sent */
	char must_start_by[5];              /* Error if not started by */
	char s_msg_sent_yn[2];				/* Flag if start error msg sent*/
	char msg_to_operator_yn[2];         /* Operator send to console */
	char msg_to[31];                    /* Who to send message to */
	//short int num_msg;                  /* How many message options */
	short int priority;                 /* Priority of Job */

    //Increased the length by one character to hold '\0' - Srini 26Aug2004
	//unsigned char stn_started[9];       /* Job machine that started job */
    unsigned char stn_started[10];       /* Job machine that started job */

	/* Job Dependencies */
	short int num_d;					/* Number of dependencies */
	char  d_job[180];                   /* Job Name of dependency */
	char  d_hrs_back[100];
	unsigned char d_cmplt[20];          /* If dependency already found done */
	char d_last_tested[200];            /* What time did a job server last test */
	short int orig_start_stat;          /* Save start stat for later use */
	char job_suspended[2];              /* If Job Temporarily Suspended */
	char restart[9];                    /* Step to Restart On */
	char job_class[2];                  /* Job Class */
	char base_dir[81];                  /* Base Directory where JOB should Start */
	short int max_job_time_warn;        /* Maximum time job will run */
	char debug_mode_yn[2];		        /* Job Debug mode */
	short int last_step;                /* Job Step number */

    //Increased the length by one character to hold '\0' - Srini 26Aug2004
	//char last_s_name[9];				/* Step Name */
	//char last_g_name[9];				/* Step Group */
  
    char last_s_name[10];				/* Step Name */
	char last_g_name[10];				/* Step Group */

	char submitted_file_name[13];       /* Name of Job Script file */
	char p_msg_sent_yn[2];		        /* Prompt Operator message sent */
	short int max_job_time_kill;
	char max_c_msg_yn[2];		        /* Has warning been sent? */
	char stn_dependancy_yn[2];			/* Was station dependency submitted or
											filled in because multiprocessing off*/
	char no_fail_message_yn[2];			/* Do Not send console message when
											its a failed job */
	char msg_when_failed[2];			/* 0=Do not send message, 1=Send message */
	short spawn_algorithm;				/* Resubmit job on successful execution */
	short spawn_parm;					/* Date logic parameter */
	char  d_station[180];
	
	// WR27164 - Hamsha
	char jsgroup[10];

} js_jobq_sql_def;


typedef struct js_job_sql_ind_record {
	short status;
	short pos;           
	short name;          
	short no;				
	short station;       
	short time_entered;            
	short time_started;             
	short time_completed;           
	short exit_code;            
	short station_submitting; 
	short msg_when_started;   
	short msg_when_done;      
	short multi_processing;   
	short date_time_to_start;      
	short start_stat;         
	short must_complete_by;         
	short c_msg_sent_yn;         
	short must_start_by;            
	short s_msg_sent_yn;         
	short msg_to_operator_yn;          
	short msg_to;                  
	short priority;               
	short stn_started;     
	short num_d;				
	short d_job;               
	short d_hrs_back;
	short d_cmplt;      
	short d_last_tested;        
	short orig_start_stat;      
	short job_suspended;             
	short restart;                
	short job_class;              
	short base_dir;              
	short max_job_time_warn;    
	short debug_mode_yn;    
	short last_step;            
	short last_s_name;   
	short last_g_name;   
	short submitted_file_name;   
	short p_msg_sent_yn;    
	short max_job_time_kill;
	short max_c_msg_yn;         
	short stn_dependancy_yn;    
	short no_fail_message_yn;   
	short msg_when_failed;      
	short spawn_algorithm;
	short spawn_parm;
	short d_station; //KLK
	
	// WR27164 - Hamsha
	short jsgroup;

} js_jobq_sql_ind_def;



/*************************************************************************
*  SQL JCS Step File 
*************************************************************************/
typedef struct js_step_sql_record {
	unsigned long no;					/* Unique Job Number */
	short int step;                     /* Job Step number */
	
  //char s_name[9];						/* Step Name */
  //Increased length by one character to hole '\0' - Srini 25Aug2004
	char s_name[10];						/* Step Name */
	
/* Status Fields */
	char status[2];						/* A=Active, N=Waiting, Y=Completed */
  //char j_name[9];						/* Job Name */
  //Increased length by one character to hole '\0' - Srini 25Aug2004
    char j_name[10];						/* Job Name */ 
	
	char date_time_started[15];         /* Time step Started */
	char date_time_completed[15];       /* Time step Ended */
	short int exit_code;                /* 0 if exited with acceptable code*/
	
/* Submission Fields */
	char command_line[140];             /* The command line to process */

/* Dependencies */
	short int num_d;                    /* Number of dependencies*/
	char d_step[180];                   /* Step name dependency */
	char d_cmplt[20];					/* If dependency already found done */
	char d_last_tested[200];            /* What time did a job server last test this */
	
/* Acceptable exit codes */
	short int num_a;                    /* number of acceptable codes */
	char exit_codes_acceptable[100];	/* These exit codes count as a 0 exit code */

	//char job_machine[9];				/* Job machine performing work */
    //Increased length by one character to hole '\0' - Srini 25Aug2004
	char job_machine[10];				/* Job machine performing work */
	
/* Group Information */
	//Increased length by one character to hole '\0' - Srini 25Aug2004
	//char d_group[20];					/* Set to 1 if Dependency is a Group Dependency */
	//char group_name[9];                 /* If step is a member of a group */
	char d_group[21];					/* Set to 1 if Dependency is a Group Dependency */
	char group_name[10];                 /* If step is a member of a group */
	char same_machine_flag_yn[2];		/* If user specified all steps in group
											should run on the same machine */
	char group_first_step_yn[2];		/* If this is the 1st step in the group */
	char skip_yn[2];					/* Skip Step because its a Restart */
	char beg_console_msg[81];           /* Console msg / console msg suspend */
	char beg_suspend_yn[2];			    /* Suspend step until reply? */
	char end_console_msg[81];           /* Console msg result / suspend */
	char end_suspend_yn[2];				/* Suspend step until reply? */
	char send_msg[81];                  /* From Send_msg command */
	char run_if_error[65];              /* program to run if there is an error - MW 4/12/99 */
	short status_interval;				/* How often to send status info */
} js_stepq_sql_def;

typedef struct js_step_sql_ind_record {
	short no;					
	short step;                 
	short s_name;            
	short status;               
	short j_name;            
	short time_started;         
	short time_completed;       
	short exit_code;            
	short command_line;    
	short num_d;                
	short d_step;          
	short d_cmplt;          
	short d_last_tested;   
	short num_a;                
	short exit_codes_acceptable;
	short job_machine;      
	short d_group;         
	short group_name;       
	short same_machine_flag_yn;
	short group_first_step_yn; 
	short skip_yn;             
	short beg_console_msg; 
	short beg_suspend_yn;      
	short end_console_msg; 
	short end_suspend_yn;    
	short send_msg;      
	short run_if_error;  
	short status_interval;
} js_stepq_sql_ind_def;



/*************************************************************************
*  SQL JCS Process Queue File
*************************************************************************/
typedef struct js_p_sql_record {
	unsigned char proc_name[10];      /* Name of Job Server */
	short int status;                /* 0=Idle 1=Busy */
	unsigned char net_node[14];      /* net Node id */
	unsigned long job_num;				/* Job number */
	char job_name[10];                /* Name of Job */
	short int step_num;              /* Step number */
	char step_name[10];               /* Step Name */
	char entry_date[15];				   /* Date/Time job entered into sys YYYYMMDDHHMISS */
	char start_date[15];				   /* Date/Time started YYYYMMDDHHMISS */
	char must_complete_by[6];        /* Time job must complete by */
	char multi_processing[2];        /* 0=No Multiprocessing, 1=Multiprocess */
	char group_name[10];              /* Group Step belongs to */
	char job_class[3];               /* Class of Job */
	unsigned char net_id[9];         /* Network ID */
	char job_paused[2];					/* Job Paused */
} js_pq_sql_def;	

typedef struct js_p_sql_ind_record {
	short proc_name;     
	short status;           
	short net_node;     
	short job_num;			
	short job_name;      
	short step_num;         
	short step_name;     
	short entry_date;			
	short start_date;			
	short must_complete_by;      
	short multi_processing;        
	short group_name;           
	short job_class;           
	short net_id;              
	short job_paused;             
} js_pq_sql_ind_def;	


/*************************************************************************
*  SQL JCS Message Queue File
*************************************************************************/
typedef struct js_m_sql_record {
	char message_time[15];              /* Time stamp of message entry YYYYMMDDHHMISS */
	unsigned char release_net_id[9];    /* Contains NetID of Job Server that created message */
	unsigned char release_net_node[14]; /* Contains node of Job Server that created message */
	unsigned char must_release[2];      /* 1=Operater must release, Job Server waits */
	unsigned char msg_class[3];         /* Class of Message        */
	unsigned char sender_js[10];
	unsigned char sender_job[10];
	unsigned char msg[458];             /* The message      */
} js_msgq_sql_def;

typedef struct js_m_sql_ind_record {
	short message_time;      
	short release_net_id;    
	short release_net_node; 
	short must_release;      
	short msg_class;         
	short sender_js;
	short sender_job;
	short msg;             
} js_msgq_sql_ind_def;


	/*************************************************************************
	*  SQL JCS Delivery Queue File
	*************************************************************************/
	typedef struct js_d_sql_record {
		char Delivery_ID[ROWS][7];				/* Unique ID for this record */
		char Bank_ID[ROWS][10];            		/* ABA for bank */
		char Src_File_Spec[ROWS][129];			/* Source filespec */
		char Src_Rename_Mask[ROWS][21];			/* Source rename spec */
		char Dest_Path[ROWS][129];				/* Destination path only */
		char Dest_Rename_Mask[ROWS][31];		/* Destination file spec */
		char Move_Flag[ROWS][2];				/* M=Move, C=Copy, N=Neither*/
		char Convert_Flag[ROWS][2];				/* A=ASCII, E=EBCIDIC, N=Neither */
		char Job_Path[ROWS][129];				/* Path & filename of job */
		char Ext_Dist_Flag_YN[ROWS][2];			/* Y=external delivery, N=not */
		char Ext_Command[ROWS][256];			/* External command line */
		char Ext_Error_File[ROWS][129];			/* External error return file */
		char Ext_Run_On_Error[ROWS][256];		/* Cmd to run on external error */
		char Ext_Timeout[ROWS][5];				/* External timeout (minutes) */
		char Ext_Login_ID[ROWS][31];			/* External login ID */
		char Ext_Password[ROWS][257];			/* External pwd for login *///I140558110 - DEPSFTP Changes for pwd Encryption- increased 15 to 257
		char Record_Type[ROWS][2];				/* To indicate a record bounds to inbound or outbound */
		char Station[ROWS][10];					/* To indicate a record bounds to inbound or outbound */

		// WR27164 - Hamsha
		char jsgroup[ROWS][10];

	} js_delivery_sql_def;


	typedef struct js_d_sql_ind_record {
		short Delivery_ID[ROWS];	
		short Bank_ID[ROWS];      
		short Src_File_Spec[ROWS];
		short Src_Rename_Mask[ROWS];
		short Dest_Path[ROWS];	
		short Dest_Rename_Mask[ROWS];
		short Move_Flag[ROWS];	
		short Convert_Flag[ROWS];	
		short Job_Path[ROWS];		
		short Ext_Dist_Flag_YN[ROWS];
		short Ext_Command[ROWS];	
		short Ext_Error_File[ROWS];
		short Ext_Run_On_Error[ROWS];
		short Ext_Timeout[ROWS];
		short Ext_Login_ID[ROWS];
		short Ext_Password[ROWS];
		short Record_Type[ROWS];
		short Station[ROWS];
		
		// WR27164 - Hamsha
		short jsgroup[ROWS];

	} js_delivery_sql_ind_def;




     typedef struct js_locked 
	{
		char SrcFile[255];           /* Unique ID for this record */
		char Delivery_Flag;          /* P=Postponed-File in Use, D=Deliverying */
	} js_locked_def;
	

	typedef struct js_holidays 
	{
		char holiday[ROWS][9];            
	} js_holiday_def;
	
	/* WR28164 - Ext FTP command - Sujatha/Veera*/
	typedef struct achps_const_tag	{
		char parameter_name[16];
		char parameter_value[41];
		char remarks[41];
	} achps_const_sql;

	typedef struct achps_const_ind_tag	{
		short parameter_name;
		short parameter_value;
		short remarks;
	} achps_const_ind;
	/* WR28164 - Ext FTP command - Sujatha/Veera*/



extern js_pq_sql_def p_q;
extern js_pq_sql_ind_def p_q_ind;

extern js_jobq_sql_def job_q;
extern js_jobq_sql_ind_def job_q_ind;

extern js_stepq_sql_def step_q;
extern js_stepq_sql_ind_def step_q_ind;

extern js_msgq_sql_def msg_q;

extern js_locked_def locked;

extern js_holiday_def holiday_rec;


extern js_stepq_sql_def stepq_sql;
extern js_stepq_sql_ind_def stepq_sql_ind;

extern js_jobq_sql_def jobq_sql;
extern js_jobq_sql_ind_def jobq_sql_ind;

extern js_delivery_sql_def		delivery_recs;
extern js_delivery_sql_ind_def	delivery_recs_inds;


//	extern CRITICAL_SECTION sql_lock;

	EXEC SQL END DECLARE SECTION;
#endif


                                                                    document/set1/NET.CPP_3.pdf                                                                         0000644     %g4001001 00000011625 14011436757 013642  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               /***************************************************************

JSNT
Copyright (C) 1998 Deluxe Electronic Payment Systems

Windows Sockets & Network Module

***************************************************************/
/* Include the regular jsnt header */
#include	"jsnt.h"


//KLK REPLACE WITH TCPIP
/*********************** load_net_id ***************************
*                                                              *
* Description: This function calls other functions to get the  *
*  Novell login user name, connection number, network and node *
*  address.                                                    *
*                                                              *
* Creation Date: 07/24/96        By: Mike West                 *
* Modified Date: 12/17/96        By: Andrew Bartels            *
*                                                              *
***************************************************************/
//int load_net_id(char *node, char *net) {
//
//    ipx_inet_addr card_addr;
//    char *cp;

/*  Get the network card number, return ASCII components */
//    if (get_primary_card_addr (&card_addr, 1) != SUCCESS) 
//		return ERR;
//    net_to_ascii  (card_addr.network, net);
//    node_to_ascii (card_addr.node, node);

//    cp = getenv("COMPUTERNAME");
//    if (cp) 
//		strcpy (server_name, cp);
//    else 
//		strcpy (server_name, "N/A");

//    uppercase (server_name);
//	return(SUCCESS);
//}
//KLK END REPLACE WITH TCPIP



/************************ get_user_name ************************
*                                                              *
* Description: This function returns the Windows/NT user name. *
*   This is the name used to log into the local workstation.   *
*   Other login names may be used for mapping drives, etc. Use *
*   WNetGetName() for those.                                   *
*                                                              *
*   The returned username is always uppercase.                 *
*                                                              *
*   Returns SUCCESS if successful, or ERR if there was a       *
*   problem getting the user name.                             *
*                                                              *
*   This function is only for Win/NT - We need to add DOS &    *
*   Novell support some time.                                  *
*                                                              *
* Creation Date: 12/18/96        By: Andrew Bartels            *
*                                                              *
***************************************************************/
int get_user_name (char *user_name) {
    char *cp;

    *user_name = 0;
    cp = getenv ("USERNAME");
    if (cp) {
        strcpy (user_name, cp);
        uppercase (user_name);
        return SUCCESS;
    }
    return ERR;
}


/****************** format_novell_info *************************
*                                                              *
* Description: Formats novell information so that it can be    *
*  displayed.                                                  *
*                                                              *
* Creation Date: 06/24/96        By: Mike West                 *
*                                                              *
***************************************************************/
int format_novell_info () 
{
	short int ret=0;
	char tempstr[80];
	static first_time = 1;

	char sname[20];
	char netid[20];
	char netfad[20];
	
	strcpy (network_station_id, "N/A");

/*  Determine who we are logged in as */
    ret = get_user_name (user_name);
    if (ret!=SUCCESS) strcpy(user_name, "No Network Available");

/*  Determine network leg and node address */
	//ret = load_net_id (network_full_address, network_id_s);
	//memcpy (network_physical_address, network_full_address+4, 8);
   strcpy(network_physical_address, "UNKNOWN     ");


/*  Determine the name of the NT machine */
	if(strlen(server_name) == 0) strcpy(server_name, "LOCAL NT");
	server_name[11] = 0;								/* Up to 11 chars for FS name */

	strcpy(sname, server_name);
	_padl(sname, ' ', 11);
	strcpy(netid, network_id_s);
	_padl(netid, ' ', 8);
	strcpy(netfad, network_full_address);
	_padl(netfad, ' ', 12);
	copy_cat(szdispline3, " MACHINE:", sname, " ", netid, ":", netfad, " ", NULL);
	//sprintf (szdispline3, " MACHINE:%-11.11s %-8.8s:%-12.12s ",
	//	server_name, network_id_s, network_full_address);

/*  Display the Console Title now */
	if (first_time) 
	{
		copy_cat(tempstr, "[", szjsname, "] - IDLE                              ", prog_version, NULL);
		//sprintf (tempstr, "[%s] - IDLE                              %s", szjsname, prog_version);
		SetConsoleTitle (tempstr);                  /* set the console title       */
		first_time = 0;
	}

	return SUCCESS;
}

                                                                                                           document/set1/QUEUES.cpp_3.pdf                                                                      0000644     %g4001001 00001015106 14011436761 014355  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               
/* Result Sets Interface */
#ifndef SQL_CRSR
#  define SQL_CRSR
  struct sql_cursor
  {
    unsigned int curocn;
    void *ptr1;
    void *ptr2;
    unsigned int magic;
  };
  typedef struct sql_cursor sql_cursor;
  typedef struct sql_cursor SQL_CURSOR;
#endif /* SQL_CRSR */

/* Thread Safety */
typedef void * sql_context;
typedef void * SQL_CONTEXT;

/* Object support */
struct sqltvn
{
  unsigned char *tvnvsn; 
  unsigned short tvnvsnl; 
  unsigned char *tvnnm;
  unsigned short tvnnml; 
  unsigned char *tvnsnm;
  unsigned short tvnsnml;
};
typedef struct sqltvn sqltvn;

struct sqladts
{
  unsigned int adtvsn; 
  unsigned short adtmode; 
  unsigned short adtnum;  
  sqltvn adttvn[1];       
};
typedef struct sqladts sqladts;

static struct sqladts sqladt = {
  1,0,0,
};

/* Binding to PL/SQL Records */
struct sqltdss
{
  unsigned int tdsvsn; 
  unsigned short tdsnum; 
  unsigned char *tdsval[1]; 
};
typedef struct sqltdss sqltdss;
static struct sqltdss sqltds =
{
  1,
  0,
};

/* File name & Package Name */
struct sqlcxp
{
  unsigned short fillen;
           char  filnam[12];
};
static const struct sqlcxp sqlfpn =
{
    11,
    ".\\QUEUES.pc"
};


static unsigned int sqlctx = 135139;


static struct sqlexd {
   unsigned int   sqlvsn;
   unsigned int   arrsiz;
   unsigned int   iters;
   unsigned int   offset;
   unsigned short selerr;
   unsigned short sqlety;
   unsigned int   occurs;
      const short *cud;
   unsigned char  *sqlest;
      const char  *stmt;
   sqladts *sqladtp;
   sqltdss *sqltdsp;
            void  **sqphsv;
   unsigned int   *sqphsl;
            int   *sqphss;
            void  **sqpind;
            int   *sqpins;
   unsigned int   *sqparm;
   unsigned int   **sqparc;
   unsigned short  *sqpadto;
   unsigned short  *sqptdso;
   unsigned int   sqlcmax;
   unsigned int   sqlcmin;
   unsigned int   sqlcincr;
   unsigned int   sqlctimeout;
   unsigned int   sqlcnowait;
              int   sqfoff;
   unsigned int   sqcmod;
   unsigned int   sqfmod;
   unsigned int   sqlpfmem;
            void  *sqhstv[51];
   unsigned int   sqhstl[51];
            int   sqhsts[51];
            void  *sqindv[51];
            int   sqinds[51];
   unsigned int   sqharm[51];
   unsigned int   *sqharc[51];
   unsigned short  sqadto[51];
   unsigned short  sqtdso[51];
} sqlstm = {13,51};

// Prototypes
extern "C" {
  void sqlcxt (void **, unsigned int *,
               struct sqlexd *, const struct sqlcxp *);
  void sqlcx2t(void **, unsigned int *,
               struct sqlexd *, const struct sqlcxp *);
  void sqlbuft(void **, char *);
  void sqlgs2t(void **, char *);
  void sqlorat(void **, unsigned int *, void *);
}

// Forms Interface
static const int IAPSUCC = 0;
static const int IAPFAIL = 1403;
static const int IAPFTL  = 535;
extern "C" { void sqliem(unsigned char *, signed int *); }

 static const char *sq0009 = 
"select status ,pos ,name ,no ,station ,date_time_entered ,date_time_started \
,date_time_completed ,exit_code ,station_submitting ,msg_when_started ,msg_whe\
n_done ,multi_processing ,date_time_to_start ,start_stat ,must_complete_by ,c_\
msg_sent_yn ,must_start_by ,s_msg_sent_yn ,msg_to_operator_yn ,msg_to ,priorit\
y ,stn_started ,num_d ,d_job ,d_hrs_back ,d_cmplt ,d_last_tested ,orig_start_s\
tat ,job_suspended ,restart ,job_class ,base_dir ,max_job_time_warn ,debug_mod\
e_yn ,last_step ,last_s_name ,last_g_name ,submitted_file_name ,p_msg_sent_yn \
,max_job_time_kill ,max_c_msg_yn ,stn_dependancy_yn ,no_fail_message_yn ,msg_w\
hen_failed ,spawn_algorithm ,spawn_parm ,d_station ,jsgroup  from JOBQ where (\
(status='A' and (((station is null  and jsgroup is null ) or trim(station)=:b0\
) or trim(jsgroup)=:b1)) and pos>=0)           ";

 static const char *sq0010 = 
"select no ,step ,s_name ,status ,j_name ,date_time_started ,date_time_comple\
ted ,exit_code ,command_line ,num_d ,d_step ,d_cmplt ,d_last_tested ,num_a ,ex\
it_codes_acceptable ,job_machine ,d_group ,group_name ,same_machine_flag_yn ,g\
roup_first_step_yn ,skip_yn ,beg_console_msg ,beg_suspend_yn ,end_console_msg \
,end_suspend_yn ,send_msg ,run_if_error ,status_interval  from STEPQ where ((n\
o=:b0 and step>=0) and status<>'Y') order by step            ";

 static const char *sq0018 = 
"select rowid  from JOBQ where ((status='R' and (((station is null  and jsgro\
up is null ) or trim(station)=:b0) or trim(jsgroup)=:b1)) and pos>=0) order by\
 no            ";

typedef struct { unsigned short len; unsigned char arr[1]; } VARCHAR;
typedef struct { unsigned short len; unsigned char arr[1]; } varchar;

/* cud (compilation unit data) array */
static const short sqlcud0[] =
{13,4130,178,0,0,
5,0,0,1,77,0,516,273,0,0,2,1,0,1,0,2,97,0,0,1,97,0,0,
28,0,0,2,1373,0,516,305,0,0,51,2,0,1,0,2,97,0,0,2,3,0,0,2,97,0,0,2,68,0,0,2,97,
0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,
97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,
97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,
97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,
3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,3,0,0,2,97,0,0,2,97,0,0,1,
97,0,0,1,97,0,0,
247,0,0,3,138,0,516,477,0,0,4,1,0,1,0,2,97,0,0,2,3,0,0,2,97,0,0,1,97,0,0,
278,0,0,4,109,0,517,513,0,0,3,3,0,1,0,1,97,0,0,1,3,0,0,1,97,0,0,
305,0,0,5,0,0,543,524,0,0,0,0,0,1,0,
320,0,0,6,0,0,541,539,0,0,0,0,0,1,0,
335,0,0,7,0,0,543,545,0,0,0,0,0,1,0,
350,0,0,8,77,0,516,631,0,0,2,1,0,1,0,2,97,0,0,1,97,0,0,
373,0,0,9,825,0,521,771,0,0,2,2,0,1,0,1,97,0,0,1,97,0,0,
396,0,0,9,0,0,525,797,0,0,49,0,0,1,0,2,97,0,0,2,3,0,0,2,97,0,0,2,68,0,0,2,97,0,
0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,
0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,
0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,
0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,
0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,3,0,0,2,97,0,0,2,97,0,0,
607,0,0,9,0,0,527,808,0,0,0,0,0,1,0,
622,0,0,9,0,0,527,829,0,0,0,0,0,1,0,
637,0,0,10,449,0,521,843,0,0,1,1,0,1,0,1,68,0,0,
656,0,0,9,0,0,525,877,0,0,49,0,0,1,0,2,97,0,0,2,3,0,0,2,97,0,0,2,68,0,0,2,97,0,
0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,
0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,
0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,
0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,
0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,3,0,0,2,97,0,0,2,97,0,0,
867,0,0,10,0,0,527,889,0,0,0,0,0,1,0,
882,0,0,9,0,0,527,890,0,0,0,0,0,1,0,
897,0,0,10,0,0,527,910,0,0,0,0,0,1,0,
912,0,0,9,0,0,527,911,0,0,0,0,0,1,0,
927,0,0,10,449,0,521,926,0,0,1,1,0,1,0,1,68,0,0,
946,0,0,9,0,0,527,947,0,0,0,0,0,1,0,
961,0,0,10,0,0,525,1032,0,0,28,0,0,1,0,2,68,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,
0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,
0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,
97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,
1088,0,0,10,0,0,527,1047,0,0,0,0,0,1,0,
1103,0,0,9,0,0,527,1048,0,0,0,0,0,1,0,
1118,0,0,10,0,0,527,1070,0,0,0,0,0,1,0,
1133,0,0,9,0,0,527,1071,0,0,0,0,0,1,0,
1148,0,0,10,0,0,527,1087,0,0,0,0,0,1,0,
1163,0,0,9,0,0,527,1088,0,0,0,0,0,1,0,
1178,0,0,10,0,0,525,1109,0,0,28,0,0,1,0,2,68,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,
97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,
3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,
2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,
1305,0,0,10,0,0,527,1136,0,0,0,0,0,1,0,
1320,0,0,9,0,0,527,1137,0,0,0,0,0,1,0,
1335,0,0,9,0,0,527,1183,0,0,0,0,0,1,0,
1350,0,0,10,0,0,527,1184,0,0,0,0,0,1,0,
1365,0,0,11,92,0,516,1228,0,0,5,2,0,1,0,2,97,0,0,2,3,0,0,2,97,0,0,1,97,0,0,1,
68,0,0,
1400,0,0,10,0,0,527,1247,0,0,0,0,0,1,0,
1415,0,0,9,0,0,527,1248,0,0,0,0,0,1,0,
1430,0,0,12,90,0,517,1268,0,0,5,5,0,1,0,1,3,0,0,1,97,0,0,1,97,0,0,1,97,0,0,1,
68,0,0,
1465,0,0,10,0,0,527,1280,0,0,0,0,0,1,0,
1480,0,0,9,0,0,527,1281,0,0,0,0,0,1,0,
1495,0,0,13,0,0,543,1282,0,0,0,0,0,1,0,
1510,0,0,14,0,0,541,1297,0,0,0,0,0,1,0,
1525,0,0,15,0,0,543,1303,0,0,0,0,0,1,0,
1540,0,0,10,0,0,527,1304,0,0,0,0,0,1,0,
1555,0,0,9,0,0,527,1305,0,0,0,0,0,1,0,
1570,0,0,10,0,0,527,1335,0,0,0,0,0,1,0,
1585,0,0,9,0,0,527,1336,0,0,0,0,0,1,0,
1600,0,0,10,0,0,527,1348,0,0,0,0,0,1,0,
1615,0,0,9,0,0,527,1349,0,0,0,0,0,1,0,
1630,0,0,16,77,0,516,1410,0,0,2,1,0,1,0,2,97,0,0,1,97,0,0,
1653,0,0,17,171,0,516,1443,0,0,3,2,0,1,0,2,97,0,0,1,97,0,0,1,97,0,0,
1680,0,0,18,169,0,521,1495,0,0,2,2,0,1,0,1,97,0,0,1,97,0,0,
1703,0,0,18,0,0,525,1520,0,0,1,0,0,1,0,2,97,0,0,
1722,0,0,18,0,0,527,1532,0,0,0,0,0,1,0,
1737,0,0,18,0,0,527,1549,0,0,0,0,0,1,0,
1752,0,0,19,1206,0,516,1568,0,0,50,1,0,1,0,2,97,0,0,2,3,0,0,2,97,0,0,2,68,0,0,
2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,
0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,
0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,
0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,
0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,3,0,0,2,97,0,0,2,97,0,
0,1,97,0,0,
1967,0,0,20,0,0,543,1659,0,0,0,0,0,1,0,
1982,0,0,21,0,0,543,1671,0,0,0,0,0,1,0,
1997,0,0,22,0,0,543,1684,0,0,0,0,0,1,0,
2012,0,0,23,0,0,543,1690,0,0,0,0,0,1,0,
2027,0,0,18,0,0,527,1691,0,0,0,0,0,1,0,
2042,0,0,24,0,0,543,1703,0,0,0,0,0,1,0,
2057,0,0,25,0,0,543,1715,0,0,0,0,0,1,0,
2072,0,0,18,0,0,527,1716,0,0,0,0,0,1,0,
2087,0,0,18,0,0,527,1723,0,0,0,0,0,1,0,
2102,0,0,26,0,0,543,1729,0,0,0,0,0,1,0,
2117,0,0,18,0,0,527,1735,0,0,0,0,0,1,0,
2132,0,0,27,682,0,516,1833,0,0,30,2,0,1,0,2,68,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,
97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,
3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,
2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,1,68,0,0,1,3,0,0,
2267,0,0,28,682,0,516,1902,0,0,30,2,0,1,0,2,68,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,
97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,
3,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,
2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,1,68,0,0,1,3,0,0,
2402,0,0,29,167,0,517,1975,0,0,10,10,0,1,0,1,3,0,0,1,97,0,0,1,97,0,0,1,97,0,0,
1,97,0,0,1,97,0,0,1,97,0,0,1,97,0,0,1,97,0,0,1,68,0,0,
2457,0,0,30,0,0,543,1993,0,0,0,0,0,1,0,
2472,0,0,31,0,0,541,2009,0,0,0,0,0,1,0,
2487,0,0,32,0,0,543,2016,0,0,0,0,0,1,0,
};


/****************************************************************

JSNT
Copyright (C) 1999 - 2000 eFunds Corporation. All Rights Reserved.

Queue Checking Module - (Delivery Queue Handling Is In DELIVERY.C)

****************************************************************/
#define SQLCA_STORAGE_CLASS extern
#define	ORACA_STORAGE_CLASS extern


/* EXEC SQL INCLUDE	"sqlca.h"; 
 */ 
/*
 * $Header: sqlca.h,v 1.3 1994/12/12 19:27:27 jbasu Exp $ sqlca.h 
 */

/* Copyright (c) 1985,1986, 1998 by Oracle Corporation. */
 
/*
NAME
  SQLCA : SQL Communications Area.
FUNCTION
  Contains no code. Oracle fills in the SQLCA with status info
  during the execution of a SQL stmt.
NOTES
  **************************************************************
  ***                                                        ***
  *** This file is SOSD.  Porters must change the data types ***
  *** appropriately on their platform.  See notes/pcport.doc ***
  *** for more information.                                  ***
  ***                                                        ***
  **************************************************************

  If the symbol SQLCA_STORAGE_CLASS is defined, then the SQLCA
  will be defined to have this storage class. For example:
 
    #define SQLCA_STORAGE_CLASS extern
 
  will define the SQLCA as an extern.
 
  If the symbol SQLCA_INIT is defined, then the SQLCA will be
  statically initialized. Although this is not necessary in order
  to use the SQLCA, it is a good pgming practice not to have
  unitialized variables. However, some C compilers/OS's don't
  allow automatic variables to be init'd in this manner. Therefore,
  if you are INCLUDE'ing the SQLCA in a place where it would be
  an automatic AND your C compiler/OS doesn't allow this style
  of initialization, then SQLCA_INIT should be left undefined --
  all others can define SQLCA_INIT if they wish.

  If the symbol SQLCA_NONE is defined, then the SQLCA variable will
  not be defined at all.  The symbol SQLCA_NONE should not be defined
  in source modules that have embedded SQL.  However, source modules
  that have no embedded SQL, but need to manipulate a sqlca struct
  passed in as a parameter, can set the SQLCA_NONE symbol to avoid
  creation of an extraneous sqlca variable.
 
MODIFIED
    lvbcheng   07/31/98 -  long to int
    jbasu      12/12/94 -  Bug 217878: note this is an SOSD file
    losborne   08/11/92 -  No sqlca var if SQLCA_NONE macro set 
  Clare      12/06/84 - Ch SQLCA to not be an extern.
  Clare      10/21/85 - Add initialization.
  Bradbury   01/05/86 - Only initialize when SQLCA_INIT set
  Clare      06/12/86 - Add SQLCA_STORAGE_CLASS option.
*/
 
#ifndef SQLCA
#define SQLCA 1
 
struct   sqlca
         {
         /* ub1 */ char    sqlcaid[8];
         /* b4  */ int     sqlabc;
         /* b4  */ int     sqlcode;
         struct
           {
           /* ub2 */ unsigned short sqlerrml;
           /* ub1 */ char           sqlerrmc[70];
           } sqlerrm;
         /* ub1 */ char    sqlerrp[8];
         /* b4  */ int     sqlerrd[6];
         /* ub1 */ char    sqlwarn[8];
         /* ub1 */ char    sqlext[8];
         };

#ifndef SQLCA_NONE 
#ifdef   SQLCA_STORAGE_CLASS
SQLCA_STORAGE_CLASS struct sqlca sqlca
#else
         struct sqlca sqlca
#endif
 
#ifdef  SQLCA_INIT
         = {
         {'S', 'Q', 'L', 'C', 'A', ' ', ' ', ' '},
         sizeof(struct sqlca),
         0,
         { 0, {0}},
         {'N', 'O', 'T', ' ', 'S', 'E', 'T', ' '},
         {0, 0, 0, 0, 0, 0},
         {0, 0, 0, 0, 0, 0, 0, 0},
         {0, 0, 0, 0, 0, 0, 0, 0}
         }
#endif
         ;
#endif
 
#endif
 
/* end SQLCA */
/* EXEC SQL INCLUDE	"orcltype.h";
 */ 
/***************************************************************

ACHOS Function Library
Copyright (C) 1996 Deluxe Electronic Payment Systems, Inc.

Header Containing TypeDefs for Native ORACLE data types
and function prototypes for ORCLTYPE.LIB.

NOTE:  Programs should use EXEC SQL INCLUDE orcltype;
to include this header AFTER including achosprd.h!

FILE:			ORCLTYPE.H

CREATED:		07/01/96		Troy Clark
MODIFIED:	11/25/96		Troy Clark

***************************************************************/

#ifndef	ORCLTYPE_H_
#define	ORCLTYPE_H_

/***************************************************************
	Typedefs
***************************************************************/
/*
NOTICE:  Any changes made to oracle_date or oracle_varnum typedefs
			must also be made to their re-definition within DDSI.H
			The duplication is required so that DDSI.H does not
			required using oracles pro*c precompiler!
*/

/* EXEC SQL BEGIN DECLARE SECTION; */ 


typedef	struct	oracle_date_tag {
	unsigned char	century;
	unsigned	char	year;
	unsigned	char	month;
	unsigned	char	day;
	unsigned	char	hour;
	unsigned char	minute;
	unsigned char	second;
} oracle_date;

typedef struct oracle_varnum_tag {
	unsigned char	length;			/* # of bytes to follow -- includes expon. */
	unsigned char	exponent;			
	unsigned char	mantissa[20];	/* signif.digits - NO lead/trail zeros */
} oracle_varnum;

/* EXEC SQL TYPE	oracle_date		IS		DATE; */ 

/* EXEC SQL TYPE	oracle_varnum	IS		VARNUM(22); */ 


/* EXEC SQL END DECLARE SECTION; */ 


#endif

/* EXEC SQL INCLUDE	"jsnt_sql.h"; 
 */ 
/****************************************************************

js_SQL.H
Copyright (C) 1999 - 2000 eFunds Corporation. All Rights Reserved.

Header File for Database table definitions

****************************************************************/

#ifndef JSNT_SQL_H
#define JSNT_SQL_H


/* Oracle Errors -- Only Very Common Ones */
#define ORCL_NOT_FOUND		1403
#define ORCL_NO_ERROR		0
#define ORCL_DUPLICATE		-1

/* Database connection info */
#define DB_CONNECT_RETRIES	100
#define LOCK_TRIES 10
#define MAX_GROUPS_TO_RUN 10


	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		extern sql_context g_ctx;
	/* EXEC SQL END DECLARE SECTION; */ 



	/* EXEC SQL BEGIN DECLARE SECTION; */ 


	#define ROWS 100

/*************************************************************************
*  SQL JCS Job File		   
************************************************************************ */
typedef struct js_job_sql_record {
	char status[2];						/* A=Active, H=On Hold R=Ready S=Scheduled Y=Completed */
	long pos;                           /* Position in Queue */
	
	//Increased the length by one character to hold '\0' - Srini 26Aug2004
	//char name[9];						/* Job Name */
	char name[10];						/* Job Name */

	unsigned long no;					/* Unique Job Number */

	//Increased the length by one character to hold '\0' - Srini 26Aug2004
	//char station[9];					/* Station network adapter depdcy */
	  char station[10];					/* Station network adapter depdcy */ 

	/* Status Fields */
	char date_time_entered[15];         /* Time job submitted */
	char date_time_started[15];         /* Time job Started */
	char date_time_completed[15];       /* Time job Ended */
	short int exit_code;                /* 0 if successful, 99 if cancelled */
	char station_submitting[2];			/* Connection # of Station submitting job */
	char msg_when_started[2];			/* 0=Do not send message, 1=Send message */
	char msg_when_done[2];				/* SAME flags as above */
	char multi_processing[2];           /* 0=No Multiprocessing, 1=Multiprocess */
	
	/* Submission Fields */
	char date_time_to_start[15];        /* Date the job should start YYYYMMDDHHMISS */
	short int start_stat;               /* 0=Run 1=On Hold 2=Prompt operator 3=Both */
	char must_complete_by[5];           /* Error msg if not completed by */
	char c_msg_sent_yn[2];				/* Flag if error message sent */
	char must_start_by[5];              /* Error if not started by */
	char s_msg_sent_yn[2];				/* Flag if start error msg sent*/
	char msg_to_operator_yn[2];         /* Operator send to console */
	char msg_to[31];                    /* Who to send message to */
	//short int num_msg;                  /* How many message options */
	short int priority;                 /* Priority of Job */

    //Increased the length by one character to hold '\0' - Srini 26Aug2004
	//unsigned char stn_started[9];       /* Job machine that started job */
    unsigned char stn_started[10];       /* Job machine that started job */

	/* Job Dependencies */
	short int num_d;					/* Number of dependencies */
	char  d_job[180];                   /* Job Name of dependency */
	char  d_hrs_back[100];
	unsigned char d_cmplt[20];          /* If dependency already found done */
	char d_last_tested[200];            /* What time did a job server last test */
	short int orig_start_stat;          /* Save start stat for later use */
	char job_suspended[2];              /* If Job Temporarily Suspended */
	char restart[9];                    /* Step to Restart On */
	char job_class[2];                  /* Job Class */
	char base_dir[81];                  /* Base Directory where JOB should Start */
	short int max_job_time_warn;        /* Maximum time job will run */
	char debug_mode_yn[2];		        /* Job Debug mode */
	short int last_step;                /* Job Step number */

    //Increased the length by one character to hold '\0' - Srini 26Aug2004
	//char last_s_name[9];				/* Step Name */
	//char last_g_name[9];				/* Step Group */
  
    char last_s_name[10];				/* Step Name */
	char last_g_name[10];				/* Step Group */

	char submitted_file_name[13];       /* Name of Job Script file */
	char p_msg_sent_yn[2];		        /* Prompt Operator message sent */
	short int max_job_time_kill;
	char max_c_msg_yn[2];		        /* Has warning been sent? */
	char stn_dependancy_yn[2];			/* Was station dependency submitted or
											filled in because multiprocessing off*/
	char no_fail_message_yn[2];			/* Do Not send console message when
											its a failed job */
	char msg_when_failed[2];			/* 0=Do not send message, 1=Send message */
	short spawn_algorithm;				/* Resubmit job on successful execution */
	short spawn_parm;					/* Date logic parameter */
	char  d_station[180];
	
	// WR27164 - Hamsha
	char jsgroup[10];

} js_jobq_sql_def;


typedef struct js_job_sql_ind_record {
	short status;
	short pos;           
	short name;          
	short no;				
	short station;       
	short time_entered;            
	short time_started;             
	short time_completed;           
	short exit_code;            
	short station_submitting; 
	short msg_when_started;   
	short msg_when_done;      
	short multi_processing;   
	short date_time_to_start;      
	short start_stat;         
	short must_complete_by;         
	short c_msg_sent_yn;         
	short must_start_by;            
	short s_msg_sent_yn;         
	short msg_to_operator_yn;          
	short msg_to;                  
	short priority;               
	short stn_started;     
	short num_d;				
	short d_job;               
	short d_hrs_back;
	short d_cmplt;      
	short d_last_tested;        
	short orig_start_stat;      
	short job_suspended;             
	short restart;                
	short job_class;              
	short base_dir;              
	short max_job_time_warn;    
	short debug_mode_yn;    
	short last_step;            
	short last_s_name;   
	short last_g_name;   
	short submitted_file_name;   
	short p_msg_sent_yn;    
	short max_job_time_kill;
	short max_c_msg_yn;         
	short stn_dependancy_yn;    
	short no_fail_message_yn;   
	short msg_when_failed;      
	short spawn_algorithm;
	short spawn_parm;
	short d_station; //KLK
	
	// WR27164 - Hamsha
	short jsgroup;

} js_jobq_sql_ind_def;



/*************************************************************************
*  SQL JCS Step File 
*************************************************************************/
typedef struct js_step_sql_record {
	unsigned long no;					/* Unique Job Number */
	short int step;                     /* Job Step number */
	
  //char s_name[9];						/* Step Name */
  //Increased length by one character to hole '\0' - Srini 25Aug2004
	char s_name[10];						/* Step Name */
	
/* Status Fields */
	char status[2];						/* A=Active, N=Waiting, Y=Completed */
  //char j_name[9];						/* Job Name */
  //Increased length by one character to hole '\0' - Srini 25Aug2004
    char j_name[10];						/* Job Name */ 
	
	char date_time_started[15];         /* Time step Started */
	char date_time_completed[15];       /* Time step Ended */
	short int exit_code;                /* 0 if exited with acceptable code*/
	
/* Submission Fields */
	char command_line[140];             /* The command line to process */

/* Dependencies */
	short int num_d;                    /* Number of dependencies*/
	char d_step[180];                   /* Step name dependency */
	char d_cmplt[20];					/* If dependency already found done */
	char d_last_tested[200];            /* What time did a job server last test this */
	
/* Acceptable exit codes */
	short int num_a;                    /* number of acceptable codes */
	char exit_codes_acceptable[100];	/* These exit codes count as a 0 exit code */

	//char job_machine[9];				/* Job machine performing work */
    //Increased length by one character to hole '\0' - Srini 25Aug2004
	char job_machine[10];				/* Job machine performing work */
	
/* Group Information */
	//Increased length by one character to hole '\0' - Srini 25Aug2004
	//char d_group[20];					/* Set to 1 if Dependency is a Group Dependency */
	//char group_name[9];                 /* If step is a member of a group */
	char d_group[21];					/* Set to 1 if Dependency is a Group Dependency */
	char group_name[10];                 /* If step is a member of a group */
	char same_machine_flag_yn[2];		/* If user specified all steps in group
											should run on the same machine */
	char group_first_step_yn[2];		/* If this is the 1st step in the group */
	char skip_yn[2];					/* Skip Step because its a Restart */
	char beg_console_msg[81];           /* Console msg / console msg suspend */
	char beg_suspend_yn[2];			    /* Suspend step until reply? */
	char end_console_msg[81];           /* Console msg result / suspend */
	char end_suspend_yn[2];				/* Suspend step until reply? */
	char send_msg[81];                  /* From Send_msg command */
	char run_if_error[65];              /* program to run if there is an error - MW 4/12/99 */
	short status_interval;				/* How often to send status info */
} js_stepq_sql_def;

typedef struct js_step_sql_ind_record {
	short no;					
	short step;                 
	short s_name;            
	short status;               
	short j_name;            
	short time_started;         
	short time_completed;       
	short exit_code;            
	short command_line;    
	short num_d;                
	short d_step;          
	short d_cmplt;          
	short d_last_tested;   
	short num_a;                
	short exit_codes_acceptable;
	short job_machine;      
	short d_group;         
	short group_name;       
	short same_machine_flag_yn;
	short group_first_step_yn; 
	short skip_yn;             
	short beg_console_msg; 
	short beg_suspend_yn;      
	short end_console_msg; 
	short end_suspend_yn;    
	short send_msg;      
	short run_if_error;  
	short status_interval;
} js_stepq_sql_ind_def;



/*************************************************************************
*  SQL JCS Process Queue File
*************************************************************************/
typedef struct js_p_sql_record {
	unsigned char proc_name[10];      /* Name of Job Server */
	short int status;                /* 0=Idle 1=Busy */
	unsigned char net_node[14];      /* net Node id */
	unsigned long job_num;				/* Job number */
	char job_name[10];                /* Name of Job */
	short int step_num;              /* Step number */
	char step_name[10];               /* Step Name */
	char entry_date[15];				   /* Date/Time job entered into sys YYYYMMDDHHMISS */
	char start_date[15];				   /* Date/Time started YYYYMMDDHHMISS */
	char must_complete_by[6];        /* Time job must complete by */
	char multi_processing[2];        /* 0=No Multiprocessing, 1=Multiprocess */
	char group_name[10];              /* Group Step belongs to */
	char job_class[3];               /* Class of Job */
	unsigned char net_id[9];         /* Network ID */
	char job_paused[2];					/* Job Paused */
} js_pq_sql_def;	

typedef struct js_p_sql_ind_record {
	short proc_name;     
	short status;           
	short net_node;     
	short job_num;			
	short job_name;      
	short step_num;         
	short step_name;     
	short entry_date;			
	short start_date;			
	short must_complete_by;      
	short multi_processing;        
	short group_name;           
	short job_class;           
	short net_id;              
	short job_paused;             
} js_pq_sql_ind_def;	


/*************************************************************************
*  SQL JCS Message Queue File
*************************************************************************/
typedef struct js_m_sql_record {
	char message_time[15];              /* Time stamp of message entry YYYYMMDDHHMISS */
	unsigned char release_net_id[9];    /* Contains NetID of Job Server that created message */
	unsigned char release_net_node[14]; /* Contains node of Job Server that created message */
	unsigned char must_release[2];      /* 1=Operater must release, Job Server waits */
	unsigned char msg_class[3];         /* Class of Message        */
	unsigned char sender_js[10];
	unsigned char sender_job[10];
	unsigned char msg[458];             /* The message      */
} js_msgq_sql_def;

typedef struct js_m_sql_ind_record {
	short message_time;      
	short release_net_id;    
	short release_net_node; 
	short must_release;      
	short msg_class;         
	short sender_js;
	short sender_job;
	short msg;             
} js_msgq_sql_ind_def;


	/*************************************************************************
	*  SQL JCS Delivery Queue File
	*************************************************************************/
	typedef struct js_d_sql_record {
		char Delivery_ID[ROWS][7];				/* Unique ID for this record */
		char Bank_ID[ROWS][10];            		/* ABA for bank */
		char Src_File_Spec[ROWS][129];			/* Source filespec */
		char Src_Rename_Mask[ROWS][21];			/* Source rename spec */
		char Dest_Path[ROWS][129];				/* Destination path only */
		char Dest_Rename_Mask[ROWS][31];		/* Destination file spec */
		char Move_Flag[ROWS][2];				/* M=Move, C=Copy, N=Neither*/
		char Convert_Flag[ROWS][2];				/* A=ASCII, E=EBCIDIC, N=Neither */
		char Job_Path[ROWS][129];				/* Path & filename of job */
		char Ext_Dist_Flag_YN[ROWS][2];			/* Y=external delivery, N=not */
		char Ext_Command[ROWS][256];			/* External command line */
		char Ext_Error_File[ROWS][129];			/* External error return file */
		char Ext_Run_On_Error[ROWS][256];		/* Cmd to run on external error */
		char Ext_Timeout[ROWS][5];				/* External timeout (minutes) */
		char Ext_Login_ID[ROWS][31];			/* External login ID */
		char Ext_Password[ROWS][257];			/* External pwd for login *///I140558110 - DEPSFTP Changes for pwd Encryption- increased 15 to 257
		char Record_Type[ROWS][2];				/* To indicate a record bounds to inbound or outbound */
		char Station[ROWS][10];					/* To indicate a record bounds to inbound or outbound */

		// WR27164 - Hamsha
		char jsgroup[ROWS][10];

	} js_delivery_sql_def;


	typedef struct js_d_sql_ind_record {
		short Delivery_ID[ROWS];	
		short Bank_ID[ROWS];      
		short Src_File_Spec[ROWS];
		short Src_Rename_Mask[ROWS];
		short Dest_Path[ROWS];	
		short Dest_Rename_Mask[ROWS];
		short Move_Flag[ROWS];	
		short Convert_Flag[ROWS];	
		short Job_Path[ROWS];		
		short Ext_Dist_Flag_YN[ROWS];
		short Ext_Command[ROWS];	
		short Ext_Error_File[ROWS];
		short Ext_Run_On_Error[ROWS];
		short Ext_Timeout[ROWS];
		short Ext_Login_ID[ROWS];
		short Ext_Password[ROWS];
		short Record_Type[ROWS];
		short Station[ROWS];
		
		// WR27164 - Hamsha
		short jsgroup[ROWS];

	} js_delivery_sql_ind_def;




     typedef struct js_locked 
	{
		char SrcFile[255];           /* Unique ID for this record */
		char Delivery_Flag;          /* P=Postponed-File in Use, D=Deliverying */
	} js_locked_def;
	

	typedef struct js_holidays 
	{
		char holiday[ROWS][9];            
	} js_holiday_def;
	
	/* WR28164 - Ext FTP command - Sujatha/Veera*/
	typedef struct achps_const_tag	{
		char parameter_name[16];
		char parameter_value[41];
		char remarks[41];
	} achps_const_sql;

	typedef struct achps_const_ind_tag	{
		short parameter_name;
		short parameter_value;
		short remarks;
	} achps_const_ind;
	/* WR28164 - Ext FTP command - Sujatha/Veera*/



extern js_pq_sql_def p_q;
extern js_pq_sql_ind_def p_q_ind;

extern js_jobq_sql_def job_q;
extern js_jobq_sql_ind_def job_q_ind;

extern js_stepq_sql_def step_q;
extern js_stepq_sql_ind_def step_q_ind;

extern js_msgq_sql_def msg_q;

extern js_locked_def locked;

extern js_holiday_def holiday_rec;


extern js_stepq_sql_def stepq_sql;
extern js_stepq_sql_ind_def stepq_sql_ind;

extern js_jobq_sql_def jobq_sql;
extern js_jobq_sql_ind_def jobq_sql_ind;

extern js_delivery_sql_def		delivery_recs;
extern js_delivery_sql_ind_def	delivery_recs_inds;


//	extern CRITICAL_SECTION sql_lock;

	/* EXEC SQL END DECLARE SECTION; */ 

#endif





#include "jsnt.h"


 
void trim_sql_jobq(js_jobq_sql_def *jobq);
void trim_sql_stepq(js_stepq_sql_def *stepq);
 

/*********************** search_queue **************************
*                                                              *
* Description: Start searching through the Schedule, Active    *
*  and Waiting queues to see if there are any jobs to run.     *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
*  Modifed Date: 06/28/96        By: Mike West                 *
*                                                              *
***************************************************************/
int search_queue (void) 
{
	short int ret;
	char szbuff[500];
	long tim;
	static long last_tim = 0;
	char tempstr[50];
	char szret[10];


 
	/* EXEC SQL CONTEXT USE :g_ctx; */ 

 


	Sleep(1500);
	time(&tim);

	if (idle && !now) {
		if(tim > (last_tim + INTERVAL) );
		else return SUCCESS;
	}
	last_tim = tim;
	now = 0;

/*  Search the delivery configuration file for any matching files  */

//	if (! job_processing)	// only do delivery when we don't have a job processing
//	{
		if (! no_delivery)	// command line parameter to not do delivery
		{
			if (search_delivery() != SUCCESS)
				return(-2);
		}
//	}

// WR 28164  - sujatha/Veera

    if(station_only)
	{
		if(search_delivery() != SUCCESS)
			return -3;
	}

	if(!no_delivery && !no_submit)
		qtext(xpos,ypos+STATUS_LINE,           "        Waiting for Job or Delivery...     ");
	else if (!no_delivery)
		qtext(xpos,ypos+STATUS_LINE,           "        Waiting for Delivery...            ");
	else
		qtext(xpos,ypos+STATUS_LINE,           "        Waiting for Job...                 ");

/* First check scheduled queue and see if anything ready to go */
	if (!no_submit)  // command line parameter to not to submit
	{
		debug_log ("Checking Scheduled Queue");
		ret = check_scheduled ();

		if(ret != 0) 
		{
			logit (0,"Error on scheduled queue check");
			debug_log ("Error on scheduled queue check");
			return ERR;
		}
	

/* Next Check the Active Jobs to see if any STEPS need processing */
		debug_log ("Checking active jobs");
		ret = check_actives();

		if (ret == 1) 
		{
			job_processing = 1;
			debug_log ("Found job - actives - Processing");
		ret = process_task();

			if(ret == -2) 
			{
				_itoa(ret, szret, 10);
				copy_cat(szbuff, "ERROR Active Jobs: Process Task returned ", szret, NULL);
				//sprintf (szbuff, "ERROR Active Jobs: Process Task returned %d", ret);
				logit (0, szbuff);
				debug_log (szbuff);
				return ERR;
			}

			if(ret) 
			{
				_itoa(ret, szret, 10);
				copy_cat(szbuff, "ERROR Active Jobs: Process Task returned ", szret, NULL);
				//sprintf (szbuff, "ERROR Active Jobs: Process Task returned %d", ret);
				logit (0, szbuff);
				debug_log (szbuff);
				return ERR;
			}
			return SUCCESS;
		}

		if (ret == 2)     /* A task is waiting to be completed on another job server */
		{
			debug_log ("Abandoned check active queue so another JS could close task");
			return SUCCESS;  
		}
		
		if (ret) 			/* Some other error */
		{
			logit (0,"Error on check actives");
			debug_log ("Error on check actives");
			return ERR;
		}
	

/* If NO active STEPS ready to go, then look at WAITING QUEUE and 
 start 1st Step */

		debug_log ("Checking Waiting Queue");
		ret = check_waiting ();
		if (ret == 1) 
		{
			job_processing = 1;
			debug_log("Found job - waiting - processing");
			ret = process_task ();

			if(ret == -2) 
			{
				_itoa(ret, szret, 10);
				copy_cat(szbuff, "ERROR Waiting Jobs: Process Task returned ", szret, NULL);
				//sprintf (szbuff, "ERROR Waiting Jobs: Process Task returned %d", ret);
				logit (0, szbuff);
				debug_log (szbuff);
				return ERR;
			}

			if(ret) 
			{
				_itoa(ret, szret, 10);
				copy_cat(szbuff, "ERROR Waiting Jobs: Process Task returned ", szret, NULL);
				//sprintf (szbuff, "ERROR Waiting Jobs: Process Task returned %d", ret);
				logit (0, szbuff);
				debug_log (szbuff);
				return ERR;
			}
			return SUCCESS;
		}

		if (ret) 			/* Some other error */
		{
			logit (0,"Error on check waiting");
			debug_log ("Error on check waiting");
			return ERR;
		}
	}

	if(no_delivery && no_submit && (!station_only))
	{
		//nothing would be executed.
		qtext(xpos,ypos+STATUS_LINE," JOB Server set to idle. Check Config file.");
		logit (0,"JOB Server set to idle. Check Config file.");
		debug_log ("JOB Server set to idle. Check Config file.");
		Sleep (5000);
	}

	debug_log ("No jobs to run or execute.");

	if (! idle) 
	{
		if (login_js ()) 
			return ERR;
		idle = 1;
		copy_cat(tempstr, "[", szjsname, "] - IDLE                              ", prog_version, NULL);
		//sprintf (tempstr, "[%s] - IDLE                              %s", szjsname, prog_version);
		SetConsoleTitle (tempstr);                  /* set the console title       */
	}

	return SUCCESS;  
}

/********************* check_scheduled *************************
*                                                              *
* Description: Start searching through the schedule queue for  *
*  any jobs that are on hold or time scheduled jobs to run.    *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
*  Modifed Date: 06/28/96        By: Mike West                 *
*  Modifed Date: 07/29/99        By: Mike West                 *
*                                                              *
***************************************************************/
int check_scheduled (void) {
	char test_d[20];
	char j_test[20];
	char szbuff[300];
	SYSTIME st;
	//short int tries;
	int l_sqlcode;
	char szret[10];
	char sqlmsg[80];

	// WR27164 - Hamsha

	char szcode[10];
	char tempstr[500];


   char month[3];
   char day[3];
   char year[5];
   char hour[3];
   char minute[3];
   char second[3];


 
   	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		char job_status[2];			/* A=Active, H=On Hold R=Ready S=Scheduled Y=Completed */
		long job_pos;               /* Position in Queue */
		char job_name[10];
	/* EXEC SQL END DECLARE SECTION; */ 

 


	while (1) 
	{

 

   	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		char job_server[10];
		char js_group[10]; // WR27164 - Hamsha
   	/* EXEC SQL END DECLARE SECTION; */ 


	strcpy(job_server, szjsname);
	memset(&job_q, 0, sizeof(job_q) );
	EnterCriticalSection(&jsnt_sql_lock);

// Added for WR27164 on 02/14/2005 - Hamsha

	trimlr(job_server);
	memset(js_group,'\0',sizeof(js_group));

	/* EXEC SQL 
		SELECT trim(jsgroup) 
        INTO   :js_group
		FROM   JOB_SERVER_GROUPS
		WHERE  trim(STATION) = :job_server; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 2;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = "select trim(jsgroup) into :b0  from JOB_SERVER_GROUPS where \
trim(STATION)=:b1";
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )5;
 sqlstm.selerr = (unsigned short)1;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqhstv[0] = (         void  *)js_group;
 sqlstm.sqhstl[0] = (unsigned int  )10;
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)job_server;
 sqlstm.sqhstl[1] = (unsigned int  )10;
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;

	LeaveCriticalSection(&jsnt_sql_lock);

	if( (l_sqlcode != ORCL_NO_ERROR) &&  (l_sqlcode != ORCL_NOT_FOUND) )
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
				"JOB_SERVER_GROUPS", sqlmsg, "JS_GROUP", NULL);
		_itoa(l_sqlcode, szcode, 10);
		copy_cat(tempstr, "Error during SELECT FROM JOB_SERVER_GROUPS table - SQLCA.SQLCODE=",
				szcode, sqlmsg, NULL);
		logit (0, tempstr);
		debug_log(tempstr);
		return ERR;

	}
	if (l_sqlcode == ORCL_NOT_FOUND)
		memset(js_group, 0x00, sizeof(js_group));
	
	trimlr(js_group);

// End - Hamsha

		EnterCriticalSection(&jsnt_sql_lock);

		/* EXEC SQL SELECT 
			status,
			pos,
			name,
			no,
			station,
			date_time_entered,
			date_time_started,
			date_time_completed,
			exit_code,
			station_submitting,
			msg_when_started,
			msg_when_done,
			multi_processing,
			date_time_to_start,
			start_stat,
			must_complete_by,
			c_msg_sent_yn,
			must_start_by,
			s_msg_sent_yn,
			msg_to_operator_yn,
			msg_to,
			priority,
			stn_started,
			num_d,
			d_job,
			d_hrs_back,
			d_cmplt,
			d_last_tested,
			orig_start_stat,
			job_suspended,
			restart,
			job_class,
			base_dir,
			max_job_time_warn,
			debug_mode_yn,
			last_step,
			last_s_name,
			last_g_name,
			submitted_file_name,
			p_msg_sent_yn,
			max_job_time_kill,
			max_c_msg_yn,
			stn_dependancy_yn,
			no_fail_message_yn,
			msg_when_failed,
			spawn_algorithm,
			spawn_parm,
			d_station,
			jsgroup			// WR27164 - Hamsha
		INTO :job_q:job_q_ind
		FROM JOBQ

// Modified for WR27164 on 02/14/2005 - Hamsha

//		WHERE status = 'S'
//		AND   to_char(date_time_to_start, 'YYYYMMDDHH24MISS') >= '00000000000000'
//		AND   (station is NULL OR station = :job_server)
//		AND   ROWNUM=1;

		WHERE status = 'S'
		AND   to_char(date_time_to_start, 'YYYYMMDDHH24MISS') >= '00000000000000'
		and ((station is NULL and jsgroup is NULL)
			OR  ( TRIM(station) = :job_server )  
			OR  ( TRIM(jsgroup) = :js_group ))
		AND   ROWNUM=1; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 51;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlbuft(&g_ctx,
    "select status ,pos ,name ,no ,station ,date_time_entered ,date_time_sta\
rted ,date_time_completed ,exit_code ,station_submitting ,msg_when_started ,\
msg_when_done ,multi_processing ,date_time_to_start ,start_stat ,must_comple\
te_by ,c_msg_sent_yn ,must_start_by ,s_msg_sent_yn ,msg_to_operator_yn ,msg_\
to ,priority ,stn_started ,num_d ,d_job ,d_hrs_back ,d_cmplt ,d_last_tested \
,orig_start_stat ,job_suspended ,restart ,job_class ,base_dir ,max_job_time_\
warn ,debug_mode_yn ,last_step ,last_s_name ,last_g_name ,submitted_file_nam\
e ,p_msg_sent_yn ,max_job_time_kill ,max_c_msg_yn ,stn_dependancy_yn ,no_fai\
l_message_yn ,msg_when_failed ,spawn_algorithm ,spawn_parm ,d_station ,jsgro\
up into :s1:s2 ,:s3:s4 ,:s5:s6 ,:s7:s8 ,:s9:s10 ,:s11:s12 ,:s13:s14 ,:s15:s1\
6 ,:s17:s18 ,:s19:s20 ,:s21:s22 ,:s23:s24 ,:s25:s26 ,:s27:s28 ,:s29:s30 ,:s3\
1:s32 ,:s33:s34 ,:s35:s36 ,:s37:s38 ,:s39:s40 ,:s41:s42 ,:s43:s44 ,:s45:s46 \
,:s47:s48 ,:s49:s50 ,:s51:s52 ,:s53:s54 ,:s55:s56 ,:s57:s58 ,:s59:s60 ,:s61:\
s62 ,:s63:s64 ,:s65:s66 ,:s67:s68 ,:s69:s");
  sqlstm.stmt = "70 ,:s71:s72 ,:s73:s74 ,:s75:s76 ,:s77:s78 ,:s79:s80 ,:s81:\
s82 ,:s83:s84 ,:s85:s86 ,:s87:s88 ,:s89:s90 ,:s91:s92 ,:s93:s94 ,:s95:s96 ,:s9\
7:s98   from JOBQ where (((status='S' and to_char(date_time_to_start,'YYYYMMDD\
HH24MISS')>='00000000000000') and (((station is null  and jsgroup is null ) or\
 trim(station)=:b2) or trim(jsgroup)=:b3)) and ROWNUM=1)";
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )28;
  sqlstm.selerr = (unsigned short)1;
  sqlstm.sqlpfmem = (unsigned int  )0;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlstm.sqhstv[0] = (         void  *)job_q.status;
  sqlstm.sqhstl[0] = (unsigned int  )2;
  sqlstm.sqhsts[0] = (         int  )0;
  sqlstm.sqindv[0] = (         void  *)&job_q_ind.status;
  sqlstm.sqinds[0] = (         int  )0;
  sqlstm.sqharm[0] = (unsigned int  )0;
  sqlstm.sqadto[0] = (unsigned short )0;
  sqlstm.sqtdso[0] = (unsigned short )0;
  sqlstm.sqhstv[1] = (         void  *)&job_q.pos;
  sqlstm.sqhstl[1] = (unsigned int  )sizeof(long);
  sqlstm.sqhsts[1] = (         int  )0;
  sqlstm.sqindv[1] = (         void  *)&job_q_ind.pos;
  sqlstm.sqinds[1] = (         int  )0;
  sqlstm.sqharm[1] = (unsigned int  )0;
  sqlstm.sqadto[1] = (unsigned short )0;
  sqlstm.sqtdso[1] = (unsigned short )0;
  sqlstm.sqhstv[2] = (         void  *)job_q.name;
  sqlstm.sqhstl[2] = (unsigned int  )10;
  sqlstm.sqhsts[2] = (         int  )0;
  sqlstm.sqindv[2] = (         void  *)&job_q_ind.name;
  sqlstm.sqinds[2] = (         int  )0;
  sqlstm.sqharm[2] = (unsigned int  )0;
  sqlstm.sqadto[2] = (unsigned short )0;
  sqlstm.sqtdso[2] = (unsigned short )0;
  sqlstm.sqhstv[3] = (         void  *)&job_q.no;
  sqlstm.sqhstl[3] = (unsigned int  )sizeof(long);
  sqlstm.sqhsts[3] = (         int  )0;
  sqlstm.sqindv[3] = (         void  *)&job_q_ind.no;
  sqlstm.sqinds[3] = (         int  )0;
  sqlstm.sqharm[3] = (unsigned int  )0;
  sqlstm.sqadto[3] = (unsigned short )0;
  sqlstm.sqtdso[3] = (unsigned short )0;
  sqlstm.sqhstv[4] = (         void  *)job_q.station;
  sqlstm.sqhstl[4] = (unsigned int  )10;
  sqlstm.sqhsts[4] = (         int  )0;
  sqlstm.sqindv[4] = (         void  *)&job_q_ind.station;
  sqlstm.sqinds[4] = (         int  )0;
  sqlstm.sqharm[4] = (unsigned int  )0;
  sqlstm.sqadto[4] = (unsigned short )0;
  sqlstm.sqtdso[4] = (unsigned short )0;
  sqlstm.sqhstv[5] = (         void  *)job_q.date_time_entered;
  sqlstm.sqhstl[5] = (unsigned int  )15;
  sqlstm.sqhsts[5] = (         int  )0;
  sqlstm.sqindv[5] = (         void  *)&job_q_ind.time_entered;
  sqlstm.sqinds[5] = (         int  )0;
  sqlstm.sqharm[5] = (unsigned int  )0;
  sqlstm.sqadto[5] = (unsigned short )0;
  sqlstm.sqtdso[5] = (unsigned short )0;
  sqlstm.sqhstv[6] = (         void  *)job_q.date_time_started;
  sqlstm.sqhstl[6] = (unsigned int  )15;
  sqlstm.sqhsts[6] = (         int  )0;
  sqlstm.sqindv[6] = (         void  *)&job_q_ind.time_started;
  sqlstm.sqinds[6] = (         int  )0;
  sqlstm.sqharm[6] = (unsigned int  )0;
  sqlstm.sqadto[6] = (unsigned short )0;
  sqlstm.sqtdso[6] = (unsigned short )0;
  sqlstm.sqhstv[7] = (         void  *)job_q.date_time_completed;
  sqlstm.sqhstl[7] = (unsigned int  )15;
  sqlstm.sqhsts[7] = (         int  )0;
  sqlstm.sqindv[7] = (         void  *)&job_q_ind.time_completed;
  sqlstm.sqinds[7] = (         int  )0;
  sqlstm.sqharm[7] = (unsigned int  )0;
  sqlstm.sqadto[7] = (unsigned short )0;
  sqlstm.sqtdso[7] = (unsigned short )0;
  sqlstm.sqhstv[8] = (         void  *)&job_q.exit_code;
  sqlstm.sqhstl[8] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[8] = (         int  )0;
  sqlstm.sqindv[8] = (         void  *)&job_q_ind.exit_code;
  sqlstm.sqinds[8] = (         int  )0;
  sqlstm.sqharm[8] = (unsigned int  )0;
  sqlstm.sqadto[8] = (unsigned short )0;
  sqlstm.sqtdso[8] = (unsigned short )0;
  sqlstm.sqhstv[9] = (         void  *)job_q.station_submitting;
  sqlstm.sqhstl[9] = (unsigned int  )2;
  sqlstm.sqhsts[9] = (         int  )0;
  sqlstm.sqindv[9] = (         void  *)&job_q_ind.station_submitting;
  sqlstm.sqinds[9] = (         int  )0;
  sqlstm.sqharm[9] = (unsigned int  )0;
  sqlstm.sqadto[9] = (unsigned short )0;
  sqlstm.sqtdso[9] = (unsigned short )0;
  sqlstm.sqhstv[10] = (         void  *)job_q.msg_when_started;
  sqlstm.sqhstl[10] = (unsigned int  )2;
  sqlstm.sqhsts[10] = (         int  )0;
  sqlstm.sqindv[10] = (         void  *)&job_q_ind.msg_when_started;
  sqlstm.sqinds[10] = (         int  )0;
  sqlstm.sqharm[10] = (unsigned int  )0;
  sqlstm.sqadto[10] = (unsigned short )0;
  sqlstm.sqtdso[10] = (unsigned short )0;
  sqlstm.sqhstv[11] = (         void  *)job_q.msg_when_done;
  sqlstm.sqhstl[11] = (unsigned int  )2;
  sqlstm.sqhsts[11] = (         int  )0;
  sqlstm.sqindv[11] = (         void  *)&job_q_ind.msg_when_done;
  sqlstm.sqinds[11] = (         int  )0;
  sqlstm.sqharm[11] = (unsigned int  )0;
  sqlstm.sqadto[11] = (unsigned short )0;
  sqlstm.sqtdso[11] = (unsigned short )0;
  sqlstm.sqhstv[12] = (         void  *)job_q.multi_processing;
  sqlstm.sqhstl[12] = (unsigned int  )2;
  sqlstm.sqhsts[12] = (         int  )0;
  sqlstm.sqindv[12] = (         void  *)&job_q_ind.multi_processing;
  sqlstm.sqinds[12] = (         int  )0;
  sqlstm.sqharm[12] = (unsigned int  )0;
  sqlstm.sqadto[12] = (unsigned short )0;
  sqlstm.sqtdso[12] = (unsigned short )0;
  sqlstm.sqhstv[13] = (         void  *)job_q.date_time_to_start;
  sqlstm.sqhstl[13] = (unsigned int  )15;
  sqlstm.sqhsts[13] = (         int  )0;
  sqlstm.sqindv[13] = (         void  *)&job_q_ind.date_time_to_start;
  sqlstm.sqinds[13] = (         int  )0;
  sqlstm.sqharm[13] = (unsigned int  )0;
  sqlstm.sqadto[13] = (unsigned short )0;
  sqlstm.sqtdso[13] = (unsigned short )0;
  sqlstm.sqhstv[14] = (         void  *)&job_q.start_stat;
  sqlstm.sqhstl[14] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[14] = (         int  )0;
  sqlstm.sqindv[14] = (         void  *)&job_q_ind.start_stat;
  sqlstm.sqinds[14] = (         int  )0;
  sqlstm.sqharm[14] = (unsigned int  )0;
  sqlstm.sqadto[14] = (unsigned short )0;
  sqlstm.sqtdso[14] = (unsigned short )0;
  sqlstm.sqhstv[15] = (         void  *)job_q.must_complete_by;
  sqlstm.sqhstl[15] = (unsigned int  )5;
  sqlstm.sqhsts[15] = (         int  )0;
  sqlstm.sqindv[15] = (         void  *)&job_q_ind.must_complete_by;
  sqlstm.sqinds[15] = (         int  )0;
  sqlstm.sqharm[15] = (unsigned int  )0;
  sqlstm.sqadto[15] = (unsigned short )0;
  sqlstm.sqtdso[15] = (unsigned short )0;
  sqlstm.sqhstv[16] = (         void  *)job_q.c_msg_sent_yn;
  sqlstm.sqhstl[16] = (unsigned int  )2;
  sqlstm.sqhsts[16] = (         int  )0;
  sqlstm.sqindv[16] = (         void  *)&job_q_ind.c_msg_sent_yn;
  sqlstm.sqinds[16] = (         int  )0;
  sqlstm.sqharm[16] = (unsigned int  )0;
  sqlstm.sqadto[16] = (unsigned short )0;
  sqlstm.sqtdso[16] = (unsigned short )0;
  sqlstm.sqhstv[17] = (         void  *)job_q.must_start_by;
  sqlstm.sqhstl[17] = (unsigned int  )5;
  sqlstm.sqhsts[17] = (         int  )0;
  sqlstm.sqindv[17] = (         void  *)&job_q_ind.must_start_by;
  sqlstm.sqinds[17] = (         int  )0;
  sqlstm.sqharm[17] = (unsigned int  )0;
  sqlstm.sqadto[17] = (unsigned short )0;
  sqlstm.sqtdso[17] = (unsigned short )0;
  sqlstm.sqhstv[18] = (         void  *)job_q.s_msg_sent_yn;
  sqlstm.sqhstl[18] = (unsigned int  )2;
  sqlstm.sqhsts[18] = (         int  )0;
  sqlstm.sqindv[18] = (         void  *)&job_q_ind.s_msg_sent_yn;
  sqlstm.sqinds[18] = (         int  )0;
  sqlstm.sqharm[18] = (unsigned int  )0;
  sqlstm.sqadto[18] = (unsigned short )0;
  sqlstm.sqtdso[18] = (unsigned short )0;
  sqlstm.sqhstv[19] = (         void  *)job_q.msg_to_operator_yn;
  sqlstm.sqhstl[19] = (unsigned int  )2;
  sqlstm.sqhsts[19] = (         int  )0;
  sqlstm.sqindv[19] = (         void  *)&job_q_ind.msg_to_operator_yn;
  sqlstm.sqinds[19] = (         int  )0;
  sqlstm.sqharm[19] = (unsigned int  )0;
  sqlstm.sqadto[19] = (unsigned short )0;
  sqlstm.sqtdso[19] = (unsigned short )0;
  sqlstm.sqhstv[20] = (         void  *)job_q.msg_to;
  sqlstm.sqhstl[20] = (unsigned int  )31;
  sqlstm.sqhsts[20] = (         int  )0;
  sqlstm.sqindv[20] = (         void  *)&job_q_ind.msg_to;
  sqlstm.sqinds[20] = (         int  )0;
  sqlstm.sqharm[20] = (unsigned int  )0;
  sqlstm.sqadto[20] = (unsigned short )0;
  sqlstm.sqtdso[20] = (unsigned short )0;
  sqlstm.sqhstv[21] = (         void  *)&job_q.priority;
  sqlstm.sqhstl[21] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[21] = (         int  )0;
  sqlstm.sqindv[21] = (         void  *)&job_q_ind.priority;
  sqlstm.sqinds[21] = (         int  )0;
  sqlstm.sqharm[21] = (unsigned int  )0;
  sqlstm.sqadto[21] = (unsigned short )0;
  sqlstm.sqtdso[21] = (unsigned short )0;
  sqlstm.sqhstv[22] = (         void  *)job_q.stn_started;
  sqlstm.sqhstl[22] = (unsigned int  )10;
  sqlstm.sqhsts[22] = (         int  )0;
  sqlstm.sqindv[22] = (         void  *)&job_q_ind.stn_started;
  sqlstm.sqinds[22] = (         int  )0;
  sqlstm.sqharm[22] = (unsigned int  )0;
  sqlstm.sqadto[22] = (unsigned short )0;
  sqlstm.sqtdso[22] = (unsigned short )0;
  sqlstm.sqhstv[23] = (         void  *)&job_q.num_d;
  sqlstm.sqhstl[23] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[23] = (         int  )0;
  sqlstm.sqindv[23] = (         void  *)&job_q_ind.num_d;
  sqlstm.sqinds[23] = (         int  )0;
  sqlstm.sqharm[23] = (unsigned int  )0;
  sqlstm.sqadto[23] = (unsigned short )0;
  sqlstm.sqtdso[23] = (unsigned short )0;
  sqlstm.sqhstv[24] = (         void  *)job_q.d_job;
  sqlstm.sqhstl[24] = (unsigned int  )180;
  sqlstm.sqhsts[24] = (         int  )0;
  sqlstm.sqindv[24] = (         void  *)&job_q_ind.d_job;
  sqlstm.sqinds[24] = (         int  )0;
  sqlstm.sqharm[24] = (unsigned int  )0;
  sqlstm.sqadto[24] = (unsigned short )0;
  sqlstm.sqtdso[24] = (unsigned short )0;
  sqlstm.sqhstv[25] = (         void  *)job_q.d_hrs_back;
  sqlstm.sqhstl[25] = (unsigned int  )100;
  sqlstm.sqhsts[25] = (         int  )0;
  sqlstm.sqindv[25] = (         void  *)&job_q_ind.d_hrs_back;
  sqlstm.sqinds[25] = (         int  )0;
  sqlstm.sqharm[25] = (unsigned int  )0;
  sqlstm.sqadto[25] = (unsigned short )0;
  sqlstm.sqtdso[25] = (unsigned short )0;
  sqlstm.sqhstv[26] = (         void  *)job_q.d_cmplt;
  sqlstm.sqhstl[26] = (unsigned int  )20;
  sqlstm.sqhsts[26] = (         int  )0;
  sqlstm.sqindv[26] = (         void  *)&job_q_ind.d_cmplt;
  sqlstm.sqinds[26] = (         int  )0;
  sqlstm.sqharm[26] = (unsigned int  )0;
  sqlstm.sqadto[26] = (unsigned short )0;
  sqlstm.sqtdso[26] = (unsigned short )0;
  sqlstm.sqhstv[27] = (         void  *)job_q.d_last_tested;
  sqlstm.sqhstl[27] = (unsigned int  )200;
  sqlstm.sqhsts[27] = (         int  )0;
  sqlstm.sqindv[27] = (         void  *)&job_q_ind.d_last_tested;
  sqlstm.sqinds[27] = (         int  )0;
  sqlstm.sqharm[27] = (unsigned int  )0;
  sqlstm.sqadto[27] = (unsigned short )0;
  sqlstm.sqtdso[27] = (unsigned short )0;
  sqlstm.sqhstv[28] = (         void  *)&job_q.orig_start_stat;
  sqlstm.sqhstl[28] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[28] = (         int  )0;
  sqlstm.sqindv[28] = (         void  *)&job_q_ind.orig_start_stat;
  sqlstm.sqinds[28] = (         int  )0;
  sqlstm.sqharm[28] = (unsigned int  )0;
  sqlstm.sqadto[28] = (unsigned short )0;
  sqlstm.sqtdso[28] = (unsigned short )0;
  sqlstm.sqhstv[29] = (         void  *)job_q.job_suspended;
  sqlstm.sqhstl[29] = (unsigned int  )2;
  sqlstm.sqhsts[29] = (         int  )0;
  sqlstm.sqindv[29] = (         void  *)&job_q_ind.job_suspended;
  sqlstm.sqinds[29] = (         int  )0;
  sqlstm.sqharm[29] = (unsigned int  )0;
  sqlstm.sqadto[29] = (unsigned short )0;
  sqlstm.sqtdso[29] = (unsigned short )0;
  sqlstm.sqhstv[30] = (         void  *)job_q.restart;
  sqlstm.sqhstl[30] = (unsigned int  )9;
  sqlstm.sqhsts[30] = (         int  )0;
  sqlstm.sqindv[30] = (         void  *)&job_q_ind.restart;
  sqlstm.sqinds[30] = (         int  )0;
  sqlstm.sqharm[30] = (unsigned int  )0;
  sqlstm.sqadto[30] = (unsigned short )0;
  sqlstm.sqtdso[30] = (unsigned short )0;
  sqlstm.sqhstv[31] = (         void  *)job_q.job_class;
  sqlstm.sqhstl[31] = (unsigned int  )2;
  sqlstm.sqhsts[31] = (         int  )0;
  sqlstm.sqindv[31] = (         void  *)&job_q_ind.job_class;
  sqlstm.sqinds[31] = (         int  )0;
  sqlstm.sqharm[31] = (unsigned int  )0;
  sqlstm.sqadto[31] = (unsigned short )0;
  sqlstm.sqtdso[31] = (unsigned short )0;
  sqlstm.sqhstv[32] = (         void  *)job_q.base_dir;
  sqlstm.sqhstl[32] = (unsigned int  )81;
  sqlstm.sqhsts[32] = (         int  )0;
  sqlstm.sqindv[32] = (         void  *)&job_q_ind.base_dir;
  sqlstm.sqinds[32] = (         int  )0;
  sqlstm.sqharm[32] = (unsigned int  )0;
  sqlstm.sqadto[32] = (unsigned short )0;
  sqlstm.sqtdso[32] = (unsigned short )0;
  sqlstm.sqhstv[33] = (         void  *)&job_q.max_job_time_warn;
  sqlstm.sqhstl[33] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[33] = (         int  )0;
  sqlstm.sqindv[33] = (         void  *)&job_q_ind.max_job_time_warn;
  sqlstm.sqinds[33] = (         int  )0;
  sqlstm.sqharm[33] = (unsigned int  )0;
  sqlstm.sqadto[33] = (unsigned short )0;
  sqlstm.sqtdso[33] = (unsigned short )0;
  sqlstm.sqhstv[34] = (         void  *)job_q.debug_mode_yn;
  sqlstm.sqhstl[34] = (unsigned int  )2;
  sqlstm.sqhsts[34] = (         int  )0;
  sqlstm.sqindv[34] = (         void  *)&job_q_ind.debug_mode_yn;
  sqlstm.sqinds[34] = (         int  )0;
  sqlstm.sqharm[34] = (unsigned int  )0;
  sqlstm.sqadto[34] = (unsigned short )0;
  sqlstm.sqtdso[34] = (unsigned short )0;
  sqlstm.sqhstv[35] = (         void  *)&job_q.last_step;
  sqlstm.sqhstl[35] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[35] = (         int  )0;
  sqlstm.sqindv[35] = (         void  *)&job_q_ind.last_step;
  sqlstm.sqinds[35] = (         int  )0;
  sqlstm.sqharm[35] = (unsigned int  )0;
  sqlstm.sqadto[35] = (unsigned short )0;
  sqlstm.sqtdso[35] = (unsigned short )0;
  sqlstm.sqhstv[36] = (         void  *)job_q.last_s_name;
  sqlstm.sqhstl[36] = (unsigned int  )10;
  sqlstm.sqhsts[36] = (         int  )0;
  sqlstm.sqindv[36] = (         void  *)&job_q_ind.last_s_name;
  sqlstm.sqinds[36] = (         int  )0;
  sqlstm.sqharm[36] = (unsigned int  )0;
  sqlstm.sqadto[36] = (unsigned short )0;
  sqlstm.sqtdso[36] = (unsigned short )0;
  sqlstm.sqhstv[37] = (         void  *)job_q.last_g_name;
  sqlstm.sqhstl[37] = (unsigned int  )10;
  sqlstm.sqhsts[37] = (         int  )0;
  sqlstm.sqindv[37] = (         void  *)&job_q_ind.last_g_name;
  sqlstm.sqinds[37] = (         int  )0;
  sqlstm.sqharm[37] = (unsigned int  )0;
  sqlstm.sqadto[37] = (unsigned short )0;
  sqlstm.sqtdso[37] = (unsigned short )0;
  sqlstm.sqhstv[38] = (         void  *)job_q.submitted_file_name;
  sqlstm.sqhstl[38] = (unsigned int  )13;
  sqlstm.sqhsts[38] = (         int  )0;
  sqlstm.sqindv[38] = (         void  *)&job_q_ind.submitted_file_name;
  sqlstm.sqinds[38] = (         int  )0;
  sqlstm.sqharm[38] = (unsigned int  )0;
  sqlstm.sqadto[38] = (unsigned short )0;
  sqlstm.sqtdso[38] = (unsigned short )0;
  sqlstm.sqhstv[39] = (         void  *)job_q.p_msg_sent_yn;
  sqlstm.sqhstl[39] = (unsigned int  )2;
  sqlstm.sqhsts[39] = (         int  )0;
  sqlstm.sqindv[39] = (         void  *)&job_q_ind.p_msg_sent_yn;
  sqlstm.sqinds[39] = (         int  )0;
  sqlstm.sqharm[39] = (unsigned int  )0;
  sqlstm.sqadto[39] = (unsigned short )0;
  sqlstm.sqtdso[39] = (unsigned short )0;
  sqlstm.sqhstv[40] = (         void  *)&job_q.max_job_time_kill;
  sqlstm.sqhstl[40] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[40] = (         int  )0;
  sqlstm.sqindv[40] = (         void  *)&job_q_ind.max_job_time_kill;
  sqlstm.sqinds[40] = (         int  )0;
  sqlstm.sqharm[40] = (unsigned int  )0;
  sqlstm.sqadto[40] = (unsigned short )0;
  sqlstm.sqtdso[40] = (unsigned short )0;
  sqlstm.sqhstv[41] = (         void  *)job_q.max_c_msg_yn;
  sqlstm.sqhstl[41] = (unsigned int  )2;
  sqlstm.sqhsts[41] = (         int  )0;
  sqlstm.sqindv[41] = (         void  *)&job_q_ind.max_c_msg_yn;
  sqlstm.sqinds[41] = (         int  )0;
  sqlstm.sqharm[41] = (unsigned int  )0;
  sqlstm.sqadto[41] = (unsigned short )0;
  sqlstm.sqtdso[41] = (unsigned short )0;
  sqlstm.sqhstv[42] = (         void  *)job_q.stn_dependancy_yn;
  sqlstm.sqhstl[42] = (unsigned int  )2;
  sqlstm.sqhsts[42] = (         int  )0;
  sqlstm.sqindv[42] = (         void  *)&job_q_ind.stn_dependancy_yn;
  sqlstm.sqinds[42] = (         int  )0;
  sqlstm.sqharm[42] = (unsigned int  )0;
  sqlstm.sqadto[42] = (unsigned short )0;
  sqlstm.sqtdso[42] = (unsigned short )0;
  sqlstm.sqhstv[43] = (         void  *)job_q.no_fail_message_yn;
  sqlstm.sqhstl[43] = (unsigned int  )2;
  sqlstm.sqhsts[43] = (         int  )0;
  sqlstm.sqindv[43] = (         void  *)&job_q_ind.no_fail_message_yn;
  sqlstm.sqinds[43] = (         int  )0;
  sqlstm.sqharm[43] = (unsigned int  )0;
  sqlstm.sqadto[43] = (unsigned short )0;
  sqlstm.sqtdso[43] = (unsigned short )0;
  sqlstm.sqhstv[44] = (         void  *)job_q.msg_when_failed;
  sqlstm.sqhstl[44] = (unsigned int  )2;
  sqlstm.sqhsts[44] = (         int  )0;
  sqlstm.sqindv[44] = (         void  *)&job_q_ind.msg_when_failed;
  sqlstm.sqinds[44] = (         int  )0;
  sqlstm.sqharm[44] = (unsigned int  )0;
  sqlstm.sqadto[44] = (unsigned short )0;
  sqlstm.sqtdso[44] = (unsigned short )0;
  sqlstm.sqhstv[45] = (         void  *)&job_q.spawn_algorithm;
  sqlstm.sqhstl[45] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[45] = (         int  )0;
  sqlstm.sqindv[45] = (         void  *)&job_q_ind.spawn_algorithm;
  sqlstm.sqinds[45] = (         int  )0;
  sqlstm.sqharm[45] = (unsigned int  )0;
  sqlstm.sqadto[45] = (unsigned short )0;
  sqlstm.sqtdso[45] = (unsigned short )0;
  sqlstm.sqhstv[46] = (         void  *)&job_q.spawn_parm;
  sqlstm.sqhstl[46] = (unsigned int  )sizeof(short);
  sqlstm.sqhsts[46] = (         int  )0;
  sqlstm.sqindv[46] = (         void  *)&job_q_ind.spawn_parm;
  sqlstm.sqinds[46] = (         int  )0;
  sqlstm.sqharm[46] = (unsigned int  )0;
  sqlstm.sqadto[46] = (unsigned short )0;
  sqlstm.sqtdso[46] = (unsigned short )0;
  sqlstm.sqhstv[47] = (         void  *)job_q.d_station;
  sqlstm.sqhstl[47] = (unsigned int  )180;
  sqlstm.sqhsts[47] = (         int  )0;
  sqlstm.sqindv[47] = (         void  *)&job_q_ind.d_station;
  sqlstm.sqinds[47] = (         int  )0;
  sqlstm.sqharm[47] = (unsigned int  )0;
  sqlstm.sqadto[47] = (unsigned short )0;
  sqlstm.sqtdso[47] = (unsigned short )0;
  sqlstm.sqhstv[48] = (         void  *)job_q.jsgroup;
  sqlstm.sqhstl[48] = (unsigned int  )10;
  sqlstm.sqhsts[48] = (         int  )0;
  sqlstm.sqindv[48] = (         void  *)&job_q_ind.jsgroup;
  sqlstm.sqinds[48] = (         int  )0;
  sqlstm.sqharm[48] = (unsigned int  )0;
  sqlstm.sqadto[48] = (unsigned short )0;
  sqlstm.sqtdso[48] = (unsigned short )0;
  sqlstm.sqhstv[49] = (         void  *)job_server;
  sqlstm.sqhstl[49] = (unsigned int  )10;
  sqlstm.sqhsts[49] = (         int  )0;
  sqlstm.sqindv[49] = (         void  *)0;
  sqlstm.sqinds[49] = (         int  )0;
  sqlstm.sqharm[49] = (unsigned int  )0;
  sqlstm.sqadto[49] = (unsigned short )0;
  sqlstm.sqtdso[49] = (unsigned short )0;
  sqlstm.sqhstv[50] = (         void  *)js_group;
  sqlstm.sqhstl[50] = (unsigned int  )10;
  sqlstm.sqhsts[50] = (         int  )0;
  sqlstm.sqindv[50] = (         void  *)0;
  sqlstm.sqinds[50] = (         int  )0;
  sqlstm.sqharm[50] = (unsigned int  )0;
  sqlstm.sqadto[50] = (unsigned short )0;
  sqlstm.sqtdso[50] = (unsigned short )0;
  sqlstm.sqphsv = sqlstm.sqhstv;
  sqlstm.sqphsl = sqlstm.sqhstl;
  sqlstm.sqphss = sqlstm.sqhsts;
  sqlstm.sqpind = sqlstm.sqindv;
  sqlstm.sqpins = sqlstm.sqinds;
  sqlstm.sqparm = sqlstm.sqharm;
  sqlstm.sqparc = sqlstm.sqharc;
  sqlstm.sqpadto = sqlstm.sqadto;
  sqlstm.sqptdso = sqlstm.sqtdso;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



// End - Hamsha

		l_sqlcode = sqlca.sqlcode;
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		LeaveCriticalSection(&jsnt_sql_lock);

	
		if (l_sqlcode == ORCL_NOT_FOUND)
		{
			debug_log("No Scheduled Jobs");
			break;
		}

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"JOBQ", sqlmsg, " ", NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff, "Error selecting Scheduled Jobs from JOBQ - sqlca.sqlcode=",
						szret, sqlmsg, NULL);
			//sprintf (szbuff, "Error selecting Scheduled Jobs from JOBQ - sqlca.sqlcode=%d, %s", 
			//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log (szbuff);
			return ERR;
		} 

		trim_sql_jobq(&job_q);	

		/*		Even if it thinks it found a record, check the status to make sure */
		if(job_q.status[0] != 'S')      /* status 'S' mean scheduled job */
		{
			debug_log("No scheduled jobs");
			break;
		}
 

		getsystime (&st);           /* get current system date & time    */

		_itoa(st.wMonth, month, 10);
		if(st.wMonth < 10)
			_padl(month, '0', 2);

		_itoa(st.wDay, day, 10);
		if(st.wDay < 10)
			_padl(day, '0', 2);

		_itoa(st.wHour, hour, 10);
		if(st.wHour < 10)
			_padl(hour, '0', 2);

		_itoa(st.wMinute, minute, 10);
		if(st.wMinute < 10)
			_padl(minute, '0', 2);

		_itoa(st.wSecond, second, 10);
		if(st.wSecond < 10)
			_padl(second, '0', 2);


 
		_itoa(st.wYear, year, 10);
		copy_cat(test_d, year, month, day, hour, minute, second, NULL);

		//sprintf(test_d, "%04d%02d%02d%02d%02d%02d", st.wYear, st.wMonth,
		//				st.wDay, st.wHour, st.wMinute, st.wSecond);		
		memset(j_test, 0, sizeof(j_test) );
		memcpy(j_test, job_q.date_time_to_start, sizeof(job_q.date_time_to_start) );
 

		copy_cat(szbuff, "Job: ", job_q.name, " ", j_test, NULL);
		//sprintf(szbuff, "Job: %s %s", job_q.name, j_test);
		debug_log(szbuff);

		/* Is it time to run this job yet? */
		if (strcmp(test_d, j_test) < 0)  /* compare system time against scheduled time.*/
		{
			debug_log("Not time yet");
			break;
		}

 
/*		j_rec.start_stat, 0=Run, 1=On Hold, 2=Prompt Operator, 3=Both */
		if(job_q.start_stat == 1 || job_q.start_stat == 3) 
		{
			debug_log ("Job changed to Hold Queue");
			strcpy(job_q.status, "H");  /* Change to HOLD status */
		}
		else 
		{
			debug_log ("Job changed to Ready Queue");
			strcpy(job_q.status, "R");  /* Change to READY status */
		}

		time(&job_q.pos);
 



 
	   	// Try to Lock the row for updating up to 10 times before Erroring out.
		EnterCriticalSection(&jsnt_sql_lock);

		//for(tries=0; tries < LOCK_TRIES; tries++)
		//{
			/* EXEC SQL SELECT 
				status,
				pos,
				name
			INTO :job_status, :job_pos, job_name
			FROM JOBQ
			WHERE status = 'S'
			AND   to_char(date_time_to_start, 'YYYYMMDDHH24MISS') = :job_q.date_time_to_start
			FOR UPDATE; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 51;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select status ,pos ,name into :b0,:b1,:b2  from JOBQ where\
 (status='S' and to_char(date_time_to_start,'YYYYMMDDHH24MISS')=:b3) for updat\
e ";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )247;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)job_status;
   sqlstm.sqhstl[0] = (unsigned int  )2;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)&job_pos;
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(long);
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)job_name;
   sqlstm.sqhstl[2] = (unsigned int  )10;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)(job_q.date_time_to_start);
   sqlstm.sqhstl[3] = (unsigned int  )15;
   sqlstm.sqhsts[3] = (         int  )0;
   sqlstm.sqindv[3] = (         void  *)0;
   sqlstm.sqinds[3] = (         int  )0;
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


			//FOR UPDATE NOWAIT;
			l_sqlcode = sqlca.sqlcode;
						
   			if(l_sqlcode != ORCL_NO_ERROR)
			{
		//		if(tries < LOCK_TRIES)
		//			Sleep(1000);
		//		else
		//		{
					strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
					LeaveCriticalSection(&jsnt_sql_lock);

					ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
								"JOBQ", sqlmsg, "For Update", NULL);
					_itoa(l_sqlcode, szret, 10);
					copy_cat(szbuff, "Error selecting JOBQ for Update - sqlca.sqlcode=", 
								szret, " ", sqlmsg, NULL);
					//sprintf (szbuff, "Error selecting JOBQ for Update - sqlca.sqlcode=%d, %s", 
					//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
					logit (0, szbuff);
					debug_log (szbuff);
					return ERR;
		//		} 
			}
		//	break;
		//}

		/* EXEC SQL UPDATE JOBQ
			SET status = :job_q.status,	
				pos    = :job_q.pos
			WHERE status = 'S'
			AND   to_char(date_time_to_start, 'YYYYMMDDHH24MISS') = :job_q.date_time_to_start; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 51;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.stmt = "update JOBQ  set status=:b0,pos=:b1 where (status='S' and t\
o_char(date_time_to_start,'YYYYMMDDHH24MISS')=:b2)";
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )278;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlstm.sqhstv[0] = (         void  *)(job_q.status);
  sqlstm.sqhstl[0] = (unsigned int  )2;
  sqlstm.sqhsts[0] = (         int  )0;
  sqlstm.sqindv[0] = (         void  *)0;
  sqlstm.sqinds[0] = (         int  )0;
  sqlstm.sqharm[0] = (unsigned int  )0;
  sqlstm.sqadto[0] = (unsigned short )0;
  sqlstm.sqtdso[0] = (unsigned short )0;
  sqlstm.sqhstv[1] = (         void  *)&(job_q.pos);
  sqlstm.sqhstl[1] = (unsigned int  )sizeof(long);
  sqlstm.sqhsts[1] = (         int  )0;
  sqlstm.sqindv[1] = (         void  *)0;
  sqlstm.sqinds[1] = (         int  )0;
  sqlstm.sqharm[1] = (unsigned int  )0;
  sqlstm.sqadto[1] = (unsigned short )0;
  sqlstm.sqtdso[1] = (unsigned short )0;
  sqlstm.sqhstv[2] = (         void  *)(job_q.date_time_to_start);
  sqlstm.sqhstl[2] = (unsigned int  )15;
  sqlstm.sqhsts[2] = (         int  )0;
  sqlstm.sqindv[2] = (         void  *)0;
  sqlstm.sqinds[2] = (         int  )0;
  sqlstm.sqharm[2] = (unsigned int  )0;
  sqlstm.sqadto[2] = (unsigned short )0;
  sqlstm.sqtdso[2] = (unsigned short )0;
  sqlstm.sqphsv = sqlstm.sqhstv;
  sqlstm.sqphsl = sqlstm.sqhstl;
  sqlstm.sqphss = sqlstm.sqhsts;
  sqlstm.sqpind = sqlstm.sqindv;
  sqlstm.sqpins = sqlstm.sqinds;
  sqlstm.sqparm = sqlstm.sqharm;
  sqlstm.sqparc = sqlstm.sqharc;
  sqlstm.sqpadto = sqlstm.sqadto;
  sqlstm.sqptdso = sqlstm.sqtdso;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



		l_sqlcode = sqlca.sqlcode;

		if(l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			/* EXEC SQL ROLLBACK; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 51;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )305;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_UPDATE", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"JOBQ", sqlmsg, " ", NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"Error during UPDATE of JOBQ table - SQLCA.SQLCODE=", 
						szret, " ", sqlmsg, NULL);
			//sprintf(szbuff, "Error during UPDATE of JOBQ table - SQLCA.SQLCODE=%d, %s", 
			//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log(szbuff);
			return ERR;
		}
	
		/* EXEC SQL COMMIT; */ 

{
  struct sqlexd sqlstm;
  sqlstm.sqlvsn = 13;
  sqlstm.arrsiz = 51;
  sqlstm.sqladtp = &sqladt;
  sqlstm.sqltdsp = &sqltds;
  sqlstm.iters = (unsigned int  )1;
  sqlstm.offset = (unsigned int  )320;
  sqlstm.cud = sqlcud0;
  sqlstm.sqlest = (unsigned char  *)&sqlca;
  sqlstm.sqlety = (unsigned short)4352;
  sqlstm.occurs = (unsigned int  )0;
  sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


		l_sqlcode = sqlca.sqlcode;

		if (l_sqlcode != ORCL_NO_ERROR)
		{
			strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
			/* EXEC SQL ROLLBACK; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 51;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )335;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


			LeaveCriticalSection(&jsnt_sql_lock);

			ifs_custerr("ORC_COMMIT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
						"JOBQ", sqlmsg, NULL);
			_itoa(l_sqlcode, szret, 10);
			copy_cat(szbuff,"ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=",  
						szret, " ", sqlmsg, NULL);
			//sprintf(szbuff, "ERROR: COMMIT after UPDATE of JOBQ table failed: - SQLCA.SQLCODE=%d, %s", 
			//			l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
			logit (0, szbuff);
			debug_log(szbuff);
			return ERR;
		}	

		LeaveCriticalSection(&jsnt_sql_lock);

 
	}
	return SUCCESS;
}


/*********************** check_actives *************************
*                                                              *
* Description: This function checks the active job queue for   *
*  any work to do.                                             *
*                                                              *
* Creation Date: ??/??/??        By: Ron Tanner                *
* Modifiy Date:  07/01/96        By: Mike West                 *
* Modifiy Date:  07/29/99        By: Mike West                 *
*                                                              *
***************************************************************/
int check_actives (void) 
{
	short int status=0;
	short int zero=0;
	short int s_dep;
	short int s_first_time=1;
	short int j_first_time=1;
	short int task_semaphore=0;
	//short int tries;
	unsigned long same_group_job = 0;
	char same_machine_group_name[10];
	char szbuff[300];
	int l_sqlcode;
	char szret[10];
	char sznum[20];
	char sqlmsg[80];

	// WR27164 - Hamsha

	char szcode[10];
	char tempstr[500];

//int errcode;
//char *errmsg;

 
   	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		short int last_step;
		unsigned long job_q_num;
		unsigned char last_s_name[10];
		unsigned char last_g_name[10];
		char job_status[2];			/* A=Active, H=On Hold R=Ready S=Scheduled Y=Completed */
		long job_pos;               /* Position in Queue */
		char job_name[10];
		char job_server[10];
		char js_group[10]; // WR27164 - Hamsha
	/* EXEC SQL END DECLARE SECTION; */ 


 



 
	strcpy(job_server,szjsname);

	EnterCriticalSection(&jsnt_sql_lock);

	// Added for WR27164 on 02/14/2005 - Hamsha

	trimlr(job_server);
	memset(js_group,'\0',sizeof(js_group));


	/* EXEC SQL 
		SELECT trim(jsgroup) 
        INTO   :js_group
		FROM   JOB_SERVER_GROUPS
		WHERE  trim(STATION) = :job_server; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 51;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = "select trim(jsgroup) into :b0  from JOB_SERVER_GROUPS where \
trim(STATION)=:b1";
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )350;
 sqlstm.selerr = (unsigned short)1;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqhstv[0] = (         void  *)js_group;
 sqlstm.sqhstl[0] = (unsigned int  )10;
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)job_server;
 sqlstm.sqhstl[1] = (unsigned int  )10;
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}


	
	l_sqlcode = sqlca.sqlcode;

	LeaveCriticalSection(&jsnt_sql_lock);

	if( (l_sqlcode != ORCL_NO_ERROR) &&  (l_sqlcode != ORCL_NOT_FOUND) )
	{
		strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
		ifs_custerr("ORC_SELECT", __FILE__, (DWORD) __LINE__, IFS_LOG, 
				"JOB_SERVER_GROUPS", sqlmsg, "JS_GROUP", NULL);
		_itoa(l_sqlcode, szcode, 10);
		copy_cat(tempstr, "Error during SELECT FROM JOB_SERVER_GROUPS table - SQLCA.SQLCODE=",
				szcode, sqlmsg, NULL);
		logit (0, tempstr);
		debug_log(tempstr);
		return ERR;

	}

	if (l_sqlcode == ORCL_NOT_FOUND)
		memset(js_group, 0x00, sizeof(js_group));

	trimlr(js_group);

// End - Hamsha

	EnterCriticalSection(&jsnt_sql_lock);

	/* EXEC SQL DECLARE active_job_curs CURSOR FOR 
	 SELECT 
		status,
		pos,
		name,
		no,
		station,
		date_time_entered,
		date_time_started,
		date_time_completed,
		exit_code,
		station_submitting,
		msg_when_started,
		msg_when_done,
		multi_processing,
		date_time_to_start,
		start_stat,
		must_complete_by,
		c_msg_sent_yn,
		must_start_by,
		s_msg_sent_yn,
		msg_to_operator_yn,
		msg_to,
		priority,
		stn_started,
		num_d,
		d_job,
		d_hrs_back,
		d_cmplt,
		d_last_tested,
		orig_start_stat,
		job_suspended,
		restart,
		job_class,
		base_dir,
		max_job_time_warn,
		debug_mode_yn,
		last_step,
		last_s_name,
		last_g_name,
		submitted_file_name,
		p_msg_sent_yn,
		max_job_time_kill,
		max_c_msg_yn,
		stn_dependancy_yn,
		no_fail_message_yn,
		msg_when_failed,
		spawn_algorithm,
		spawn_parm,
		d_station,
		jsgroup // WR27164 - Hamsha
	FROM JOBQ

//Modified for WR27164 on 02/14/2005 - Hamsha

//	WHERE status = 'A'
//	AND   (station is NULL OR station = :job_server)
//	AND   pos >= 0;

	WHERE 
		status = 'A' and 
		((station is NULL and jsgroup is NULL)
		OR  ( TRIM(station) = :job_server )  
		OR  ( TRIM(jsgroup) = :js_group ))
		AND   pos >= 0; */ 


// End - Hamsha

	/* EXEC SQL DECLARE active_step_curs CURSOR FOR 
	 SELECT 
		no,
		step,
		s_name,
		status,
		j_name,
		date_time_started,
		date_time_completed,
		exit_code,
		command_line,
		num_d,
		d_step,
		d_cmplt,
		d_last_tested,
		num_a,
		exit_codes_acceptable,
		job_machine,
		d_group,
		group_name,
		same_machine_flag_yn,
		group_first_step_yn,
		skip_yn,
		beg_console_msg,
		beg_suspend_yn,
		end_console_msg,
		end_suspend_yn,
		send_msg,
		run_if_error,
		status_interval
	FROM STEPQ
	WHERE no = :job_q_num
	AND step >= 0
	AND status <> 'Y'
	ORDER BY step; */ 




	// Open active_job_curs cursor
	/* EXEC SQL OPEN active_job_curs; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 51;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = sq0009;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )373;
 sqlstm.selerr = (unsigned short)0;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqcmod = (unsigned int )0;
 sqlstm.sqhstv[0] = (         void  *)job_server;
 sqlstm.sqhstl[0] = (unsigned int  )10;
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)js_group;
 sqlstm.sqhstl[1] = (unsigned int  )10;
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt(&g_ctx, &sqlctx, &sqlstm, &sqlfpn);
}



	l_sqlcode = sqlca.sqlcode;
	strcpy(sqlmsg, sqlca.sqlerrm.sqlerrmc);
	LeaveCriticalSection(&jsnt_sql_lock);


	if (l_sqlcode != ORCL_NO_ERROR)
	{
		ifs_custerr("ORC_OPENCSR", __FILE__, (DWORD) __LINE__, IFS_LOG, 
					"active_job_curs", sqlmsg, " ", NULL);
		_ltoa((DWORD) __LINE__, sznum, 10);
		_itoa(l_sqlcode, szret, 10);
		copy_cat(szbuff,"Open Cursor for active_job_curs Failed! on line ", sznum, " - SQLCA.SQLCODE=",
					szret, sqlmsg, NULL);
		//sprintf(szbuff, "Open Cursor for %s Failed! on line %ld - SQLCA.SQLCODE=%d, %s", 
		//			"active_job_curs", __LINE__, l_sqlcode, &sqlca.sqlerrm.sqlerrmc);
		logit (0, szbuff);
		debug_log (szbuff);
		return(-1);
	}

	// Fetch into job_q structure using status='A' and pos >= 0
	memset(&job_q, 0, sizeof(job_q) );
	EnterCriticalSection(&jsnt_sql_lock);

	/* EXEC SQL FETCH active_job_curs INTO :job_q:job_q_ind; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 51;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )396;
 sqlstm.selerr = (unsigned short)0;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqfoff = (           int )0;
 sqlstm.sqfmod = (unsigned int )2;
 sqlstm.sqhstv[0] = (         void  *)job_q.status;
 sqlstm.sqhstl[0] = (unsigned int  )2;
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)&job_q_ind.status;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)&job_q.pos;
 sqlstm.sqhstl[1] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)&job_q_ind.pos;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqhstv[2] = (         void  *)job_q.name;
 sqlstm.sqhstl[2] = (unsigned int  )10;
 sqlstm.sqhsts[2] = (         int  )0;
 sqlstm.sqindv[2] = (         void  *)&job_q_ind.name;
 sqlstm.sqinds[2] = (         int  )0;
 sqlstm.sqharm[2] = (unsigned int  )0;
 sqlstm.sqadto[2] = (unsigned short )0;
 sqlstm.sqtdso[2] = (unsigned short )0;
 sqlstm.sqhstv[3] = (         void  *)&job_q.no;
 sqlstm.sqhstl[3] = (unsigned int  )sizeof(long);
 sqlstm.sqhsts[3] = (         int  )0;
 sqlstm.sqindv[3] = (         void  *)&job_q_ind.no;
 sqlstm.sqinds[3] = (         int  )0;
 sqlstm.sqharm[3] = (unsigned int  )0;
 sqlstm.sqadto[3] = (unsigned short )0;
 sqlstm.sqtdso[3] = (unsigned short )0;
 sqlstm.sqhstv[4] = (         void  *)job_q.station;
 sqlstm.sqhstl[4] = (unsigned int  )10;
 sqlstm.sqhsts[4] = (         int  )0;
 sqlstm.sqindv[4] = (         void  *)&job_q_ind.station;
 sqlstm.sqinds[4] = (         int  )0;
 sqlstm.sqharm[4] = (unsigned int  )0;
 sqlstm.sqadto[4] = (unsigned short )0;
 sqlstm.sqtdso[4] = (unsigned short )0;
 sqlstm.sqhstv[5] = (         void  *)job_q.date_time_entered;
 sqlstm.sqhstl[5] = (unsigned int  )15;
 sqlstm.sqhsts[5] = (         int  )0;
 sqlstm.sqindv[5] = (         void  *)&job_q_ind.time_entered;
 sqlstm.sqinds[5] = (         int  )0;
 sqlstm.sqharm[5] = (unsigned int  )0;
 sqlstm.sqadto[5] = (unsigned short )0;
 sqlstm.sqtdso[5] = (unsigned short )0;
 sqlstm.sqhstv[6] = (         void  *)job_q.date_time_started;
 sqlstm.sqhstl[6] = (unsigned int  )15;
 sqlstm.sqhsts[6] = (         int  )0;
 sqlstm.sqindv[6] = (         void  *)&job_q_ind.time_started;
 sqlstm.sqinds[6] = (         int  )0;
 sqlstm.sqharm[6] = (unsigned int  )0;
 sqlstm.sqadto[6] = (unsigned short )0;
 sqlstm.sqtdso[6] = (unsigned short )0;
 sqlstm.sqhstv[7] = (         void  *)job_q.date_time_completed;
 sqlstm.sqhstl[7] = (unsigned int  )15;
 sqlstm.sqhsts[7] = (         int  )0;
 sqlstm.sqindv[7] = (         void  *)&job_q_ind.time_completed;
 sqlstm.sqinds[7] = (         int  )0;
 sqlstm.sqharm[7] = (unsigned int  )0;
 sqlstm.sqadto[7] = (unsigned short )0;
 sqlstm.sqtdso[7] = (unsigned short )0;
 sqlstm.sqhstv[8] = (         void  *)&job_q.exit_code;
 sqlstm.sqhstl[8] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[8] = (         int  )0;
 sqlstm.sqindv[8] = (         void  *)&job_q_ind.exit_code;
 sqlstm.sqinds[8] = (         int  )0;
 sqlstm.sqharm[8] = (unsigned int  )0;
 sqlstm.sqadto[8] = (unsigned short )0;
 sqlstm.sqtdso[8] = (unsigned short )0;
 sqlstm.sqhstv[9] = (         void  *)job_q.station_submitting;
 sqlstm.sqhstl[9] = (unsigned int  )2;
 sqlstm.sqhsts[9] = (         int  )0;
 sqlstm.sqindv[9] = (         void  *)&job_q_ind.station_submitting;
 sqlstm.sqinds[9] = (         int  )0;
 sqlstm.sqharm[9] = (unsigned int  )0;
 sqlstm.sqadto[9] = (unsigned short )0;
 sqlstm.sqtdso[9] = (unsigned short )0;
 sqlstm.sqhstv[10] = (         void  *)job_q.msg_when_started;
 sqlstm.sqhstl[10] = (unsigned int  )2;
 sqlstm.sqhsts[10] = (         int  )0;
 sqlstm.sqindv[10] = (         void  *)&job_q_ind.msg_when_started;
 sqlstm.sqinds[10] = (         int  )0;
 sqlstm.sqharm[10] = (unsigned int  )0;
 sqlstm.sqadto[10] = (unsigned short )0;
 sqlstm.sqtdso[10] = (unsigned short )0;
 sqlstm.sqhstv[11] = (         void  *)job_q.msg_when_done;
 sqlstm.sqhstl[11] = (unsigned int  )2;
 sqlstm.sqhsts[11] = (         int  )0;
 sqlstm.sqindv[11] = (         void  *)&job_q_ind.msg_when_done;
 sqlstm.sqinds[11] = (         int  )0;
 sqlstm.sqharm[11] = (unsigned int  )0;
 sqlstm.sqadto[11] = (unsigned short )0;
 sqlstm.sqtdso[11] = (unsigned short )0;
 sqlstm.sqhstv[12] = (         void  *)job_q.multi_processing;
 sqlstm.sqhstl[12] = (unsigned int  )2;
 sqlstm.sqhsts[12] = (         int  )0;
 sqlstm.sqindv[12] = (         void  *)&job_q_ind.multi_processing;
 sqlstm.sqinds[12] = (         int  )0;
 sqlstm.sqharm[12] = (unsigned int  )0;
 sqlstm.sqadto[12] = (unsigned short )0;
 sqlstm.sqtdso[12] = (unsigned short )0;
 sqlstm.sqhstv[13] = (         void  *)job_q.date_time_to_start;
 sqlstm.sqhstl[13] = (unsigned int  )15;
 sqlstm.sqhsts[13] = (         int  )0;
 sqlstm.sqindv[13] = (         void  *)&job_q_ind.date_time_to_start;
 sqlstm.sqinds[13] = (         int  )0;
 sqlstm.sqharm[13] = (unsigned int  )0;
 sqlstm.sqadto[13] = (unsigned short )0;
 sqlstm.sqtdso[13] = (unsigned short )0;
 sqlstm.sqhstv[14] = (         void  *)&job_q.start_stat;
 sqlstm.sqhstl[14] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[14] = (         int  )0;
 sqlstm.sqindv[14] = (         void  *)&job_q_ind.start_stat;
 sqlstm.sqinds[14] = (         int  )0;
 sqlstm.sqharm[14] = (unsigned int  )0;
 sqlstm.sqadto[14] = (unsigned short )0;
 sqlstm.sqtdso[14] = (unsigned short )0;
 sqlstm.sqhstv[15] = (         void  *)job_q.must_complete_by;
 sqlstm.sqhstl[15] = (unsigned int  )5;
 sqlstm.sqhsts[15] = (         int  )0;
 sqlstm.sqindv[15] = (         void  *)&job_q_ind.must_complete_by;
 sqlstm.sqinds[15] = (         int  )0;
 sqlstm.sqharm[15] = (unsigned int  )0;
 sqlstm.sqadto[15] = (unsigned short )0;
 sqlstm.sqtdso[15] = (unsigned short )0;
 sqlstm.sqhstv[16] = (         void  *)job_q.c_msg_sent_yn;
 sqlstm.sqhstl[16] = (unsigned int  )2;
 sqlstm.sqhsts[16] = (         int  )0;
 sqlstm.sqindv[16] = (         void  *)&job_q_ind.c_msg_sent_yn;
 sqlstm.sqinds[16] = (         int  )0;
 sqlstm.sqharm[16] = (unsigned int  )0;
 sqlstm.sqadto[16] = (unsigned short )0;
 sqlstm.sqtdso[16] = (unsigned short )0;
 sqlstm.sqhstv[17] = (         void  *)job_q.must_start_by;
 sqlstm.sqhstl[17] = (unsigned int  )5;
 sqlstm.sqhsts[17] = (         int  )0;
 sqlstm.sqindv[17] = (         void  *)&job_q_ind.must_start_by;
 sqlstm.sqinds[17] = (         int  )0;
 sqlstm.sqharm[17] = (unsigned int  )0;
 sqlstm.sqadto[17] = (unsigned short )0;
 sqlstm.sqtdso[17] = (unsigned short )0;
 sqlstm.sqhstv[18] = (         void  *)job_q.s_msg_sent_yn;
 sqlstm.sqhstl[18] = (unsigned int  )2;
 sqlstm.sqhsts[18] = (         int  )0;
 sqlstm.sqindv[18] = (         void  *)&job_q_ind.s_msg_sent_yn;
 sqlstm.sqinds[18] = (         int  )0;
 sqlstm.sqharm[18] = (unsigned int  )0;
 sqlstm.sqadto[18] = (unsigned short )0;
 sqlstm.sqtdso[18] = (unsigned short )0;
 sqlstm.sqhstv[19] = (         void  *)job_q.msg_to_operator_yn;
 sqlstm.sqhstl[19] = (unsigned int  )2;
 sqlstm.sqhsts[19] = (         int  )0;
 sqlstm.sqindv[19] = (         void  *)&job_q_ind.msg_to_operator_yn;
 sqlstm.sqinds[19] = (         int  )0;
 sqlstm.sqharm[19] = (unsigned int  )0;
 sqlstm.sqadto[19] = (unsigned short )0;
 sqlstm.sqtdso[19] = (unsigned short )0;
 sqlstm.sqhstv[20] = (         void  *)job_q.msg_to;
 sqlstm.sqhstl[20] = (unsigned int  )31;
 sqlstm.sqhsts[20] = (         int  )0;
 sqlstm.sqindv[20] = (         void  *)&job_q_ind.msg_to;
 sqlstm.sqinds[20] = (         int  )0;
 sqlstm.sqharm[20] = (unsigned int  )0;
 sqlstm.sqadto[20] = (unsigned short )0;
 sqlstm.sqtdso[20] = (unsigned short )0;
 sqlstm.sqhstv[21] = (         void  *)&job_q.priority;
 sqlstm.sqhstl[21] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[21] = (         int  )0;
 sqlstm.sqindv[21] = (         void  *)&job_q_ind.priority;
 sqlstm.sqinds[21] = (         int  )0;
 sqlstm.sqharm[21] = (unsigned int  )0;
 sqlstm.sqadto[21] = (unsigned short )0;
 sqlstm.sqtdso[21] = (unsigned short )0;
 sqlstm.sqhstv[22] = (         void  *)job_q.stn_started;
 sqlstm.sqhstl[22] = (unsigned int  )10;
 sqlstm.sqhsts[22] = (         int  )0;
 sqlstm.sqindv[22] = (         void  *)&job_q_ind.stn_started;
 sqlstm.sqinds[22] = (         int  )0;
 sqlstm.sqharm[22] = (unsigned int  )0;
 sqlstm.sqadto[22] = (unsigned short )0;
 sqlstm.sqtdso[22] = (unsigned short )0;
 sqlstm.sqhstv[23] = (         void  *)&job_q.num_d;
 sqlstm.sqhstl[23] = (unsigned int  )sizeof(short);
 sqlstm.sqhsts[23] = (         int  )0;
 sqlstm.sqindv[23] = (         void  *)&job_q_ind.num_d;
 sqlstm.sqinds[23] = (         int  )0;
 sqlstm.sqharm[23] = (unsigned int  )0;
 sqlstm.sqadto[23] = (unsigned short )0;
 sqlstm.sqtdso[23] = (unsigned short )0;
 sqlstm.sqhstv[24] = (         void  *)job_q.d_job;
 sqlstm.sqhstl[24] = (unsigned int  )180;
 sqlstm.sqhsts[24] = (         int  )0;
 sqlstm.sqindv[24] = (         void  *)&job_q_ind.d_job;
 sqlstm.sqinds[24] = (         int  )0;
 sqlstm.sqharm[24] = (unsigned int  )0;
 sqlstm.sqadto[24] = (unsigned short )0;
 sqlstm.sqtdso[24] = (unsigned short )0;
 sqlstm.sqhstv[25] = (         void  *)job_q.d_hrs_back;
 sqlstm.sqhstl[25] = (unsigned int  )100;
 sqlstm.sqhsts[25] = (         int  )0;
 sqlstm.sqindv[25] = (         void  *)&job_q_ind.d_hrs_back;
 sqlstm.sqinds[25] = (         int  )0;
 sqlstm.sqharm[25] = (unsigned int  )0;
 sqlstm.sqadto[25] = (unsigned short )0;
 sqlstm.sqtdso[25] = (unsigned short )0;
 sqlstm.sqhstv[26] = (         void  *)job_q.d_cmplt;
 sqlstm.sqhstl[26] = (unsigned int  )20;
 sqlstm.sqhsts[26] = (         int  )0;
 sqlstm.sqindv[26] = (         void  *)&job_q_ind.d_cmplt;
 sqlstm.sqinds[26] = (         int  )0;
 sqlstm.sqharm[26] = (unsigned int  )0;
 sqlstm.sqadto[26] = (unsigned short )0;
 sqlstm.sqtdso[26] = (unsigned short )0;
 sqlstm.sqhstv[27] = (         void  *)job_q.d_last_tested;
 sqlstm.sqhstl[27] = (unsigned int  )200;
 sqlstm.sqhsts[27] = (         int  )0;
 sqlstm.sqindv[27] = (         void  *)&job_q_ind.d_last_tested;
 sqlstm.sqinds[27] = (         int  