 int  )1;
    sqlstm.offset = (unsigned int  )288;
    sqlstm.cud = sqlcud0;
    sqlstm.sqlest = (unsigned char  *)&sqlca;
    sqlstm.sqlety = (unsigned short)4352;
    sqlstm.occurs = (unsigned int  )0;
    sqlstm.sqhstv[0] = (         void  *)&h_new_status;
    sqlstm.sqhstl[0] = (unsigned int  )1;
    sqlstm.sqhsts[0] = (         int  )0;
    sqlstm.sqindv[0] = (         void  *)0;
    sqlstm.sqinds[0] = (         int  )0;
    sqlstm.sqharm[0] = (unsigned int  )0;
    sqlstm.sqadto[0] = (unsigned short )0;
    sqlstm.sqtdso[0] = (unsigned short )0;
    sqlstm.sqhstv[1] = (         void  *)h_fi_rt;
    sqlstm.sqhstl[1] = (unsigned int  )10;
    sqlstm.sqhsts[1] = (         int  )0;
    sqlstm.sqindv[1] = (         void  *)0;
    sqlstm.sqinds[1] = (         int  )0;
    sqlstm.sqharm[1] = (unsigned int  )0;
    sqlstm.sqadto[1] = (unsigned short )0;
    sqlstm.sqtdso[1] = (unsigned short )0;
    sqlstm.sqhstv[2] = (         void  *)&h_fsch_id;
    sqlstm.sqhstl[2] = (unsigned int  )sizeof(double);
    sqlstm.sqhsts[2] = (         int  )0;
    sqlstm.sqindv[2] = (         void  *)0;
    sqlstm.sqinds[2] = (         int  )0;
    sqlstm.sqharm[2] = (unsigned int  )0;
    sqlstm.sqadto[2] = (unsigned short )0;
    sqlstm.sqtdso[2] = (unsigned short )0;
    sqlstm.sqphsv = sqlstm.sqhstv;
    sqlstm.sqphsl = sqlstm.sqhstl;
    sqlstm.sqphss = sqlstm.sqhsts;
    sqlstm.sqpind = sqlstm.sqindv;
    sqlstm.sqpins = sqlstm.sqinds;
    sqlstm.sqparm = sqlstm.sqharm;
    sqlstm.sqparc = sqlstm.sqharc;
    sqlstm.sqpadto = sqlstm.sqadto;
    sqlstm.sqptdso = sqlstm.sqtdso;
    sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

 
   }

   if (sqlca.sqlcode == ORCL_NO_ERROR)
   {  /* if update successful */
      /* EXEC SQL COMMIT WORK; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 4;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )315;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

            /* commit update work */
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
         ifs_fatal("ORC_COMMIT",
                     __FILE__, (DWORD)__LINE__, IFS_LOG,
                     g_orcl_etext_buf,
                     g_fi_info,
                     NULL);
         paint_task_line(0, "Unable to Commit Changes");
         exit(1);
      }
      return (0);          /* return SUCCESS */
   }
   else
   {                          
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
      gpszIFSMsg = ifs_warning("ORC_UPDATE",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "FILE_SCH",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
      return (-1);         /* return ERROR */
   }
} /* end file_sch_set_status() */


/*********************** id_input_file *****************************************
* Description:                                                                 *
*     Attempts to identify an achinput file by finding a file_id record whose  *
* non-null criteria fields match the corresponing fields in the file’s ‘1’     *
* record.  If success then it...                                               *
*  1. Sets *file_id = found file_id.                                           *
*  2. If the file contained a special header but the matching file_id was not  *
*     defined to expect one then sets the *ynRejectPtr = ‘Y’ else ‘N’.         *
*  3. Sets the *wRecSizePtr = 94 or 96 depending on whether or not there are   *
*     CR/LF’s at end of records.                                               *
*  4. Returns True.                                                            *
*                                                                              *
*  If unsuccessful then it Returns False                                       *
*                                                                              *
* Creation Date:  06/25/1996  By: Troy Clark                                   *
* Modified Date:  07/09/1996  By: George Lin                                   *
*******************************************************************************/
int id_input_file(char *rec_one, char *fi_rt, FILE *file_ptr, 
               char *file_name_str, double *file_id, 
               char* reject_yn, int* rec_size)
{
   long  offset_to_one;       /* offset to one rec    */
   long  hdr_yn;              /* Was there a special header not indicated */
   char  temp_rec[96];        /* temporary record        */
   short rec_len;             /* record length        */
   short rec_idx;             /* record index            */
   short fld_idx;             /* field index          */

   typedef struct nacha_one_rec_tag{   /* struct for nacha one rec */
      char rec_type[1];
      char priority_code[2];
      char imm_dest[10];
      char imm_origin[10];
      char file_creat_yymmdd[6];
      char file_creat_hhmm[4];
      char file_id_mod[1];
      char rec_size[3];
      char block_fact[2];
      char format_code[1];
      char imm_dest_name[23];
      char imm_origin_name[23];
      char ref_code[8];
   } nacha_one_rec;

   nacha_one_rec  one[1];     /* record for nacha one rec */

   /* EXEC SQL BEGIN DECLARE SECTION; */ 
  /* declare host var */
      char     h_fi_rt[10];
      char     h_imm_origin[11]; 
      char     h_imm_origin_name[24];
      char     h_priority_code[3];
      char     h_imm_dst[11];
      char     h_file_creat_yymmdd[7];
      char     h_file_creat_hhmm[5];
      char     h_file_id_mod[2];
      char     h_format_code[2];
      char     h_imm_dst_name[24];
      char     h_ref_code[9];
      double   h_file_id = 0;       
      char     h_spec_hdr_rec_yn[2];
      char     h_file_on_hold_yn[2];
      char     h_foreign_origin_yn[2];
      char     h_hold_if_sch_err_yn[2];
      char     h_hold_if_batch_err_yn[2];
      char     h_hold_if_entry_err_yn[2];
      char     h_test_file_yn[2];
      char     h_corp_orig_id[11];
      double   h_edit_prof_id = 0;
      double   h_edit_err_threshhold = 0;
      double   h_risk_prof_id = 0;
      char     h_bal_file_yn[2];
      short    h_risk_prof_ind = 0;
   /* EXEC SQL END DECLARE SECTION; */ 


   /* Initialization. We must initialize the variables before they are passed */
   /* into the sp_get_file_id() function, or we'll get an oracle error.       */

   h_fi_rt[0] = 0;
   h_imm_origin[0] = 0; 
   h_imm_origin_name[0] = 0;
   h_priority_code[0] = 0;
   h_imm_dst[0] = 0;
   h_file_creat_yymmdd[0] = 0;
   h_file_creat_hhmm[0] = 0;
   h_file_id_mod[0] = 0;
   h_format_code[0] = 0;
   h_imm_dst_name[0] = 0;
   h_ref_code[0] = 0;
   h_spec_hdr_rec_yn[0] = 0;
   h_file_on_hold_yn[0] = 0;
   h_foreign_origin_yn[0] = 0;
   h_hold_if_sch_err_yn[0] = 0;
   h_hold_if_batch_err_yn[0] = 0;
   h_hold_if_entry_err_yn[0] = 0;
   h_test_file_yn[0] = 0;
   h_corp_orig_id[0] = 0;
   h_bal_file_yn[0] = 0;


   strcpy(h_fi_rt, fi_rt);

   /* Basically, you find the one_rec_offset, read the one record, pass the   */
   /* criteria fields from the one_rec to the stored proc sp_find_file_id()   */
   /* which sets two arg values -- file_id and has_spec_hdr_rec_yn that       */
   /* represent the matching file_id and the value of its has_spec_hdr_rec_yn */
   /* field. File_id will be 0 if no match is found. The process of searching */
   /* for a valid 1-record will continue until either an EOF occurs or a      */
   /* valid one record is found.                                              */

      offset_to_one = one_rec_offset(file_ptr, file_name_str, rec_size);
      if (offset_to_one == -1)   /* error has found */
         return(0);

   /* Save the offset_to_one for use in checking if the file is rejected      */
      hdr_yn = offset_to_one;


   /*//////////////////////////////////////////////////////////////////*/
   /*                                                                  */
   /*Cycle through the file until a "valid" one record or EOF is found */
   /*                                                                  */
   /*//////////////////////////////////////////////////////////////////*/

   do
   {
      /* SEEK_SET means to move the file pointer offset bytes from the        */
      /* beginning of the file.                                               */
      if (fseek (file_ptr, offset_to_one, SEEK_SET) != OK)
      {
         gpszIFSMsg = ifs_fatal("FILESEEK", 
                                 __FILE__, (DWORD)__LINE__, IFS_LOG,
                                 file_name_str, 
                                 _itoa(_doserrno, gs_scratch, 10),
                                 NULL);
         paint_task_line(0, "fseek failed in id_input_file()!");
         do_exit(1);
      }
      
      if (*rec_size == 96)
      {
         fgets(temp_rec, 97, file_ptr);   /* fgets should be used for rec_size = 96 */
         trimlr(temp_rec);
         rec_len = strlen(temp_rec) - 1;
            
         strncpy(h_priority_code,      temp_rec+1,  2);
         strncpy(h_imm_dst,            temp_rec+3,  10);
         strncpy(h_imm_origin,         temp_rec+13, 10);
         strncpy(h_file_creat_yymmdd,  temp_rec+23, 6);
         strncpy(h_file_creat_hhmm,    temp_rec+29, 4);
         strncpy(h_file_id_mod,        temp_rec+33, 1);
         strncpy(h_format_code,        temp_rec+39, 1);

         h_priority_code      [2]   = 0;
         h_imm_dst            [10]  = 0;
         h_imm_origin         [10]  = 0;
         h_file_creat_yymmdd  [6]   = 0;
         h_file_creat_hhmm    [4]   = 0;
         h_file_id_mod        [1]   = 0;
         h_format_code        [1]   = 0;
         
         h_imm_dst_name       [0]   = 0;
         h_imm_origin_name    [0]   = 0;
         h_ref_code           [0]   = 0;

         /* Note:                                                             */
         /*   h_imm_dst_name, h_imm_origin_name, h_ref_code may or may not    */
         /* exist. That is why we have to parse each separately, see below.   */

         if (rec_len >= 41)
         {
            memset(h_imm_dst_name, ' ', 23);
         
            rec_idx = 40;
            fld_idx = 0;
            
            while (  (rec_idx <= 62) && (temp_rec[rec_idx] != 0) &&
                     (temp_rec[rec_idx] != '\n') && (temp_rec[rec_idx] != '\r')
                  )
               h_imm_dst_name[fld_idx++] = temp_rec[rec_idx++];

            h_imm_dst_name[23]   = 0;
         }
         
         if (rec_len >= 64)
         {
            memset(h_imm_origin_name, ' ', 23);
            rec_idx = 63;
            fld_idx = 0;
               
            while (  (rec_idx <= 85) && (temp_rec[rec_idx] != 0) && 
                     (temp_rec[rec_idx] != '\n') && (temp_rec[rec_idx] != '\r')
                  )
               h_imm_origin_name[fld_idx++] = temp_rec[rec_idx++];

            h_imm_origin_name[23] = 0;
         }
         
         if (rec_len >= 86)
         {
            memset(h_ref_code, ' ', 8);
            rec_idx = 86;
            fld_idx = 0;
            while (  (rec_idx <= 93) && (temp_rec[rec_idx] != 0) &&
                     (temp_rec[rec_idx] != '\n') && (temp_rec[rec_idx] != '\r')
                  )
               h_ref_code[fld_idx++] = temp_rec[rec_idx++];

            h_ref_code[8]  = 0;
         }
      }
      else 
      {
         if (fread (one, sizeof(struct nacha_one_rec_tag), 1, file_ptr) <= 0)
         {
            gpszIFSMsg = ifs_fatal("FILEREAD", 
                                    __FILE__,(DWORD)__LINE__,IFS_LOG,
                                    file_name_str, 
                                    _itoa(_doserrno, gs_scratch, 10),
                                    NULL);  
            return -1;
         }
         
         move(h_imm_origin,      10,      one[0].imm_origin,         1);
         move(h_priority_code,    2,      one[0].priority_code,      1);
         move(h_imm_dst,         10,      one[0].imm_dest,        1);   
         move(h_file_creat_yymmdd,6,      one[0].file_creat_yymmdd,  1);
         move(h_file_creat_hhmm,  4,      one[0].file_creat_hhmm,    1);
         move(h_file_id_mod,      1,      one[0].file_id_mod,        1);
         move(h_format_code,      1,      one[0].format_code,        1);
         move(h_imm_dst_name, 23,      one[0].imm_dest_name,      1);
         move(h_imm_origin_name, 23,      one[0].imm_origin_name,    1);
         move(h_ref_code,     8,    one[0].ref_code,        1);
      }

      copy_cat(rec_one, h_imm_origin, h_priority_code, h_imm_dst,
               h_file_creat_yymmdd, h_file_creat_hhmm,
               h_file_id_mod, h_format_code, h_imm_dst_name,
               h_imm_origin_name, h_ref_code, NULL);

      /* EXEC SQL EXECUTE
      BEGIN
         sp_get_file_id(:h_fi_rt, :h_imm_origin, :h_priority_code,
            :h_imm_dst, :h_file_creat_yymmdd, :h_file_creat_hhmm,
            :h_file_id_mod, :h_format_code, :h_imm_dst_name,
            :h_imm_origin_name, :h_ref_code, :h_file_id,
            :h_file_on_hold_yn, :h_foreign_origin_yn,
            :h_hold_if_sch_err_yn, :h_hold_if_batch_err_yn, 
            :h_hold_if_entry_err_yn, :h_spec_hdr_rec_yn,
            :h_test_file_yn, :h_corp_orig_id, :h_edit_prof_id,
            :h_edit_err_threshhold, :h_risk_prof_id:h_risk_prof_ind, :h_bal_file_yn);
      END;
      END-EXEC; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 24;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.stmt = "begin sp_get_file_id ( :h_fi_rt , :h_imm_origin , :h_pr\
iority_code , :h_imm_dst , :h_file_creat_yymmdd , :h_file_creat_hhmm , :h_file\
_id_mod , :h_format_code , :h_imm_dst_name , :h_imm_origin_name , :h_ref_code \
, :h_file_id , :h_file_on_hold_yn , :h_foreign_origin_yn , :h_hold_if_sch_err_\
yn , :h_hold_if_batch_err_yn , :h_hold_if_entry_err_yn , :h_spec_hdr_rec_yn , \
:h_test_file_yn , :h_corp_orig_id , :h_edit_prof_id , :h_edit_err_threshhold ,\
 :h_risk_prof_id:h_risk_prof_ind , :h_bal_file_yn ) ; END ;";
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )330;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlstm.sqhstv[0] = (         void  *)h_fi_rt;
      sqlstm.sqhstl[0] = (unsigned int  )10;
      sqlstm.sqhsts[0] = (         int  )0;
      sqlstm.sqindv[0] = (         void  *)0;
      sqlstm.sqinds[0] = (         int  )0;
      sqlstm.sqharm[0] = (unsigned int  )0;
      sqlstm.sqadto[0] = (unsigned short )0;
      sqlstm.sqtdso[0] = (unsigned short )0;
      sqlstm.sqhstv[1] = (         void  *)h_imm_origin;
      sqlstm.sqhstl[1] = (unsigned int  )11;
      sqlstm.sqhsts[1] = (         int  )0;
      sqlstm.sqindv[1] = (         void  *)0;
      sqlstm.sqinds[1] = (         int  )0;
      sqlstm.sqharm[1] = (unsigned int  )0;
      sqlstm.sqadto[1] = (unsigned short )0;
      sqlstm.sqtdso[1] = (unsigned short )0;
      sqlstm.sqhstv[2] = (         void  *)h_priority_code;
      sqlstm.sqhstl[2] = (unsigned int  )3;
      sqlstm.sqhsts[2] = (         int  )0;
      sqlstm.sqindv[2] = (         void  *)0;
      sqlstm.sqinds[2] = (         int  )0;
      sqlstm.sqharm[2] = (unsigned int  )0;
      sqlstm.sqadto[2] = (unsigned short )0;
      sqlstm.sqtdso[2] = (unsigned short )0;
      sqlstm.sqhstv[3] = (         void  *)h_imm_dst;
      sqlstm.sqhstl[3] = (unsigned int  )11;
      sqlstm.sqhsts[3] = (         int  )0;
      sqlstm.sqindv[3] = (         void  *)0;
      sqlstm.sqinds[3] = (         int  )0;
      sqlstm.sqharm[3] = (unsigned int  )0;
      sqlstm.sqadto[3] = (unsigned short )0;
      sqlstm.sqtdso[3] = (unsigned short )0;
      sqlstm.sqhstv[4] = (         void  *)h_file_creat_yymmdd;
      sqlstm.sqhstl[4] = (unsigned int  )7;
      sqlstm.sqhsts[4] = (         int  )0;
      sqlstm.sqindv[4] = (         void  *)0;
      sqlstm.sqinds[4] = (         int  )0;
      sqlstm.sqharm[4] = (unsigned int  )0;
      sqlstm.sqadto[4] = (unsigned short )0;
      sqlstm.sqtdso[4] = (unsigned short )0;
      sqlstm.sqhstv[5] = (         void  *)h_file_creat_hhmm;
      sqlstm.sqhstl[5] = (unsigned int  )5;
      sqlstm.sqhsts[5] = (         int  )0;
      sqlstm.sqindv[5] = (         void  *)0;
      sqlstm.sqinds[5] = (         int  )0;
      sqlstm.sqharm[5] = (unsigned int  )0;
      sqlstm.sqadto[5] = (unsigned short )0;
      sqlstm.sqtdso[5] = (unsigned short )0;
      sqlstm.sqhstv[6] = (         void  *)h_file_id_mod;
      sqlstm.sqhstl[6] = (unsigned int  )2;
      sqlstm.sqhsts[6] = (         int  )0;
      sqlstm.sqindv[6] = (         void  *)0;
      sqlstm.sqinds[6] = (         int  )0;
      sqlstm.sqharm[6] = (unsigned int  )0;
      sqlstm.sqadto[6] = (unsigned short )0;
      sqlstm.sqtdso[6] = (unsigned short )0;
      sqlstm.sqhstv[7] = (         void  *)h_format_code;
      sqlstm.sqhstl[7] = (unsigned int  )2;
      sqlstm.sqhsts[7] = (         int  )0;
      sqlstm.sqindv[7] = (         void  *)0;
      sqlstm.sqinds[7] = (         int  )0;
      sqlstm.sqharm[7] = (unsigned int  )0;
      sqlstm.sqadto[7] = (unsigned short )0;
      sqlstm.sqtdso[7] = (unsigned short )0;
      sqlstm.sqhstv[8] = (         void  *)h_imm_dst_name;
      sqlstm.sqhstl[8] = (unsigned int  )24;
      sqlstm.sqhsts[8] = (         int  )0;
      sqlstm.sqindv[8] = (         void  *)0;
      sqlstm.sqinds[8] = (         int  )0;
      sqlstm.sqharm[8] = (unsigned int  )0;
      sqlstm.sqadto[8] = (unsigned short )0;
      sqlstm.sqtdso[8] = (unsigned short )0;
      sqlstm.sqhstv[9] = (         void  *)h_imm_origin_name;
      sqlstm.sqhstl[9] = (unsigned int  )24;
      sqlstm.sqhsts[9] = (         int  )0;
      sqlstm.sqindv[9] = (         void  *)0;
      sqlstm.sqinds[9] = (         int  )0;
      sqlstm.sqharm[9] = (unsigned int  )0;
      sqlstm.sqadto[9] = (unsigned short )0;
      sqlstm.sqtdso[9] = (unsigned short )0;
      sqlstm.sqhstv[10] = (         void  *)h_ref_code;
      sqlstm.sqhstl[10] = (unsigned int  )9;
      sqlstm.sqhsts[10] = (         int  )0;
      sqlstm.sqindv[10] = (         void  *)0;
      sqlstm.sqinds[10] = (         int  )0;
      sqlstm.sqharm[10] = (unsigned int  )0;
      sqlstm.sqadto[10] = (unsigned short )0;
      sqlstm.sqtdso[10] = (unsigned short )0;
      sqlstm.sqhstv[11] = (         void  *)&h_file_id;
      sqlstm.sqhstl[11] = (unsigned int  )sizeof(double);
      sqlstm.sqhsts[11] = (         int  )0;
      sqlstm.sqindv[11] = (         void  *)0;
      sqlstm.sqinds[11] = (         int  )0;
      sqlstm.sqharm[11] = (unsigned int  )0;
      sqlstm.sqadto[11] = (unsigned short )0;
      sqlstm.sqtdso[11] = (unsigned short )0;
      sqlstm.sqhstv[12] = (         void  *)h_file_on_hold_yn;
      sqlstm.sqhstl[12] = (unsigned int  )2;
      sqlstm.sqhsts[12] = (         int  )0;
      sqlstm.sqindv[12] = (         void  *)0;
      sqlstm.sqinds[12] = (         int  )0;
      sqlstm.sqharm[12] = (unsigned int  )0;
      sqlstm.sqadto[12] = (unsigned short )0;
      sqlstm.sqtdso[12] = (unsigned short )0;
      sqlstm.sqhstv[13] = (         void  *)h_foreign_origin_yn;
      sqlstm.sqhstl[13] = (unsigned int  )2;
      sqlstm.sqhsts[13] = (         int  )0;
      sqlstm.sqindv[13] = (         void  *)0;
      sqlstm.sqinds[13] = (         int  )0;
      sqlstm.sqharm[13] = (unsigned int  )0;
      sqlstm.sqadto[13] = (unsigned short )0;
      sqlstm.sqtdso[13] = (unsigned short )0;
      sqlstm.sqhstv[14] = (         void  *)h_hold_if_sch_err_yn;
      sqlstm.sqhstl[14] = (unsigned int  )2;
      sqlstm.sqhsts[14] = (         int  )0;
      sqlstm.sqindv[14] = (         void  *)0;
      sqlstm.sqinds[14] = (         int  )0;
      sqlstm.sqharm[14] = (unsigned int  )0;
      sqlstm.sqadto[14] = (unsigned short )0;
      sqlstm.sqtdso[14] = (unsigned short )0;
      sqlstm.sqhstv[15] = (         void  *)h_hold_if_batch_err_yn;
      sqlstm.sqhstl[15] = (unsigned int  )2;
      sqlstm.sqhsts[15] = (         int  )0;
      sqlstm.sqindv[15] = (         void  *)0;
      sqlstm.sqinds[15] = (         int  )0;
      sqlstm.sqharm[15] = (unsigned int  )0;
      sqlstm.sqadto[15] = (unsigned short )0;
      sqlstm.sqtdso[15] = (unsigned short )0;
      sqlstm.sqhstv[16] = (         void  *)h_hold_if_entry_err_yn;
      sqlstm.sqhstl[16] = (unsigned int  )2;
      sqlstm.sqhsts[16] = (         int  )0;
      sqlstm.sqindv[16] = (         void  *)0;
      sqlstm.sqinds[16] = (         int  )0;
      sqlstm.sqharm[16] = (unsigned int  )0;
      sqlstm.sqadto[16] = (unsigned short )0;
      sqlstm.sqtdso[16] = (unsigned short )0;
      sqlstm.sqhstv[17] = (         void  *)h_spec_hdr_rec_yn;
      sqlstm.sqhstl[17] = (unsigned int  )2;
      sqlstm.sqhsts[17] = (         int  )0;
      sqlstm.sqindv[17] = (         void  *)0;
      sqlstm.sqinds[17] = (         int  )0;
      sqlstm.sqharm[17] = (unsigned int  )0;
      sqlstm.sqadto[17] = (unsigned short )0;
      sqlstm.sqtdso[17] = (unsigned short )0;
      sqlstm.sqhstv[18] = (         void  *)h_test_file_yn;
      sqlstm.sqhstl[18] = (unsigned int  )2;
      sqlstm.sqhsts[18] = (         int  )0;
      sqlstm.sqindv[18] = (         void  *)0;
      sqlstm.sqinds[18] = (         int  )0;
      sqlstm.sqharm[18] = (unsigned int  )0;
      sqlstm.sqadto[18] = (unsigned short )0;
      sqlstm.sqtdso[18] = (unsigned short )0;
      sqlstm.sqhstv[19] = (         void  *)h_corp_orig_id;
      sqlstm.sqhstl[19] = (unsigned int  )11;
      sqlstm.sqhsts[19] = (         int  )0;
      sqlstm.sqindv[19] = (         void  *)0;
      sqlstm.sqinds[19] = (         int  )0;
      sqlstm.sqharm[19] = (unsigned int  )0;
      sqlstm.sqadto[19] = (unsigned short )0;
      sqlstm.sqtdso[19] = (unsigned short )0;
      sqlstm.sqhstv[20] = (         void  *)&h_edit_prof_id;
      sqlstm.sqhstl[20] = (unsigned int  )sizeof(double);
      sqlstm.sqhsts[20] = (         int  )0;
      sqlstm.sqindv[20] = (         void  *)0;
      sqlstm.sqinds[20] = (         int  )0;
      sqlstm.sqharm[20] = (unsigned int  )0;
      sqlstm.sqadto[20] = (unsigned short )0;
      sqlstm.sqtdso[20] = (unsigned short )0;
      sqlstm.sqhstv[21] = (         void  *)&h_edit_err_threshhold;
      sqlstm.sqhstl[21] = (unsigned int  )sizeof(double);
      sqlstm.sqhsts[21] = (         int  )0;
      sqlstm.sqindv[21] = (         void  *)0;
      sqlstm.sqinds[21] = (         int  )0;
      sqlstm.sqharm[21] = (unsigned int  )0;
      sqlstm.sqadto[21] = (unsigned short )0;
      sqlstm.sqtdso[21] = (unsigned short )0;
      sqlstm.sqhstv[22] = (         void  *)&h_risk_prof_id;
      sqlstm.sqhstl[22] = (unsigned int  )sizeof(double);
      sqlstm.sqhsts[22] = (         int  )0;
      sqlstm.sqindv[22] = (         void  *)&h_risk_prof_ind;
      sqlstm.sqinds[22] = (         int  )0;
      sqlstm.sqharm[22] = (unsigned int  )0;
      sqlstm.sqadto[22] = (unsigned short )0;
      sqlstm.sqtdso[22] = (unsigned short )0;
      sqlstm.sqhstv[23] = (         void  *)h_bal_file_yn;
      sqlstm.sqhstl[23] = (unsigned int  )2;
      sqlstm.sqhsts[23] = (         int  )0;
      sqlstm.sqindv[23] = (         void  *)0;
      sqlstm.sqinds[23] = (         int  )0;
      sqlstm.sqharm[23] = (unsigned int  )0;
      sqlstm.sqadto[23] = (unsigned short )0;
      sqlstm.sqtdso[23] = (unsigned short )0;
      sqlstm.sqphsv = sqlstm.sqhstv;
      sqlstm.sqphsl = sqlstm.sqhstl;
      sqlstm.sqphss = sqlstm.sqhsts;
      sqlstm.sqpind = sqlstm.sqindv;
      sqlstm.sqpins = sqlstm.sqinds;
      sqlstm.sqparm = sqlstm.sqharm;
      sqlstm.sqparc = sqlstm.sqharc;
      sqlstm.sqpadto = sqlstm.sqadto;
      sqlstm.sqptdso = sqlstm.sqtdso;
      sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



      if (sqlca.sqlcode != ORCL_NO_ERROR) 
      {
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
         gpszIFSMsg = ifs_fatal("ORC_SELECT",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "FILE_ID",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
         paint_task_line(0,"Select record from file_id; -- FAILED!");
         paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
         do_exit(1);
      }

      *file_id = h_file_id;

      if ((int)*file_id == 0) 
      {
         /* no matching file_id record was found try to find next one record */
         offset_to_one = find_one_rec (file_ptr, rec_size, offset_to_one, file_name_str);

         if(offset_to_one == -1)
            return 0;
      }
      else 
      {
         if (h_spec_hdr_rec_yn[0] == 'N' && hdr_yn > 0)
         {
            /* file_id said no spec hdr but file had one */
            *reject_yn = 'Y'; 
            return 1;
         }
         else
         {
            *reject_yn = 'N';
            return 1;
         }
      }

      /*cycle through the file until a "valid" one record or EOF is found */

   }  while(offset_to_one != -1);
   return 1;//taa
} /* end id_input_file() */

/***************************** find_one_rec ************************************
* Description:    This function will be called if the first one record in the  *
*              file is not valid.  A search for the next, if any, one record   *
*              is done and the number of bytes to that one record is returned. *                                                        *
*                                                                              *
*                                                                              *
* Creation Date:  05/15/1998           By: Darcy Sivertson                     *
* Modified Date:  10/22/1998           By: Mike West                           *
*******************************************************************************/
long find_one_rec(FILE* fPointer, int* rec_size, long offset_to_one, char* file_name_str)
{

   char  temp_one[96];           /* temporary record        */
   long  lOldOffset;
   int   offset_bytes = *rec_size ;
   int   temp_str_len = 0;

   /* struct for nacha one rec */
   typedef struct nacha_one_rec_tag
   {  
      char rec_type;
      char priority_code[2];
      char imm_dest[10];
      char imm_origin[10];
      char file_creat_yymmdd[6];
      char file_creat_hhmm[4];
      char file_id_mod[1];
      char rec_size[3];
      char block_fact[2];
      char format_code[1];
      char imm_dest_name[23];
      char imm_origin_name[23];
      char ref_code[8];
   } nacha_one_rec;

   nacha_one_rec  one[1];     /* record for nacha one rec */

   /* Make sure that we have valid file pointer */
   if (!fPointer)
      return -1;

   /* Use this block of code if the file has carrage returns/line feeds        */
   /* cycle through the file until a one record is found -- return pointer     */
   /* position to one record.                                                  */
   if(offset_bytes == 96)
   {
      for(;;)
      {
         /*Read to the end of this line (carrage return/line feed)*/
         if(fgets(temp_one, 97, fPointer) == NULL)
         {
            return -1;
         }

         trimlr(temp_one);

         if (strlen(temp_one) == 0)
            continue;

         /*Check for indication of one record */
         if(temp_one[0] == '1')
         {
            /* Save current file position */
            lOldOffset = ftell(fPointer);
            if (lOldOffset == -1)
            {
               gpszIFSMsg = ifs_fatal("FILEREAD", 
                                       __FILE__,(DWORD)__LINE__,IFS_LOG,
                                       file_name_str,
                                       _itoa(_doserrno, gs_scratch, 10),
                                       NULL);
               return -1;
            }
            /* return bytes from beginning of file to one record */
            temp_str_len = strlen(temp_one);
            return (lOldOffset - temp_str_len);

         }
      } // End of For
   } // End of If

   /* Use this block of code if the file is continous w/out carrage returns/line feeds */
   /* cycle through the file until a one record is found -- return pointer position to one record*/
   if(offset_bytes == 94)
   {
      for(;;)
      {
         if (fread (one, sizeof(struct nacha_one_rec_tag), 1, fPointer) <= 0)
         {
            gpszIFSMsg = ifs_fatal("FILEREAD", 
                                    __FILE__, (DWORD)__LINE__, IFS_LOG,
                                    file_name_str, 
                                    _itoa(_doserrno, gs_scratch, 10),
                                    NULL);  
            return -1;
         }

         /*Check for EOF */
         if (feof(fPointer))
         {
            return -1;
         }

         /*Check for indication of one record */
         if(one[0].rec_type == '1' )
         {
            /* Get current file position */
            lOldOffset = ftell(fPointer);
            if (lOldOffset == -1)
            {
               gpszIFSMsg = ifs_fatal("FILEREAD", 
                                       __FILE__,(DWORD)__LINE__,IFS_LOG,
                                       file_name_str,
                                       _itoa(_doserrno, gs_scratch, 10),
                                       NULL);
               return -1;
            }
            /* return bytes from beginning of file to one record */
            temp_str_len = strlen(temp_one);
            return (lOldOffset - temp_str_len);

         }
      } // end For
   }// end If
   return 1;//taa
} /* end find_one_rec() */

   
/********************** one_rec_offset *****************************************
* Description:                                                                 *
*     This function returns the char offset from the beginning of the file to  *
* the actual ‘1’ record and sets the value of *rec_size to either 94 or 96.    *
*     It must determine whether or not there is a custom header in the file    *
* pointed to by strFile.                                                       *
* If yes, then it calculates and returns the offset to the actual ‘1’ record.  *
* Otherwise, it returns an offset of zero.                                     *
* Use the algorithm documented in tech. specs.                                 *
*                                                                              *
* NOTE:  this function will also be used by ACHINPUT.EXE.                      *
*                                                                              *
* Creation Date:  06/25/1996  By: Troy Clark                                   *
* Modified Date:  07/09/1996  By: George Lin                                   *
* Modified Date:  08/28/1996  By: George Lin                                   *
*******************************************************************************/
long one_rec_offset(FILE* fPointer, char* file_name_str, int* rec_size)
{
   char  Temp[192];
   int      iBytesRead;
   int      iIndex;
   int      iRecordLength;    /* var for record length */
   BOOL  bFoundCR = FALSE;
   int      iRemainder, iQuotient;
   long  lFileLength;         /* length of the file */
   long  lOffsetToOne;
   long  lOldOffset;

   /* Make sure that we have valid file pointer */
   if (!fPointer)
      return -1;

   /* Save current file pointer */
   lOldOffset = ftell(fPointer);
   if (lOldOffset == -1)
   {
      gpszIFSMsg = ifs_fatal("FILEREAD", 
                              __FILE__,(DWORD)__LINE__,IFS_LOG,
                              file_name_str,
                              _itoa(_doserrno, gs_scratch, 10),
                              NULL);
      return -1;
   }

   /* Read first 192 bytes of data and check to see if there is any CR/LF.    */
   if (fseek(fPointer, 0L, SEEK_SET))
   {
      gpszIFSMsg = ifs_fatal("FILESEEK", 
                              __FILE__, (DWORD)__LINE__,IFS_LOG,
                              file_name_str, 
                              _itoa(_doserrno, gs_scratch, 10),
                              NULL);
      return -1;
   }
   iBytesRead = fread(Temp, sizeof(char), 192, fPointer);
   if (iBytesRead <= 0)
   {
      gpszIFSMsg = ifs_fatal("FILEREAD", 
                              __FILE__,(DWORD)__LINE__,IFS_LOG,
                              file_name_str,
                              _itoa(_doserrno, gs_scratch, 10),
                              NULL);
      return -1;
   }

   for (iIndex=0; iIndex<iBytesRead; iIndex++)  
   {
      if (Temp[iIndex] == '\r' || Temp[iIndex] == '\n')     /* found CR/LF */
      {
         bFoundCR = TRUE;
         break;
      }
   }

   if (bFoundCR)              /* found CR/LF  */
      iRecordLength = 96;        /* record length = 96 */
   else                       /* else */
      iRecordLength = 94;        /* record length = 94 */


   /* If record length is 94 */
   if (!bFoundCR)
   {
      /* Sets the file position to the end of file, returns non-zero on error */
      if (fseek(fPointer, 0L, SEEK_END))
      {
         gpszIFSMsg = ifs_fatal("FILESEEK", 
                                 __FILE__,(DWORD)__LINE__,IFS_LOG,
                                 file_name_str, 
                                 _itoa(_doserrno, gs_scratch, 10),
                                 NULL);
         return -1;
      }
      /* returns the current file position, which has been set to eof */
      lFileLength = ftell(fPointer);

      /* Check for error in returning file length */
      if (lFileLength == -1)
      {
         gpszIFSMsg = ifs_fatal("FILEREAD", 
                                 __FILE__,(DWORD)__LINE__, IFS_LOG,
                                 file_name_str,
                                 _itoa(_doserrno, gs_scratch, 10),
                                 NULL);
         return -1;
      }

      iRemainder = lFileLength % iRecordLength;

      /* No offset to the one record is found */
      if (!iRemainder)
         lOffsetToOne = iRemainder;
      else
      {
         iQuotient = lFileLength / iRecordLength;
         if (iQuotient == (iQuotient / 10) * 10)
            lOffsetToOne = 0;
         else
            lOffsetToOne = iRecordLength;
      }
   }
   else  /* Found CR/LF */
   {
      while (Temp[iIndex] == '\r' || Temp[iIndex] == '\n')
         iIndex++;
      if (Temp[iIndex] == '1')
      {
         iIndex++;
         lOffsetToOne = (long)iIndex;
      }
      else if (Temp[iIndex] == '5')
         lOffsetToOne = 0;
      else
         lOffsetToOne = -1;
   }

   /* Restore original file offset. */
   if (fseek(fPointer, lOldOffset, SEEK_SET))
   {
      gpszIFSMsg = ifs_fatal("FILESEEK", 
                              __FILE__,(DWORD)__LINE__, IFS_LOG,
                              file_name_str, 
                              _itoa(_doserrno, gs_scratch, 10),
                              NULL);
      return -1;
   }
   *rec_size = iRecordLength;

   return lOffsetToOne;
} /* end one_rec_offset() */


/************************ file_sch_hit *****************************************
* Description:                                                                 *
*  Attempts to find a file_sch record for the h_file_id arg that is within     *
* it's earliest_ts and latest_ts.                                              *
*  Sets the value of h_fch_id and returns 1(true) if successful else 0(false). *
*                                                                              *
* Creation Date:  06/25/1996  By: Troy Clark                                   *
* Modified Date:  07/19/1996  By: George Lin                                   *
*******************************************************************************/
int file_sch_hit(char *fi_rt, double file_id, double *fsch_id)
{
   /* EXEC SQL BEGIN DECLARE SECTION; */ 
     /* declare host variable */
      char     h_fi_rt[10];
      double      h_file_id;
      double      h_file_sch_id;

   /* EXEC SQL END DECLARE SECTION; */ 


   strcpy(h_fi_rt, fi_rt);
   h_file_id = file_id;

   
   /* Fetch the first file_sch record (eg, (oper_dt + g_cur_time) BETWEEN     */
   /* file_sch.earliest AND file_sch.latest_ts.                               */

   /* EXEC SQL
      DECLARE  file_sch_cursor CURSOR FOR
      SELECT   fs.file_sch_id
      FROM     fi, file_sch fs 
      WHERE    fi.fi_rt = fs.fi_rt
      AND      fi.active_yn = 'Y'
      AND      fi.wh_status = 'U'
      AND      fi.fi_rt = :h_fi_rt
      AND      fs.file_id = :h_file_id
      AND      (     fs.override_yn = 'Y'
                  OR (     fs.missed_yn = 'N'
                        AND   fs.proc_status = 'N'
                        AND   :g_cur_dt_time > TO_CHAR(fs.earliest_ts, 'YYYYMMDDHH24MISS')
                        AND   :g_cur_dt_time < TO_CHAR(fs.latest_ts, 'YYYYMMDDHH24MISS')
                     )
               ); */ 

      
   /* Notice that the above select statement performs a JOIN between the      */
   /* fi and file_sch tables such that only file_sch records whose fi_rt      */
   /* matches a fi record's fi_rt where the fi is active and in an "Up"       */
   /* condition are considered.  The join allows proper date compares since   */
   /* FI's may not all have the same oper_dt due to differing EOD times, etc. */

   /* EXEC SQL OPEN file_sch_cursor; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 24;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = sq0014;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )441;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqcmod = (unsigned int )0;
   sqlstm.sqhstv[0] = (         void  *)h_fi_rt;
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)&h_file_id;
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)g_cur_dt_time;
   sqlstm.sqhstl[2] = (unsigned int  )14;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)g_cur_dt_time;
   sqlstm.sqhstl[3] = (unsigned int  )14;
   sqlstm.sqhsts[3] = (         int  )0;
   sqlstm.sqindv[3] = (         void  *)0;
   sqlstm.sqinds[3] = (         int  )0;
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {     /* open cursor failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FILE_SCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Open file_sch_cursor failed!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* EXEC SQL FETCH file_sch_cursor INTO :h_file_sch_id; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 24;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )472;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqfoff = (           int )0;
   sqlstm.sqfmod = (unsigned int )2;
   sqlstm.sqhstv[0] = (         void  *)&h_file_sch_id;
   sqlstm.sqhstl[0] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode == ORCL_NOT_FOUND)
   {     /* close cursor failed */
      *fsch_id = 0;
      /* EXEC SQL CLOSE file_sch_cursor; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 24;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )491;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
         gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "FILE_SCH_CURSOR",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
         paint_task_line(0, "Close file_sch cursor failed in file_sch_hit!");
         paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
         do_exit(1);
      }
      return(0);
   }
   else if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FILE_SCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Select file_sch failed in file_sch_hit!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);

      /* EXEC SQL CLOSE file_sch_cursor; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 24;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )506;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


      if (sqlca.sqlcode != ORCL_NO_ERROR) {     /* close cursor failed */
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
         gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                                 __FILE__, (DWORD) __LINE__,IFS_LOG,
                                 "FILE_SCH_CURSOR",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
         paint_task_line(0, "close file_sch cursor failed in file_sch_hit!");
         paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
         do_exit(1);
      }
      return(0);
   }

   *fsch_id = h_file_sch_id;  /* assign file sch id to fsch_id */
   /* EXEC SQL CLOSE file_sch_cursor; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 24;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )521;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {  /* close cursor failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FILE_SCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Close file_sch cursor failed!");
      paint_task_line(1, sqlca.sqlerrm. sqlerrmc);
      do_exit(1);
   }
   return(1);
} /* end file_sch_hit() */


/******************* file_sch_ck_at_risk ***************************************
* Description:                                                                 *
*   This function checks the file_sch table for files...                       *
*     where their at_risk_yn = 'N'                                             *
*     and   their proc_status = ''(unprocessed)                                *
*     and   'current system timestamp'> their at_risk_ts.                      *
*   For each file found, it sets their at_risk_yn = 'Y' and sends a message to *
* the FI, looping until all "At Risk" files have been processed.               *
*                                                                              *
* Creation Date:  06/19/1996  By: Troy Clark                                   *
* Modified Date:  07/19/1996  By: George Lin                                   *
* Modified Date:  02/03/1999  By: FRNash DR#97-300                             *
*******************************************************************************/
void file_sch_ck_at_risk(void)
{
   int   fsch_no;          /* temp var for file sch no */
   char  file_id_str[20];  /* file_id in string format */
   char  msg_text[171];    /* message text to log to the mes table */
   int      cur_fsch_cnt = 0;    /* current file schedule count */
   char  temp_date2[20];
   char  temp_date3[20];
   char  yyyy[5];
   char  mm[3];
   char  dd[3];
   char  hh[3];
   char  mi[3];
   char  ss[3];

   /* EXEC SQL BEGIN DECLARE SECTION; */ 

   char  fi_rt[10];
   char  temp_date0[15];
   char  temp_date1[15];
   /* EXEC SQL END   DECLARE SECTION; */ 

   

   /* Get all file_sch recs that are now in their "Late Grace" period         */
   /* (eg, oper_dt + orcl_cur_hhmm > file_sch.at_risk_ts)                     */

   paint_task_line(1, "Checking File Schedule.....");
   Sleep(2000);   /* delay the message display for 1 second */

   /* EXEC SQL
      DECLARE  risk_cursor CURSOR FOR
      SELECT
               fs.fi_rt, 
               fs.file_sch_id, 
               fs.file_id,
               TO_CHAR(fs.earliest_ts, 'YYYYMMDDHH24MISS'),
               TO_CHAR(fs.latest_ts, 'YYYYMMDDHH24MISS')
      FROM     fi, file_sch fs 
      WHERE 
               fi.fi_rt = fs.fi_rt AND 
               fi.active_yn = 'Y' AND 
               fi.wh_status = 'U' AND 
               fs.missed_yn = 'N' AND 
               fs.at_risk_yn = 'N' AND
               fs.proc_status = 'N' AND
               :g_cur_dt_time > TO_CHAR(fs.at_risk_ts, 'YYYYMMDDHH24MISS')
      ORDER BY fs.at_risk_ts; */ 


   /* Notice that the above select statement performs a JOIN between the      */
   /* fi and file_sch tables such that only file_sch records whose fi_rt      */
   /* matches a fi record's fi_rt where the fi is active and in an "Up"       */
   /* condition are considered.  The join allows proper date compares since   */
   /* FI's may not all have the same oper_dt due to differing EOD times, and  */
   /* it also addresses the case where the schedule is OVERRIDDEN! etc.       */

   /* EXEC SQL OPEN risk_cursor; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 24;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = sq0015;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )536;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqcmod = (unsigned int )0;
   sqlstm.sqhstv[0] = (         void  *)g_cur_dt_time;
   sqlstm.sqhstl[0] = (unsigned int  )14;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

       /* open cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "RISK_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"OPEN CURSOR risk_cursor; -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   
   /* Loop through all files that need to be input, fetching FSCH_BUF_CNT     */
   /* number of records at a time on each pass through the loop.              */
   /* EG. if 200 files need to be input and FSCH_BUF_CNT = 100 then,          */
   /*       it will loop 2 times, fetching & processing 100 on each pass...   */

   /* EXEC SQL FETCH risk_cursor INTO :g_fsch_recs:g_fsch_inds; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 24;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )100;
   sqlstm.offset = (unsigned int  )555;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqfoff = (           int )0;
   sqlstm.sqfmod = (unsigned int )2;
   sqlstm.sqhstv[0] = (         void  *)g_fsch_recs.fi_rt;
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )10;
   sqlstm.sqindv[0] = (         void  *)g_fsch_inds.fi_rt;
   sqlstm.sqinds[0] = (         int  )sizeof(short);
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqharc[0] = (unsigned int   *)0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)g_fsch_recs.file_sch_id;
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[1] = (         int  )sizeof(double);
   sqlstm.sqindv[1] = (         void  *)g_fsch_inds.file_sch_id;
   sqlstm.sqinds[1] = (         int  )sizeof(short);
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqharc[1] = (unsigned int   *)0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)g_fsch_recs.file_id;
   sqlstm.sqhstl[2] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[2] = (         int  )sizeof(double);
   sqlstm.sqindv[2] = (         void  *)g_fsch_inds.file_id;
   sqlstm.sqinds[2] = (         int  )sizeof(short);
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqharc[2] = (unsigned int   *)0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)g_fsch_recs.earliest_ts;
   sqlstm.sqhstl[3] = (unsigned int  )15;
   sqlstm.sqhsts[3] = (         int  )15;
   sqlstm.sqindv[3] = (         void  *)g_fsch_inds.earliest_ts;
   sqlstm.sqinds[3] = (         int  )sizeof(short);
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqharc[3] = (unsigned int   *)0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqhstv[4] = (         void  *)g_fsch_recs.latest_ts;
   sqlstm.sqhstl[4] = (unsigned int  )15;
   sqlstm.sqhsts[4] = (         int  )15;
   sqlstm.sqindv[4] = (         void  *)g_fsch_inds.latest_ts;
   sqlstm.sqinds[4] = (         int  )sizeof(short);
   sqlstm.sqharm[4] = (unsigned int  )0;
   sqlstm.sqharc[4] = (unsigned int   *)0;
   sqlstm.sqadto[4] = (unsigned short )0;
   sqlstm.sqtdso[4] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

   
   
   g_fsch_cnt = 0;
   while ((sqlca.sqlcode == ORCL_NOT_FOUND || sqlca.sqlcode == ORCL_NO_ERROR) 
            && sqlca.sqlerrd[2] > 0) 
   {
      /* Save the actual # of records fetched                                 */
      cur_fsch_cnt = sqlca.sqlerrd[2] - g_fsch_cnt;
      g_fsch_cnt = sqlca.sqlerrd[2];

      /* Process all file records fetched into g_fsch_recs buffer             */
      for (fsch_no = 0; fsch_no < cur_fsch_cnt; fsch_no++) 
      {  
         /* Update the file_sch item's at_risk_yn = 'Y' */
         // modified 02/03/1999 DR#97-300 -FRN
         /* EXEC SQL
            UPDATE   file_sch SET at_risk_yn = 'Y' 
            WHERE    fi_rt = :g_fsch_recs.fi_rt[fsch_no]
            AND      file_sch_id = :g_fsch_recs.file_sch_id[fsch_no]
            AND      file_id = :g_fsch_recs.file_id[fsch_no]
            AND      :g_cur_dt_time > TO_CHAR(at_risk_ts, 'YYYYMMDDHH24MISS')
            AND      at_risk_yn = 'N'; */ 

{
         struct sqlexd sqlstm;
         sqlstm.sqlvsn = 13;
         sqlstm.arrsiz = 24;
         sqlstm.sqladtp = &sqladt;
         sqlstm.sqltdsp = &sqltds;
         sqlstm.stmt = "update file_sch  set at_risk_yn='Y' where ((((fi_rt=\
:b0 and file_sch_id=:b1) and file_id=:b2) and :b3>TO_CHAR(at_risk_ts,'YYYYMMDD\
HH24MISS')) and at_risk_yn='N')";
         sqlstm.iters = (unsigned int  )1;
         sqlstm.offset = (unsigned int  )590;
         sqlstm.cud = sqlcud0;
         sqlstm.sqlest = (unsigned char  *)&sqlca;
         sqlstm.sqlety = (unsigned short)4352;
         sqlstm.occurs = (unsigned int  )0;
         sqlstm.sqhstv[0] = (         void  *)(g_fsch_recs.fi_rt)[fsch_no];
         sqlstm.sqhstl[0] = (unsigned int  )10;
         sqlstm.sqhsts[0] = (         int  )0;
         sqlstm.sqindv[0] = (         void  *)0;
         sqlstm.sqinds[0] = (         int  )0;
         sqlstm.sqharm[0] = (unsigned int  )0;
         sqlstm.sqadto[0] = (unsigned short )0;
         sqlstm.sqtdso[0] = (unsigned short )0;
         sqlstm.sqhstv[1] = (         void  *)&(g_fsch_recs.file_sch_id)[fsch_no];
         sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
         sqlstm.sqhsts[1] = (         int  )0;
         sqlstm.sqindv[1] = (         void  *)0;
         sqlstm.sqinds[1] = (         int  )0;
         sqlstm.sqharm[1] = (unsigned int  )0;
         sqlstm.sqadto[1] = (unsigned short )0;
         sqlstm.sqtdso[1] = (unsigned short )0;
         sqlstm.sqhstv[2] = (         void  *)&(g_fsch_recs.file_id)[fsch_no];
         sqlstm.sqhstl[2] = (unsigned int  )sizeof(double);
         sqlstm.sqhsts[2] = (         int  )0;
         sqlstm.sqindv[2] = (         void  *)0;
         sqlstm.sqinds[2] = (         int  )0;
         sqlstm.sqharm[2] = (unsigned int  )0;
         sqlstm.sqadto[2] = (unsigned short )0;
         sqlstm.sqtdso[2] = (unsigned short )0;
         sqlstm.sqhstv[3] = (         void  *)g_cur_dt_time;
         sqlstm.sqhstl[3] = (unsigned int  )14;
         sqlstm.sqhsts[3] = (         int  )0;
         sqlstm.sqindv[3] = (         void  *)0;
         sqlstm.sqinds[3] = (         int  )0;
         sqlstm.sqharm[3] = (unsigned int  )0;
         sqlstm.sqadto[3] = (unsigned short )0;
         sqlstm.sqtdso[3] = (unsigned short )0;
         sqlstm.sqphsv = sqlstm.sqhstv;
         sqlstm.sqphsl = sqlstm.sqhstl;
         sqlstm.sqphss = sqlstm.sqhsts;
         sqlstm.sqpind = sqlstm.sqindv;
         sqlstm.sqpins = sqlstm.sqinds;
         sqlstm.sqparm = sqlstm.sqharm;
         sqlstm.sqparc = sqlstm.sqharc;
         sqlstm.sqpadto = sqlstm.sqadto;
         sqlstm.sqptdso = sqlstm.sqtdso;
         sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


         
         if (sqlca.sqlcode != ORCL_NO_ERROR)
         {
            sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
            g_orcl_etext_buf[g_orcl_etext_len] = '\0';
            copy_cat(g_fi_info, "FI: ", g_fsch_recs.fi_rt[fsch_no], NULL);
            gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                    __FILE__, (DWORD) __LINE__, IFS_LOG,
                                    "FILE_SCH",
                                    g_orcl_etext_buf,
                                    g_fi_info,
                                    NULL);
            paint_task_line(0,"Update file_sch; -- FAILED!");
            paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
            do_exit(1);
         }
         else
         {
            /* EXEC SQL COMMIT WORK; */ 

{
            struct sqlexd sqlstm;
            sqlstm.sqlvsn = 13;
            sqlstm.arrsiz = 24;
            sqlstm.sqladtp = &sqladt;
            sqlstm.sqltdsp = &sqltds;
            sqlstm.iters = (unsigned int  )1;
            sqlstm.offset = (unsigned int  )621;
            sqlstm.cud = sqlcud0;
            sqlstm.sqlest = (unsigned char  *)&sqlca;
            sqlstm.sqlety = (unsigned short)4352;
            sqlstm.occurs = (unsigned int  )0;
            sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

   /* commit update work */
            if (sqlca.sqlcode != ORCL_NO_ERROR)
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", g_fsch_recs.fi_rt[fsch_no], NULL);
               ifs_fatal("ORC_COMMIT",
                           __FILE__, (DWORD)__LINE__, IFS_LOG,
                           g_orcl_etext_buf,
                           g_fi_info,
                           NULL);
               paint_task_line(0, "Unable to Commit Changes");
               exit(1);
            }
         }
         
         /* Send a warning message to the FI */
         _gcvt(g_fsch_recs.file_id[fsch_no], 10, file_id_str);

         /* remove the decimal point from file_id_str */
         if (file_id_str[strlen(file_id_str)-1] == '.')
            file_id_str[strlen(file_id_str)-1] = '\0';

         get_corp_orig_id(fsch_no);    /* psm mod - 5/08/1997 */

         strcpy(fi_rt, g_fsch_recs.fi_rt[fsch_no]);
         strcpy(temp_date0, g_fsch_recs.earliest_ts[fsch_no]);

         /* EXEC SQL EXECUTE
            BEGIN
               :temp_date1 := local_date(:temp_date0, :fi_rt); 
            END;
         END-EXEC; */ 

{
         struct sqlexd sqlstm;
         sqlstm.sqlvsn = 13;
         sqlstm.arrsiz = 24;
         sqlstm.sqladtp = &sqladt;
         sqlstm.sqltdsp = &sqltds;
         sqlstm.stmt = "begin :temp_date1 := local_date ( :temp_date0 , :fi_\
rt ) ; END ;";
         sqlstm.iters = (unsigned int  )1;
         sqlstm.offset = (unsigned int  )636;
         sqlstm.cud = sqlcud0;
         sqlstm.sqlest = (unsigned char  *)&sqlca;
         sqlstm.sqlety = (unsigned short)4352;
         sqlstm.occurs = (unsigned int  )0;
         sqlstm.sqhstv[0] = (         void  *)temp_date1;
         sqlstm.sqhstl[0] = (unsigned int  )15;
         sqlstm.sqhsts[0] = (         int  )0;
         sqlstm.sqindv[0] = (         void  *)0;
         sqlstm.sqinds[0] = (         int  )0;
         sqlstm.sqharm[0] = (unsigned int  )0;
         sqlstm.sqadto[0] = (unsigned short )0;
         sqlstm.sqtdso[0] = (unsigned short )0;
         sqlstm.sqhstv[1] = (         void  *)temp_date0;
         sqlstm.sqhstl[1] = (unsigned int  )15;
         sqlstm.sqhsts[1] = (         int  )0;
         sqlstm.sqindv[1] = (         void  *)0;
         sqlstm.sqinds[1] = (         int  )0;
         sqlstm.sqharm[1] = (unsigned int  )0;
         sqlstm.sqadto[1] = (unsigned short )0;
         sqlstm.sqtdso[1] = (unsigned short )0;
         sqlstm.sqhstv[2] = (         void  *)fi_rt;
         sqlstm.sqhstl[2] = (unsigned int  )10;
         sqlstm.sqhsts[2] = (         int  )0;
         sqlstm.sqindv[2] = (         void  *)0;
         sqlstm.sqinds[2] = (         int  )0;
         sqlstm.sqharm[2] = (unsigned int  )0;
         sqlstm.sqadto[2] = (unsigned short )0;
         sqlstm.sqtdso[2] = (unsigned short )0;
         sqlstm.sqphsv = sqlstm.sqhstv;
         sqlstm.sqphsl = sqlstm.sqhstl;
         sqlstm.sqphss = sqlstm.sqhsts;
         sqlstm.sqpind = sqlstm.sqindv;
         sqlstm.sqpins = sqlstm.sqinds;
         sqlstm.sqparm = sqlstm.sqharm;
         sqlstm.sqparc = sqlstm.sqharc;
         sqlstm.sqpadto = sqlstm.sqadto;
         sqlstm.sqptdso = sqlstm.sqtdso;
         sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



         strncpy(yyyy, temp_date1, 4);
         yyyy[4] = 0;

         strncpy(mm, temp_date1 + 4, 2);
         mm[2] = 0;

         strncpy(dd, temp_date1 + 6, 2);
         dd[2] = 0;

         strncpy(hh, temp_date1 + 8, 2);
         hh[2] = 0;

         strncpy(mi, temp_date1 + 10, 2);
         mi[2] = 0;

         strncpy(ss, temp_date1 + 12, 2);
         ss[2] = 0;

         sprintf(temp_date2, "%2s/%2s/%4s %2s:%2s:%2s", mm, dd, yyyy, hh, mi, ss);

         strcpy(temp_date0, g_fsch_recs.latest_ts[fsch_no]);

         /* EXEC SQL EXECUTE
            BEGIN
               :temp_date1 := local_date(:temp_date0, :fi_rt); 
            END;
         END-EXEC; */ 

{
         struct sqlexd sqlstm;
         sqlstm.sqlvsn = 13;
         sqlstm.arrsiz = 24;
         sqlstm.sqladtp = &sqladt;
         sqlstm.sqltdsp = &sqltds;
         sqlstm.stmt = "begin :temp_date1 := local_date ( :temp_date0 , :fi_\
rt ) ; END ;";
         sqlstm.iters = (unsigned int  )1;
         sqlstm.offset = (unsigned int  )663;
         sqlstm.cud = sqlcud0;
         sqlstm.sqlest = (unsigned char  *)&sqlca;
         sqlstm.sqlety = (unsigned short)4352;
         sqlstm.occurs = (unsigned int  )0;
         sqlstm.sqhstv[0] = (         void  *)temp_date1;
         sqlstm.sqhstl[0] = (unsigned int  )15;
         sqlstm.sqhsts[0] = (         int  )0;
         sqlstm.sqindv[0] = (         void  *)0;
         sqlstm.sqinds[0] = (         int  )0;
         sqlstm.sqharm[0] = (unsigned int  )0;
         sqlstm.sqadto[0] = (unsigned short )0;
         sqlstm.sqtdso[0] = (unsigned short )0;
         sqlstm.sqhstv[1] = (         void  *)temp_date0;
         sqlstm.sqhstl[1] = (unsigned int  )15;
         sqlstm.sqhsts[1] = (         int  )0;
         sqlstm.sqindv[1] = (         void  *)0;
         sqlstm.sqinds[1] = (         int  )0;
         sqlstm.sqharm[1] = (unsigned int  )0;
         sqlstm.sqadto[1] = (unsigned short )0;
         sqlstm.sqtdso[1] = (unsigned short )0;
         sqlstm.sqhstv[2] = (         void  *)fi_rt;
         sqlstm.sqhstl[2] = (unsigned int  )10;
         sqlstm.sqhsts[2] = (         int  )0;
         sqlstm.sqindv[2] = (         void  *)0;
         sqlstm.sqinds[2] = (         int  )0;
         sqlstm.sqharm[2] = (unsigned int  )0;
         sqlstm.sqadto[2] = (unsigned short )0;
         sqlstm.sqtdso[2] = (unsigned short )0;
         sqlstm.sqphsv = sqlstm.sqhstv;
         sqlstm.sqphsl = sqlstm.sqhstl;
         sqlstm.sqphss = sqlstm.sqhsts;
         sqlstm.sqpind = sqlstm.sqindv;
         sqlstm.sqpins = sqlstm.sqinds;
         sqlstm.sqparm = sqlstm.sqharm;
         sqlstm.sqparc = sqlstm.sqharc;
         sqlstm.sqpadto = sqlstm.sqadto;
         sqlstm.sqptdso = sqlstm.sqtdso;
         sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



         strncpy(yyyy, temp_date1, 4);
         yyyy[4] = 0;

         strncpy(mm, temp_date1 + 4, 2);
         mm[2] = 0;

         strncpy(dd, temp_date1 + 6, 2);
         dd[2] = 0;

         strncpy(hh, temp_date1 + 8, 2);
         hh[2] = 0;

         strncpy(mi, temp_date1 + 10, 2);
         mi[2] = 0;

         strncpy(ss, temp_date1 + 12, 2);
         ss[2] = 0;

         sprintf(temp_date3, "%2s/%2s/%4s %2s:%2s:%2s", mm, dd, yyyy, hh, mi, ss);

         //replaced FI_RT with the corporate originator id - PSM, 5/08/1997
         copy_cat(msg_text, "A Scheduled File ", file_id_str,
            " has not arrived and is late.  The Originator is ", 
            g_corp_orig_id, ".  Window is from ", 
            temp_date2, " to ", temp_date3, NULL);

         if (!post_msg(g_fsch_recs.fi_rt[fsch_no], NULL, 'W', msg_text, "OT", -1, -1, -1, -1, -1))
         {
            copy_cat(g_fi_info, "FI: ", g_fsch_recs.fi_rt[fsch_no], NULL);
            gpszIFSMsg = ifs_fatal("AOS_WRITE_MSG",
                                    __FILE__, (DWORD) __LINE__, IFS_LOG,
                                    "-1", "W", msg_text, "OT", "-1", "-1", "-1",
                                    g_fi_info,
                                    NULL);
            paint_task_line(0, "Post_msg failed in file_sch_ck_at_risk()!");
            do_exit(1);
         }

      }
      /* Attempt to Fetch another buffer full of ioq records for the next pass */
      if (cur_fsch_cnt < FSCH_BUF_CNT)
         break;
      else /* EXEC SQL FETCH risk_cursor INTO :g_fsch_recs:g_fsch_inds; */ 

{
           struct sqlexd sqlstm;
           sqlstm.sqlvsn = 13;
           sqlstm.arrsiz = 24;
           sqlstm.sqladtp = &sqladt;
           sqlstm.sqltdsp = &sqltds;
           sqlstm.iters = (unsigned int  )100;
           sqlstm.offset = (unsigned int  )690;
           sqlstm.selerr = (unsigned short)0;
           sqlstm.sqlpfmem = (unsigned int  )0;
           sqlstm.cud = sqlcud0;
           sqlstm.sqlest = (unsigned char  *)&sqlca;
           sqlstm.sqlety = (unsigned short)4352;
           sqlstm.occurs = (unsigned int  )0;
           sqlstm.sqfoff = (           int )0;
           sqlstm.sqfmod = (unsigned int )2;
           sqlstm.sqhstv[0] = (         void  *)g_fsch_recs.fi_rt;
           sqlstm.sqhstl[0] = (unsigned int  )10;
           sqlstm.sqhsts[0] = (         int  )10;
           sqlstm.sqindv[0] = (         void  *)g_fsch_inds.fi_rt;
           sqlstm.sqinds[0] = (         int  )sizeof(short);
           sqlstm.sqharm[0] = (unsigned int  )0;
           sqlstm.sqharc[0] = (unsigned int   *)0;
           sqlstm.sqadto[0] = (unsigned short )0;
           sqlstm.sqtdso[0] = (unsigned short )0;
           sqlstm.sqhstv[1] = (         void  *)g_fsch_recs.file_sch_id;
           sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
           sqlstm.sqhsts[1] = (         int  )sizeof(double);
           sqlstm.sqindv[1] = (         void  *)g_fsch_inds.file_sch_id;
           sqlstm.sqinds[1] = (         int  )sizeof(short);
           sqlstm.sqharm[1] = (unsigned int  )0;
           sqlstm.sqharc[1] = (unsigned int   *)0;
           sqlstm.sqadto[1] = (unsigned short )0;
           sqlstm.sqtdso[1] = (unsigned short )0;
           sqlstm.sqhstv[2] = (         void  *)g_fsch_recs.file_id;
           sqlstm.sqhstl[2] = (unsigned int  )sizeof(double);
           sqlstm.sqhsts[2] = (         int  )sizeof(double);
           sqlstm.sqindv[2] = (         void  *)g_fsch_inds.file_id;
           sqlstm.sqinds[2] = (         int  )sizeof(short);
           sqlstm.sqharm[2] = (unsigned int  )0;
           sqlstm.sqharc[2] = (unsigned int   *)0;
           sqlstm.sqadto[2] = (unsigned short )0;
           sqlstm.sqtdso[2] = (unsigned short )0;
           sqlstm.sqhstv[3] = (         void  *)g_fsch_recs.earliest_ts;
           sqlstm.sqhstl[3] = (unsigned int  )15;
           sqlstm.sqhsts[3] = (         int  )15;
           sqlstm.sqindv[3] = (         void  *)g_fsch_inds.earliest_ts;
           sqlstm.sqinds[3] = (         int  )sizeof(short);
           sqlstm.sqharm[3] = (unsigned int  )0;
           sqlstm.sqharc[3] = (unsigned int   *)0;
           sqlstm.sqadto[3] = (unsigned short )0;
           sqlstm.sqtdso[3] = (unsigned short )0;
           sqlstm.sqhstv[4] = (         void  *)g_fsch_recs.latest_ts;
           sqlstm.sqhstl[4] = (unsigned int  )15;
           sqlstm.sqhsts[4] = (         int  )15;
           sqlstm.sqindv[4] = (         void  *)g_fsch_inds.latest_ts;
           sqlstm.sqinds[4] = (         int  )sizeof(short);
           sqlstm.sqharm[4] = (unsigned int  )0;
           sqlstm.sqharc[4] = (unsigned int   *)0;
           sqlstm.sqadto[4] = (unsigned short )0;
           sqlstm.sqtdso[4] = (unsigned short )0;
           sqlstm.sqphsv = sqlstm.sqhstv;
           sqlstm.sqphsl = sqlstm.sqhstl;
           sqlstm.sqphss = sqlstm.sqhsts;
           sqlstm.sqpind = sqlstm.sqindv;
           sqlstm.sqpins = sqlstm.sqinds;
           sqlstm.sqparm = sqlstm.sqharm;
           sqlstm.sqparc = sqlstm.sqharc;
           sqlstm.sqpadto = sqlstm.sqadto;
           sqlstm.sqptdso = sqlstm.sqtdso;
           sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

 
   }  

   if ((sqlca.sqlcode != ORCL_NO_ERROR) && (sqlca.sqlcode != ORCL_NOT_FOUND))
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "RISK_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"FETCH risk_cursor FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }


   /* EXEC SQL CLOSE risk_cursor; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 24;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )725;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

      /* close cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "RISK_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"CLOSE Cursor risk_cursor; -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
} /* end file_sch_ck_at_risk() */


/******************** file_sch_ck_missed ***************************************
* Description:                                                                 *
*     This function checks the file_sch table for files...                     *
*           where their at_risk_yn = 'Y'                                       *
*           and   the 'current system timestamp'> their latest_due_ts          *
*           and   fi_rt = strRT.                                               *
*     For each file found, it sets the missed_yn = 'Y' and sends a message to  *
* the FI, looping until all "Missed" files have been processed.                *
*                                                                              *
* Creation Date:  06/19/1996  By: Troy Clark                                   *
* Modified Date:  07/19/1996  By: George Lin                                   *
*******************************************************************************/
void file_sch_ck_missed(void)
{
   int   fsch_no;          /* file sch no */
   int   cur_fsch_cnt = 0;

   /* Identify files that are now BEYOND their "Late Grace" period             */
   /* (eg. oper_dt + g_cur_time > file_sch.latest_ts)                          */

   /* EXEC SQL DECLARE missed_cursor CURSOR FOR
      SELECT
            fs.fi_rt, 
            fs.file_sch_id, 
            fs.file_id,
            TO_CHAR(fs.earliest_ts, 'YYYYMMDDHH24MISS'),
            TO_CHAR(fs.latest_ts, 'YYYYMMDDHH24MISS')
      FROM
            fi, file_sch fs 
      WHERE 
            fi.fi_rt = fs.fi_rt AND 
            fi.active_yn = 'Y' AND 
            fi.wh_status = 'U' AND 
            fs.missed_yn = 'N' AND 
            fs.at_risk_yn = 'Y' AND
            fs.proc_status = 'N' AND 
            :g_cur_dt_time > TO_CHAR(fs.latest_ts, 'YYYYMMDDHH24MISS')
      ORDER BY 
            fs.latest_ts; */ 

   /* Notice that the above select statement performs a JOIN between the      */
   /* fi and file_sch tables such that only file_sch records whose fi_rt      */
   /* matches a fi record's fi_rt where the fi is active and in an "Up"       */
   /* condition are considered.  The join allows proper date compares since   */
   /* FI's may not all have the same oper_dt due to differing EOD times, etc. */
   /* EXEC SQL OPEN missed_cursor; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 24;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = sq0020;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )740;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqcmod = (unsigned int )0;
   sqlstm.sqhstv[0] = (         void  *)g_cur_dt_time;
   sqlstm.sqhstl[0] = (unsigned int  )14;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "MISSED_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"OPEN CURSOR missed_cursor FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   
   /* Loop through all files that need to be input, fetching FSCH_BUF_CNT   */
   /* number of records at a time on each pass through the loop.            */
   /* EG. if 200 files need to be input and FSCH_BUF_CNT = 100 then,        */
   /* it will loop 2 times, fetching & processing 100 on each pass...       */

   /* EXEC SQL FETCH missed_cursor INTO :g_fsch_recs:g_fsch_inds; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 24;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )100;
   sqlstm.offset = (unsigned int  )759;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqfoff = (           int )0;
   sqlstm.sqfmod = (unsigned int )2;
   sqlstm.sqhstv[0] = (         void  *)g_fsch_recs.fi_rt;
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )10;
   sqlstm.sqindv[0] = (         void  *)g_fsch_inds.fi_rt;
   sqlstm.sqinds[0] = (         int  )sizeof(short);
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqharc[0] = (unsigned int   *)0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)g_fsch_recs.file_sch_id;
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[1] = (         int  )sizeof(double);
   sqlstm.sqindv[1] = (         void  *)g_fsch_inds.file_sch_id;
   sqlstm.sqinds[1] = (         int  )sizeof(short);
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqharc[1] = (unsigned int   *)0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)g_fsch_recs.file_id;
   sqlstm.sqhstl[2] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[2] = (         int  )sizeof(double);
   sqlstm.sqindv[2] = (         void  *)g_fsch_inds.file_id;
   sqlstm.sqinds[2] = (         int  )sizeof(short);
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqharc[2] = (unsigned int   *)0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)g_fsch_recs.earliest_ts;
   sqlstm.sqhstl[3] = (unsigned int  )15;
   sqlstm.sqhsts[3] = (         int  )15;
   sqlstm.sqindv[3] = (         void  *)g_fsch_inds.earliest_ts;
   sqlstm.sqinds[3] = (         int  )sizeof(short);
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqharc[3] = (unsigned int   *)0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqhstv[4] = (         void  *)g_fsch_recs.latest_ts;
   sqlstm.sqhstl[4] = (unsigned int  )15;
   sqlstm.sqhsts[4] = (         int  )15;
   sqlstm.sqindv[4] = (         void  *)g_fsch_inds.latest_ts;
   sqlstm.sqinds[4] = (         int  )sizeof(short);
   sqlstm.sqharm[4] = (unsigned int  )0;
   sqlstm.sqharc[4] = (unsigned int   *)0;
   sqlstm.sqadto[4] = (unsigned short )0;
   sqlstm.sqtdso[4] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

 
   
   g_fsch_cnt = 0;
   while ((sqlca.sqlcode == ORCL_NOT_FOUND || sqlca.sqlcode == ORCL_NO_ERROR) 
            && sqlca.sqlerrd[2] > 0) 
   {
      /* Save the actual # of records fetched */
      cur_fsch_cnt = sqlca.sqlerrd[2] - g_fsch_cnt;
      g_fsch_cnt = sqlca.sqlerrd[2];
   
      /* Process all file records fetched into g_fsch_recs buffer             */
      for (fsch_no = 0; fsch_no < cur_fsch_cnt; fsch_no++) 
      { 
         /* Update file_sch item's missed_yn = 'Y'                            */
         /* Update file_sch item's at_risk_yn = 'N'                           */
         /* EXEC SQL UPDATE file_sch SET missed_yn = 'Y',at_risk_yn = 'N' 
            WHERE  fi_rt = :g_fsch_recs.fi_rt[fsch_no]
              AND  file_sch_id = :g_fsch_recs.file_sch_id[fsch_no]
              AND  file_id = :g_fsch_recs.file_id[fsch_no]; */ 

{
         struct sqlexd sqlstm;
         sqlstm.sqlvsn = 13;
         sqlstm.arrsiz = 24;
         sqlstm.sqladtp = &sqladt;
         sqlstm.sqltdsp = &sqltds;
         sqlstm.stmt = "update file_sch  set missed_yn='Y',at_risk_yn='N' wh\
ere ((fi_rt=:b0 and file_sch_id=:b1) and file_id=:b2)";
         sqlstm.iters = (unsigned int  )1;
         sqlstm.offset = (unsigned int  )794;
         sqlstm.cud = sqlcud0;
         sqlstm.sqlest = (unsigned char  *)&sqlca;
         sqlstm.sqlety = (unsigned short)4352;
         sqlstm.occurs = (unsigned int  )0;
         sqlstm.sqhstv[0] = (         void  *)(g_fsch_recs.fi_rt)[fsch_no];
         sqlstm.sqhstl[0] = (unsigned int  )10;
         sqlstm.sqhsts[0] = (         int  )0;
         sqlstm.sqindv[0] = (         void  *)0;
         sqlstm.sqinds[0] = (         int  )0;
         sqlstm.sqharm[0] = (unsigned int  )0;
         sqlstm.sqadto[0] = (unsigned short )0;
         sqlstm.sqtdso[0] = (unsigned short )0;
         sqlstm.sqhstv[1] = (         void  *)&(g_fsch_recs.file_sch_id)[fsch_no];
         sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
         sqlstm.sqhsts[1] = (         int  )0;
         sqlstm.sqindv[1] = (         void  *)0;
         sqlstm.sqinds[1] = (         int  )0;
         sqlstm.sqharm[1] = (unsigned int  )0;
         sqlstm.sqadto[1] = (unsigned short )0;
         sqlstm.sqtdso[1] = (unsigned short )0;
         sqlstm.sqhstv[2] = (         void  *)&(g_fsch_recs.file_id)[fsch_no];
         sqlstm.sqhstl[2] = (unsigned int  )sizeof(double);
         sqlstm.sqhsts[2] = (         int  )0;
         sqlstm.sqindv[2] = (         void  *)0;
         sqlstm.sqinds[2] = (         int  )0;
         sqlstm.sqharm[2] = (unsigned int  )0;
         sqlstm.sqadto[2] = (unsigned short )0;
         sqlstm.sqtdso[2] = (unsigned short )0;
         sqlstm.sqphsv = sqlstm.sqhstv;
         sqlstm.sqphsl = sqlstm.sqhstl;
         sqlstm.sqphss = sqlstm.sqhsts;
         sqlstm.sqpind = sqlstm.sqindv;
         sqlstm.sqpins = sqlstm.sqinds;
         sqlstm.sqparm = sqlstm.sqharm;
         sqlstm.sqparc = sqlstm.sqharc;
         sqlstm.sqpadto = sqlstm.sqadto;
         sqlstm.sqptdso = sqlstm.sqtdso;
         sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


         
         if (sqlca.sqlcode != ORCL_NO_ERROR) 
         {
            sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
            g_orcl_etext_buf[g_orcl_etext_len] = '\0';
            copy_cat(g_fi_info, "FI: ", g_fsch_recs.fi_rt[fsch_no], NULL);
            gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                    __FILE__, (DWORD) __LINE__,
                                    IFS_LOG,
                                    "FILE_SCH",
                                    g_orcl_etext_buf,
                                    g_fi_info,
                                    NULL);
            paint_task_line(0,"Update file_sch; -- FAILED!");
            paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
            do_exit(1);
         }
         else
         {
            /* EXEC SQL COMMIT WORK; */ 

{
            struct sqlexd sqlstm;
            sqlstm.sqlvsn = 13;
            sqlstm.arrsiz = 24;
            sqlstm.sqladtp = &sqladt;
            sqlstm.sqltdsp = &sqltds;
            sqlstm.iters = (unsigned int  )1;
            sqlstm.offset = (unsigned int  )821;
            sqlstm.cud = sqlcud0;
            sqlstm.sqlest = (unsigned char  *)&sqlca;
            sqlstm.sqlety = (unsigned short)4352;
            sqlstm.occurs = (unsigned int  )0;
            sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

   /* commit update work */
            if (sqlca.sqlcode != ORCL_NO_ERROR)
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", g_fsch_recs.fi_rt[fsch_no], NULL);
               ifs_fatal("ORC_COMMIT",
                           __FILE__, (DWORD)__LINE__, IFS_LOG,
                           g_orcl_etext_buf,
                           g_fi_info,
                           NULL);
               paint_task_line(0, "Unable to Commit Changes");
               exit(1);
            }
         }
      }

      if (cur_fsch_cnt < FSCH_BUF_CNT)
         break;
      else
         /* Attempt to Fetch another buffer full of ioq records for the next pass */
         /* EXEC SQL FETCH missed_cursor INTO :g_fsch_recs:g_fsch_inds; */ 

{
         struct sqlexd sqlstm;
         sqlstm.sqlvsn = 13;
         sqlstm.arrsiz = 24;
         sqlstm.sqladtp = &sqladt;
         sqlstm.sqltdsp = &sqltds;
         sqlstm.iters = (unsigned int  )100;
         sqlstm.offset = (unsigned int  )836;
         sqlstm.selerr = (unsigned short)0;
         sqlstm.sqlpfmem = (unsigned int  )0;
         sqlstm.cud = sqlcud0;
         sqlstm.sqlest = (unsigned char  *)&sqlca;
         sqlstm.sqlety = (unsigned short)4352;
         sqlstm.occurs = (unsigned int  )0;
         sqlstm.sqfoff = (           int )0;
         sqlstm.sqfmod = (unsigned int )2;
         sqlstm.sqhstv[0] = (         void  *)g_fsch_recs.fi_rt;
         sqlstm.sqhstl[0] = (unsigned int  )10;
         sqlstm.sqhsts[0] = (         int  )10;
         sqlstm.sqindv[0] = (         void  *)g_fsch_inds.fi_rt;
         sqlstm.sqinds[0] = (         int  )sizeof(short);
         sqlstm.sqharm[0] = (unsigned int  )0;
         sqlstm.sqharc[0] = (unsigned int   *)0;
         sqlstm.sqadto[0] = (unsigned short )0;
         sqlstm.sqtdso[0] = (unsigned short )0;
         sqlstm.sqhstv[1] = (         void  *)g_fsch_recs.file_sch_id;
         sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
         sqlstm.sqhsts[1] = (         int  )sizeof(double);
         sqlstm.sqindv[1] = (         void  *)g_fsch_inds.file_sch_id;
         sqlstm.sqinds[1] = (         int  )sizeof(short);
         sqlstm.sqharm[1] = (unsigned int  )0;
         sqlstm.sqharc[1] = (unsigned int   *)0;
         sqlstm.sqadto[1] = (unsigned short )0;
         sqlstm.sqtdso[1] = (unsigned short )0;
         sqlstm.sqhstv[2] = (         void  *)g_fsch_recs.file_id;
         sqlstm.sqhstl[2] = (unsigned int  )sizeof(double);
         sqlstm.sqhsts[2] = (         int  )sizeof(double);
         sqlstm.sqindv[2] = (         void  *)g_fsch_inds.file_id;
         sqlstm.sqinds[2] = (         int  )sizeof(short);
         sqlstm.sqharm[2] = (unsigned int  )0;
         sqlstm.sqharc[2] = (unsigned int   *)0;
         sqlstm.sqadto[2] = (unsigned short )0;
         sqlstm.sqtdso[2] = (unsigned short )0;
         sqlstm.sqhstv[3] = (         void  *)g_fsch_recs.earliest_ts;
         sqlstm.sqhstl[3] = (unsigned int  )15;
         sqlstm.sqhsts[3] = (         int  )15;
         sqlstm.sqindv[3] = (         void  *)g_fsch_inds.earliest_ts;
         sqlstm.sqinds[3] = (         int  )sizeof(short);
         sqlstm.sqharm[3] = (unsigned int  )0;
         sqlstm.sqharc[3] = (unsigned int   *)0;
         sqlstm.sqadto[3] = (unsigned short )0;
         sqlstm.sqtdso[3] = (unsigned short )0;
         sqlstm.sqhstv[4] = (         void  *)g_fsch_recs.latest_ts;
         sqlstm.sqhstl[4] = (unsigned int  )15;
         sqlstm.sqhsts[4] = (         int  )15;
         sqlstm.sqindv[4] = (         void  *)g_fsch_inds.latest_ts;
         sqlstm.sqinds[4] = (         int  )sizeof(short);
         sqlstm.sqharm[4] = (unsigned int  )0;
         sqlstm.sqharc[4] = (unsigned int   *)0;
         sqlstm.sqadto[4] = (unsigned short )0;
         sqlstm.sqtdso[4] = (unsigned short )0;
         sqlstm.sqphsv = sqlstm.sqhstv;
         sqlstm.sqphsl = sqlstm.sqhstl;
         sqlstm.sqphss = sqlstm.sqhsts;
         sqlstm.sqpind = sqlstm.sqindv;
         sqlstm.sqpins = sqlstm.sqinds;
         sqlstm.sqparm = sqlstm.sqharm;
         sqlstm.sqparc = sqlstm.sqharc;
         sqlstm.sqpadto = sqlstm.sqadto;
         sqlstm.sqptdso = sqlstm.sqtdso;
         sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

 
   }

   if ((sqlca.sqlcode != ORCL_NO_ERROR) && (sqlca.sqlcode != ORCL_NOT_FOUND))
   {  /* Fetch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "MISSED_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Fetch record from CURSOR missed_cursor failed!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }


   /* EXEC SQL CLOSE missed_cursor; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 24;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )871;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "MISSED_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"CLOSE CURSOR missed_cursor; -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
} /* end file_sch_ck_missed() */


/********************** get_corp_orig_id ***************************************
* Description:                                                                 *
*     This function retrieves the corp_orig_id from the file_id table in the   *
* case that a file schedule was either 'missed' or within the grace period.    *
*                                                                              *
* Creation Date:  05/08/1997  By: Phil Mestnick                                *
*******************************************************************************/
void get_corp_orig_id(int fsch_no)
{

   /* EXEC SQL SELECT corp_orig_id
      INTO :g_corp_orig_id
   FROM file_id WHERE fi_rt = :g_fsch_recs.fi_rt[fsch_no] and
      file_id = :g_fsch_recs.file_id[fsch_no]; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 24;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select corp_orig_id into :b0  from file_id where (fi_rt=:b\
1 and file_id=:b2)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )886;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)g_corp_orig_id;
   sqlstm.sqhstl[0] = (unsigned int  )11;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)(g_fsch_recs.fi_rt)[fsch_no];
   sqlstm.sqhstl[1] = (unsigned int  )10;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)&(g_fsch_recs.file_id)[fsch_no];
   sqlstm.sqhstl[2] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_fsch_recs.fi_rt[fsch_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FILE_ID",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Select record from file_id; -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
} /* end get_corp_orig_id() */

/********************** id_nonnacha_file ***************************************
* Description:                                                                 *
*     Attempts to identify the non_nacha file by comparing the first ten       *
* characters from the input file beginning to the NONNACHA_FILE_TYPE table.    *
*  If successful then it Returns True.                                         *
*  If unsuccessful then it Returns False                                       *
*                                                                              *
* Creation Date:  10/22/1997  By: Darcy Sivertson                              *
*******************************************************************************/
int id_nonnacha_file(FILE *file_ptr, char* file_name_str)
{

   /* EXEC SQL BEGIN DECLARE SECTION; */ 

      char  input_file_begin[11];   //temp variable 
      char  dummy_type[11];         //output host var
      short dummy_type_ind;         //output host var
   /* EXEC SQL END DECLARE SECTION; */ 


   int iBytesRead = 0;  
   
   memset(input_file_begin, 0, 11);
   memset(dummy_type, 0, 11);
   dummy_type_ind = 0;

   //place first ten characters of file_ptr into input_file_begin
   iBytesRead = fread(input_file_begin, sizeof(char), 10, file_ptr);
   input_file_begin[10] = 0;
   if (iBytesRead <= 0)
   {
      gpszIFSMsg = ifs_fatal("FILEREAD", 
                              __FILE__,(DWORD)__LINE__, IFS_LOG,
                              file_name_str,
                              _itoa(_doserrno, gs_scratch, 10),
                              NULL);
      return -1;
   }

   //sets file position to beginning, returns non_zero on error
   if (fseek(file_ptr, 0L, SEEK_SET))
   {
      gpszIFSMsg = ifs_fatal("FILESEEK", 
                              __FILE__, (DWORD)__LINE__, IFS_LOG,
                              file_name_str, 
                              _itoa(_doserrno, gs_scratch, 10),
                              NULL);
      return -1;
   }

   //Converts all characters to upper case
   upch(input_file_begin);
   //removes all whitspaces from beginning & end of string, NULL terminiated
   trimlr(input_file_begin); 

   //searching for a nonnacha_file_type equal to the input_file_begin
   /* EXEC SQL SELECT nonnacha_file_type
            INTO :dummy_type:dummy_type_ind
            FROM nonnacha_file_type
            WHERE UPPER(LTRIM(RTRIM(nonnacha_file_type))) = :input_file_begin; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 24;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select nonnacha_file_type into :b0:b1  from nonnacha_file_\
type where UPPER(LTRIM(RTRIM(nonnacha_file_type)))=:b2";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )913;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)dummy_type;
   sqlstm.sqhstl[0] = (unsigned int  )11;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)&dummy_type_ind;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)input_file_begin;
   sqlstm.sqhstl[1] = (unsigned int  )11;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   //Status variable returns 0 if no ORACLE errors detected
   if (sqlca.sqlcode == 0 && dummy_type_ind == 0)
      return 1;
   else return 0;
} /* end id_nonnacha_file() */
                                                                                                                                                                                                                                                                                                                                                                                                                                    document/set2/CKFILSCH.PC_2.pdf                                                                     0000644 €    %çg4001001 00000247270 14011517332 014256  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               /*******************************************************************************
CKFILSCH.PC -- An ACHOS Program - Module of WATCH.EXE
Version 1.08.10

Copyright (C) 1995, 1998 Deluxe Data Systems, Inc.
Copyright (C) 1997, 1998, 1999 Deluxe Electronic Payent Systems, Inc.

Part of WATCH.EXE which does file input based on the file schedule.
*******************************************************************************/


/*******************************************************************************
   INCLUDES & DEFINES                              
*******************************************************************************/

EXEC SQL BEGIN DECLARE SECTION;
/* This #define PREVENTS the sqlca to be declared as external in sqlca.h */
#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern
#define INCLUDE_AS_EXTERN   extern

EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE  "sqlproto.h";
EXEC SQL INCLUDE  "sqlca.h";
EXEC SQL INCLUDE  "orcltype.h";
#include          "ddsi.h"
#include          "achosprd.h"
#include          "stdlib.h"

EXEC SQL INCLUDE watch; /* inserts watch.h into src for Pro*C */ 


long  offset = 0; /* number of bytes read so far in search of the one record*/

/*********************** ck_file_sch *******************************************
* Description:                                                                 *
*  Gets all files from ioq that need to be run thru ACHINPUT and calls         *
* input_file() to process them. It also checks the file_sch for files at_risk  *
* (that are in their late grace period) and warns the FI.  Also, checks the    *
* file for files that missed their schedule and notifies FI.                   *
*                                                                              *
* Creation Date:  06/25/1996  By: Troy Clark                                   *
* Modified Date:  11/18/1996  By: Dan Jung                                     *
* Modified Date:  02/01/1999  By: R.Malladi  Bug Fixes: 90128Hb and 90128I     *
* Modified Date:  02/02/1999  By: FRNash     Bug Fix: 90201Ea                  *
* Modified Date:    03/14/2000  By: Mike West   Dev Req 99-106
*******************************************************************************/
void ck_file_sch(void)
{
   int   ioq_cnt = 0;
   int   ioq_no;                 /* index no for ioq buffers */
   int   cur_ioq_cnt;            /* current IOQ count */

int errcode;
   
   /* display message to screen */
   paint_task_line(1, "Checking IOQ.....");
   Sleep(2000);

   /* Get all files that are available to be input!                           */
   EXEC SQL DECLARE ioq_cursor CURSOR FOR   /* declare cursor */
   SELECT  upper(i.file_name), 
         TO_CHAR(i.recv_ts, 'YYYYMMDDHH24MISS'),
         i.fi_rt, 
         upper(i.type)
         FROM fi f, ioq i
         WHERE f.fi_rt = i.fi_rt 
         AND f.active_yn = 'Y' 
         AND f.wh_status = 'U' 
         AND i.status = 'AU'
         ORDER  BY recv_ts;

   /* Notice that the above select statement performs a join on the FI and    */
   /* ioq table such that only ioq records whose dst_fi_rt matches a FI       *
   /* record's fi_rt where the fi is active and in an "Up" condition are      */
   /* returned. Thus, we don't need to check the fi for a wh_status = 'U'     */
   /* after the fact--it's built into the where clause...                     */

   EXEC SQL OPEN ioq_cursor;           /* opens cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "IOQ_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"OPEN CURSOR ioq_cursor failed in ck_file_sch()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* Loop through all files that need to be input, fetching IOQ_BUF_CNT      */
   /* number of records at a time on each pass through the loop.              */
   /* EG. if 200 files need to be input and IOQ_BUF_CNT = 100 then,           */
   /*       it will loop 2 times, fetching & processing 100 on each pass...   */

   EXEC SQL FETCH ioq_cursor INTO :g_ioq_recs:g_ioq_inds; /* fetch record */  

   while ((sqlca.sqlcode == ORCL_NOT_FOUND || sqlca.sqlcode == ORCL_NO_ERROR) 
            && sqlca.sqlerrd[2] > 0) 
   {

      /* Save the actual # of ioq file records fetched */
      cur_ioq_cnt = sqlca.sqlerrd[2] - ioq_cnt;
      ioq_cnt = sqlca.sqlerrd[2];

      /* Process all file records fetched into g_ioq_recs buffer */
      for (ioq_no = 0; ioq_no < cur_ioq_cnt; ioq_no++) 
         input_file( ioq_no );

      if (cur_ioq_cnt < IOQ_BUF_CNT)
         break;
      else
         /* Attempt to fetch another buffer full for the next pass */
         EXEC SQL FETCH ioq_cursor INTO :g_ioq_recs:g_ioq_inds;
   }  

   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      /* Fetch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "IOQ_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);   
      paint_task_line(0, "Fetch ioq_cursor failed in ck_file_sch()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   EXEC SQL CLOSE ioq_cursor;   /* closes cursor */

   errcode = sqlca.sqlcode;

   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "IOQ_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"CLOSE CURSOR ioq_cursor failed in ck_file_sch()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   
   /* Identify files that are now in their "Late Grace" period,               */
   /* update their at_risk_yn = 'Y' and send a msg to the fi.                 */
   
   file_sch_ck_at_risk();
   
} /* end ck_file_sch() */


/************************ input_file *******************************************
* Description:                                                                 *
*     Attempts to ID the file in ioq buffer and then sees if the file is       *
* scheduled (expected now).  If so, then it submits an ACHINPUT job.           *
*                                                                              *
* Creation Date:  06/25/1996  By: Troy Clark                                   *
* Modified Date:  07/08/1996  By: George Lin                                   *
* Modified Date:  11/04/1996  By: Dan Jung                                     *
* Modified Date:  10/22/1997  By: Darcy Sivertson                              *
*  Description of modification: Attempts to ID the file in ioq buffer as a     *
*  non_nacha file                                                              *
*******************************************************************************/
void input_file(int ioq_no)
{
   int      identified_nacha_file=0;      /* temp var */
   int      identified_nonnacha_file=0;   /*temp var */
   int      wRecSize;            /* var for record size */
   char     strFName[13];        /* var for file name */
   char     ynRejected;          /* var for file rejected yes or no */
   char     strRecvTS[15];       /* var for file received time stamp */
   double   dwFileSchId;         /* var for file sch id */
   FILE     *filePtr;            /* temp var for file pointer */
   char     errstr[300];         /* error string */
   char     rec_one[95];         /* used to store the file header (record 1) */
   char     msg_text[396];       /* actual message text to post */
   char     tmp_str[350];        /* temporary string */

   char  connect_yn[15];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  fi_rt[17];
   char  file_name_str[300];
   char  file_name[80];
   int   ok_to_submit = 1;
   char  delivery_path[129];
   char  nacha_path[129];
   char  nonnacha_path[129];
   char  command_string[512];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;

   EXEC SQL BEGIN DECLARE SECTION;
      char     strRT[10];           /* var for fi rt string */
      double   dwFileId;         /* var for file id */
      char     root_path[129];
      char     input_path[129];
   EXEC SQL END DECLARE SECTION;

   /* strFName represents --> g_ioq_recs.file_name[ioq_no]                    */
   /*       and                                                               */
   /* strRT  represents --> g_ioq_recs.fi_rt[ioq_no]                          */

   strcpy(strFName, g_ioq_recs.file_name[ioq_no]); 
   strcpy(strRT,    g_ioq_recs.fi_rt[ioq_no]);     
   strcpy(strRecvTS,g_ioq_recs.recv_ts[ioq_no]);   

   /* set ioq status to "Achinput In-process" */
   if (ioq_set_status(strFName, strRT, "AI") == ERR) 
   {
      paint_task_line(1, "Set ioq status to AI failed in input_file()!");
      do_exit(1);
   }
   
   /* find the path of the input file */
   EXEC SQL SELECT upper(js_root_path), upper(input_path)
   INTO :root_path, :input_path
   FROM sys_info 
   WHERE fi_rt = :g_ioq_recs.fi_rt[ioq_no];
   
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_ioq_recs.fi_rt[ioq_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(js_root_path, input_path FROM) SYS_INFO",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select sys_info failed in input_file()! ");
      do_exit(1);
   }

/* Determine if slashes need to be added, and build file name */
   trimlr(root_path);
   trimlr(input_path);

   if (input_path[0] != '\\')
   {
      if (root_path[strlen(root_path) - 1] != '\\')
         strcat(root_path,"\\");
   }
   else
   {
      if (root_path[strlen(root_path) - 1] == '\\')
      {
         root_path[strlen(root_path) - 1] = '\0';
      }
   }

   if (input_path[strlen(input_path) - 1] == '\\')
   {
      input_path[strlen(root_path) - 1] = '\0';
   }

   upch(g_ioq_recs.type[ioq_no]);

   memset(delivery_path, 0, 129);
   memset(nacha_path, 0, 129);
   memset(nonnacha_path, 0, 129);
   memset(command_string, 0, 512);

   copy_cat(delivery_path, root_path, "DELIVERY",NULL);
   copy_cat(nacha_path, root_path, input_path, NULL);
   copy_cat(nonnacha_path, root_path, input_path, "\\", "NONNACHA", NULL);

   trimlr(delivery_path);
   trimlr(nacha_path);
   trimlr(nonnacha_path);

   copy_cat(file_name_str, root_path, input_path, "\\", strFName, NULL);

   dwFileId = 0;
   dwFileSchId = 0;

   /* Open strFName as filePtr */
   filePtr = fopen(file_name_str, "r");

   if (filePtr == NULL)
   {
      gpszIFSMsg = ifs_fatal("FILEOPENR", 
                              __FILE__, (DWORD)__LINE__, IFS_LOG,
                              file_name_str, 
                              _itoa(_doserrno, gs_scratch, 10), 
                              NULL);
      paint_task_line(0, "Fopen failed in input_file()!");
      do_exit(1);
   }
   
   /* try to identify the input file as NON_NACHA*/ 
   identified_nonnacha_file = id_nonnacha_file(filePtr, file_name_str); 

   /* NOTE: id_input_file() sets dwFileID=0 if the file is not id’d  */
   if (fclose(filePtr) != OK)   /* close filePtr */
   {
      gpszIFSMsg = ifs_fatal("FILECLOSE", 
                              __FILE__,(DWORD)__LINE__,IFS_LOG,
                              file_name_str, 
                              _itoa(_doserrno, gs_scratch, 10), 
                              NULL);
      paint_task_line(0, "Fclose failed in input_file()!");
      do_exit(1);
   }
   
   if (identified_nonnacha_file == 0) /* file unidentified as a NON-NACHA file*/
   {  
      /* try to identify the input file as NACHA*/    

      filePtr = fopen(file_name_str, "r");

      if (filePtr == NULL)
      {  
         gpszIFSMsg = ifs_fatal("FILEOPENR", 
                                 __FILE__,(DWORD)__LINE__, IFS_LOG,
                                 file_name_str, 
                                 _itoa(_doserrno, gs_scratch, 10), 
                                 NULL);
         paint_task_line(0, "Fopen failed in input_file()!");
         do_exit(1);
      }

      identified_nacha_file = 
      id_input_file(rec_one, strRT, filePtr, file_name_str, &dwFileId, &ynRejected, &wRecSize);

      if (fclose(filePtr) != OK)   /* close filePtr */
      {
         gpszIFSMsg = ifs_fatal("FILECLOSE", 
                                 __FILE__, (DWORD)__LINE__,IFS_LOG,
                                 file_name_str, 
                                 _itoa(_doserrno, gs_scratch, 10), 
                                 NULL);
         paint_task_line(0, "Fclose failed in input_file()!");
         do_exit(1);
      }

      if (!identified_nacha_file) /* file unidentified as NACHA file */
      {
		  //Error message format changed - R120054493-Non NACHA Errors ability to drill
         copy_cat(tmp_str, "<FILENAME-",strFName,">"," The file received could not be identified as a NACHA or a Non-Nacha input file",NULL);
         paint_proc_info(tmp_str);
         paint_proc_info(blank_line);
         if (!post_msg_risk(strRT, NULL, 'E', tmp_str, "OT", -1, -1, -1, -1, -1,4))
         {
            copy_cat(g_fi_info, "FI: ", g_ioq_recs.fi_rt[ioq_no], NULL);
            gpszIFSMsg = ifs_fatal("AOS_WRITE_MSG",
                                    __FILE__, (DWORD) __LINE__, IFS_LOG,
                                    "-1", "E", tmp_str, "OT", "-1", "-1", "-1",
                                    g_fi_info,
                                    NULL);
            paint_task_line(0, "Post_msg_risk failed in input_file()!");
            do_exit(1);
         }

         /* Set file’s io_queue status to completed */
         if (ioq_set_status (strFName, strRT, "AC") == ERR)
         {
            paint_task_line(0, "Ioq_set_status failed in input_file()!");
            do_exit(1);
         }
         return;
      }
      else  /*file Identified as NACHA file*/
      {
         if (strcmp(g_ioq_recs.type[ioq_no], "ACH") == 0)
         {
            if (ynRejected == 'Y')  /* file set to rejected for special header */
            {  
            /* Set file’s io_queue status to completed */
               if (ioq_set_status (strFName, strRT, "AC") == ERR)
               {
                  paint_task_line(0, "ioq_set_status failed in input_file()!");
                  do_exit(1);
               }
      
               /*  Send a "File Rejected for Special Header" message to the FI   */
               copy_cat(tmp_str, "File ", file_name_str, " Rejected for Special Header", NULL);
               paint_proc_info(tmp_str);
               paint_proc_info(blank_line);
			   //Error message format changed - R120054493-Non NACHA Errors ability to drill
               copy_cat(msg_text, "<FILENAME-",strFName,">"," ",rec_one, "File Rejected for Special Header", NULL);
               if (!post_msg_risk(strRT, NULL, 'E', msg_text, "OT", -1, -1, -1, -1, -1,4))
               {
                  copy_cat(g_fi_info, "FI: ", g_ioq_recs.fi_rt[ioq_no], NULL);
                  gpszIFSMsg = ifs_fatal("AOS_WRITE_MSG",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "-1", "E", tmp_str, "OT", "-1", "-1", "-1",
                                       g_fi_info,
                                       NULL);
                  paint_task_line(0, "Post_msg_risk failed in input_file()!");
                  do_exit(1);
               }
               return;
            }
         }
         else
         {
            ok_to_submit = 0;
            // Add code to copy the file to the correct directory
            copy_cat(command_string, "copy ", nacha_path, "\\", strFName, " ", delivery_path, "> nul", NULL);
            if (system(command_string) != 0)
            {
               paint_task_line(0, "Copy of Nacha File failed in input_file()!");
               return;
            }

            EXEC SQL
               UPDATE   ioq
               SET      type = 'ACH', status = 'AC'
               WHERE    fi_rt = :g_ioq_recs.fi_rt[ioq_no]
               AND      file_name = :g_ioq_recs.file_name[ioq_no];

            if (sqlca.sqlcode == ORCL_NO_ERROR)
            {  /* if update successful */
               EXEC SQL COMMIT WORK;
               if (sqlca.sqlcode != ORCL_NO_ERROR)
               {
                  sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
                  g_orcl_etext_buf[g_orcl_etext_len] = '\0';
                  copy_cat(g_fi_info, "FI: ", strRT, NULL);
                  ifs_fatal("ORC_COMMIT",
                              __FILE__, (DWORD)__LINE__, IFS_LOG,
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
                  paint_task_line(0, "Unable to Commit Changes");
                  exit(1);
               }           /* commit update work */
               return;                    
            }
            else
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", strRT, NULL);
               gpszIFSMsg = ifs_warning("ORC_UPDATE",
                                          __FILE__, (DWORD) __LINE__, IFS_LOG,
                                          "IOQ",
                                          g_orcl_etext_buf,
                                          g_fi_info,
                                          NULL);   /* else */
               return;                 
            }
         }
      }
      
   }
   else
   {
      if (strcmp(g_ioq_recs.type[ioq_no], "ACH") == 0)
      {
         ok_to_submit = 0;

         if (identified_nonnacha_file != -1)
         {
            //copy the Non-Nacha File to the correct directory
            copy_cat(command_string, "copy ", nacha_path, "\\", strFName, " ", nonnacha_path, "> nul", NULL);
            if (system(command_string) != 0)
            {
               paint_task_line(0, "Copy of Non-Nacha File failed in input_file()!");
               return;
            }
            
            EXEC SQL
               UPDATE   ioq
               SET      type = 'NNF', status = 'AC'
               WHERE    fi_rt = :g_ioq_recs.fi_rt[ioq_no]
               AND      file_name = :g_ioq_recs.file_name[ioq_no];
         }
         else
         {
			 //Error message format changed - R120054493-Non NACHA Errors ability to drill
            copy_cat(tmp_str,"<FILENAME-",strFName,">"," File ", "cannot be identified because it is Empty or is locked by another process.", NULL);
            paint_proc_info(tmp_str);
            paint_proc_info(blank_line);
            
            strcpy(msg_text, tmp_str);
                        
            if (!post_msg_risk(strRT, NULL, 'E', msg_text, "OT", -1, -1, -1, -1, -1,4))
            {
               copy_cat(g_fi_info, "FI: ", g_ioq_recs.fi_rt[ioq_no], NULL);
               gpszIFSMsg = ifs_fatal("AOS_WRITE_MSG",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "-1", "E", tmp_str, "OT", "-1", "-1", "-1",
                                       g_fi_info,
                                       NULL);
               paint_task_line(0, "Post_msg_risk failed in input_file()!");
               do_exit(1);
            }

            // Write Empty File message to Message Table.
            EXEC SQL
               UPDATE   ioq
               SET      status = 'AC'
               WHERE    fi_rt = :g_ioq_recs.fi_rt[ioq_no]
               AND      file_name = :g_ioq_recs.file_name[ioq_no];
         }

         if (sqlca.sqlcode == ORCL_NO_ERROR)
         {  /* if update successful */
            EXEC SQL COMMIT WORK;
            if (sqlca.sqlcode != ORCL_NO_ERROR)
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", strRT, NULL);
               ifs_fatal("ORC_COMMIT",
                           __FILE__, (DWORD)__LINE__, IFS_LOG,
                           g_orcl_etext_buf,
                           g_fi_info,
                           NULL);
               paint_task_line(0, "Unable to Commit Changes");
               exit(1);
            }           /* commit update work */
            return;                 
         }
         else
         {
            sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
            g_orcl_etext_buf[g_orcl_etext_len] = '\0';
            copy_cat(g_fi_info, "FI: ", strRT, NULL);
            gpszIFSMsg = ifs_warning("ORC_UPDATE",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "IOQ",
                                       g_orcl_etext_buf,
                                       g_fi_info,
                                       NULL);   /* else */
            return;                 
         }
      }
      else
      {
         if (identified_nonnacha_file == -1)
         {
			 //Error message format changed - R120054493-Non NACHA Errors ability to drill
            copy_cat(tmp_str,"<FILENAME-",strFName,">"," File ", "cannot be identified because it is Empty or is locked by another process.", NULL);
            paint_proc_info(tmp_str);
            paint_proc_info(blank_line);
            
            strcpy(msg_text, tmp_str);
                        
            if (!post_msg_risk(strRT, NULL, 'E', msg_text, "OT", -1, -1, -1, -1, -1,4))
            {
               copy_cat(g_fi_info, "FI: ", g_ioq_recs.fi_rt[ioq_no], NULL);
               gpszIFSMsg = ifs_fatal("AOS_WRITE_MSG",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "-1", "E", tmp_str, "OT", "-1", "-1", "-1",
                                       g_fi_info,
                                       NULL);
               paint_task_line(0, "Post_msg_risk failed in input_file()!");
               do_exit(1);
            }

            ok_to_submit = 0;
         }
      }
   }

   if (ok_to_submit)
   {
      if (strcmp(g_ioq_recs.type[ioq_no], "ACH") == 0)
      {
         if ( !file_sch_hit(strRT, dwFileId, &dwFileSchId) ) 
         {

         }
         else
            dwFileSchId = 0L;       
            /* tells achinput to HOLD THE FILE for a sched violation */
      }

      /* Identified as NACHA file, ORIGFILE.JOB submitted with appropriate parameters, 
      IOQ Status Changed*/
      if (identified_nacha_file)
      {
         copy_cat(file_name, "%FILE%=", strFName, NULL);
         copy_cat(fi_rt, "%FI_RT%=", strRT, NULL);
         copy_cat(job_file, job_path, "\\ORIGFILE.JOB", NULL);
         strcpy(connect_yn, "DBCONNECT=N");

         /* Set file’s io_queue status to in process */
         if (ioq_set_status(strFName, strRT, "AI") == ERR)
         {
            paint_task_line(0, "ioq_set_status failed in input_file()!");
            do_exit(1);
         }

         /* submit achinput job */
 	     memset(parm, 0, sizeof(parm));
		 memset(arg, 0, sizeof(arg));
         memset(errstr, 0, sizeof(errstr));

	     strcpy(parm[0], connect_yn);	arguments++;
         strcpy(parm[1], fi_rt);		arguments++;
         strcpy(parm[2], file_name);	arguments++;

		 for(n = 0; n<arguments; n++)
			arg[n] = parm[n];

         if (submit_job(strRT, job_file, errstr, arg, arguments) == ERR)
         {
            copy_cat(g_fi_info, "FI: ", strRT, NULL);
            copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
            gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                                    __FILE__, (DWORD) __LINE__, IFS_LOG,
                                    submit_errfilestr,
                                    g_fi_info,
                                    NULL);
            paint_task_line(1, "sql_jcsubmit error in input_file()!");
            do_exit(1);
         }
   
         copy_cat(msg_text,
                  "ORIGFILE.JOB for FI=",
                  strRT,
                  " was submitted at ",
                  g_prn_time,
                  " on ",
                  g_prn_dt,
                  NULL);
         paint_proc_info(msg_text);
         paint_proc_info(blank_line);
      }

      /* Identified as NON-NACHA file, NACHACNV job submitted with            */
      /* appropriate parameters, IOQ Status Changed                           */
      if (identified_nonnacha_file)
      {
         copy_cat(file_name, "%FILE%=", strFName, NULL);
         copy_cat(fi_rt, "%FI_RT%=", strRT, NULL);          
         copy_cat(job_file, job_path, "\\NACHACNV.JOB", NULL);
         strcpy(connect_yn, "DBCONNECT=N");

         /* Set file’s io_queue status to In Process */
         if (ioq_set_status(strFName, strRT, "AI") == ERR) 
         {
            paint_task_line(0, "ioq_set_status failed in input_file()!");
            do_exit(1);
         }

         /* submit NACHACNV job */
	     memset(parm, 0, sizeof(parm));
		 memset(arg, 0, sizeof(arg));
	     memset(errstr, 0, sizeof(errstr));

	     strcpy(parm[0], connect_yn);	arguments++;
         strcpy(parm[1], fi_rt);		arguments++;
         strcpy(parm[2], file_name);	arguments++;

		 for(n = 0; n<arguments; n++)
			arg[n] = parm[n];

         if (submit_job(strRT, job_file, errstr, arg, arguments) == ERR)
         {
            copy_cat(g_fi_info, "FI: ", strRT, NULL);
            copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
            gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                                    __FILE__, (DWORD) __LINE__, IFS_LOG,
                                    submit_errfilestr,
                                    g_fi_info,
                                    NULL);
            paint_task_line(1, "sql_jcsubmit error in input_file()!");
            do_exit(1);
         }
   
         copy_cat(msg_text,
                  "NACHACNV.JOB for FI=",
                  strRT,
                  " was submitted at ",
                  g_prn_time,
                  " on ", 
                  g_prn_dt,
                  NULL);
      
         paint_proc_info(msg_text);
         paint_proc_info(blank_line);
      }
   }
   else
   {
      /* Set file’s io_queue status to File Processed */
      if (ioq_set_status(strFName, strRT, "AC") == ERR) 
      {
         paint_task_line(0, "ioq_set_status failed in input_file()!");
         do_exit(1);
      }
   }

   return;
/* There was an unmatched brace here!  See 'FIX FOR UNMATCHED BRACE' above.   */
} /* end input_file() */

/********************* ioq_set_status ******************************************
* Description:                                                                 *
*     Sets the ioq record's status = status_str.                               *
*                                                                              *
* Creation Date:  06/24/1996  By: Troy Clark                                   *
* Modified Date:  07/03/1996  By: George Lin                                   *
*******************************************************************************/
/* NOTE: ioq_set_status() needs to be put in ACHOSPRD.LIB once tested.        */
int ioq_set_status(char *file_name, char *fi_rt, char *status_str)
{
   EXEC SQL BEGIN DECLARE SECTION; /* declare host variable */
      char  h_file_name[13];     /* file name */
      char  h_fi_rt[10];         /* fi rt */
      char  h_status_str[3];     /* status */
   EXEC SQL END DECLARE SECTION;

   strcpy(h_file_name, file_name);  /* copy argument to host variable */
   strcpy(h_fi_rt, fi_rt);
   strcpy(h_status_str, status_str);

   /* update ioq set status to status_str */
   EXEC SQL
      UPDATE   ioq
      SET      status = :h_status_str 
      WHERE    file_name = :h_file_name
      AND      fi_rt = :h_fi_rt;

   if (sqlca.sqlcode == ORCL_NO_ERROR)
   {  /* if update successful */
      EXEC SQL COMMIT WORK;
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
         ifs_fatal("ORC_COMMIT",
                     __FILE__, (DWORD)__LINE__, IFS_LOG,
                     g_orcl_etext_buf,
                     g_fi_info,
                     NULL);
         paint_task_line(0, "Unable to Commit Changes");
         exit(1);
      }           /* commit update work */
      return (0);    /* return SUCCESS */
   }
   else
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
      gpszIFSMsg = ifs_warning("ORC_UPDATE",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "IOQ",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);                           
      return (ERR);  /* return ERROR */
   }
} /* end ioq_set_status() */


/******************* file_sch_set_status ***************************************
* Description:                                                                 *
*     Set the file_sch records status to value of the char new_status;  if     *
* proc_status gets set to IN_PROCESS, it must also set the at_risk_yn to 'N'.  *
*                                                                              *
* Creation Date:  06/24/1996  By: Troy Clark                                   *
* Modified Date:  07/05/1996  By: George Lin                                   *
*******************************************************************************/
int file_sch_set_status(char *fi_rt, double fsch_id, char new_status)
{
   EXEC SQL BEGIN DECLARE SECTION;
      char  h_fi_rt[10];         /* fi rt */
      double h_fsch_id;       /* sch id */
      char  h_new_status;        /* new status */
   EXEC SQL END DECLARE SECTION;

   strcpy(h_fi_rt, fi_rt);
   h_new_status = new_status;
   h_fsch_id = fsch_id;

   /* Update the file_sch records proc_status to new_status                   */
   /* Return SUCCESS or ERROR...                                              */

   if (h_new_status == 'Y')
   {
      EXEC SQL
         UPDATE   file_sch
         SET      proc_status = 'Y',
                  at_risk_yn  = 'N' 
         WHERE    fi_rt = :h_fi_rt
         AND      file_sch_id = :h_fsch_id;
   }
   else
   {
    EXEC SQL
       UPDATE  file_sch
       SET     proc_status = :h_new_status
       WHERE   fi_rt = :h_fi_rt
       AND     file_sch_id = :h_fsch_id; 
   }

   if (sqlca.sqlcode == ORCL_NO_ERROR)
   {  /* if update successful */
      EXEC SQL COMMIT WORK;            /* commit update work */
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
         ifs_fatal("ORC_COMMIT",
                     __FILE__, (DWORD)__LINE__, IFS_LOG,
                     g_orcl_etext_buf,
                     g_fi_info,
                     NULL);
         paint_task_line(0, "Unable to Commit Changes");
         exit(1);
      }
      return (0);          /* return SUCCESS */
   }
   else
   {                          
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
      gpszIFSMsg = ifs_warning("ORC_UPDATE",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "FILE_SCH",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
      return (-1);         /* return ERROR */
   }
} /* end file_sch_set_status() */


/*********************** id_input_file *****************************************
* Description:                                                                 *
*     Attempts to identify an achinput file by finding a file_id record whose  *
* non-null criteria fields match the corresponing fields in the file’s ‘1’     *
* record.  If success then it...                                               *
*  1. Sets *file_id = found file_id.                                           *
*  2. If the file contained a special header but the matching file_id was not  *
*     defined to expect one then sets the *ynRejectPtr = ‘Y’ else ‘N’.         *
*  3. Sets the *wRecSizePtr = 94 or 96 depending on whether or not there are   *
*     CR/LF’s at end of records.                                               *
*  4. Returns True.                                                            *
*                                                                              *
*  If unsuccessful then it Returns False                                       *
*                                                                              *
* Creation Date:  06/25/1996  By: Troy Clark                                   *
* Modified Date:  07/09/1996  By: George Lin                                   *
*******************************************************************************/
int id_input_file(char *rec_one, char *fi_rt, FILE *file_ptr, 
               char *file_name_str, double *file_id, 
               char* reject_yn, int* rec_size)
{
   long  offset_to_one;       /* offset to one rec    */
   long  hdr_yn;              /* Was there a special header not indicated */
   char  temp_rec[96];        /* temporary record        */
   short rec_len;             /* record length        */
   short rec_idx;             /* record index            */
   short fld_idx;             /* field index          */

   typedef struct nacha_one_rec_tag{   /* struct for nacha one rec */
      char rec_type[1];
      char priority_code[2];
      char imm_dest[10];
      char imm_origin[10];
      char file_creat_yymmdd[6];
      char file_creat_hhmm[4];
      char file_id_mod[1];
      char rec_size[3];
      char block_fact[2];
      char format_code[1];
      char imm_dest_name[23];
      char imm_origin_name[23];
      char ref_code[8];
   } nacha_one_rec;

   nacha_one_rec  one[1];     /* record for nacha one rec */

   EXEC SQL BEGIN DECLARE SECTION;  /* declare host var */
      char     h_fi_rt[10];
      char     h_imm_origin[11]; 
      char     h_imm_origin_name[24];
      char     h_priority_code[3];
      char     h_imm_dst[11];
      char     h_file_creat_yymmdd[7];
      char     h_file_creat_hhmm[5];
      char     h_file_id_mod[2];
      char     h_format_code[2];
      char     h_imm_dst_name[24];
      char     h_ref_code[9];
      double   h_file_id = 0;       
      char     h_spec_hdr_rec_yn[2];
      char     h_file_on_hold_yn[2];
      char     h_foreign_origin_yn[2];
      char     h_hold_if_sch_err_yn[2];
      char     h_hold_if_batch_err_yn[2];
      char     h_hold_if_entry_err_yn[2];
      char     h_test_file_yn[2];
      char     h_corp_orig_id[11];
      double   h_edit_prof_id = 0;
      double   h_edit_err_threshhold = 0;
      double   h_risk_prof_id = 0;
      char     h_bal_file_yn[2];
      short    h_risk_prof_ind = 0;
   EXEC SQL END DECLARE SECTION;

   /* Initialization. We must initialize the variables before they are passed */
   /* into the sp_get_file_id() function, or we'll get an oracle error.       */

   h_fi_rt[0] = 0;
   h_imm_origin[0] = 0; 
   h_imm_origin_name[0] = 0;
   h_priority_code[0] = 0;
   h_imm_dst[0] = 0;
   h_file_creat_yymmdd[0] = 0;
   h_file_creat_hhmm[0] = 0;
   h_file_id_mod[0] = 0;
   h_format_code[0] = 0;
   h_imm_dst_name[0] = 0;
   h_ref_code[0] = 0;
   h_spec_hdr_rec_yn[0] = 0;
   h_file_on_hold_yn[0] = 0;
   h_foreign_origin_yn[0] = 0;
   h_hold_if_sch_err_yn[0] = 0;
   h_hold_if_batch_err_yn[0] = 0;
   h_hold_if_entry_err_yn[0] = 0;
   h_test_file_yn[0] = 0;
   h_corp_orig_id[0] = 0;
   h_bal_file_yn[0] = 0;


   strcpy(h_fi_rt, fi_rt);

   /* Basically, you find the one_rec_offset, read the one record, pass the   */
   /* criteria fields from the one_rec to the stored proc sp_find_file_id()   */
   /* which sets two arg values -- file_id and has_spec_hdr_rec_yn that       */
   /* represent the matching file_id and the value of its has_spec_hdr_rec_yn */
   /* field. File_id will be 0 if no match is found. The process of searching */
   /* for a valid 1-record will continue until either an EOF occurs or a      */
   /* valid one record is found.                                              */

      offset_to_one = one_rec_offset(file_ptr, file_name_str, rec_size);
      if (offset_to_one == -1)   /* error has found */
         return(0);

   /* Save the offset_to_one for use in checking if the file is rejected      */
      hdr_yn = offset_to_one;


   /*//////////////////////////////////////////////////////////////////*/
   /*                                                                  */
   /*Cycle through the file until a "valid" one record or EOF is found */
   /*                                                                  */
   /*//////////////////////////////////////////////////////////////////*/

   do
   {
      /* SEEK_SET means to move the file pointer offset bytes from the        */
      /* beginning of the file.                                               */
      if (fseek (file_ptr, offset_to_one, SEEK_SET) != OK)
      {
         gpszIFSMsg = ifs_fatal("FILESEEK", 
                                 __FILE__, (DWORD)__LINE__, IFS_LOG,
                                 file_name_str, 
                                 _itoa(_doserrno, gs_scratch, 10),
                                 NULL);
         paint_task_line(0, "fseek failed in id_input_file()!");
         do_exit(1);
      }
      
      if (*rec_size == 96)
      {
         fgets(temp_rec, 97, file_ptr);   /* fgets should be used for rec_size = 96 */
         trimlr(temp_rec);
         rec_len = strlen(temp_rec) - 1;
            
         strncpy(h_priority_code,      temp_rec+1,  2);
         strncpy(h_imm_dst,            temp_rec+3,  10);
         strncpy(h_imm_origin,         temp_rec+13, 10);
         strncpy(h_file_creat_yymmdd,  temp_rec+23, 6);
         strncpy(h_file_creat_hhmm,    temp_rec+29, 4);
         strncpy(h_file_id_mod,        temp_rec+33, 1);
         strncpy(h_format_code,        temp_rec+39, 1);

         h_priority_code      [2]   = 0;
         h_imm_dst            [10]  = 0;
         h_imm_origin         [10]  = 0;
         h_file_creat_yymmdd  [6]   = 0;
         h_file_creat_hhmm    [4]   = 0;
         h_file_id_mod        [1]   = 0;
         h_format_code        [1]   = 0;
         
         h_imm_dst_name       [0]   = 0;
         h_imm_origin_name    [0]   = 0;
         h_ref_code           [0]   = 0;

         /* Note:                                                             */
         /*   h_imm_dst_name, h_imm_origin_name, h_ref_code may or may not    */
         /* exist. That is why we have to parse each separately, see below.   */

         if (rec_len >= 41)
         {
            memset(h_imm_dst_name, ' ', 23);
         
            rec_idx = 40;
            fld_idx = 0;
            
            while (  (rec_idx <= 62) && (temp_rec[rec_idx] != 0) &&
                     (temp_rec[rec_idx] != '\n') && (temp_rec[rec_idx] != '\r')
                  )
               h_imm_dst_name[fld_idx++] = temp_rec[rec_idx++];

            h_imm_dst_name[23]   = 0;
         }
         
         if (rec_len >= 64)
         {
            memset(h_imm_origin_name, ' ', 23);
            rec_idx = 63;
            fld_idx = 0;
               
            while (  (rec_idx <= 85) && (temp_rec[rec_idx] != 0) && 
                     (temp_rec[rec_idx] != '\n') && (temp_rec[rec_idx] != '\r')
                  )
               h_imm_origin_name[fld_idx++] = temp_rec[rec_idx++];

            h_imm_origin_name[23] = 0;
         }
         
         if (rec_len >= 86)
         {
            memset(h_ref_code, ' ', 8);
            rec_idx = 86;
            fld_idx = 0;
            while (  (rec_idx <= 93) && (temp_rec[rec_idx] != 0) &&
                     (temp_rec[rec_idx] != '\n') && (temp_rec[rec_idx] != '\r')
                  )
               h_ref_code[fld_idx++] = temp_rec[rec_idx++];

            h_ref_code[8]  = 0;
         }
      }
      else 
      {
         if (fread (one, sizeof(struct nacha_one_rec_tag), 1, file_ptr) <= 0)
         {
            gpszIFSMsg = ifs_fatal("FILEREAD", 
                                    __FILE__,(DWORD)__LINE__,IFS_LOG,
                                    file_name_str, 
                                    _itoa(_doserrno, gs_scratch, 10),
                                    NULL);  
            return -1;
         }
         
         move(h_imm_origin,      10,      one[0].imm_origin,         1);
         move(h_priority_code,    2,      one[0].priority_code,      1);
         move(h_imm_dst,         10,      one[0].imm_dest,        1);   
         move(h_file_creat_yymmdd,6,      one[0].file_creat_yymmdd,  1);
         move(h_file_creat_hhmm,  4,      one[0].file_creat_hhmm,    1);
         move(h_file_id_mod,      1,      one[0].file_id_mod,        1);
         move(h_format_code,      1,      one[0].format_code,        1);
         move(h_imm_dst_name, 23,      one[0].imm_dest_name,      1);
         move(h_imm_origin_name, 23,      one[0].imm_origin_name,    1);
         move(h_ref_code,     8,    one[0].ref_code,        1);
      }

      copy_cat(rec_one, h_imm_origin, h_priority_code, h_imm_dst,
               h_file_creat_yymmdd, h_file_creat_hhmm,
               h_file_id_mod, h_format_code, h_imm_dst_name,
               h_imm_origin_name, h_ref_code, NULL);

      EXEC SQL EXECUTE
      BEGIN
         sp_get_file_id(:h_fi_rt, :h_imm_origin, :h_priority_code,
            :h_imm_dst, :h_file_creat_yymmdd, :h_file_creat_hhmm,
            :h_file_id_mod, :h_format_code, :h_imm_dst_name,
            :h_imm_origin_name, :h_ref_code, :h_file_id,
            :h_file_on_hold_yn, :h_foreign_origin_yn,
            :h_hold_if_sch_err_yn, :h_hold_if_batch_err_yn, 
            :h_hold_if_entry_err_yn, :h_spec_hdr_rec_yn,
            :h_test_file_yn, :h_corp_orig_id, :h_edit_prof_id,
            :h_edit_err_threshhold, :h_risk_prof_id:h_risk_prof_ind, :h_bal_file_yn);
      END;
      END-EXEC;

      if (sqlca.sqlcode != ORCL_NO_ERROR) 
      {
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", h_fi_rt, NULL);
         gpszIFSMsg = ifs_fatal("ORC_SELECT",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "FILE_ID",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
         paint_task_line(0,"Select record from file_id; -- FAILED!");
         paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
         do_exit(1);
      }

      *file_id = h_file_id;

      if ((int)*file_id == 0) 
      {
         /* no matching file_id record was found try to find next one record */
         offset_to_one = find_one_rec (file_ptr, rec_size, offset_to_one, file_name_str);

         if(offset_to_one == -1)
            return 0;
      }
      else 
      {
         if (h_spec_hdr_rec_yn[0] == 'N' && hdr_yn > 0)
         {
            /* file_id said no spec hdr but file had one */
            *reject_yn = 'Y'; 
            return 1;
         }
         else
         {
            *reject_yn = 'N';
            return 1;
         }
      }

      /*cycle through the file until a "valid" one record or EOF is found */

   }  while(offset_to_one != -1);
   return 1;//taa
} /* end id_input_file() */

/***************************** find_one_rec ************************************
* Description:    This function will be called if the first one record in the  *
*              file is not valid.  A search for the next, if any, one record   *
*              is done and the number of bytes to that one record is returned. *                                                        *
*                                                                              *
*                                                                              *
* Creation Date:  05/15/1998           By: Darcy Sivertson                     *
* Modified Date:  10/22/1998           By: Mike West                           *
*******************************************************************************/
long find_one_rec(FILE* fPointer, int* rec_size, long offset_to_one, char* file_name_str)
{

   char  temp_one[96];           /* temporary record        */
   long  lOldOffset;
   int   offset_bytes = *rec_size ;
   int   temp_str_len = 0;

   /* struct for nacha one rec */
   typedef struct nacha_one_rec_tag
   {  
      char rec_type;
      char priority_code[2];
      char imm_dest[10];
      char imm_origin[10];
      char file_creat_yymmdd[6];
      char file_creat_hhmm[4];
      char file_id_mod[1];
      char rec_size[3];
      char block_fact[2];
      char format_code[1];
      char imm_dest_name[23];
      char imm_origin_name[23];
      char ref_code[8];
   } nacha_one_rec;

   nacha_one_rec  one[1];     /* record for nacha one rec */

   /* Make sure that we have valid file pointer */
   if (!fPointer)
      return -1;

   /* Use this block of code if the file has carrage returns/line feeds        */
   /* cycle through the file until a one record is found -- return pointer     */
   /* position to one record.                                                  */
   if(offset_bytes == 96)
   {
      for(;;)
      {
         /*Read to the end of this line (carrage return/line feed)*/
         if(fgets(temp_one, 97, fPointer) == NULL)
         {
            return -1;
         }

         trimlr(temp_one);

         if (strlen(temp_one) == 0)
            continue;

         /*Check for indication of one record */
         if(temp_one[0] == '1')
         {
            /* Save current file position */
            lOldOffset = ftell(fPointer);
            if (lOldOffset == -1)
            {
               gpszIFSMsg = ifs_fatal("FILEREAD", 
                                       __FILE__,(DWORD)__LINE__,IFS_LOG,
                                       file_name_str,
                                       _itoa(_doserrno, gs_scratch, 10),
                                       NULL);
               return -1;
            }
            /* return bytes from beginning of file to one record */
            temp_str_len = strlen(temp_one);
            return (lOldOffset - temp_str_len);

         }
      } // End of For
   } // End of If

   /* Use this block of code if the file is continous w/out carrage returns/line feeds */
   /* cycle through the file until a one record is found -- return pointer position to one record*/
   if(offset_bytes == 94)
   {
      for(;;)
      {
         if (fread (one, sizeof(struct nacha_one_rec_tag), 1, fPointer) <= 0)
         {
            gpszIFSMsg = ifs_fatal("FILEREAD", 
                                    __FILE__, (DWORD)__LINE__, IFS_LOG,
                                    file_name_str, 
                                    _itoa(_doserrno, gs_scratch, 10),
                                    NULL);  
            return -1;
         }

         /*Check for EOF */
         if (feof(fPointer))
         {
            return -1;
         }

         /*Check for indication of one record */
         if(one[0].rec_type == '1' )
         {
            /* Get current file position */
            lOldOffset = ftell(fPointer);
            if (lOldOffset == -1)
            {
               gpszIFSMsg = ifs_fatal("FILEREAD", 
                                       __FILE__,(DWORD)__LINE__,IFS_LOG,
                                       file_name_str,
                                       _itoa(_doserrno, gs_scratch, 10),
                                       NULL);
               return -1;
            }
            /* return bytes from beginning of file to one record */
            temp_str_len = strlen(temp_one);
            return (lOldOffset - temp_str_len);

         }
      } // end For
   }// end If
   return 1;//taa
} /* end find_one_rec() */

   
/********************** one_rec_offset *****************************************
* Description:                                                                 *
*     This function returns the char offset from the beginning of the file to  *
* the actual ‘1’ record and sets the value of *rec_size to either 94 or 96.    *
*     It must determine whether or not there is a custom header in the file    *
* pointed to by strFile.                                                       *
* If yes, then it calculates and returns the offset to the actual ‘1’ record.  *
* Otherwise, it returns an offset of zero.                                     *
* Use the algorithm documented in tech. specs.                                 *
*                                                                              *
* NOTE:  this function will also be used by ACHINPUT.EXE.                      *
*                                                                              *
* Creation Date:  06/25/1996  By: Troy Clark                                   *
* Modified Date:  07/09/1996  By: George Lin                                   *
* Modified Date:  08/28/1996  By: George Lin                                   *
*******************************************************************************/
long one_rec_offset(FILE* fPointer, char* file_name_str, int* rec_size)
{
   char  Temp[192];
   int      iBytesRead;
   int      iIndex;
   int      iRecordLength;    /* var for record length */
   BOOL  bFoundCR = FALSE;
   int      iRemainder, iQuotient;
   long  lFileLength;         /* length of the file */
   long  lOffsetToOne;
   long  lOldOffset;

   /* Make sure that we have valid file pointer */
   if (!fPointer)
      return -1;

   /* Save current file pointer */
   lOldOffset = ftell(fPointer);
   if (lOldOffset == -1)
   {
      gpszIFSMsg = ifs_fatal("FILEREAD", 
                              __FILE__,(DWORD)__LINE__,IFS_LOG,
                              file_name_str,
                              _itoa(_doserrno, gs_scratch, 10),
                              NULL);
      return -1;
   }

   /* Read first 192 bytes of data and check to see if there is any CR/LF.    */
   if (fseek(fPointer, 0L, SEEK_SET))
   {
      gpszIFSMsg = ifs_fatal("FILESEEK", 
                              __FILE__, (DWORD)__LINE__,IFS_LOG,
                              file_name_str, 
                              _itoa(_doserrno, gs_scratch, 10),
                              NULL);
      return -1;
   }
   iBytesRead = fread(Temp, sizeof(char), 192, fPointer);
   if (iBytesRead <= 0)
   {
      gpszIFSMsg = ifs_fatal("FILEREAD", 
                              __FILE__,(DWORD)__LINE__,IFS_LOG,
                              file_name_str,
                              _itoa(_doserrno, gs_scratch, 10),
                              NULL);
      return -1;
   }

   for (iIndex=0; iIndex<iBytesRead; iIndex++)  
   {
      if (Temp[iIndex] == '\r' || Temp[iIndex] == '\n')     /* found CR/LF */
      {
         bFoundCR = TRUE;
         break;
      }
   }

   if (bFoundCR)              /* found CR/LF  */
      iRecordLength = 96;        /* record length = 96 */
   else                       /* else */
      iRecordLength = 94;        /* record length = 94 */


   /* If record length is 94 */
   if (!bFoundCR)
   {
      /* Sets the file position to the end of file, returns non-zero on error */
      if (fseek(fPointer, 0L, SEEK_END))
      {
         gpszIFSMsg = ifs_fatal("FILESEEK", 
                                 __FILE__,(DWORD)__LINE__,IFS_LOG,
                                 file_name_str, 
                                 _itoa(_doserrno, gs_scratch, 10),
                                 NULL);
         return -1;
      }
      /* returns the current file position, which has been set to eof */
      lFileLength = ftell(fPointer);

      /* Check for error in returning file length */
      if (lFileLength == -1)
      {
         gpszIFSMsg = ifs_fatal("FILEREAD", 
                                 __FILE__,(DWORD)__LINE__, IFS_LOG,
                                 file_name_str,
                                 _itoa(_doserrno, gs_scratch, 10),
                                 NULL);
         return -1;
      }

      iRemainder = lFileLength % iRecordLength;

      /* No offset to the one record is found */
      if (!iRemainder)
         lOffsetToOne = iRemainder;
      else
      {
         iQuotient = lFileLength / iRecordLength;
         if (iQuotient == (iQuotient / 10) * 10)
            lOffsetToOne = 0;
         else
            lOffsetToOne = iRecordLength;
      }
   }
   else  /* Found CR/LF */
   {
      while (Temp[iIndex] == '\r' || Temp[iIndex] == '\n')
         iIndex++;
      if (Temp[iIndex] == '1')
      {
         iIndex++;
         lOffsetToOne = (long)iIndex;
      }
      else if (Temp[iIndex] == '5')
         lOffsetToOne = 0;
      else
         lOffsetToOne = -1;
   }

   /* Restore original file offset. */
   if (fseek(fPointer, lOldOffset, SEEK_SET))
   {
      gpszIFSMsg = ifs_fatal("FILESEEK", 
                              __FILE__,(DWORD)__LINE__, IFS_LOG,
                              file_name_str, 
                              _itoa(_doserrno, gs_scratch, 10),
                              NULL);
      return -1;
   }
   *rec_size = iRecordLength;

   return lOffsetToOne;
} /* end one_rec_offset() */


/************************ file_sch_hit *****************************************
* Description:                                                                 *
*  Attempts to find a file_sch record for the h_file_id arg that is within     *
* it's earliest_ts and latest_ts.                                              *
*  Sets the value of h_fch_id and returns 1(true) if successful else 0(false). *
*                                                                              *
* Creation Date:  06/25/1996  By: Troy Clark                                   *
* Modified Date:  07/19/1996  By: George Lin                                   *
*******************************************************************************/
int file_sch_hit(char *fi_rt, double file_id, double *fsch_id)
{
   EXEC SQL BEGIN DECLARE SECTION;     /* declare host variable */
      char     h_fi_rt[10];
      double      h_file_id;
      double      h_file_sch_id;

   EXEC SQL END DECLARE SECTION;

   strcpy(h_fi_rt, fi_rt);
   h_file_id = file_id;

   
   /* Fetch the first file_sch record (eg, (oper_dt + g_cur_time) BETWEEN     */
   /* file_sch.earliest AND file_sch.latest_ts.                               */

   EXEC SQL
      DECLARE  file_sch_cursor CURSOR FOR
      SELECT   fs.file_sch_id
      FROM     fi, file_sch fs 
      WHERE    fi.fi_rt = fs.fi_rt
      AND      fi.active_yn = 'Y'
      AND      fi.wh_status = 'U'
      AND      fi.fi_rt = :h_fi_rt
      AND      fs.file_id = :h_file_id
      AND      (     fs.override_yn = 'Y'
                  OR (     fs.missed_yn = 'N'
                        AND   fs.proc_status = 'N'
                        AND   :g_cur_dt_time > TO_CHAR(fs.earliest_ts, 'YYYYMMDDHH24MISS')
                        AND   :g_cur_dt_time < TO_CHAR(fs.latest_ts, 'YYYYMMDDHH24MISS')
                     )
               );
      
   /* Notice that the above select statement performs a JOIN between the      */
   /* fi and file_sch tables such that only file_sch records whose fi_rt      */
   /* matches a fi record's fi_rt where the fi is active and in an "Up"       */
   /* condition are considered.  The join allows proper date compares since   */
   /* FI's may not all have the same oper_dt due to differing EOD times, etc. */

   EXEC SQL OPEN file_sch_cursor;
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {     /* open cursor failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FILE_SCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Open file_sch_cursor failed!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   EXEC SQL FETCH file_sch_cursor INTO :h_file_sch_id;
   if (sqlca.sqlcode == ORCL_NOT_FOUND)
   {     /* close cursor failed */
      *fsch_id = 0;
      EXEC SQL CLOSE file_sch_cursor;
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
         gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "FILE_SCH_CURSOR",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
         paint_task_line(0, "Close file_sch cursor failed in file_sch_hit!");
         paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
         do_exit(1);
      }
      return(0);
   }
   else if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FILE_SCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Select file_sch failed in file_sch_hit!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);

      EXEC SQL CLOSE file_sch_cursor;
      if (sqlca.sqlcode != ORCL_NO_ERROR) {     /* close cursor failed */
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
         gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                                 __FILE__, (DWORD) __LINE__,IFS_LOG,
                                 "FILE_SCH_CURSOR",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
         paint_task_line(0, "close file_sch cursor failed in file_sch_hit!");
         paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
         do_exit(1);
      }
      return(0);
   }

   *fsch_id = h_file_sch_id;  /* assign file sch id to fsch_id */
   EXEC SQL CLOSE file_sch_cursor;

   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {  /* close cursor failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FILE_SCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Close file_sch cursor failed!");
      paint_task_line(1, sqlca.sqlerrm. sqlerrmc);
      do_exit(1);
   }
   return(1);
} /* end file_sch_hit() */


/******************* file_sch_ck_at_risk ***************************************
* Description:                                                                 *
*   This function checks the file_sch table for files...                       *
*     where their at_risk_yn = 'N'                                             *
*     and   their proc_status = ''(unprocessed)                                *
*     and   'current system timestamp'> their at_risk_ts.                      *
*   For each file found, it sets their at_risk_yn = 'Y' and sends a message to *
* the FI, looping until all "At Risk" files have been processed.               *
*                                                                              *
* Creation Date:  06/19/1996  By: Troy Clark                                   *
* Modified Date:  07/19/1996  By: George Lin                                   *
* Modified Date:  02/03/1999  By: FRNash DR#97-300                             *
*******************************************************************************/
void file_sch_ck_at_risk(void)
{
   int   fsch_no;          /* temp var for file sch no */
   char  file_id_str[20];  /* file_id in string format */
   char  msg_text[171];    /* message text to log to the mes table */
   int      cur_fsch_cnt = 0;    /* current file schedule count */
   char  temp_date2[20];
   char  temp_date3[20];
   char  yyyy[5];
   char  mm[3];
   char  dd[3];
   char  hh[3];
   char  mi[3];
   char  ss[3];

   EXEC SQL BEGIN DECLARE SECTION;
   char  fi_rt[10];
   char  temp_date0[15];
   char  temp_date1[15];
   EXEC SQL END   DECLARE SECTION;
   

   /* Get all file_sch recs that are now in their "Late Grace" period         */
   /* (eg, oper_dt + orcl_cur_hhmm > file_sch.at_risk_ts)                     */

   paint_task_line(1, "Checking File Schedule.....");
   Sleep(2000);   /* delay the message display for 1 second */

   EXEC SQL
      DECLARE  risk_cursor CURSOR FOR
      SELECT
               fs.fi_rt, 
               fs.file_sch_id, 
               fs.file_id,
               TO_CHAR(fs.earliest_ts, 'YYYYMMDDHH24MISS'),
               TO_CHAR(fs.latest_ts, 'YYYYMMDDHH24MISS')
      FROM     fi, file_sch fs 
      WHERE 
               fi.fi_rt = fs.fi_rt AND 
               fi.active_yn = 'Y' AND 
               fi.wh_status = 'U' AND 
               fs.missed_yn = 'N' AND 
               fs.at_risk_yn = 'N' AND
               fs.proc_status = 'N' AND
               :g_cur_dt_time > TO_CHAR(fs.at_risk_ts, 'YYYYMMDDHH24MISS')
      ORDER BY fs.at_risk_ts;

   /* Notice that the above select statement performs a JOIN between the      */
   /* fi and file_sch tables such that only file_sch records whose fi_rt      */
   /* matches a fi record's fi_rt where the fi is active and in an "Up"       */
   /* condition are considered.  The join allows proper date compares since   */
   /* FI's may not all have the same oper_dt due to differing EOD times, and  */
   /* it also addresses the case where the schedule is OVERRIDDEN! etc.       */

   EXEC SQL OPEN risk_cursor;       /* open cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "RISK_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"OPEN CURSOR risk_cursor; -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   
   /* Loop through all files that need to be input, fetching FSCH_BUF_CNT     */
   /* number of records at a time on each pass through the loop.              */
   /* EG. if 200 files need to be input and FSCH_BUF_CNT = 100 then,          */
   /*       it will loop 2 times, fetching & processing 100 on each pass...   */

   EXEC SQL FETCH risk_cursor INTO :g_fsch_recs:g_fsch_inds;   
   
   g_fsch_cnt = 0;
   while ((sqlca.sqlcode == ORCL_NOT_FOUND || sqlca.sqlcode == ORCL_NO_ERROR) 
            && sqlca.sqlerrd[2] > 0) 
   {
      /* Save the actual # of records fetched                                 */
      cur_fsch_cnt = sqlca.sqlerrd[2] - g_fsch_cnt;
      g_fsch_cnt = sqlca.sqlerrd[2];

      /* Process all file records fetched into g_fsch_recs buffer             */
      for (fsch_no = 0; fsch_no < cur_fsch_cnt; fsch_no++) 
      {  
         /* Update the file_sch item's at_risk_yn = 'Y' */
         // modified 02/03/1999 DR#97-300 -FRN
         EXEC SQL
            UPDATE   file_sch SET at_risk_yn = 'Y' 
            WHERE    fi_rt = :g_fsch_recs.fi_rt[fsch_no]
            AND      file_sch_id = :g_fsch_recs.file_sch_id[fsch_no]
            AND      file_id = :g_fsch_recs.file_id[fsch_no]
            AND      :g_cur_dt_time > TO_CHAR(at_risk_ts, 'YYYYMMDDHH24MISS')
            AND      at_risk_yn = 'N';
         
         if (sqlca.sqlcode != ORCL_NO_ERROR)
         {
            sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
            g_orcl_etext_buf[g_orcl_etext_len] = '\0';
            copy_cat(g_fi_info, "FI: ", g_fsch_recs.fi_rt[fsch_no], NULL);
            gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                    __FILE__, (DWORD) __LINE__, IFS_LOG,
                                    "FILE_SCH",
                                    g_orcl_etext_buf,
                                    g_fi_info,
                                    NULL);
            paint_task_line(0,"Update file_sch; -- FAILED!");
            paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
            do_exit(1);
         }
         else
         {
            EXEC SQL COMMIT WORK;   /* commit update work */
            if (sqlca.sqlcode != ORCL_NO_ERROR)
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", g_fsch_recs.fi_rt[fsch_no], NULL);
               ifs_fatal("ORC_COMMIT",
                           __FILE__, (DWORD)__LINE__, IFS_LOG,
                           g_orcl_etext_buf,
                           g_fi_info,
                           NULL);
               paint_task_line(0, "Unable to Commit Changes");
               exit(1);
            }
         }
         
         /* Send a warning message to the FI */
         _gcvt(g_fsch_recs.file_id[fsch_no], 10, file_id_str);

         /* remove the decimal point from file_id_str */
         if (file_id_str[strlen(file_id_str)-1] == '.')
            file_id_str[strlen(file_id_str)-1] = '\0';

         get_corp_orig_id(fsch_no);    /* psm mod - 5/08/1997 */

         strcpy(fi_rt, g_fsch_recs.fi_rt[fsch_no]);
         strcpy(temp_date0, g_fsch_recs.earliest_ts[fsch_no]);

         EXEC SQL EXECUTE
            BEGIN
               :temp_date1 := local_date(:temp_date0, :fi_rt); 
            END;
         END-EXEC;

         strncpy(yyyy, temp_date1, 4);
         yyyy[4] = 0;

         strncpy(mm, temp_date1 + 4, 2);
         mm[2] = 0;

         strncpy(dd, temp_date1 + 6, 2);
         dd[2] = 0;

         strncpy(hh, temp_date1 + 8, 2);
         hh[2] = 0;

         strncpy(mi, temp_date1 + 10, 2);
         mi[2] = 0;

         strncpy(ss, temp_date1 + 12, 2);
         ss[2] = 0;

         sprintf(temp_date2, "%2s/%2s/%4s %2s:%2s:%2s", mm, dd, yyyy, hh, mi, ss);

         strcpy(temp_date0, g_fsch_recs.latest_ts[fsch_no]);

         EXEC SQL EXECUTE
            BEGIN
               :temp_date1 := local_date(:temp_date0, :fi_rt); 
            END;
         END-EXEC;

         strncpy(yyyy, temp_date1, 4);
         yyyy[4] = 0;

         strncpy(mm, temp_date1 + 4, 2);
         mm[2] = 0;

         strncpy(dd, temp_date1 + 6, 2);
         dd[2] = 0;

         strncpy(hh, temp_date1 + 8, 2);
         hh[2] = 0;

         strncpy(mi, temp_date1 + 10, 2);
         mi[2] = 0;

         strncpy(ss, temp_date1 + 12, 2);
         ss[2] = 0;

         sprintf(temp_date3, "%2s/%2s/%4s %2s:%2s:%2s", mm, dd, yyyy, hh, mi, ss);

         //replaced FI_RT with the corporate originator id - PSM, 5/08/1997
         copy_cat(msg_text, "A Scheduled File ", file_id_str,
            " has not arrived and is late.  The Originator is ", 
            g_corp_orig_id, ".  Window is from ", 
            temp_date2, " to ", temp_date3, NULL);

         if (!post_msg(g_fsch_recs.fi_rt[fsch_no], NULL, 'W', msg_text, "OT", -1, -1, -1, -1, -1))
         {
            copy_cat(g_fi_info, "FI: ", g_fsch_recs.fi_rt[fsch_no], NULL);
            gpszIFSMsg = ifs_fatal("AOS_WRITE_MSG",
                                    __FILE__, (DWORD) __LINE__, IFS_LOG,
                                    "-1", "W", msg_text, "OT", "-1", "-1", "-1",
                                    g_fi_info,
                                    NULL);
            paint_task_line(0, "Post_msg failed in file_sch_ck_at_risk()!");
            do_exit(1);
         }

      }
      /* Attempt to Fetch another buffer full of ioq records for the next pass */
      if (cur_fsch_cnt < FSCH_BUF_CNT)
         break;
      else EXEC SQL FETCH risk_cursor INTO :g_fsch_recs:g_fsch_inds; 
   }  

   if ((sqlca.sqlcode != ORCL_NO_ERROR) && (sqlca.sqlcode != ORCL_NOT_FOUND))
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "RISK_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"FETCH risk_cursor FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }


   EXEC SQL CLOSE risk_cursor;      /* close cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "RISK_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"CLOSE Cursor risk_cursor; -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
} /* end file_sch_ck_at_risk() */


/******************** file_sch_ck_missed ***************************************
* Description:                                                                 *
*     This function checks the file_sch table for files...                     *
*           where their at_risk_yn = 'Y'                                       *
*           and   the 'current system timestamp'> their latest_due_ts          *
*           and   fi_rt = strRT.                                               *
*     For each file found, it sets the missed_yn = 'Y' and sends a message to  *
* the FI, looping until all "Missed" files have been processed.                *
*                                                                              *
* Creation Date:  06/19/1996  By: Troy Clark                                   *
* Modified Date:  07/19/1996  By: George Lin                                   *
*******************************************************************************/
void file_sch_ck_missed(void)
{
   int   fsch_no;          /* file sch no */
   int   cur_fsch_cnt = 0;

   /* Identify files that are now BEYOND their "Late Grace" period             */
   /* (eg. oper_dt + g_cur_time > file_sch.latest_ts)                          */

   EXEC SQL DECLARE missed_cursor CURSOR FOR
      SELECT
            fs.fi_rt, 
            fs.file_sch_id, 
            fs.file_id,
            TO_CHAR(fs.earliest_ts, 'YYYYMMDDHH24MISS'),
            TO_CHAR(fs.latest_ts, 'YYYYMMDDHH24MISS')
      FROM
            fi, file_sch fs 
      WHERE 
            fi.fi_rt = fs.fi_rt AND 
            fi.active_yn = 'Y' AND 
            fi.wh_status = 'U' AND 
            fs.missed_yn = 'N' AND 
            fs.at_risk_yn = 'Y' AND
            fs.proc_status = 'N' AND 
            :g_cur_dt_time > TO_CHAR(fs.latest_ts, 'YYYYMMDDHH24MISS')
      ORDER BY 
            fs.latest_ts;
   /* Notice that the above select statement performs a JOIN between the      */
   /* fi and file_sch tables such that only file_sch records whose fi_rt      */
   /* matches a fi record's fi_rt where the fi is active and in an "Up"       */
   /* condition are considered.  The join allows proper date compares since   */
   /* FI's may not all have the same oper_dt due to differing EOD times, etc. */
   EXEC SQL OPEN missed_cursor;
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "MISSED_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"OPEN CURSOR missed_cursor FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   
   /* Loop through all files that need to be input, fetching FSCH_BUF_CNT   */
   /* number of records at a time on each pass through the loop.            */
   /* EG. if 200 files need to be input and FSCH_BUF_CNT = 100 then,        */
   /* it will loop 2 times, fetching & processing 100 on each pass...       */

   EXEC SQL FETCH missed_cursor INTO :g_fsch_recs:g_fsch_inds; 
   
   g_fsch_cnt = 0;
   while ((sqlca.sqlcode == ORCL_NOT_FOUND || sqlca.sqlcode == ORCL_NO_ERROR) 
            && sqlca.sqlerrd[2] > 0) 
   {
      /* Save the actual # of records fetched */
      cur_fsch_cnt = sqlca.sqlerrd[2] - g_fsch_cnt;
      g_fsch_cnt = sqlca.sqlerrd[2];
   
      /* Process all file records fetched into g_fsch_recs buffer             */
      for (fsch_no = 0; fsch_no < cur_fsch_cnt; fsch_no++) 
      { 
         /* Update file_sch item's missed_yn = 'Y'                            */
         /* Update file_sch item's at_risk_yn = 'N'                           */
         EXEC SQL UPDATE file_sch SET missed_yn = 'Y',at_risk_yn = 'N' 
            WHERE  fi_rt = :g_fsch_recs.fi_rt[fsch_no]
              AND  file_sch_id = :g_fsch_recs.file_sch_id[fsch_no]
              AND  file_id = :g_fsch_recs.file_id[fsch_no];
         
         if (sqlca.sqlcode != ORCL_NO_ERROR) 
         {
            sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
            g_orcl_etext_buf[g_orcl_etext_len] = '\0';
            copy_cat(g_fi_info, "FI: ", g_fsch_recs.fi_rt[fsch_no], NULL);
            gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                    __FILE__, (DWORD) __LINE__,
                                    IFS_LOG,
                                    "FILE_SCH",
                                    g_orcl_etext_buf,
                                    g_fi_info,
                                    NULL);
            paint_task_line(0,"Update file_sch; -- FAILED!");
            paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
            do_exit(1);
         }
         else
         {
            EXEC SQL COMMIT WORK;   /* commit update work */
            if (sqlca.sqlcode != ORCL_NO_ERROR)
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", g_fsch_recs.fi_rt[fsch_no], NULL);
               ifs_fatal("ORC_COMMIT",
                           __FILE__, (DWORD)__LINE__, IFS_LOG,
                           g_orcl_etext_buf,
                           g_fi_info,
                           NULL);
               paint_task_line(0, "Unable to Commit Changes");
               exit(1);
            }
         }
      }

      if (cur_fsch_cnt < FSCH_BUF_CNT)
         break;
      else
         /* Attempt to Fetch another buffer full of ioq records for the next pass */
         EXEC SQL FETCH missed_cursor INTO :g_fsch_recs:g_fsch_inds; 
   }

   if ((sqlca.sqlcode != ORCL_NO_ERROR) && (sqlca.sqlcode != ORCL_NOT_FOUND))
   {  /* Fetch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "MISSED_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Fetch record from CURSOR missed_cursor failed!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }


   EXEC SQL CLOSE missed_cursor;
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "MISSED_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"CLOSE CURSOR missed_cursor; -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
} /* end file_sch_ck_missed() */


/********************** get_corp_orig_id ***************************************
* Description:                                                                 *
*     This function retrieves the corp_orig_id from the file_id table in the   *
* case that a file schedule was either 'missed' or within the grace period.    *
*                                                                              *
* Creation Date:  05/08/1997  By: Phil Mestnick                                *
*******************************************************************************/
void get_corp_orig_id(int fsch_no)
{

   EXEC SQL SELECT corp_orig_id
      INTO :g_corp_orig_id
   FROM file_id WHERE fi_rt = :g_fsch_recs.fi_rt[fsch_no] and
      file_id = :g_fsch_recs.file_id[fsch_no];
   
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_fsch_recs.fi_rt[fsch_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "FILE_ID",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Select record from file_id; -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
} /* end get_corp_orig_id() */

/********************** id_nonnacha_file ***************************************
* Description:                                                                 *
*     Attempts to identify the non_nacha file by comparing the first ten       *
* characters from the input file beginning to the NONNACHA_FILE_TYPE table.    *
*  If successful then it Returns True.                                         *
*  If unsuccessful then it Returns False                                       *
*                                                                              *
* Creation Date:  10/22/1997  By: Darcy Sivertson                              *
*******************************************************************************/
int id_nonnacha_file(FILE *file_ptr, char* file_name_str)
{

   EXEC SQL BEGIN DECLARE SECTION;
      char  input_file_begin[11];   //temp variable 
      char  dummy_type[11];         //output host var
      short dummy_type_ind;         //output host var
   EXEC SQL END DECLARE SECTION;

   int iBytesRead = 0;  
   
   memset(input_file_begin, 0, 11);
   memset(dummy_type, 0, 11);
   dummy_type_ind = 0;

   //place first ten characters of file_ptr into input_file_begin
   iBytesRead = fread(input_file_begin, sizeof(char), 10, file_ptr);
   input_file_begin[10] = 0;
   if (iBytesRead <= 0)
   {
      gpszIFSMsg = ifs_fatal("FILEREAD", 
                              __FILE__,(DWORD)__LINE__, IFS_LOG,
                              file_name_str,
                              _itoa(_doserrno, gs_scratch, 10),
                              NULL);
      return -1;
   }

   //sets file position to beginning, returns non_zero on error
   if (fseek(file_ptr, 0L, SEEK_SET))
   {
      gpszIFSMsg = ifs_fatal("FILESEEK", 
                              __FILE__, (DWORD)__LINE__, IFS_LOG,
                              file_name_str, 
                              _itoa(_doserrno, gs_scratch, 10),
                              NULL);
      return -1;
   }

   //Converts all characters to upper case
   upch(input_file_begin);
   //removes all whitspaces from beginning & end of string, NULL terminiated
   trimlr(input_file_begin); 

   //searching for a nonnacha_file_type equal to the input_file_begin
   EXEC SQL SELECT nonnacha_file_type
            INTO :dummy_type:dummy_type_ind
            FROM nonnacha_file_type
            WHERE UPPER(LTRIM(RTRIM(nonnacha_file_type))) = :input_file_begin;

   //Status variable returns 0 if no ORACLE errors detected
   if (sqlca.sqlcode == 0 && dummy_type_ind == 0)
      return 1;
   else return 0;
} /* end id_nonnacha_file() */
                                                                                                                                                                                                                                                                                                                                        document/set2/CKTSKSCH.cpp_3.pdf                                                                    0000644 €    %çg4001001 00000344372 14011517335 014572  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               
/* Result Sets Interface */
#ifndef SQL_CRSR
#  define SQL_CRSR
  struct sql_cursor
  {
    unsigned int curocn;
    void *ptr1;
    void *ptr2;
    unsigned int magic;
  };
  typedef struct sql_cursor sql_cursor;
  typedef struct sql_cursor SQL_CURSOR;
#endif /* SQL_CRSR */

/* Thread Safety */
typedef void * sql_context;
typedef void * SQL_CONTEXT;

/* Object support */
struct sqltvn
{
  unsigned char *tvnvsn; 
  unsigned short tvnvsnl; 
  unsigned char *tvnnm;
  unsigned short tvnnml; 
  unsigned char *tvnsnm;
  unsigned short tvnsnml;
};
typedef struct sqltvn sqltvn;

struct sqladts
{
  unsigned int adtvsn; 
  unsigned short adtmode; 
  unsigned short adtnum;  
  sqltvn adttvn[1];       
};
typedef struct sqladts sqladts;

static struct sqladts sqladt = {
  1,0,0,
};

/* Binding to PL/SQL Records */
struct sqltdss
{
  unsigned int tdsvsn; 
  unsigned short tdsnum; 
  unsigned char *tdsval[1]; 
};
typedef struct sqltdss sqltdss;
static struct sqltdss sqltds =
{
  1,
  0,
};

/* File name & Package Name */
struct sqlcxp
{
  unsigned short fillen;
           char  filnam[14];
};
static const struct sqlcxp sqlfpn =
{
    13,
    ".\\CKTSKSCH.pc"
};


static unsigned int sqlctx = 525483;


static struct sqlexd {
   unsigned int   sqlvsn;
   unsigned int   arrsiz;
   unsigned int   iters;
   unsigned int   offset;
   unsigned short selerr;
   unsigned short sqlety;
   unsigned int   occurs;
      const short *cud;
   unsigned char  *sqlest;
      const char  *stmt;
   sqladts *sqladtp;
   sqltdss *sqltdsp;
            void  **sqphsv;
   unsigned int   *sqphsl;
            int   *sqphss;
            void  **sqpind;
            int   *sqpins;
   unsigned int   *sqparm;
   unsigned int   **sqparc;
   unsigned short  *sqpadto;
   unsigned short  *sqptdso;
   unsigned int   sqlcmax;
   unsigned int   sqlcmin;
   unsigned int   sqlcincr;
   unsigned int   sqlctimeout;
   unsigned int   sqlcnowait;
              int   sqfoff;
   unsigned int   sqcmod;
   unsigned int   sqfmod;
   unsigned int   sqlpfmem;
            void  *sqhstv[11];
   unsigned int   sqhstl[11];
            int   sqhsts[11];
            void  *sqindv[11];
            int   sqinds[11];
   unsigned int   sqharm[11];
   unsigned int   *sqharc[11];
   unsigned short  sqadto[11];
   unsigned short  sqtdso[11];
} sqlstm = {13,11};

// Prototypes
extern "C" {
  void sqlcxt (void **, unsigned int *,
               struct sqlexd *, const struct sqlcxp *);
  void sqlcx2t(void **, unsigned int *,
               struct sqlexd *, const struct sqlcxp *);
  void sqlbuft(void **, char *);
  void sqlgs2t(void **, char *);
  void sqlorat(void **, unsigned int *, void *);
}

// Forms Interface
static const int IAPSUCC = 0;
static const int IAPFAIL = 1403;
static const int IAPFTL  = 535;
extern "C" { void sqliem(unsigned char *, signed int *); }

 static const char *sq0001 = 
"select t.task_type ,t.fi_rt ,t.task_id ,t.dist_prof_id ,upper(t.task_name) ,\
upper(t.file_name) ,upper(t.run_at_eod_yn) ,upper(t.proc_opt) ,t.days_past ,to\
_char(t.dist_ts,'YYYYMMDDHH24MISS') ,upper(t.corp_orig_id)  from fi f ,task_sc\
h t where (((((f.fi_rt=t.fi_rt and f.active_yn='Y') and f.wh_status='U') and t\
.proc_status='N') and t.run_at_eod_yn='N') and ((to_char(t.due_dt,'YYYYMMDD')=\
:b0 and :b1>=t.run_hhmm) or to_char(t.due_dt,'YYYYMMDD')<:b0)) order by t.due_\
dt,t.run_hhmm            ";

 static const char *sq0002 = 
"select n.fi_rt ,n.nacha_file_id  from nacha_file_info n ,fi f where (f.fi_rt\
=n.fi_rt and n.file_status='A')           ";

typedef struct { unsigned short len; unsigned char arr[1]; } VARCHAR;
typedef struct { unsigned short len; unsigned char arr[1]; } varchar;

/* cud (compilation unit data) array */
static const short sqlcud0[] =
{13,4130,178,0,0,
5,0,0,1,491,0,521,85,0,0,3,3,0,1,0,1,97,0,0,1,97,0,0,1,97,0,0,
32,0,0,1,0,0,525,104,0,0,11,0,0,1,0,2,97,0,0,2,97,0,0,2,4,0,0,2,4,0,0,2,97,0,0,
2,97,0,0,2,97,0,0,2,97,0,0,2,3,0,0,2,97,0,0,2,97,0,0,
91,0,0,1,0,0,527,122,0,0,0,0,0,1,0,
106,0,0,2,118,0,521,188,0,0,0,0,0,1,0,
121,0,0,2,0,0,525,207,0,0,2,0,0,1,0,2,97,0,0,2,4,0,0,
144,0,0,3,83,0,517,271,0,0,2,2,0,1,0,1,97,0,0,1,4,0,0,
167,0,0,4,0,0,541,292,0,0,0,0,0,1,0,
182,0,0,5,70,0,517,377,0,0,2,2,0,1,0,1,97,0,0,1,4,0,0,
205,0,0,6,0,0,541,398,0,0,0,0,0,1,0,
220,0,0,7,70,0,517,436,0,0,2,2,0,1,0,1,97,0,0,1,4,0,0,
243,0,0,8,0,0,541,458,0,0,0,0,0,1,0,
258,0,0,9,70,0,517,567,0,0,2,2,0,1,0,1,97,0,0,1,4,0,0,
281,0,0,10,0,0,541,589,0,0,0,0,0,1,0,
296,0,0,11,70,0,517,717,0,0,2,2,0,1,0,1,97,0,0,1,4,0,0,
319,0,0,12,0,0,541,739,0,0,0,0,0,1,0,
334,0,0,13,329,0,516,754,0,0,6,2,0,1,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,1,
97,0,0,1,97,0,0,
373,0,0,14,70,0,517,918,0,0,2,2,0,1,0,1,97,0,0,1,4,0,0,
396,0,0,15,0,0,541,939,0,0,0,0,0,1,0,
411,0,0,16,70,0,517,1036,0,0,2,2,0,1,0,1,97,0,0,1,4,0,0,
434,0,0,17,0,0,541,1058,0,0,0,0,0,1,0,
449,0,0,18,70,0,517,1153,0,0,2,2,0,1,0,1,97,0,0,1,4,0,0,
472,0,0,19,0,0,541,1175,0,0,0,0,0,1,0,
487,0,0,20,70,0,517,1274,0,0,2,2,0,1,0,1,97,0,0,1,4,0,0,
510,0,0,21,0,0,541,1296,0,0,0,0,0,1,0,
525,0,0,22,95,0,516,1404,0,0,3,2,0,1,0,2,97,0,0,1,97,0,0,1,97,0,0,
552,0,0,23,70,0,517,1429,0,0,2,2,0,1,0,1,97,0,0,1,4,0,0,
575,0,0,24,0,0,541,1450,0,0,0,0,0,1,0,
};


/*******************************************************************************
CKTSKSCH.PC -- An ACHOS Program - Module of WATCH.EXE

Copyright (C) 1995, 1998 Deluxe Data Systems, Inc.
Copyright (C) 1997, 1998, 1999 Deluxe Electronic Payent Systems, Inc.

Part of WATCH.EXE which runs tasks based on the task schedule.
*******************************************************************************/


/*******************************************************************************
   INCLUDES & DEFINES                              
*******************************************************************************/
/* EXEC SQL BEGIN DECLARE SECTION; */ 

/* This #define PREVENTS the sqlca to be declared as external in sqlca.h */
#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern
#define INCLUDE_AS_EXTERN   extern

/* EXEC SQL END DECLARE SECTION; */ 


/* EXEC SQL INCLUDE  "sqlproto.h";
 */ 
#include <sqlcpr.h>

/* EXEC SQL INCLUDE  "sqlca.h";
 */ 
/*
 * $Header: sqlca.h,v 1.3 1994/12/12 19:27:27 jbasu Exp $ sqlca.h 
 */

/* Copyright (c) 1985,1986, 1998 by Oracle Corporation. */
 
/*
NAME
  SQLCA : SQL Communications Area.
FUNCTION
  Contains no code. Oracle fills in the SQLCA with status info
  during the execution of a SQL stmt.
NOTES
  **************************************************************
  ***                                                        ***
  *** This file is SOSD.  Porters must change the data types ***
  *** appropriately on their platform.  See notes/pcport.doc ***
  *** for more information.                                  ***
  ***                                                        ***
  **************************************************************

  If the symbol SQLCA_STORAGE_CLASS is defined, then the SQLCA
  will be defined to have this storage class. For example:
 
    #define SQLCA_STORAGE_CLASS extern
 
  will define the SQLCA as an extern.
 
  If the symbol SQLCA_INIT is defined, then the SQLCA will be
  statically initialized. Although this is not necessary in order
  to use the SQLCA, it is a good pgming practice not to have
  unitialized variables. However, some C compilers/OS's don't
  allow automatic variables to be init'd in this manner. Therefore,
  if you are INCLUDE'ing the SQLCA in a place where it would be
  an automatic AND your C compiler/OS doesn't allow this style
  of initialization, then SQLCA_INIT should be left undefined --
  all others can define SQLCA_INIT if they wish.

  If the symbol SQLCA_NONE is defined, then the SQLCA variable will
  not be defined at all.  The symbol SQLCA_NONE should not be defined
  in source modules that have embedded SQL.  However, source modules
  that have no embedded SQL, but need to manipulate a sqlca struct
  passed in as a parameter, can set the SQLCA_NONE symbol to avoid
  creation of an extraneous sqlca variable.
 
MODIFIED
    lvbcheng   07/31/98 -  long to int
    jbasu      12/12/94 -  Bug 217878: note this is an SOSD file
    losborne   08/11/92 -  No sqlca var if SQLCA_NONE macro set 
  Clare      12/06/84 - Ch SQLCA to not be an extern.
  Clare      10/21/85 - Add initialization.
  Bradbury   01/05/86 - Only initialize when SQLCA_INIT set
  Clare      06/12/86 - Add SQLCA_STORAGE_CLASS option.
*/
 
#ifndef SQLCA
#define SQLCA 1
 
struct   sqlca
         {
         /* ub1 */ char    sqlcaid[8];
         /* b4  */ int     sqlabc;
         /* b4  */ int     sqlcode;
         struct
           {
           /* ub2 */ unsigned short sqlerrml;
           /* ub1 */ char           sqlerrmc[70];
           } sqlerrm;
         /* ub1 */ char    sqlerrp[8];
         /* b4  */ int     sqlerrd[6];
         /* ub1 */ char    sqlwarn[8];
         /* ub1 */ char    sqlext[8];
         };

#ifndef SQLCA_NONE 
#ifdef   SQLCA_STORAGE_CLASS
SQLCA_STORAGE_CLASS struct sqlca sqlca
#else
         struct sqlca sqlca
#endif
 
#ifdef  SQLCA_INIT
         = {
         {'S', 'Q', 'L', 'C', 'A', ' ', ' ', ' '},
         sizeof(struct sqlca),
         0,
         { 0, {0}},
         {'N', 'O', 'T', ' ', 'S', 'E', 'T', ' '},
         {0, 0, 0, 0, 0, 0},
         {0, 0, 0, 0, 0, 0, 0, 0},
         {0, 0, 0, 0, 0, 0, 0, 0}
         }
#endif
         ;
#endif
 
#endif
 
/* end SQLCA */
/* EXEC SQL INCLUDE  "orcltype.h";
 */ 
/***************************************************************

ACHOS Function Library
Copyright (C) 1996 Deluxe Electronic Payment Systems, Inc.

Header Containing TypeDefs for Native ORACLE data types
and function prototypes for ORCLTYPE.LIB.

NOTE:  Programs should use EXEC SQL INCLUDE orcltype;
to include this header AFTER including achosprd.h!

FILE:			ORCLTYPE.H

CREATED:		07/01/96		Troy Clark
MODIFIED:	11/25/96		Troy Clark

***************************************************************/

#ifndef	ORCLTYPE_H_
#define	ORCLTYPE_H_

/***************************************************************
	Typedefs
***************************************************************/
/*
NOTICE:  Any changes made to oracle_date or oracle_varnum typedefs
			must also be made to their re-definition within DDSI.H
			The duplication is required so that DDSI.H does not
			required using oracles pro*c precompiler!
*/

/* EXEC SQL BEGIN DECLARE SECTION; */ 


typedef	struct	oracle_date_tag {
	unsigned char	century;
	unsigned	char	year;
	unsigned	char	month;
	unsigned	char	day;
	unsigned	char	hour;
	unsigned char	minute;
	unsigned char	second;
} oracle_date;

typedef struct oracle_varnum_tag {
	unsigned char	length;			/* # of bytes to follow -- includes expon. */
	unsigned char	exponent;			
	unsigned char	mantissa[20];	/* signif.digits - NO lead/trail zeros */
} oracle_varnum;

/* EXEC SQL TYPE	oracle_date		IS		DATE; */ 

/* EXEC SQL TYPE	oracle_varnum	IS		VARNUM(22); */ 


/* EXEC SQL END DECLARE SECTION; */ 


#endif

#include          "ddsi.h"
#include          "achosprd.h"

/* EXEC SQL INCLUDE watch; /o inserts watch.h into src for Pro*C o/ 
 */ 
/***************************************************************

WATCH.H Header File for WATCH.EXE and it's assoc. sub-programs
Version 1.08.10

Copyright (C) 1995 Deluxe Data Systems, Inc.
Copyright (C) 1997, 1998 Deluxe Electronic Payent Systems, Inc.

Header Containing Prototypes for all functions in the ACHOSPRD.LIB
   FILE:       watch.h
   CREATED:    06/18/1996  Troy Clark
   MODIFIED:   06/18/1996  Troy Clark
   MODIFIED:   05/14/1998  FRNash
***************************************************************/


/***************************************************************
   INCLUDES 
***************************************************************/


/***************************************************************
   TYPEDEFS, DEFINES AND DECLARATIONS
***************************************************************/
#ifndef _WATCH_H_
#define _WATCH_H_

/* EXEC SQL BEGIN DECLARE SECTION; */ 


#define  TSCH_BUF_CNT            100
#define  IOQ_BUF_CNT             100
#define  FSCH_BUF_CNT            100
#define  FI_BUF_CNT              101
#define  MAX_LOOP_CNT            50
#define  MAX_NACHA_CURSOR_CNT    100
#define  MOUSE_TARGET_MIN_X      36
#define  MOUSE_TARGET_MIN_Y      23

#define  MOUSE_TARGET_MAX_X      39
#define  MOUSE_TARGET_MAX_Y      23

#define  blank_line " "
/* 
   Max allowed FI cnt = (FI_BUF_CNT - 1) or 100 
   This makes detecting when more than max allowed FI recs exist easy
   since doing an array fetch only sets sqlca.sqlcode == 0 when it
   fetches exactly the same # of rows as the array size.  Otherwise,
   it will set sqlca.sqlcode = 100 and sqlca.sqlerrd[2] = actual fetch
   cnt.
*/

typedef struct rpt_info_rec_tag {
   char     task_type[2];
   char     fi_rt[10];
   double   task_id;
   double   dist_prof_id;
   char     task_name[31];       /* max len is 30 */
   char     file_name[13];
   char     run_at_eod_yn[2];
   char     proc_opt[101];        /* max len is 100  Increased the size for SLA Report */
   char     dist_ts[16];         /* max len is 15 */
   char     corp_orig_id[11];
} rpt_info_rec_type;

typedef struct watch_tsch_recs_tag {
   char     task_type       [TSCH_BUF_CNT][2];
   char     fi_rt           [TSCH_BUF_CNT][10];
   double   task_id         [TSCH_BUF_CNT];
   double   dist_prof_id    [TSCH_BUF_CNT];
   char     task_name       [TSCH_BUF_CNT][31];  /* max len is 30 */
   char     file_name       [TSCH_BUF_CNT][13];
   char     run_at_eod_yn   [TSCH_BUF_CNT][2];
   char     proc_opt        [TSCH_BUF_CNT][101];  /* max len is 100 */
   int      days_past       [TSCH_BUF_CNT];
   char     dist_ts         [TSCH_BUF_CNT][16];
   char     corp_orig_id    [TSCH_BUF_CNT][11];
} watch_tsch_recs;

typedef struct watch_tsch_ind_recs_tag {
   short    task_type       [TSCH_BUF_CNT];
   short    fi_rt           [TSCH_BUF_CNT];
   short    task_id         [TSCH_BUF_CNT];
   short    dist_prof_id    [TSCH_BUF_CNT];
   short    task_name       [TSCH_BUF_CNT];
   short    file_name       [TSCH_BUF_CNT];
   short    run_at_eod_yn   [TSCH_BUF_CNT];
   short    proc_opt        [TSCH_BUF_CNT];
   short    days_past       [TSCH_BUF_CNT];
   short    dist_ts         [TSCH_BUF_CNT];
   short    corp_orig_id    [TSCH_BUF_CNT];
} watch_tsch_ind_recs;  /* indicators for watch_task_recs */

typedef struct watch_ioq_recs_tag {
   char     file_name      [IOQ_BUF_CNT][13];
   char     recv_ts        [IOQ_BUF_CNT][15];
   char     fi_rt          [IOQ_BUF_CNT][10];
   char     type           [IOQ_BUF_CNT][4];
} watch_ioq_recs;

typedef struct watch_ioq_ind_recs_tag {
   short    file_name      [IOQ_BUF_CNT];
   short    recv_ts        [IOQ_BUF_CNT];
   short    fi_rt          [IOQ_BUF_CNT];
   short    type           [IOQ_BUF_CNT];
} watch_ioq_ind_recs;

typedef struct watch_fsch_recs_tag {
   char     fi_rt          [FSCH_BUF_CNT][10];
   double   file_sch_id    [FSCH_BUF_CNT];
   double   file_id        [FSCH_BUF_CNT];
   char     earliest_ts    [FSCH_BUF_CNT][15];  /* TS is in 'YYYYMMDDHH24MISS' format */
   char     latest_ts      [FSCH_BUF_CNT][15];
} watch_fsch_recs;

typedef struct watch_fsch_ind_recs_tag {
   short    fi_rt          [FSCH_BUF_CNT];
   short    file_sch_id    [FSCH_BUF_CNT];
   short    file_id        [FSCH_BUF_CNT];
   short    earliest_ts    [FSCH_BUF_CNT];
   short    latest_ts      [FSCH_BUF_CNT];
} watch_fsch_ind_recs;

typedef  struct watch_fi_rt_rec_tag {
   char     fi_rt[FSCH_BUF_CNT][10];
} watch_fi_rt_rec;

typedef  struct watch_eod_rec_tag {
   char     fi_rt[FSCH_BUF_CNT][10];
   char     eod_status[FSCH_BUF_CNT][2];
} watch_eod_rec;

typedef  struct watch_eod_ind_rec_tag {
   short    fi_rt[FSCH_BUF_CNT];
   short    eod_status[FSCH_BUF_CNT];
} watch_eod_ind_rec;

typedef  struct g_nacha_file_id_tag 
{
char     fi_rt[MAX_NACHA_CURSOR_CNT][10];
double   nacha_file_id[MAX_NACHA_CURSOR_CNT];
}g_nacha_file_rec;


typedef  struct g_nacha_file_ind_tag 
{
short    fi_rt[MAX_NACHA_CURSOR_CNT];
short    nacha_file_id[MAX_NACHA_CURSOR_CNT];
}g_nacha_file_ind;   

/* Struct Def. for Nacha File Id used in CKTSKSCH.PC (DS)*/

INCLUDE_AS_EXTERN watch_tsch_recs        g_tsch_recs;
INCLUDE_AS_EXTERN watch_tsch_ind_recs    g_tsch_inds;
INCLUDE_AS_EXTERN int                    g_tsch_cnt;
INCLUDE_AS_EXTERN watch_ioq_recs         g_ioq_recs;
INCLUDE_AS_EXTERN watch_ioq_ind_recs     g_ioq_inds;
INCLUDE_AS_EXTERN int                    g_ioq_cnt;
INCLUDE_AS_EXTERN watch_fsch_recs        g_fsch_recs;
INCLUDE_AS_EXTERN watch_fsch_ind_recs    g_fsch_inds;
INCLUDE_AS_EXTERN int                    g_fsch_cnt;
INCLUDE_AS_EXTERN watch_fi_rt_rec        g_fi_rt_rec;


INCLUDE_AS_EXTERN g_nacha_file_rec  g_nacha_file_id;
INCLUDE_AS_EXTERN g_nacha_file_ind  g_nacha_file_id_ind; 
INCLUDE_AS_EXTERN  rpt_info_rec_type rpt_info_rec;
INCLUDE_AS_EXTERN char        g_prn_dt[9];
INCLUDE_AS_EXTERN char        g_prn_time[6];
INCLUDE_AS_EXTERN char        g_cur_dt[9];               /* current date */
INCLUDE_AS_EXTERN char        g_cur_time[5];             /* current time */
INCLUDE_AS_EXTERN char        g_cur_dt_time[14];         /* current date and time */
INCLUDE_AS_EXTERN char*       gpszIFSMsg;
INCLUDE_AS_EXTERN char        g_user_name[81];
INCLUDE_AS_EXTERN char        g_db_name[81];
INCLUDE_AS_EXTERN char        g_orcl_etext_buf[256];
INCLUDE_AS_EXTERN char        g_fi_info[81];
INCLUDE_AS_EXTERN int         g_orcl_etext_len;
INCLUDE_AS_EXTERN int         g_orcl_etext_size;
INCLUDE_AS_EXTERN char        p_fi_rt[10];
INCLUDE_AS_EXTERN char        gs_scratch[81];
INCLUDE_AS_EXTERN char        g_corp_orig_id[11];                 /* psm - 5/08/1997 mod */
INCLUDE_AS_EXTERN int         g_num_fi;
INCLUDE_AS_EXTERN int         g_cur_fi;
INCLUDE_AS_EXTERN int         loop_cnt;                  

/* EXEC SQL END DECLARE SECTION; */ 


/* job path and btrieve path */
INCLUDE_AS_EXTERN  char        job_path[81];        
INCLUDE_AS_EXTERN char        exe_path[81];
INCLUDE_AS_EXTERN char        eod_job_name[81];

/***************************************************************
   FUNCTION PROTOTYPES 
***************************************************************/

/* Functions are listed by source file in order of their appearance */


/* SOURCE FILE:   ckeod.pc       */
void  ck_eod               (void);
void  do_start_eod         (int task_no);
BOOL  do_eod_reports       (char*);
BOOL  do_eod_job           (char*);
int   no_tasks_in_proc     (char*);
int   no_input_in_proc     (char*);
int   no_eod_in_proc       (char*);
BOOL  fail_check           (char *);


/* SOURCE FILE:   ckfildlv.pc       */
void  ck_file_dlvrs        (void);
void  deliver_file         (int ioq_no);


/* SOURCE FILE:   ckfilsch.pc       */
void  ck_file_sch          (void);
void  input_file           (int ioq_no);
int   ioq_set_status       (char *file_name, char *fi_rt, char *status_str);
/* 
   NOTE: ioq_set_status() needs to be put in ACHOSPRD.LIB once tested.
*/
int   file_sch_set_status  (char *fi_rt, double fsch_id, char new_status);
/* 
   NOTE: file_sch_set_status() needs to be put in ACHOSPRD.LIB once tested.
*/
int   id_input_file        (char *rec_one, char *fi_rt, FILE *file_handle, 
                              char * file_name_str, double *file_id,
                              char *reject_yn, int *rec_size);
long  find_one_rec         (FILE* fPointer, int* rec_size, long offset_to_one,
                              char* file_name_str);
int   id_nonnacha_file     (FILE *, char *);
long  one_rec_offset       (FILE *filePtr, char* file_name_str, int *rec_size);
void  log_file             (char *fi_rt, char *file_name, char *recv_ts, 
                              double dwFileID);
int   file_sch_hit         (char *fi_rt, double file_id, double *fsch_id);
void  file_sch_ck_at_risk  (void);
void  file_sch_ck_missed   (void);
void  get_corp_orig_id     (int fsch_no);


/* SOURCE FILE:   cktsksch.pc    */
void  ck_task_sch          (void);
void  do_task_dist         (int task_no);
void  do_task_fpickup      (int task_no);
void  do_task_integ        (int task_no);
void  do_task_report       (void);
void  do_nacha_file        (int task_no);
void  do_task_system       (int task_no);
void  do_group_task        (int task_no); // Added for DR#97-018 -FRN
void    do_task_purge         (int task_no); // Added for DR#97-199 -RMM
void  do_task_extract      (int task_no); // Added for DR#99-018 -SHA
void  do_task_billing      (int task_no); // Added for DR#99-018 -SHA
/* SOURCE FILE:   watch.pc       */
void  build_fi_rec();
void  do_exit              (int exit_value);
void  ck_mouse_quit        (HANDLE hConOut);
void  refresh_fi();
void  watch_events         (HANDLE hStdIn);
void  wr_cur_time();
void  wr_start_time();
void  wr_status(void);
int   submit_job(char* task_fi_rt, char* job_file, char* errstr,  char* arg[22], int arguments);
BOOL WINAPI CtrlHandler    (DWORD dwEvent);


/* SOURCE FILE:   mousehit.c     */
/* [Replaces the ACHOSPRD.LIB version of this function, which doesn't work!] */
short ck_mouse_hitx (HANDLE hConIn,  short min_x, short min_y, short max_x, short max_y);

#endif //_WATCH_H_





/*********************** ck_task_sch *******************************************
* Description:                                                                 *
*  Fetches tasks that are due to be run according to the task schedule for all *
* active FI's based on each individual. FI's oper_dt and the current Oracle    *
* Server's System Time.                                                        *
*  The tasks are ordered by run_hhmm.                                          *
*                                                                              *
* Creation Date:  06/18/1996  By: Troy Clark                                 *
* Modified Date:  01/05/1998  By: Darcy Sivertson                            *
* Modified Date:  10/15/1999  By: Shankar Nagarajan                          *
*     Added cursor for gathering Nacha File IDs and A function to process    *
*        the IDs is called w/in a loop.                                        *
*******************************************************************************/
void ck_task_sch(void)
{
   int   task_no = 0;      /* array index into g_tsch_recs.<fieldName>[] */
   int   new_nacha_recs = 0;
   
   /* display message to screen */
   paint_task_line(1, "Checking Task Schedule.....");
   Sleep(2000);         /* delay 1 second */

   /* Get all tasks that are scheduled to be run now. Note that the FI's may  */
   /* have differing oper_dt's due to differing eod_hhmm's etc.               */
   /* EXEC SQL DECLARE tsch_cursor CURSOR FOR
      SELECT   t.task_type, 
               t.fi_rt, 
               t.task_id,
               t.dist_prof_id,
               upper(t.task_name),
               upper(t.file_name),
               upper(t.run_at_eod_yn),
               upper(t.proc_opt),
               t.days_past,
               to_char(t.dist_ts, 'YYYYMMDDHH24MISS'),
               upper(t.corp_orig_id)
      FROM     fi f, task_sch t 
	  WHERE    f.fi_rt = t.fi_rt 
      AND      f.active_yn = 'Y' 
      AND      f.wh_status = 'U' 
	  AND      t.proc_status = 'N'     /o Not Processed o/
      AND      t.run_at_eod_yn = 'N'
      AND      ((to_char(t.due_dt, 'YYYYMMDD') = :g_cur_dt AND :g_cur_time >= t.run_hhmm)
                  OR
                (to_char(t.due_dt, 'YYYYMMDD') < :g_cur_dt)
               )
      ORDER BY t.due_dt, t.run_hhmm; */ 

   /*
   Notice that the above select statement performs a join on the fi and task_sch
   tables such that only task_sch records whose fi_rt and due_dt match a fi
   record's fi_rt and oper_dt where the FI is active and in an "Up" condition
   are returned.  Thus, we don't need to check fi for wh_status = 'U', the date
   matching, etc., after the fact. It's built into the where clause above...
   */ 
   /* EXEC SQL OPEN tsch_cursor; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 3;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = sq0001;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )5;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqcmod = (unsigned int )0;
   sqlstm.sqhstv[0] = (         void  *)g_cur_dt;
   sqlstm.sqhstl[0] = (unsigned int  )9;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)g_cur_time;
   sqlstm.sqhstl[1] = (unsigned int  )5;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)g_cur_dt;
   sqlstm.sqhstl[2] = (unsigned int  )9;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

             /* open cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {     /* open cursor failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TSCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"OPEN CURSOR tsch_cursor; -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   
   /* Loop through all tasks that need to be run by Fetching TSCH_BUF_CNT     */
   /* number of records at a time on each pass through the loop.              */
   /* EXEC SQL FETCH tsch_cursor INTO :g_tsch_recs:g_tsch_inds; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )100;
   sqlstm.offset = (unsigned int  )32;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqfoff = (           int )0;
   sqlstm.sqfmod = (unsigned int )2;
   sqlstm.sqhstv[0] = (         void  *)g_tsch_recs.task_type;
   sqlstm.sqhstl[0] = (unsigned int  )2;
   sqlstm.sqhsts[0] = (         int  )2;
   sqlstm.sqindv[0] = (         void  *)g_tsch_inds.task_type;
   sqlstm.sqinds[0] = (         int  )sizeof(short);
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqharc[0] = (unsigned int   *)0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)g_tsch_recs.fi_rt;
   sqlstm.sqhstl[1] = (unsigned int  )10;
   sqlstm.sqhsts[1] = (         int  )10;
   sqlstm.sqindv[1] = (         void  *)g_tsch_inds.fi_rt;
   sqlstm.sqinds[1] = (         int  )sizeof(short);
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqharc[1] = (unsigned int   *)0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)g_tsch_recs.task_id;
   sqlstm.sqhstl[2] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[2] = (         int  )sizeof(double);
   sqlstm.sqindv[2] = (         void  *)g_tsch_inds.task_id;
   sqlstm.sqinds[2] = (         int  )sizeof(short);
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqharc[2] = (unsigned int   *)0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)g_tsch_recs.dist_prof_id;
   sqlstm.sqhstl[3] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[3] = (         int  )sizeof(double);
   sqlstm.sqindv[3] = (         void  *)g_tsch_inds.dist_prof_id;
   sqlstm.sqinds[3] = (         int  )sizeof(short);
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqharc[3] = (unsigned int   *)0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqhstv[4] = (         void  *)g_tsch_recs.task_name;
   sqlstm.sqhstl[4] = (unsigned int  )31;
   sqlstm.sqhsts[4] = (         int  )31;
   sqlstm.sqindv[4] = (         void  *)g_tsch_inds.task_name;
   sqlstm.sqinds[4] = (         int  )sizeof(short);
   sqlstm.sqharm[4] = (unsigned int  )0;
   sqlstm.sqharc[4] = (unsigned int   *)0;
   sqlstm.sqadto[4] = (unsigned short )0;
   sqlstm.sqtdso[4] = (unsigned short )0;
   sqlstm.sqhstv[5] = (         void  *)g_tsch_recs.file_name;
   sqlstm.sqhstl[5] = (unsigned int  )13;
   sqlstm.sqhsts[5] = (         int  )13;
   sqlstm.sqindv[5] = (         void  *)g_tsch_inds.file_name;
   sqlstm.sqinds[5] = (         int  )sizeof(short);
   sqlstm.sqharm[5] = (unsigned int  )0;
   sqlstm.sqharc[5] = (unsigned int   *)0;
   sqlstm.sqadto[5] = (unsigned short )0;
   sqlstm.sqtdso[5] = (unsigned short )0;
   sqlstm.sqhstv[6] = (         void  *)g_tsch_recs.run_at_eod_yn;
   sqlstm.sqhstl[6] = (unsigned int  )2;
   sqlstm.sqhsts[6] = (         int  )2;
   sqlstm.sqindv[6] = (         void  *)g_tsch_inds.run_at_eod_yn;
   sqlstm.sqinds[6] = (         int  )sizeof(short);
   sqlstm.sqharm[6] = (unsigned int  )0;
   sqlstm.sqharc[6] = (unsigned int   *)0;
   sqlstm.sqadto[6] = (unsigned short )0;
   sqlstm.sqtdso[6] = (unsigned short )0;
   sqlstm.sqhstv[7] = (         void  *)g_tsch_recs.proc_opt;
   sqlstm.sqhstl[7] = (unsigned int  )101;
   sqlstm.sqhsts[7] = (         int  )101;
   sqlstm.sqindv[7] = (         void  *)g_tsch_inds.proc_opt;
   sqlstm.sqinds[7] = (         int  )sizeof(short);
   sqlstm.sqharm[7] = (unsigned int  )0;
   sqlstm.sqharc[7] = (unsigned int   *)0;
   sqlstm.sqadto[7] = (unsigned short )0;
   sqlstm.sqtdso[7] = (unsigned short )0;
   sqlstm.sqhstv[8] = (         void  *)g_tsch_recs.days_past;
   sqlstm.sqhstl[8] = (unsigned int  )sizeof(int);
   sqlstm.sqhsts[8] = (         int  )sizeof(int);
   sqlstm.sqindv[8] = (         void  *)g_tsch_inds.days_past;
   sqlstm.sqinds[8] = (         int  )sizeof(short);
   sqlstm.sqharm[8] = (unsigned int  )0;
   sqlstm.sqharc[8] = (unsigned int   *)0;
   sqlstm.sqadto[8] = (unsigned short )0;
   sqlstm.sqtdso[8] = (unsigned short )0;
   sqlstm.sqhstv[9] = (         void  *)g_tsch_recs.dist_ts;
   sqlstm.sqhstl[9] = (unsigned int  )16;
   sqlstm.sqhsts[9] = (         int  )16;
   sqlstm.sqindv[9] = (         void  *)g_tsch_inds.dist_ts;
   sqlstm.sqinds[9] = (         int  )sizeof(short);
   sqlstm.sqharm[9] = (unsigned int  )0;
   sqlstm.sqharc[9] = (unsigned int   *)0;
   sqlstm.sqadto[9] = (unsigned short )0;
   sqlstm.sqtdso[9] = (unsigned short )0;
   sqlstm.sqhstv[10] = (         void  *)g_tsch_recs.corp_orig_id;
   sqlstm.sqhstl[10] = (unsigned int  )11;
   sqlstm.sqhsts[10] = (         int  )11;
   sqlstm.sqindv[10] = (         void  *)g_tsch_inds.corp_orig_id;
   sqlstm.sqinds[10] = (         int  )sizeof(short);
   sqlstm.sqharm[10] = (unsigned int  )0;
   sqlstm.sqharc[10] = (unsigned int   *)0;
   sqlstm.sqadto[10] = (unsigned short )0;
   sqlstm.sqtdso[10] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

   
   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND) 
   {  
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TSCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Fetch tsch_cursor failed!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
   }
   
   g_tsch_cnt = sqlca.sqlerrd[2];

   /* EXEC SQL CLOSE tsch_cursor; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )91;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

         /* close cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {     /* close cursor failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TSCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"CLOSE CURSOR tsch_cursor; -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   
   /* Processes all tasks fetched into g_tsch_recs buffer */
   for (task_no = 0; task_no < g_tsch_cnt; task_no++) 
   {
      /* run only when EOD is not running */
      if (no_eod_in_proc(g_tsch_recs.fi_rt[task_no]))
      {
         switch (g_tsch_recs.task_type[task_no][0]) 
         {
            case 'D':   do_task_dist(task_no);     break;   /* Distribution Task */
            case 'E':   do_start_eod(task_no);     break;   /* CHECK EOD TASK */
            case 'G':   do_group_task(task_no);    break;   /* Group Task */
            case 'I':   do_task_integ(task_no);    break;   /* Integrity Task */
            case 'R':   /* copy record used by do_task_report function */
                        strcpy(rpt_info_rec.task_type, g_tsch_recs.task_type[task_no]);
                        strcpy(rpt_info_rec.fi_rt, g_tsch_recs.fi_rt[task_no]);
                        rpt_info_rec.task_id    = g_tsch_recs.task_id[task_no];
                        rpt_info_rec.dist_prof_id  = g_tsch_recs.dist_prof_id[task_no];
                        strcpy(rpt_info_rec.task_name, g_tsch_recs.task_name[task_no]);
                        strcpy(rpt_info_rec.file_name, g_tsch_recs.file_name[task_no]);
                        strcpy(rpt_info_rec.proc_opt, g_tsch_recs.proc_opt[task_no]);
                        strcpy(rpt_info_rec.dist_ts, g_tsch_recs.dist_ts[task_no]);
                        strcpy(rpt_info_rec.corp_orig_id, g_tsch_recs.corp_orig_id[task_no]);
                        do_task_report();                   /* REPORT TASK */
                        break;
            case 'S':   do_task_system(task_no);   break;   /* Systems Task (for client ops) */
            case 'P':   do_task_purge(task_no);    break;   /* Purge Task (for client ops) */
            case 'X':   do_task_extract(task_no);   break;  /* Extract Task */
            case 'B':   do_task_billing(task_no);  break;   /* Billing Task */
            default: /* data error */        break;   /* Unknown Task Type */
         }
      }
   }  

   /****************************************************************************
    *Darcy S. Added the following code as per DEV. REQ. # 97-194
   /***************************************************************************/

   /* display message to screen */
   paint_task_line(1, "Checking Nacha Conversion File Status.....");
   Sleep(2000);         /* delay 1 second */

   /*Get all nacha file ids from nacha_file_info table when file_status is active*/
   /* EXEC SQL DECLARE nacha_info_cursor CURSOR FOR
      SELECT   n.fi_rt,
               n.nacha_file_id
      FROM     nacha_file_info n, fi f
      WHERE    f.fi_rt = n.fi_rt 
      AND      n.file_status = 'A'; */ 


   /* EXEC SQL OPEN nacha_info_cursor; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = sq0002;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )106;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqcmod = (unsigned int )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {     /* open cursor failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TSCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"OPEN CURSOR nacha_info_cursor FAILED in ck_task_sch()!");
      paint_task_line(1, "..Program Exit Code 3");
      do_exit(3);
   }
   
   /* Loop through all nacha records that need to be run by Fetching 100      */
   /* records at a time.                                                      */
   /* EXEC SQL FETCH nacha_info_cursor 
   INTO :g_nacha_file_id  :g_nacha_file_id_ind; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )100;
   sqlstm.offset = (unsigned int  )121;
   sqlstm.selerr = (unsigned short)0;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqfoff = (           int )0;
   sqlstm.sqfmod = (unsigned int )2;
   sqlstm.sqhstv[0] = (         void  *)g_nacha_file_id.fi_rt;
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )10;
   sqlstm.sqindv[0] = (         void  *)g_nacha_file_id_ind.fi_rt;
   sqlstm.sqinds[0] = (         int  )sizeof(short);
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqharc[0] = (unsigned int   *)0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)g_nacha_file_id.nacha_file_id;
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[1] = (         int  )sizeof(double);
   sqlstm.sqindv[1] = (         void  *)g_nacha_file_id_ind.nacha_file_id;
   sqlstm.sqinds[1] = (         int  )sizeof(short);
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqharc[1] = (unsigned int   *)0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

 
   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND) 
   {  
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TSCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Fetch nacha_info_cursor failed in ck_task_sch()!");
      paint_task_line(1, "..Program Exit Code 4");
      do_exit(4);
   }

   new_nacha_recs = sqlca.sqlerrd[2];

   /* Processes all tasks fetched into g_nacha_file_id buffer */
   for(task_no = 0; task_no < new_nacha_recs; task_no++)
   {
      do_nacha_file(task_no);
   }
} /* end ck_task_sch() */

/*********************** do_nacha_file *****************************************
* Description:                                                                 *
*     Submits a BLDNACHA job. Arguments to be passed are:                      *
*     nacha_file_id[task_no],  fi_rt[task_no]                                  *
*                                                                              *
* Creation Date:  01/05/1998  By: Darcy Sivertson                              *
*******************************************************************************/
void do_nacha_file(int task_no)
{
   char  num_str1[22];        /* temp vars */
   char  errstr[100];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  fi_rt[17];           /*%FI_RT%=fi_rt for sql_jcsubmit*/
   char  nacha_file_id[30];   /*%NACHA_FILE_ID%=Nacha_file_id for sql_jcsubmit*/
   char  msg_text[400];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;

   /* Build an arg string to pass to the job                                  */

   /* convert g_nacha_file_id.nacha_file_id[task_no] to num_str1              */
   _gcvt(g_nacha_file_id.nacha_file_id[task_no], 10, num_str1);

   /* remove decimal point */
   if (num_str1[strlen(num_str1)-1] == '.')
      num_str1[strlen(num_str1)-1] = '\0';

   /* Submit a BLDNACHA Job                                                   */
   copy_cat(job_file, job_path, "\\", "BLDNACHA.JOB", NULL);
   copy_cat(fi_rt, "%FI_RT%=", g_nacha_file_id.fi_rt[task_no], NULL);
   copy_cat(nacha_file_id, "%NACHA_FILE_ID%=", num_str1, NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   /* EXEC SQL
      UPDATE   NACHA_FILE_INFO
      SET      file_status  = 'I'
      WHERE    fi_rt = :g_nacha_file_id.fi_rt[task_no]
      AND      nacha_file_id = :g_nacha_file_id.nacha_file_id[task_no]; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "update NACHA_FILE_INFO  set file_status='I' where (fi_rt=:\
b0 and nacha_file_id=:b1)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )144;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)(g_nacha_file_id.fi_rt)[task_no];
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)&(g_nacha_file_id.nacha_file_id)[task_no];
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {   
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_nacha_file_id.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "NACHA_FILE_INFO",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch -- FAILED in do_nacha_file()!");
      paint_task_line(1, "..Program Exit Code 5");
      do_exit(5);
   }

   /* EXEC SQL COMMIT WORK; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )167;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

      /* else commit update work */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_nacha_file_id.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes in do_nacha_file()");
      paint_task_line(1, "..Program Exit Code 6");
      exit(6);
   }

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));

   strcpy(parm[0], connect_yn);		arguments++;
   strcpy(parm[1], fi_rt);			arguments++;
   strcpy(parm[2], nacha_file_id);	arguments++;


   for(n = 0; n<arguments; n++)
       arg[n] = parm[n];

   if (submit_job(g_nacha_file_id.fi_rt[task_no], job_file, errstr, arg, arguments) == ERR)
   {
      copy_cat(g_fi_info, "FI: ", g_nacha_file_id.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "sql_jcsubmit failed in do_nacha_file()!");
      paint_task_line(1, "..Program Exit Code 7");
      do_exit(7);
   }

   copy_cat(msg_text, "BLDNACHA.JOB", " for FI=", g_nacha_file_id.fi_rt[task_no],
            " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_nacha_file() */

/*********************** do_task_dist ******************************************
* Description:                                                                 *
*  Run 1 Scheduled DISTRIBUTION Task.                                          *
*                                                                              *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  07/05/1996  By: George Lin                                   *
* Modified Date:  11/04/1996  By: Dan Jung                                     *
* Modified Date:  02/04/1998  By: Ramana                                       *
* Modified Date:  06/14/2004  By: Baskaran G                                   *
*                                 Corrected 'missing array subscript' bug.     *
*******************************************************************************/
void  do_task_dist(int task_no)
{
   char  num_str1[22], num_str2[22];         /* temp vars */
   char  errstr[100];
   char  task_id[] = "/TASK_ID=0";
   char  job_file[81];
   char  submit_errfilestr[512];
   char  fi_rt[17];
   char  dist_prof_id[30];
   char  task_sch_id[30];
   char  msg_text[400];
   char  connect_yn[15];
   char  parm[21][50];       
   char* arg[22];
   int   n;
   int   arguments = 0;


// FOR USC - WR 24990 - Start
	char     proc_opt[101];        /* max len is 100  Increased the size for SLA Report */	
   
   /* Verify that dist_prof_id isn't 0 (zero)                                 */
   if (g_tsch_recs.dist_prof_id[task_no] == 0) 
   {  /* Data error, Should not be 0 Set the proc_status = 'N' Not Processed  */
      /* EXEC SQL
         UPDATE   task_sch
         SET      proc_status = 'N'
         WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
         AND      task_id = :g_tsch_recs.task_id[task_no]; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 11;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.stmt = "update task_sch  set proc_status='N' where (fi_rt=:b0 a\
nd task_id=:b1)";
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )182;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlstm.sqhstv[0] = (         void  *)(g_tsch_recs.fi_rt)[task_no];
      sqlstm.sqhstl[0] = (unsigned int  )10;
      sqlstm.sqhsts[0] = (         int  )0;
      sqlstm.sqindv[0] = (         void  *)0;
      sqlstm.sqinds[0] = (         int  )0;
      sqlstm.sqharm[0] = (unsigned int  )0;
      sqlstm.sqadto[0] = (unsigned short )0;
      sqlstm.sqtdso[0] = (unsigned short )0;
      sqlstm.sqhstv[1] = (         void  *)&(g_tsch_recs.task_id)[task_no];
      sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
      sqlstm.sqhsts[1] = (         int  )0;
      sqlstm.sqindv[1] = (         void  *)0;
      sqlstm.sqinds[1] = (         int  )0;
      sqlstm.sqharm[1] = (unsigned int  )0;
      sqlstm.sqadto[1] = (unsigned short )0;
      sqlstm.sqtdso[1] = (unsigned short )0;
      sqlstm.sqphsv = sqlstm.sqhstv;
      sqlstm.sqphsl = sqlstm.sqhstl;
      sqlstm.sqphss = sqlstm.sqhsts;
      sqlstm.sqpind = sqlstm.sqindv;
      sqlstm.sqpins = sqlstm.sqinds;
      sqlstm.sqparm = sqlstm.sqharm;
      sqlstm.sqparc = sqlstm.sqharc;
      sqlstm.sqpadto = sqlstm.sqadto;
      sqlstm.sqptdso = sqlstm.sqtdso;
      sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


      if (sqlca.sqlcode != ORCL_NO_ERROR) 
      {   /* update task_sch failed */
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
         gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "FI",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
         paint_task_line(0,"Update task_sch -- FAILED!");
         paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
         do_exit(1);
      }

      /* EXEC SQL COMMIT WORK; */ 

{
      struct sqlexd sqlstm;
      sqlstm.sqlvsn = 13;
      sqlstm.arrsiz = 11;
      sqlstm.sqladtp = &sqladt;
      sqlstm.sqltdsp = &sqltds;
      sqlstm.iters = (unsigned int  )1;
      sqlstm.offset = (unsigned int  )205;
      sqlstm.cud = sqlcud0;
      sqlstm.sqlest = (unsigned char  *)&sqlca;
      sqlstm.sqlety = (unsigned short)4352;
      sqlstm.occurs = (unsigned int  )0;
      sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

   /* else commit update work */
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
         ifs_fatal("ORC_COMMIT",
                     __FILE__, (DWORD)__LINE__, IFS_LOG,
                     g_orcl_etext_buf,
                     g_fi_info,
                     NULL);
         paint_task_line(0, "Unable to Commit Changes");
         exit(1);
      }

      return;  /* no point in running the dummy distribution */
   }

   /* Build an arg string to pass to the job                                  */
   /* convert g_tsch_recs.task_id[task_no] to num_str1                        */
   /* convert g_tsch_recs.dist_prof_id[task_no] to num_str2                   */
   _gcvt(g_tsch_recs.task_id[task_no], 10, num_str1);
   _gcvt(g_tsch_recs.dist_prof_id[task_no], 10, num_str2); 

   /* remove decimal point */
   if (num_str1[strlen(num_str1)-1] == '.')
      num_str1[strlen(num_str1)-1] = '\0';

   if (num_str2[strlen(num_str2)-1] == '.') 
      num_str2[strlen(num_str2)-1] = '\0';

   /* Submit a Distribution Job                                               */
   copy_cat(job_file, job_path, "\\", trimlr(g_tsch_recs.task_name[task_no]), NULL);
   copy_cat(fi_rt, "%FI_RT%=", g_tsch_recs.fi_rt[task_no], NULL);
   copy_cat(dist_prof_id, "%DIST_PROF_ID%=", num_str2, NULL);
   copy_cat(task_sch_id, "%TASK_ID%=", num_str1, NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   /* EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_id = :g_tsch_recs.task_id[task_no]; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "update task_sch  set proc_status=' ' where (fi_rt=:b0 and \
task_id=:b1)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )220;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)(g_tsch_recs.fi_rt)[task_no];
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)&(g_tsch_recs.task_id)[task_no];
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* EXEC SQL COMMIT WORK; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )243;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

      /* else commit update work */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));

   strcpy(parm[0], connect_yn);		arguments++;
   strcpy(parm[1], fi_rt);			arguments++;
   strcpy(parm[2], dist_prof_id);	arguments++;
   strcpy(parm[3], task_sch_id);	arguments++;

   copy_cat(proc_opt, g_tsch_recs.proc_opt[task_no], NULL);
   trimlr(proc_opt);
   if (strlen(proc_opt) > 0)
   {
      copy_cat(parm[arguments], "%OPTION%=", proc_opt, NULL);
      arguments++;
   }


   for(n = 0; n<arguments; n++)
      arg[n] = parm[n];

   if (submit_job(g_tsch_recs.fi_rt[task_no], job_file, errstr, arg, arguments) == ERR)
   {
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);

      paint_task_line(0, "sql_jcsubmit failed in do_task_dist()!");
      do_exit(1);
   }

   copy_cat(msg_text, g_tsch_recs.task_name[task_no], " for FI=", g_tsch_recs.fi_rt[task_no],
            " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_task_dist() */


/********************** do_task_integ ******************************************
* Description:                                                                 *
*     Run 1 Scheduled INTEGRITY CHECK Task.                                    *
*                                                                              *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  07/05/1996  By: George Lin                                   *
* Modified Date:  11/04/1996  By: Dan Jung                                     *
* Modified Date:  02/09/1998  By: FRNash                                       *
*                             Corrected another 'missing array subscript' bug. *
*******************************************************************************/
void  do_task_integ(int task_no)
{

   char  num_str1[22];     /* temp var */
   char  errstr[300];   
   char  job_file[81];
   char  submit_errfilestr[512];
   char  fi_rt[17];
   char  option[81];
   char  task_id[80];
   char  msg_text[400];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;
   
   /* convert g_tsch_recs.task_id[task_no] to num_str1                        */
   _gcvt(g_tsch_recs.task_id[task_no], 10, num_str1);
   if (num_str1[strlen(num_str1)-1] == '.')
      num_str1[strlen(num_str1)-1] = '\0';
      
   copy_cat(job_file, job_path, "\\", trimlr(g_tsch_recs.task_name[task_no]), NULL);
   copy_cat(fi_rt, "%FI_RT%=", g_tsch_recs.fi_rt[task_no], NULL);
   trimlr(g_tsch_recs.proc_opt[task_no]);
   strcpy(connect_yn, "DBCONNECT=N");

   if (strcmp(g_tsch_recs.proc_opt[task_no], "/FILE") == 0)
   {
      copy_cat(option, "%OPTION%=", g_tsch_recs.proc_opt[task_no], "=", 
                 g_tsch_recs.file_name[task_no], NULL);
   }
   else
   {
      copy_cat(option, "%OPTION%=", g_tsch_recs.proc_opt[task_no], NULL); //980209 -FRN
   }

   copy_cat(task_id, "%TASK_ID%=", num_str1, NULL);

   /* EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_id = :g_tsch_recs.task_id[task_no]; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "update task_sch  set proc_status=' ' where (fi_rt=:b0 and \
task_id=:b1)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )258;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)(g_tsch_recs.fi_rt)[task_no];
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)&(g_tsch_recs.task_id)[task_no];
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* EXEC SQL COMMIT WORK; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )281;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

            /* else commit update work */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }
      
   /* submit integ */
   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));


   strcpy(parm[0], connect_yn); arguments++;
   strcpy(parm[1], fi_rt);		arguments++;
   strcpy(parm[2], option);		arguments++;
   strcpy(parm[3], task_id);	arguments++;	


   for(n = 0; n<arguments; n++)
       arg[n] = parm[n];

   if (submit_job(g_tsch_recs.fi_rt[task_no], job_file, errstr, arg, arguments) == ERR)
   {
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);
      
      paint_task_line(0, "sql_jcsubmit failed in do_task_integ");
      do_exit(1);
   }

   copy_cat(msg_text, g_tsch_recs.task_name[task_no], " for FI=",
         g_tsch_recs.fi_rt[task_no], " was submitted at ", 
         g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_task_integ() */

/********************** do_task_report *****************************************
* Description:                                                                 *
*     Run 1 Scheduled REPORT Task.                                             *
*                                                                              *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  07/05/1996  By: George Lin                                   *
* Modified Date:  11/04/1996  By: Dan Jung                                     *
* Modified Date:  08/13/1998  By: Ramana Malladi Dev. Req. 97000222.AOS        *
* Modified Date:  05/04/1999  By: FRNash Bug#90426A, replace all ' ' with '^'  *
*                                 in CORP_ORIG_ID to preserve spaces therein.  *
* Modified Date:  04/30/2002  By: Kellie Koch 99-45  Allowed proc_opt to be    *
*                                 specified for a report task.                 *
*******************************************************************************/
void  do_task_report()
{
   short result;
   char  num_str1[22];     /* temp var */
   char  errstr[300];
   char  file_name[81];
   char  task_id[30];
   char  dist_prof_id[30];
   char  dist_ts[30];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  fi_rt[17];
   char  msg_text[400];
   char  system_dist_ts[16];
   char  corp_orig_id[26];
   char  corp_orig_id_arg[26];
   char  proc_opt[101];        /* max len is 100  Increased the size for SLA Report */
   char* pstr; // for general temporary use as pointer-to-string
   char  connect_yn[15];
   char  parm[21][50];       
   char* arg[22];
   int n;
   int   arguments=0;


   /* EXEC SQL BEGIN DECLARE SECTION; */ 

      char  need_file_name_yn[2];
      char  need_dist_prof_yn[2];
      char  need_dist_ts_yn[2];
      char  need_corp_orig_yn[2];
   /* EXEC SQL END DECLARE SECTION; */ 

   
   /* Build an arg string to pass to the job                                  */
   upch(rpt_info_rec.task_name);
   trimlr(rpt_info_rec.task_name);

   if (strstr(rpt_info_rec.task_name, ".JOB") == 0)
      strcat(rpt_info_rec.task_name, ".JOB");

   _gcvt(rpt_info_rec.task_id, 10, num_str1);
   if (num_str1[strlen(num_str1)-1] == '.')
      num_str1[strlen(num_str1)-1] = '\0';
      
   copy_cat(job_file, job_path, "\\", rpt_info_rec.task_name, NULL);
   copy_cat(fi_rt, "%FI_RT%=", rpt_info_rec.fi_rt, NULL);
   copy_cat(file_name, "%FILE%=", rpt_info_rec.file_name, NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   _gcvt(rpt_info_rec.task_id, 10, num_str1);
   if (num_str1[strlen(num_str1)-1] == '.')
      num_str1[strlen(num_str1)-1] = '\0';

   copy_cat(task_id, "%TASK_ID%=", num_str1, NULL);

   _gcvt(rpt_info_rec.dist_prof_id, 10, num_str1);
   if (num_str1[strlen(num_str1)-1] == '.')
      num_str1[strlen(num_str1)-1] = '\0';

   copy_cat(dist_prof_id, "%DIST_PROF_ID%=", num_str1, NULL);

   /* Submit a Report Job.                                                    */
   /* Some reports require file name as a parameter, the others don't.        */
   /* EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :rpt_info_rec.fi_rt
      AND      task_id = :rpt_info_rec.task_id; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "update task_sch  set proc_status=' ' where (fi_rt=:b0 and \
task_id=:b1)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )296;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)(rpt_info_rec.fi_rt);
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)&(rpt_info_rec.task_id);
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", rpt_info_rec.fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch failed in do_task_report()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* EXEC SQL COMMIT WORK; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )319;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", rpt_info_rec.fi_rt, NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   /* EXEC SQL
      SELECT   UPPER(decode(need_file_name_yn, NULL, 'N', need_file_name_yn)),
               UPPER(decode(need_dist_prof_yn, NULL, 'N', need_dist_prof_yn)),
               UPPER(decode(need_dist_ts_yn, NULL, 'N', need_dist_ts_yn)),
               UPPER(decode(need_corp_orig_yn, NULL, 'N', need_corp_orig_yn))
      INTO     :need_file_name_yn, 
			   :need_dist_prof_yn, 
			   :need_dist_ts_yn, 
			   :need_corp_orig_yn
      FROM     task_names t
      WHERE    t.fi_rt = :rpt_info_rec.fi_rt
      AND      t.task_name = :rpt_info_rec.task_name; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select UPPER(decode(need_file_name_yn,null ,'N',need_file_\
name_yn)) ,UPPER(decode(need_dist_prof_yn,null ,'N',need_dist_prof_yn)) ,UPPER\
(decode(need_dist_ts_yn,null ,'N',need_dist_ts_yn)) ,UPPER(decode(need_corp_or\
ig_yn,null ,'N',need_corp_orig_yn)) into :b0,:b1,:b2,:b3  from task_names t wh\
ere (t.fi_rt=:b4 and t.task_name=:b5)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )334;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)need_file_name_yn;
   sqlstm.sqhstl[0] = (unsigned int  )2;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)need_dist_prof_yn;
   sqlstm.sqhstl[1] = (unsigned int  )2;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)need_dist_ts_yn;
   sqlstm.sqhstl[2] = (unsigned int  )2;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)need_corp_orig_yn;
   sqlstm.sqhstl[3] = (unsigned int  )2;
   sqlstm.sqhsts[3] = (         int  )0;
   sqlstm.sqindv[3] = (         void  *)0;
   sqlstm.sqinds[3] = (         int  )0;
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqhstv[4] = (         void  *)(rpt_info_rec.fi_rt);
   sqlstm.sqhstl[4] = (unsigned int  )10;
   sqlstm.sqhsts[4] = (         int  )0;
   sqlstm.sqindv[4] = (         void  *)0;
   sqlstm.sqinds[4] = (         int  )0;
   sqlstm.sqharm[4] = (unsigned int  )0;
   sqlstm.sqadto[4] = (unsigned short )0;
   sqlstm.sqtdso[4] = (unsigned short )0;
   sqlstm.sqhstv[5] = (         void  *)(rpt_info_rec.task_name);
   sqlstm.sqhstl[5] = (unsigned int  )31;
   sqlstm.sqhsts[5] = (         int  )0;
   sqlstm.sqindv[5] = (         void  *)0;
   sqlstm.sqinds[5] = (         int  )0;
   sqlstm.sqharm[5] = (unsigned int  )0;
   sqlstm.sqadto[5] = (unsigned short )0;
   sqlstm.sqtdso[5] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", rpt_info_rec.fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(need_file_name_yn FROM) TASK_NAMES",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in do_task_report()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   system_dist_ts[0] = 0;

   if (need_dist_ts_yn[0] == 'Y')
      strcpy(system_dist_ts, rpt_info_rec.dist_ts);

   trimlr(system_dist_ts);
   copy_cat(dist_ts, "%DIST_TS%=", system_dist_ts, NULL);

   copy_cat(corp_orig_id_arg, rpt_info_rec.corp_orig_id, NULL);
   while ((pstr = strstr(corp_orig_id_arg, " ")) != NULL)
         // replace all space characters in CORP_ORIG_ID...
         pstr[0] = '^'; // with arbitrary character = '^' = hex(5E) dec(94)
   copy_cat(corp_orig_id, "%CORP_ORIG_ID%=", corp_orig_id_arg, NULL);

   copy_cat(proc_opt, rpt_info_rec.proc_opt, NULL);
   trimlr(proc_opt);

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));


   strcpy(parm[0], connect_yn);	arguments++;
   strcpy(parm[1], fi_rt);		arguments++;
   strcpy(parm[2], task_id);	arguments++;	

   if (need_file_name_yn[0] == 'Y')    /* requires no file name */
   {
       strcpy(parm[arguments], file_name);
       arguments++;
   }

   if (need_corp_orig_yn[0] == 'Y')
   {
       strcpy(parm[arguments], corp_orig_id);
       arguments++;
   }

   if (need_dist_prof_yn[0] == 'Y')
   {
       strcpy(parm[arguments], dist_prof_id);
       arguments++;
   }

   if (need_dist_ts_yn[0] == 'Y')
   {
       strcpy(parm[arguments], dist_ts);
       arguments++;
   }

   if (strlen(proc_opt) > 0)
   {
      copy_cat(parm[arguments], "%OPTION%=", proc_opt, NULL);
      arguments++;
   }


   for(n = 0; n<arguments; n++)
   {
       arg[n] = parm[n];
   }


   result = submit_job(rpt_info_rec.fi_rt,job_file, errstr, arg, arguments);
   if (result == ERR)
   {     /* failed jcs submit  */
      copy_cat(g_fi_info, "FI: ", rpt_info_rec.fi_rt, NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);

      paint_task_line(0, "sql_jcsubmit failed in do_task_report()!");
      do_exit(1);
   }

   copy_cat(msg_text, rpt_info_rec.task_name, " for FI=", rpt_info_rec.fi_rt,
               " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_task_report() */

/********************** do_task_system *****************************************
* Description:                                                                 *
*     Run 1 Scheduled SYSTEMS Task.                                            *
*                                                                              *
* Creation Date:  04/01/1998  By: Barbara Chamberlin                           *
* Modified Date:  05/03/1998  By: Darcy Sivertson                              *
*******************************************************************************/
void  do_task_system(int task_no)
{
   short result;
   char  temp_str[22];  
   char  days_past[20];
   char  temp_day[22];
   char  errstr[300];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  msg_text[400];
   char  task_id[30];
   char  fi_rt[17];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;

      
   /* Build an arg string to pass to the job                                  */
   memset(errstr,'\0',sizeof(errstr));
   memset(submit_errfilestr, '\0', sizeof(submit_errfilestr));
   memset(msg_text,'\0',sizeof(msg_text));

   upch(g_tsch_recs.task_name[task_no]);
   trimlr(g_tsch_recs.task_name[task_no]);
   if (strstr(g_tsch_recs.task_name[task_no], ".JOB") == 0)
      strcat(g_tsch_recs.task_name[task_no], ".JOB");

   _gcvt(g_tsch_recs.task_id[task_no], 10, temp_str);
   if (temp_str[strlen(temp_str)-1] == '.')
      temp_str[strlen(temp_str)-1] = '\0';
      
   _itoa( g_tsch_recs.days_past[task_no], temp_day, 10 );

   copy_cat(job_file, job_path, "\\",g_tsch_recs.task_name[task_no],NULL);

   copy_cat(days_past,  "%DAYS_PAST%=", temp_day ,          NULL);
   copy_cat(task_id, "%TASK_ID%=",  temp_str,            NULL);
   copy_cat(fi_rt,      "%FI_RT%=",    g_tsch_recs.fi_rt[task_no],   NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   /* Submit a systems Job.                                                   */
   /* EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_id = :g_tsch_recs.task_id[task_no]; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "update task_sch  set proc_status=' ' where (fi_rt=:b0 and \
task_id=:b1)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )373;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)(g_tsch_recs.fi_rt)[task_no];
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)&(g_tsch_recs.task_id)[task_no];
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch failed in do_task_report()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* EXEC SQL COMMIT WORK; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )396;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));

   strcpy(parm[0], connect_yn);	arguments++;
   strcpy(parm[1], days_past);	arguments++;
   strcpy(parm[2], task_id);	arguments++;
   strcpy(parm[3], fi_rt);		arguments++;

    for(n = 0; n<arguments; n++)
       arg[n] = parm[n];

   result = submit_job(g_tsch_recs.fi_rt[task_no], job_file, errstr, arg, arguments);

   if (result == ERR)
   {     /* failed jcs submit  */
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);

      paint_task_line(0, "sql_jcsubmit failed in do_task_report()!");
      do_exit(1);
   }

   copy_cat(msg_text, g_tsch_recs.task_name[task_no], 
      " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_task_system() */

/********************** do_task_purge *******************************************
* Description: Run the FI Data Purge Task.                           *
*                                                           *
* Creation Date:  05/24/1999  By: Ramana Malladi                        *
********************************************************************************/
void  do_task_purge(int task_no)
{
   short result;
   char  temp_str[22];  
   char  errstr[300];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  msg_text[400];
   char  task_id[30];
   char  fi_rt[17];
   char  purge_fi_rt[25];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;

      
   /* Build an arg string to pass to the job                                  */
   memset(errstr,'\0',sizeof(errstr));
   memset(submit_errfilestr, '\0', sizeof(submit_errfilestr));
   memset(msg_text,'\0',sizeof(msg_text));

   upch(g_tsch_recs.task_name[task_no]);
   trimlr(g_tsch_recs.task_name[task_no]);
   if (strstr(g_tsch_recs.task_name[task_no], ".JOB") == 0)
      strcat(g_tsch_recs.task_name[task_no], ".JOB");

   _gcvt(g_tsch_recs.task_id[task_no], 10, temp_str);
   if (temp_str[strlen(temp_str)-1] == '.')
      temp_str[strlen(temp_str)-1] = '\0';
      
   copy_cat(job_file, job_path, "\\",g_tsch_recs.task_name[task_no],NULL);

   copy_cat(fi_rt, "%FI_RT%=", g_tsch_recs.fi_rt[task_no], NULL);
   copy_cat(task_id, "%TASK_ID%=", temp_str, NULL);
   trimlr(g_tsch_recs.file_name[task_no]);
   copy_cat(purge_fi_rt, "%PURGE_FI_RT%=", g_tsch_recs.file_name[task_no], NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   /* Submit a systems Job.                                                   */
   /* EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_id = :g_tsch_recs.task_id[task_no]; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "update task_sch  set proc_status=' ' where (fi_rt=:b0 and \
task_id=:b1)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )411;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)(g_tsch_recs.fi_rt)[task_no];
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)&(g_tsch_recs.task_id)[task_no];
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch failed in do_task_purge()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* EXEC SQL COMMIT WORK; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )434;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));

   strcpy(parm[0], connect_yn);		arguments++;
   strcpy(parm[1], purge_fi_rt);	arguments++;
   strcpy(parm[2], task_id);		arguments++;
   strcpy(parm[3], fi_rt);		arguments++;

   for(n = 0; n<arguments; n++)
       arg[n] = parm[n];

   result = submit_job(g_tsch_recs.fi_rt[task_no], job_file, errstr, arg, arguments);
   if (result == ERR)
   {     /* failed jcs submit  */
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);

      paint_task_line(0, "sql_jcsubmit failed in do_task_purge()!");
      do_exit(1);
   }

   copy_cat(msg_text, g_tsch_recs.task_name[task_no], 
      " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_task_purge() */

/********************** do_task_extract *****************************************
* Description: Run the FI Data Extract Task.                            *
*                                                           *
* Creation Date:  10/15/1999  By: Shankar Nagarajan                     *
********************************************************************************/
void  do_task_extract(int task_no)
{
   short result;
   char  temp_str[22];  
   char  errstr[300];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  msg_text[400];
   char  task_id[30];
   char  fi_rt[17];
   char  extract_fi_rt[25];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;
      
   /* Build an arg string to pass to the job                                  */
   memset(errstr,'\0',sizeof(errstr));
   memset(submit_errfilestr, '\0', sizeof(submit_errfilestr));
   memset(msg_text,'\0',sizeof(msg_text));

   upch(g_tsch_recs.task_name[task_no]);
   trimlr(g_tsch_recs.task_name[task_no]);
   if (strstr(g_tsch_recs.task_name[task_no], ".JOB") == 0)
      strcat(g_tsch_recs.task_name[task_no], ".JOB");

   _gcvt(g_tsch_recs.task_id[task_no], 10, temp_str);
   if (temp_str[strlen(temp_str)-1] == '.')
      temp_str[strlen(temp_str)-1] = '\0';
      
   copy_cat(job_file, job_path, "\\",g_tsch_recs.task_name[task_no],NULL);

   copy_cat(fi_rt, "%FI_RT%=", g_tsch_recs.fi_rt[task_no], NULL);
   copy_cat(task_id, "%TASK_ID%=", temp_str, NULL);
   trimlr(g_tsch_recs.file_name[task_no]);
   copy_cat(extract_fi_rt, "%EXTRACT_FI_RT%=", g_tsch_recs.file_name[task_no], NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   /* Submit a systems Job.                                                   */
   /* EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_id = :g_tsch_recs.task_id[task_no]; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "update task_sch  set proc_status=' ' where (fi_rt=:b0 and \
task_id=:b1)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )449;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)(g_tsch_recs.fi_rt)[task_no];
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)&(g_tsch_recs.task_id)[task_no];
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch failed in do_task_extract()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* EXEC SQL COMMIT WORK; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )472;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));


   strcpy(parm[0], connect_yn);		arguments++;
   strcpy(parm[1], extract_fi_rt);  arguments++;
   strcpy(parm[2], task_id);		arguments++;
   strcpy(parm[3], fi_rt);			arguments++;


   for(n = 0; n<arguments; n++)
       arg[n] = parm[n];

   result = submit_job(g_tsch_recs.fi_rt[task_no], job_file, errstr, arg, arguments);
   if (result == ERR)
   {     /* failed jcs submit  */
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);

      paint_task_line(0, "sql_jcsubmit failed in do_task_extract()!");
      do_exit(1);
   }

   copy_cat(msg_text, g_tsch_recs.task_name[task_no], 
      " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_task_extract() */

/********************** do_task_billing *****************************************
* Description: Run the FI Data Billing Task.                            *
*                                                           *
* Creation Date:  10/15/1999  By: Shankar Nagarajan                     *
********************************************************************************/
void  do_task_billing(int task_no)
{
   short result;
   char  temp_str[22];  
   char  errstr[300];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  msg_text[400];
   char  task_id[30];
   char  fi_rt[17];
   char  billing_fi_rt[25];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   char     proc_opt[101];        /* max len is 100  Increased the size for SLA Report */	
   int arguments=0;

   /* Build an arg string to pass to the job                                  */
   memset(errstr,'\0',sizeof(errstr));
   memset(submit_errfilestr, '\0', sizeof(submit_errfilestr));
   memset(msg_text,'\0',sizeof(msg_text));

   upch(g_tsch_recs.task_name[task_no]);
   trimlr(g_tsch_recs.task_name[task_no]);
   if (strstr(g_tsch_recs.task_name[task_no], ".JOB") == 0)
      strcat(g_tsch_recs.task_name[task_no], ".JOB");

   _gcvt(g_tsch_recs.task_id[task_no], 10, temp_str);
   if (temp_str[strlen(temp_str)-1] == '.')
      temp_str[strlen(temp_str)-1] = '\0';
      
   copy_cat(job_file, job_path, "\\",g_tsch_recs.task_name[task_no],NULL);

   copy_cat(fi_rt, "%FI_RT%=", g_tsch_recs.fi_rt[task_no], NULL);

   copy_cat(task_id, "%TASK_ID%=", temp_str, NULL);
   trimlr(g_tsch_recs.file_name[task_no]);
   copy_cat(billing_fi_rt, "%BILLING_FI_RT%=", g_tsch_recs.file_name[task_no], NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   /* Submit a systems Job.                                                   */
   /* EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_id = :g_tsch_recs.task_id[task_no]; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "update task_sch  set proc_status=' ' where (fi_rt=:b0 and \
task_id=:b1)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )487;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)(g_tsch_recs.fi_rt)[task_no];
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)&(g_tsch_recs.task_id)[task_no];
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch failed in do_task_billing()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* EXEC SQL COMMIT WORK; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )510;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));

   strcpy(parm[0], connect_yn);		arguments++;
   strcpy(parm[1], billing_fi_rt);	arguments++;
   strcpy(parm[2], task_id);		arguments++;
   strcpy(parm[3], fi_rt);			arguments++;

   copy_cat(proc_opt, g_tsch_recs.proc_opt[task_no], NULL);
   trimlr(proc_opt);
   if (strlen(proc_opt) > 0)
   {
      copy_cat(parm[arguments], "%OPTION%=", proc_opt, NULL);
      arguments++;
   }

   for(n = 0; n<arguments; n++)
       arg[n] = parm[n];

   result = submit_job(g_tsch_recs.fi_rt[task_no], job_file, errstr, arg, arguments);
   if (result == ERR)
   {     /* failed jcs submit  */
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);

      paint_task_line(0, "sql_jcsubmit failed in do_task_billing()!");
      do_exit(1);
   }

   copy_cat(msg_text, g_tsch_recs.task_name[task_no], 
      " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_task_billing() */


/*********************** do_group_task *****************************************
* Description:                                                                 *
*   Run 1 Scheduled GROUP Task:                                                *
* Obtain from the TASK_NAMES table the .JOB filename associated with a         *
* particular group task, and pass that .JOB filename and the associated        *
* fi_rt and task_id information to sql_jcsubmit to run the group task.             *
*                                                                              *
* Creation Date:  12/03/1998  By: FRNash                                       *
* Modified Date:              By:                                              *
*******************************************************************************/
void  do_group_task(int task_no)
{
   short result;
   char  temp_str[22];  
   char  errstr[300];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  msg_text[400];
   char  task_id[30];
   char  fi_rt[17];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;

   /* EXEC SQL BEGIN DECLARE SECTION; */ 

      char  temp_filename[13];
   /* EXEC SQL END DECLARE SECTION; */ 


   /* Build an arg string to pass to the job */
   memset(errstr,'\0',sizeof(errstr));
   memset(submit_errfilestr, '\0', sizeof(submit_errfilestr));
   memset(msg_text,'\0',sizeof(msg_text));

   upch(g_tsch_recs.task_name[task_no]);
   trimlr(g_tsch_recs.task_name[task_no]);
   if (strstr(g_tsch_recs.task_name[task_no], ".JOB") == 0)
      strcat(g_tsch_recs.task_name[task_no], ".JOB");

   _gcvt(g_tsch_recs.task_id[task_no], 10, temp_str);
   if (temp_str[strlen(temp_str)-1] == '.')
      temp_str[strlen(temp_str)-1] = '\0';

   copy_cat(fi_rt, "%FI_RT%=", g_tsch_recs.fi_rt[task_no], NULL);
   copy_cat(task_id, "%TASK_ID%=", temp_str, NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   /* obtain the job_file name for the Group Job from the TASK_NAMES table */
   /* EXEC SQL
      SELECT   UPPER(group_task_filename)
      INTO     :temp_filename
      FROM     task_names
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_name = :g_tsch_recs.task_name[task_no]; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select UPPER(group_task_filename) into :b0  from task_name\
s where (fi_rt=:b1 and task_name=:b2)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )525;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)temp_filename;
   sqlstm.sqhstl[0] = (unsigned int  )13;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)(g_tsch_recs.fi_rt)[task_no];
   sqlstm.sqhstl[1] = (unsigned int  )10;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)(g_tsch_recs.task_name)[task_no];
   sqlstm.sqhstl[2] = (unsigned int  )31;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", rpt_info_rec.fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(need_file_name_yn FROM) TASK_NAMES",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in do_group_task()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   copy_cat(job_file, job_path, "\\", temp_filename, NULL);

   /* Submit a Group Job. */
   /* EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_id = :g_tsch_recs.task_id[task_no]; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "update task_sch  set proc_status=' ' where (fi_rt=:b0 and \
task_id=:b1)";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )552;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)(g_tsch_recs.fi_rt)[task_no];
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)&(g_tsch_recs.task_id)[task_no];
   sqlstm.sqhstl[1] = (unsigned int  )sizeof(double);
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch failed in do_group_task()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* EXEC SQL COMMIT WORK; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 11;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )575;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));

   strcpy(parm[0], connect_yn);	arguments++;
   strcpy(parm[1], task_id);	arguments++;
   strcpy(parm[2], fi_rt);		arguments++;


   for(n = 0; n<arguments; n++)
       arg[n] = parm[n];

   result = submit_job(g_tsch_recs.fi_rt[task_no], job_file, errstr, arg, arguments);
   if (result == ERR)
   {     /* failed jcs submit  */
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "sql_jcsubmit failed in do_group_task()!");
      do_exit(1);
   }

   copy_cat(msg_text, g_tsch_recs.task_name[task_no], 
      " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;

} /* end do_group_task() */




                                                                                                                                                                                                                                                                      document/set2/CKTSKSCH.PC_2.pdf                                                                     0000644 €    %çg4001001 00000164252 14011517332 014303  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               /*******************************************************************************
CKTSKSCH.PC -- An ACHOS Program - Module of WATCH.EXE

Copyright (C) 1995, 1998 Deluxe Data Systems, Inc.
Copyright (C) 1997, 1998, 1999 Deluxe Electronic Payent Systems, Inc.

Part of WATCH.EXE which runs tasks based on the task schedule.
*******************************************************************************/


/*******************************************************************************
   INCLUDES & DEFINES                              
*******************************************************************************/
EXEC SQL BEGIN DECLARE SECTION;
/* This #define PREVENTS the sqlca to be declared as external in sqlca.h */
#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern
#define INCLUDE_AS_EXTERN   extern

EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE  "sqlproto.h";
EXEC SQL INCLUDE  "sqlca.h";
EXEC SQL INCLUDE  "orcltype.h";
#include          "ddsi.h"
#include          "achosprd.h"

EXEC SQL INCLUDE watch; /* inserts watch.h into src for Pro*C */ 


/*********************** ck_task_sch *******************************************
* Description:                                                                 *
*  Fetches tasks that are due to be run according to the task schedule for all *
* active FI's based on each individual. FI's oper_dt and the current Oracle    *
* Server's System Time.                                                        *
*  The tasks are ordered by run_hhmm.                                          *
*                                                                              *
* Creation Date:  06/18/1996  By: Troy Clark                                 *
* Modified Date:  01/05/1998  By: Darcy Sivertson                            *
* Modified Date:  10/15/1999  By: Shankar Nagarajan                          *
*     Added cursor for gathering Nacha File IDs and A function to process    *
*        the IDs is called w/in a loop.                                        *
*******************************************************************************/
void ck_task_sch(void)
{
   int   task_no = 0;      /* array index into g_tsch_recs.<fieldName>[] */
   int   new_nacha_recs = 0;
   
   /* display message to screen */
   paint_task_line(1, "Checking Task Schedule.....");
   Sleep(2000);         /* delay 1 second */

   /* Get all tasks that are scheduled to be run now. Note that the FI's may  */
   /* have differing oper_dt's due to differing eod_hhmm's etc.               */
   EXEC SQL DECLARE tsch_cursor CURSOR FOR
      SELECT   t.task_type, 
               t.fi_rt, 
               t.task_id,
               t.dist_prof_id,
               upper(t.task_name),
               upper(t.file_name),
               upper(t.run_at_eod_yn),
               upper(t.proc_opt),
               t.days_past,
               to_char(t.dist_ts, 'YYYYMMDDHH24MISS'),
               upper(t.corp_orig_id)
      FROM     fi f, task_sch t 
	  WHERE    f.fi_rt = t.fi_rt 
      AND      f.active_yn = 'Y' 
      AND      f.wh_status = 'U' 
	  AND      t.proc_status = 'N'     /* Not Processed */
      AND      t.run_at_eod_yn = 'N'
      AND      ((to_char(t.due_dt, 'YYYYMMDD') = :g_cur_dt AND :g_cur_time >= t.run_hhmm)
                  OR
                (to_char(t.due_dt, 'YYYYMMDD') < :g_cur_dt)
               )
      ORDER BY t.due_dt, t.run_hhmm;
   /*
   Notice that the above select statement performs a join on the fi and task_sch
   tables such that only task_sch records whose fi_rt and due_dt match a fi
   record's fi_rt and oper_dt where the FI is active and in an "Up" condition
   are returned.  Thus, we don't need to check fi for wh_status = 'U', the date
   matching, etc., after the fact. It's built into the where clause above...
   */ 
   EXEC SQL OPEN tsch_cursor;             /* open cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {     /* open cursor failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TSCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"OPEN CURSOR tsch_cursor; -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   
   /* Loop through all tasks that need to be run by Fetching TSCH_BUF_CNT     */
   /* number of records at a time on each pass through the loop.              */
   EXEC SQL FETCH tsch_cursor INTO :g_tsch_recs:g_tsch_inds;   
   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND) 
   {  
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TSCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Fetch tsch_cursor failed!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
   }
   
   g_tsch_cnt = sqlca.sqlerrd[2];

   EXEC SQL CLOSE tsch_cursor;         /* close cursor */
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {     /* close cursor failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CLOSECRS",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TSCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"CLOSE CURSOR tsch_cursor; -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }
   
   /* Processes all tasks fetched into g_tsch_recs buffer */
   for (task_no = 0; task_no < g_tsch_cnt; task_no++) 
   {
      /* run only when EOD is not running */
      if (no_eod_in_proc(g_tsch_recs.fi_rt[task_no]))
      {
         switch (g_tsch_recs.task_type[task_no][0]) 
         {
            case 'D':   do_task_dist(task_no);     break;   /* Distribution Task */
            case 'E':   do_start_eod(task_no);     break;   /* CHECK EOD TASK */
            case 'G':   do_group_task(task_no);    break;   /* Group Task */
            case 'I':   do_task_integ(task_no);    break;   /* Integrity Task */
            case 'R':   /* copy record used by do_task_report function */
                        strcpy(rpt_info_rec.task_type, g_tsch_recs.task_type[task_no]);
                        strcpy(rpt_info_rec.fi_rt, g_tsch_recs.fi_rt[task_no]);
                        rpt_info_rec.task_id    = g_tsch_recs.task_id[task_no];
                        rpt_info_rec.dist_prof_id  = g_tsch_recs.dist_prof_id[task_no];
                        strcpy(rpt_info_rec.task_name, g_tsch_recs.task_name[task_no]);
                        strcpy(rpt_info_rec.file_name, g_tsch_recs.file_name[task_no]);
                        strcpy(rpt_info_rec.proc_opt, g_tsch_recs.proc_opt[task_no]);
                        strcpy(rpt_info_rec.dist_ts, g_tsch_recs.dist_ts[task_no]);
                        strcpy(rpt_info_rec.corp_orig_id, g_tsch_recs.corp_orig_id[task_no]);
                        do_task_report();                   /* REPORT TASK */
                        break;
            case 'S':   do_task_system(task_no);   break;   /* Systems Task (for client ops) */
            case 'P':   do_task_purge(task_no);    break;   /* Purge Task (for client ops) */
            case 'X':   do_task_extract(task_no);   break;  /* Extract Task */
            case 'B':   do_task_billing(task_no);  break;   /* Billing Task */
            default: /* data error */        break;   /* Unknown Task Type */
         }
      }
   }  

   /****************************************************************************
    *Darcy S. Added the following code as per DEV. REQ. # 97-194
   /***************************************************************************/

   /* display message to screen */
   paint_task_line(1, "Checking Nacha Conversion File Status.....");
   Sleep(2000);         /* delay 1 second */

   /*Get all nacha file ids from nacha_file_info table when file_status is active*/
   EXEC SQL DECLARE nacha_info_cursor CURSOR FOR
      SELECT   n.fi_rt,
               n.nacha_file_id
      FROM     nacha_file_info n, fi f
      WHERE    f.fi_rt = n.fi_rt 
      AND      n.file_status = 'A';

   EXEC SQL OPEN nacha_info_cursor;
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {     /* open cursor failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_OPENCSR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TSCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"OPEN CURSOR nacha_info_cursor FAILED in ck_task_sch()!");
      paint_task_line(1, "..Program Exit Code 3");
      do_exit(3);
   }
   
   /* Loop through all nacha records that need to be run by Fetching 100      */
   /* records at a time.                                                      */
   EXEC SQL FETCH nacha_info_cursor 
   INTO :g_nacha_file_id  :g_nacha_file_id_ind; 
   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND) 
   {  
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_FETCH",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TSCH_CURSOR",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Fetch nacha_info_cursor failed in ck_task_sch()!");
      paint_task_line(1, "..Program Exit Code 4");
      do_exit(4);
   }

   new_nacha_recs = sqlca.sqlerrd[2];

   /* Processes all tasks fetched into g_nacha_file_id buffer */
   for(task_no = 0; task_no < new_nacha_recs; task_no++)
   {
      do_nacha_file(task_no);
   }
} /* end ck_task_sch() */

/*********************** do_nacha_file *****************************************
* Description:                                                                 *
*     Submits a BLDNACHA job. Arguments to be passed are:                      *
*     nacha_file_id[task_no],  fi_rt[task_no]                                  *
*                                                                              *
* Creation Date:  01/05/1998  By: Darcy Sivertson                              *
*******************************************************************************/
void do_nacha_file(int task_no)
{
   char  num_str1[22];        /* temp vars */
   char  errstr[100];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  fi_rt[17];           /*%FI_RT%=fi_rt for sql_jcsubmit*/
   char  nacha_file_id[30];   /*%NACHA_FILE_ID%=Nacha_file_id for sql_jcsubmit*/
   char  msg_text[400];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;

   /* Build an arg string to pass to the job                                  */

   /* convert g_nacha_file_id.nacha_file_id[task_no] to num_str1              */
   _gcvt(g_nacha_file_id.nacha_file_id[task_no], 10, num_str1);

   /* remove decimal point */
   if (num_str1[strlen(num_str1)-1] == '.')
      num_str1[strlen(num_str1)-1] = '\0';

   /* Submit a BLDNACHA Job                                                   */
   copy_cat(job_file, job_path, "\\", "BLDNACHA.JOB", NULL);
   copy_cat(fi_rt, "%FI_RT%=", g_nacha_file_id.fi_rt[task_no], NULL);
   copy_cat(nacha_file_id, "%NACHA_FILE_ID%=", num_str1, NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   EXEC SQL
      UPDATE   NACHA_FILE_INFO
      SET      file_status  = 'I'
      WHERE    fi_rt = :g_nacha_file_id.fi_rt[task_no]
      AND      nacha_file_id = :g_nacha_file_id.nacha_file_id[task_no];
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {   
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_nacha_file_id.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "NACHA_FILE_INFO",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch -- FAILED in do_nacha_file()!");
      paint_task_line(1, "..Program Exit Code 5");
      do_exit(5);
   }

   EXEC SQL COMMIT WORK;      /* else commit update work */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_nacha_file_id.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes in do_nacha_file()");
      paint_task_line(1, "..Program Exit Code 6");
      exit(6);
   }

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));

   strcpy(parm[0], connect_yn);		arguments++;
   strcpy(parm[1], fi_rt);			arguments++;
   strcpy(parm[2], nacha_file_id);	arguments++;


   for(n = 0; n<arguments; n++)
       arg[n] = parm[n];

   if (submit_job(g_nacha_file_id.fi_rt[task_no], job_file, errstr, arg, arguments) == ERR)
   {
      copy_cat(g_fi_info, "FI: ", g_nacha_file_id.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "sql_jcsubmit failed in do_nacha_file()!");
      paint_task_line(1, "..Program Exit Code 7");
      do_exit(7);
   }

   copy_cat(msg_text, "BLDNACHA.JOB", " for FI=", g_nacha_file_id.fi_rt[task_no],
            " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_nacha_file() */

/*********************** do_task_dist ******************************************
* Description:                                                                 *
*  Run 1 Scheduled DISTRIBUTION Task.                                          *
*                                                                              *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  07/05/1996  By: George Lin                                   *
* Modified Date:  11/04/1996  By: Dan Jung                                     *
* Modified Date:  02/04/1998  By: Ramana                                       *
* Modified Date:  06/14/2004  By: Baskaran G                                   *
*                                 Corrected 'missing array subscript' bug.     *
*******************************************************************************/
void  do_task_dist(int task_no)
{
   char  num_str1[22], num_str2[22];         /* temp vars */
   char  errstr[100];
   char  task_id[] = "/TASK_ID=0";
   char  job_file[81];
   char  submit_errfilestr[512];
   char  fi_rt[17];
   char  dist_prof_id[30];
   char  task_sch_id[30];
   char  msg_text[400];
   char  connect_yn[15];
   char  parm[21][50];       
   char* arg[22];
   int   n;
   int   arguments = 0;


// FOR USC - WR 24990 - Start
	char     proc_opt[101];        /* max len is 100  Increased the size for SLA Report */	
   
   /* Verify that dist_prof_id isn't 0 (zero)                                 */
   if (g_tsch_recs.dist_prof_id[task_no] == 0) 
   {  /* Data error, Should not be 0 Set the proc_status = 'N' Not Processed  */
      EXEC SQL
         UPDATE   task_sch
         SET      proc_status = 'N'
         WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
         AND      task_id = :g_tsch_recs.task_id[task_no];
      if (sqlca.sqlcode != ORCL_NO_ERROR) 
      {   /* update task_sch failed */
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
         gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "FI",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
         paint_task_line(0,"Update task_sch -- FAILED!");
         paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
         do_exit(1);
      }

      EXEC SQL COMMIT WORK;   /* else commit update work */
      if (sqlca.sqlcode != ORCL_NO_ERROR)
      {
         sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
         g_orcl_etext_buf[g_orcl_etext_len] = '\0';
         copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
         ifs_fatal("ORC_COMMIT",
                     __FILE__, (DWORD)__LINE__, IFS_LOG,
                     g_orcl_etext_buf,
                     g_fi_info,
                     NULL);
         paint_task_line(0, "Unable to Commit Changes");
         exit(1);
      }

      return;  /* no point in running the dummy distribution */
   }

   /* Build an arg string to pass to the job                                  */
   /* convert g_tsch_recs.task_id[task_no] to num_str1                        */
   /* convert g_tsch_recs.dist_prof_id[task_no] to num_str2                   */
   _gcvt(g_tsch_recs.task_id[task_no], 10, num_str1);
   _gcvt(g_tsch_recs.dist_prof_id[task_no], 10, num_str2); 

   /* remove decimal point */
   if (num_str1[strlen(num_str1)-1] == '.')
      num_str1[strlen(num_str1)-1] = '\0';

   if (num_str2[strlen(num_str2)-1] == '.') 
      num_str2[strlen(num_str2)-1] = '\0';

   /* Submit a Distribution Job                                               */
   copy_cat(job_file, job_path, "\\", trimlr(g_tsch_recs.task_name[task_no]), NULL);
   copy_cat(fi_rt, "%FI_RT%=", g_tsch_recs.fi_rt[task_no], NULL);
   copy_cat(dist_prof_id, "%DIST_PROF_ID%=", num_str2, NULL);
   copy_cat(task_sch_id, "%TASK_ID%=", num_str1, NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_id = :g_tsch_recs.task_id[task_no];

   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   EXEC SQL COMMIT WORK;      /* else commit update work */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));

   strcpy(parm[0], connect_yn);		arguments++;
   strcpy(parm[1], fi_rt);			arguments++;
   strcpy(parm[2], dist_prof_id);	arguments++;
   strcpy(parm[3], task_sch_id);	arguments++;

   copy_cat(proc_opt, g_tsch_recs.proc_opt[task_no], NULL);
   trimlr(proc_opt);
   if (strlen(proc_opt) > 0)
   {
      copy_cat(parm[arguments], "%OPTION%=", proc_opt, NULL);
      arguments++;
   }


   for(n = 0; n<arguments; n++)
      arg[n] = parm[n];

   if (submit_job(g_tsch_recs.fi_rt[task_no], job_file, errstr, arg, arguments) == ERR)
   {
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);

      paint_task_line(0, "sql_jcsubmit failed in do_task_dist()!");
      do_exit(1);
   }

   copy_cat(msg_text, g_tsch_recs.task_name[task_no], " for FI=", g_tsch_recs.fi_rt[task_no],
            " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_task_dist() */


/********************** do_task_integ ******************************************
* Description:                                                                 *
*     Run 1 Scheduled INTEGRITY CHECK Task.                                    *
*                                                                              *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  07/05/1996  By: George Lin                                   *
* Modified Date:  11/04/1996  By: Dan Jung                                     *
* Modified Date:  02/09/1998  By: FRNash                                       *
*                             Corrected another 'missing array subscript' bug. *
*******************************************************************************/
void  do_task_integ(int task_no)
{

   char  num_str1[22];     /* temp var */
   char  errstr[300];   
   char  job_file[81];
   char  submit_errfilestr[512];
   char  fi_rt[17];
   char  option[81];
   char  task_id[80];
   char  msg_text[400];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;
   
   /* convert g_tsch_recs.task_id[task_no] to num_str1                        */
   _gcvt(g_tsch_recs.task_id[task_no], 10, num_str1);
   if (num_str1[strlen(num_str1)-1] == '.')
      num_str1[strlen(num_str1)-1] = '\0';
      
   copy_cat(job_file, job_path, "\\", trimlr(g_tsch_recs.task_name[task_no]), NULL);
   copy_cat(fi_rt, "%FI_RT%=", g_tsch_recs.fi_rt[task_no], NULL);
   trimlr(g_tsch_recs.proc_opt[task_no]);
   strcpy(connect_yn, "DBCONNECT=N");

   if (strcmp(g_tsch_recs.proc_opt[task_no], "/FILE") == 0)
   {
      copy_cat(option, "%OPTION%=", g_tsch_recs.proc_opt[task_no], "=", 
                 g_tsch_recs.file_name[task_no], NULL);
   }
   else
   {
      copy_cat(option, "%OPTION%=", g_tsch_recs.proc_opt[task_no], NULL); //980209 -FRN
   }

   copy_cat(task_id, "%TASK_ID%=", num_str1, NULL);

   EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_id = :g_tsch_recs.task_id[task_no];

   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch -- FAILED!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   EXEC SQL COMMIT WORK;            /* else commit update work */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }
      
   /* submit integ */
   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));


   strcpy(parm[0], connect_yn); arguments++;
   strcpy(parm[1], fi_rt);		arguments++;
   strcpy(parm[2], option);		arguments++;
   strcpy(parm[3], task_id);	arguments++;	


   for(n = 0; n<arguments; n++)
       arg[n] = parm[n];

   if (submit_job(g_tsch_recs.fi_rt[task_no], job_file, errstr, arg, arguments) == ERR)
   {
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);
      
      paint_task_line(0, "sql_jcsubmit failed in do_task_integ");
      do_exit(1);
   }

   copy_cat(msg_text, g_tsch_recs.task_name[task_no], " for FI=",
         g_tsch_recs.fi_rt[task_no], " was submitted at ", 
         g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_task_integ() */

/********************** do_task_report *****************************************
* Description:                                                                 *
*     Run 1 Scheduled REPORT Task.                                             *
*                                                                              *
* Creation Date:  06/18/1996  By: Troy Clark                                   *
* Modified Date:  07/05/1996  By: George Lin                                   *
* Modified Date:  11/04/1996  By: Dan Jung                                     *
* Modified Date:  08/13/1998  By: Ramana Malladi Dev. Req. 97000222.AOS        *
* Modified Date:  05/04/1999  By: FRNash Bug#90426A, replace all ' ' with '^'  *
*                                 in CORP_ORIG_ID to preserve spaces therein.  *
* Modified Date:  04/30/2002  By: Kellie Koch 99-45  Allowed proc_opt to be    *
*                                 specified for a report task.                 *
*******************************************************************************/
void  do_task_report()
{
   short result;
   char  num_str1[22];     /* temp var */
   char  errstr[300];
   char  file_name[81];
   char  task_id[30];
   char  dist_prof_id[30];
   char  dist_ts[30];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  fi_rt[17];
   char  msg_text[400];
   char  system_dist_ts[16];
   char  corp_orig_id[26];
   char  corp_orig_id_arg[26];
   char  proc_opt[101];        /* max len is 100  Increased the size for SLA Report */
   char* pstr; // for general temporary use as pointer-to-string
   char  connect_yn[15];
   char  parm[21][50];       
   char* arg[22];
   int n;
   int   arguments=0;


   EXEC SQL BEGIN DECLARE SECTION;
      char  need_file_name_yn[2];
      char  need_dist_prof_yn[2];
      char  need_dist_ts_yn[2];
      char  need_corp_orig_yn[2];
   EXEC SQL END DECLARE SECTION;
   
   /* Build an arg string to pass to the job                                  */
   upch(rpt_info_rec.task_name);
   trimlr(rpt_info_rec.task_name);

   if (strstr(rpt_info_rec.task_name, ".JOB") == 0)
      strcat(rpt_info_rec.task_name, ".JOB");

   _gcvt(rpt_info_rec.task_id, 10, num_str1);
   if (num_str1[strlen(num_str1)-1] == '.')
      num_str1[strlen(num_str1)-1] = '\0';
      
   copy_cat(job_file, job_path, "\\", rpt_info_rec.task_name, NULL);
   copy_cat(fi_rt, "%FI_RT%=", rpt_info_rec.fi_rt, NULL);
   copy_cat(file_name, "%FILE%=", rpt_info_rec.file_name, NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   _gcvt(rpt_info_rec.task_id, 10, num_str1);
   if (num_str1[strlen(num_str1)-1] == '.')
      num_str1[strlen(num_str1)-1] = '\0';

   copy_cat(task_id, "%TASK_ID%=", num_str1, NULL);

   _gcvt(rpt_info_rec.dist_prof_id, 10, num_str1);
   if (num_str1[strlen(num_str1)-1] == '.')
      num_str1[strlen(num_str1)-1] = '\0';

   copy_cat(dist_prof_id, "%DIST_PROF_ID%=", num_str1, NULL);

   /* Submit a Report Job.                                                    */
   /* Some reports require file name as a parameter, the others don't.        */
   EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :rpt_info_rec.fi_rt
      AND      task_id = :rpt_info_rec.task_id;

   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", rpt_info_rec.fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch failed in do_task_report()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   EXEC SQL COMMIT WORK;
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", rpt_info_rec.fi_rt, NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   EXEC SQL
      SELECT   UPPER(decode(need_file_name_yn, NULL, 'N', need_file_name_yn)),
               UPPER(decode(need_dist_prof_yn, NULL, 'N', need_dist_prof_yn)),
               UPPER(decode(need_dist_ts_yn, NULL, 'N', need_dist_ts_yn)),
               UPPER(decode(need_corp_orig_yn, NULL, 'N', need_corp_orig_yn))
      INTO     :need_file_name_yn, 
			   :need_dist_prof_yn, 
			   :need_dist_ts_yn, 
			   :need_corp_orig_yn
      FROM     task_names t
      WHERE    t.fi_rt = :rpt_info_rec.fi_rt
      AND      t.task_name = :rpt_info_rec.task_name;

   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", rpt_info_rec.fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(need_file_name_yn FROM) TASK_NAMES",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in do_task_report()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   system_dist_ts[0] = 0;

   if (need_dist_ts_yn[0] == 'Y')
      strcpy(system_dist_ts, rpt_info_rec.dist_ts);

   trimlr(system_dist_ts);
   copy_cat(dist_ts, "%DIST_TS%=", system_dist_ts, NULL);

   copy_cat(corp_orig_id_arg, rpt_info_rec.corp_orig_id, NULL);
   while ((pstr = strstr(corp_orig_id_arg, " ")) != NULL)
         // replace all space characters in CORP_ORIG_ID...
         pstr[0] = '^'; // with arbitrary character = '^' = hex(5E) dec(94)
   copy_cat(corp_orig_id, "%CORP_ORIG_ID%=", corp_orig_id_arg, NULL);

   copy_cat(proc_opt, rpt_info_rec.proc_opt, NULL);
   trimlr(proc_opt);

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));


   strcpy(parm[0], connect_yn);	arguments++;
   strcpy(parm[1], fi_rt);		arguments++;
   strcpy(parm[2], task_id);	arguments++;	

   if (need_file_name_yn[0] == 'Y')    /* requires no file name */
   {
       strcpy(parm[arguments], file_name);
       arguments++;
   }

   if (need_corp_orig_yn[0] == 'Y')
   {
       strcpy(parm[arguments], corp_orig_id);
       arguments++;
   }

   if (need_dist_prof_yn[0] == 'Y')
   {
       strcpy(parm[arguments], dist_prof_id);
       arguments++;
   }

   if (need_dist_ts_yn[0] == 'Y')
   {
       strcpy(parm[arguments], dist_ts);
       arguments++;
   }

   if (strlen(proc_opt) > 0)
   {
      copy_cat(parm[arguments], "%OPTION%=", proc_opt, NULL);
      arguments++;
   }


   for(n = 0; n<arguments; n++)
   {
       arg[n] = parm[n];
   }


   result = submit_job(rpt_info_rec.fi_rt,job_file, errstr, arg, arguments);
   if (result == ERR)
   {     /* failed jcs submit  */
      copy_cat(g_fi_info, "FI: ", rpt_info_rec.fi_rt, NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);

      paint_task_line(0, "sql_jcsubmit failed in do_task_report()!");
      do_exit(1);
   }

   copy_cat(msg_text, rpt_info_rec.task_name, " for FI=", rpt_info_rec.fi_rt,
               " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_task_report() */

/********************** do_task_system *****************************************
* Description:                                                                 *
*     Run 1 Scheduled SYSTEMS Task.                                            *
*                                                                              *
* Creation Date:  04/01/1998  By: Barbara Chamberlin                           *
* Modified Date:  05/03/1998  By: Darcy Sivertson                              *
*******************************************************************************/
void  do_task_system(int task_no)
{
   short result;
   char  temp_str[22];  
   char  days_past[20];
   char  temp_day[22];
   char  errstr[300];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  msg_text[400];
   char  task_id[30];
   char  fi_rt[17];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;

      
   /* Build an arg string to pass to the job                                  */
   memset(errstr,'\0',sizeof(errstr));
   memset(submit_errfilestr, '\0', sizeof(submit_errfilestr));
   memset(msg_text,'\0',sizeof(msg_text));

   upch(g_tsch_recs.task_name[task_no]);
   trimlr(g_tsch_recs.task_name[task_no]);
   if (strstr(g_tsch_recs.task_name[task_no], ".JOB") == 0)
      strcat(g_tsch_recs.task_name[task_no], ".JOB");

   _gcvt(g_tsch_recs.task_id[task_no], 10, temp_str);
   if (temp_str[strlen(temp_str)-1] == '.')
      temp_str[strlen(temp_str)-1] = '\0';
      
   _itoa( g_tsch_recs.days_past[task_no], temp_day, 10 );

   copy_cat(job_file, job_path, "\\",g_tsch_recs.task_name[task_no],NULL);

   copy_cat(days_past,  "%DAYS_PAST%=", temp_day ,          NULL);
   copy_cat(task_id, "%TASK_ID%=",  temp_str,            NULL);
   copy_cat(fi_rt,      "%FI_RT%=",    g_tsch_recs.fi_rt[task_no],   NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   /* Submit a systems Job.                                                   */
   EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_id = :g_tsch_recs.task_id[task_no];
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch failed in do_task_report()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   EXEC SQL COMMIT WORK;
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));

   strcpy(parm[0], connect_yn);	arguments++;
   strcpy(parm[1], days_past);	arguments++;
   strcpy(parm[2], task_id);	arguments++;
   strcpy(parm[3], fi_rt);		arguments++;

    for(n = 0; n<arguments; n++)
       arg[n] = parm[n];

   result = submit_job(g_tsch_recs.fi_rt[task_no], job_file, errstr, arg, arguments);

   if (result == ERR)
   {     /* failed jcs submit  */
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);

      paint_task_line(0, "sql_jcsubmit failed in do_task_report()!");
      do_exit(1);
   }

   copy_cat(msg_text, g_tsch_recs.task_name[task_no], 
      " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_task_system() */

/********************** do_task_purge *******************************************
* Description: Run the FI Data Purge Task.                           *
*                                                           *
* Creation Date:  05/24/1999  By: Ramana Malladi                        *
********************************************************************************/
void  do_task_purge(int task_no)
{
   short result;
   char  temp_str[22];  
   char  errstr[300];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  msg_text[400];
   char  task_id[30];
   char  fi_rt[17];
   char  purge_fi_rt[25];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;

      
   /* Build an arg string to pass to the job                                  */
   memset(errstr,'\0',sizeof(errstr));
   memset(submit_errfilestr, '\0', sizeof(submit_errfilestr));
   memset(msg_text,'\0',sizeof(msg_text));

   upch(g_tsch_recs.task_name[task_no]);
   trimlr(g_tsch_recs.task_name[task_no]);
   if (strstr(g_tsch_recs.task_name[task_no], ".JOB") == 0)
      strcat(g_tsch_recs.task_name[task_no], ".JOB");

   _gcvt(g_tsch_recs.task_id[task_no], 10, temp_str);
   if (temp_str[strlen(temp_str)-1] == '.')
      temp_str[strlen(temp_str)-1] = '\0';
      
   copy_cat(job_file, job_path, "\\",g_tsch_recs.task_name[task_no],NULL);

   copy_cat(fi_rt, "%FI_RT%=", g_tsch_recs.fi_rt[task_no], NULL);
   copy_cat(task_id, "%TASK_ID%=", temp_str, NULL);
   trimlr(g_tsch_recs.file_name[task_no]);
   copy_cat(purge_fi_rt, "%PURGE_FI_RT%=", g_tsch_recs.file_name[task_no], NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   /* Submit a systems Job.                                                   */
   EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_id = :g_tsch_recs.task_id[task_no];

   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch failed in do_task_purge()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   EXEC SQL COMMIT WORK;
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));

   strcpy(parm[0], connect_yn);		arguments++;
   strcpy(parm[1], purge_fi_rt);	arguments++;
   strcpy(parm[2], task_id);		arguments++;
   strcpy(parm[3], fi_rt);		arguments++;

   for(n = 0; n<arguments; n++)
       arg[n] = parm[n];

   result = submit_job(g_tsch_recs.fi_rt[task_no], job_file, errstr, arg, arguments);
   if (result == ERR)
   {     /* failed jcs submit  */
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);

      paint_task_line(0, "sql_jcsubmit failed in do_task_purge()!");
      do_exit(1);
   }

   copy_cat(msg_text, g_tsch_recs.task_name[task_no], 
      " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_task_purge() */

/********************** do_task_extract *****************************************
* Description: Run the FI Data Extract Task.                            *
*                                                           *
* Creation Date:  10/15/1999  By: Shankar Nagarajan                     *
********************************************************************************/
void  do_task_extract(int task_no)
{
   short result;
   char  temp_str[22];  
   char  errstr[300];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  msg_text[400];
   char  task_id[30];
   char  fi_rt[17];
   char  extract_fi_rt[25];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;
      
   /* Build an arg string to pass to the job                                  */
   memset(errstr,'\0',sizeof(errstr));
   memset(submit_errfilestr, '\0', sizeof(submit_errfilestr));
   memset(msg_text,'\0',sizeof(msg_text));

   upch(g_tsch_recs.task_name[task_no]);
   trimlr(g_tsch_recs.task_name[task_no]);
   if (strstr(g_tsch_recs.task_name[task_no], ".JOB") == 0)
      strcat(g_tsch_recs.task_name[task_no], ".JOB");

   _gcvt(g_tsch_recs.task_id[task_no], 10, temp_str);
   if (temp_str[strlen(temp_str)-1] == '.')
      temp_str[strlen(temp_str)-1] = '\0';
      
   copy_cat(job_file, job_path, "\\",g_tsch_recs.task_name[task_no],NULL);

   copy_cat(fi_rt, "%FI_RT%=", g_tsch_recs.fi_rt[task_no], NULL);
   copy_cat(task_id, "%TASK_ID%=", temp_str, NULL);
   trimlr(g_tsch_recs.file_name[task_no]);
   copy_cat(extract_fi_rt, "%EXTRACT_FI_RT%=", g_tsch_recs.file_name[task_no], NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   /* Submit a systems Job.                                                   */
   EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_id = :g_tsch_recs.task_id[task_no];

   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch failed in do_task_extract()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   EXEC SQL COMMIT WORK;
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));


   strcpy(parm[0], connect_yn);		arguments++;
   strcpy(parm[1], extract_fi_rt);  arguments++;
   strcpy(parm[2], task_id);		arguments++;
   strcpy(parm[3], fi_rt);			arguments++;


   for(n = 0; n<arguments; n++)
       arg[n] = parm[n];

   result = submit_job(g_tsch_recs.fi_rt[task_no], job_file, errstr, arg, arguments);
   if (result == ERR)
   {     /* failed jcs submit  */
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);

      paint_task_line(0, "sql_jcsubmit failed in do_task_extract()!");
      do_exit(1);
   }

   copy_cat(msg_text, g_tsch_recs.task_name[task_no], 
      " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_task_extract() */

/********************** do_task_billing *****************************************
* Description: Run the FI Data Billing Task.                            *
*                                                           *
* Creation Date:  10/15/1999  By: Shankar Nagarajan                     *
********************************************************************************/
void  do_task_billing(int task_no)
{
   short result;
   char  temp_str[22];  
   char  errstr[300];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  msg_text[400];
   char  task_id[30];
   char  fi_rt[17];
   char  billing_fi_rt[25];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   char     proc_opt[101];        /* max len is 100  Increased the size for SLA Report */	
   int arguments=0;

   /* Build an arg string to pass to the job                                  */
   memset(errstr,'\0',sizeof(errstr));
   memset(submit_errfilestr, '\0', sizeof(submit_errfilestr));
   memset(msg_text,'\0',sizeof(msg_text));

   upch(g_tsch_recs.task_name[task_no]);
   trimlr(g_tsch_recs.task_name[task_no]);
   if (strstr(g_tsch_recs.task_name[task_no], ".JOB") == 0)
      strcat(g_tsch_recs.task_name[task_no], ".JOB");

   _gcvt(g_tsch_recs.task_id[task_no], 10, temp_str);
   if (temp_str[strlen(temp_str)-1] == '.')
      temp_str[strlen(temp_str)-1] = '\0';
      
   copy_cat(job_file, job_path, "\\",g_tsch_recs.task_name[task_no],NULL);

   copy_cat(fi_rt, "%FI_RT%=", g_tsch_recs.fi_rt[task_no], NULL);

   copy_cat(task_id, "%TASK_ID%=", temp_str, NULL);
   trimlr(g_tsch_recs.file_name[task_no]);
   copy_cat(billing_fi_rt, "%BILLING_FI_RT%=", g_tsch_recs.file_name[task_no], NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   /* Submit a systems Job.                                                   */
   EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_id = :g_tsch_recs.task_id[task_no];

   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch failed in do_task_billing()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   EXEC SQL COMMIT WORK;
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));

   strcpy(parm[0], connect_yn);		arguments++;
   strcpy(parm[1], billing_fi_rt);	arguments++;
   strcpy(parm[2], task_id);		arguments++;
   strcpy(parm[3], fi_rt);			arguments++;

   copy_cat(proc_opt, g_tsch_recs.proc_opt[task_no], NULL);
   trimlr(proc_opt);
   if (strlen(proc_opt) > 0)
   {
      copy_cat(parm[arguments], "%OPTION%=", proc_opt, NULL);
      arguments++;
   }

   for(n = 0; n<arguments; n++)
       arg[n] = parm[n];

   result = submit_job(g_tsch_recs.fi_rt[task_no], job_file, errstr, arg, arguments);
   if (result == ERR)
   {     /* failed jcs submit  */
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);

      paint_task_line(0, "sql_jcsubmit failed in do_task_billing()!");
      do_exit(1);
   }

   copy_cat(msg_text, g_tsch_recs.task_name[task_no], 
      " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;
} /* end do_task_billing() */


/*********************** do_group_task *****************************************
* Description:                                                                 *
*   Run 1 Scheduled GROUP Task:                                                *
* Obtain from the TASK_NAMES table the .JOB filename associated with a         *
* particular group task, and pass that .JOB filename and the associated        *
* fi_rt and task_id information to sql_jcsubmit to run the group task.             *
*                                                                              *
* Creation Date:  12/03/1998  By: FRNash                                       *
* Modified Date:              By:                                              *
*******************************************************************************/
void  do_group_task(int task_no)
{
   short result;
   char  temp_str[22];  
   char  errstr[300];
   char  job_file[81];
   char  submit_errfilestr[512];
   char  msg_text[400];
   char  task_id[30];
   char  fi_rt[17];
   char  connect_yn[15];
   char parm[21][50];       
   char* arg[22];
   int n;
   int arguments=0;

   EXEC SQL BEGIN DECLARE SECTION;
      char  temp_filename[13];
   EXEC SQL END DECLARE SECTION;

   /* Build an arg string to pass to the job */
   memset(errstr,'\0',sizeof(errstr));
   memset(submit_errfilestr, '\0', sizeof(submit_errfilestr));
   memset(msg_text,'\0',sizeof(msg_text));

   upch(g_tsch_recs.task_name[task_no]);
   trimlr(g_tsch_recs.task_name[task_no]);
   if (strstr(g_tsch_recs.task_name[task_no], ".JOB") == 0)
      strcat(g_tsch_recs.task_name[task_no], ".JOB");

   _gcvt(g_tsch_recs.task_id[task_no], 10, temp_str);
   if (temp_str[strlen(temp_str)-1] == '.')
      temp_str[strlen(temp_str)-1] = '\0';

   copy_cat(fi_rt, "%FI_RT%=", g_tsch_recs.fi_rt[task_no], NULL);
   copy_cat(task_id, "%TASK_ID%=", temp_str, NULL);
   strcpy(connect_yn, "DBCONNECT=N");

   /* obtain the job_file name for the Group Job from the TASK_NAMES table */
   EXEC SQL
      SELECT   UPPER(group_task_filename)
      INTO     :temp_filename
      FROM     task_names
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_name = :g_tsch_recs.task_name[task_no];

   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", rpt_info_rec.fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(need_file_name_yn FROM) TASK_NAMES",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select failed in do_group_task()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   copy_cat(job_file, job_path, "\\", temp_filename, NULL);

   /* Submit a Group Job. */
   EXEC SQL
      UPDATE   task_sch
      SET      proc_status = ' '
      WHERE    fi_rt = :g_tsch_recs.fi_rt[task_no]
      AND      task_id = :g_tsch_recs.task_id[task_no];
   if (sqlca.sqlcode != ORCL_NO_ERROR) 
   {   /* update task_sch failed */
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "TASK_SCH",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0,"Update task_sch failed in do_group_task()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   EXEC SQL COMMIT WORK;
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   memset(parm, 0, sizeof(parm));
   memset(arg, 0, sizeof(arg));
   memset(errstr, 0, sizeof(errstr));

   strcpy(parm[0], connect_yn);	arguments++;
   strcpy(parm[1], task_id);	arguments++;
   strcpy(parm[2], fi_rt);		arguments++;


   for(n = 0; n<arguments; n++)
       arg[n] = parm[n];

   result = submit_job(g_tsch_recs.fi_rt[task_no], job_file, errstr, arg, arguments);
   if (result == ERR)
   {     /* failed jcs submit  */
      copy_cat(g_fi_info, "FI: ", g_tsch_recs.fi_rt[task_no], NULL);
      copy_cat(submit_errfilestr, job_file, " - ", errstr, NULL);
      gpszIFSMsg = ifs_fatal("AOS_sql_jcsubmit",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              submit_errfilestr,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "sql_jcsubmit failed in do_group_task()!");
      do_exit(1);
   }

   copy_cat(msg_text, g_tsch_recs.task_name[task_no], 
      " was submitted at ", g_prn_time, " on ", g_prn_dt, NULL);

   paint_proc_info(msg_text);
   paint_proc_info(blank_line);
   return;

} /* end do_group_task() */




                                                                                                                                                                                                                                                                                                                                                      document/set2/Mousehit.cpp_3.pdf                                                                    0000644 €    %çg4001001 00000005470 14011517332 015140  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               /****************(**************************************************************
mousehit.c -- An ACHOS Program - Module of WATCH.EXE
Version 1.08.00

Copyright (C) 1998 Deluxe Electronic Payent Systems, Inc.

Part of WATCH.EXE which runs tasks based on the task schedule.
*******************************************************************************/

/* Save the project pack value */
#pragma pack	( push, prior_pack )
/* Set MS default value as needed for windows.h structures */
#pragma pack	( 8 )
#include			<windows.h>
/* Restore the project pack value */
#pragma pack	( pop, prior_pack )

/* Now it's safe to include the rest */
//#include			"G:\DEV\AOS\LIB\REF\119.00\achosprd.h"

/*********************** ck_mouse_hit ******************************************
* Description:    [cloned from ACHOSPRD.LIB)                                   *
*    Returns TRUE if the mouse was clicked in the console between coordinates  *
* (min_x, min_y) and (max_x, max_y).                                           *
*                                                                              *
* Creation Date:	05/05/1998	By: DSivertson                                   *
* Modified Date:	05/14/1998	By: FRNash pragma stuff, mouse event logic       *
*******************************************************************************/
short ck_mouse_hitx (HANDLE hConIn, short min_x, short min_y,
							short max_x, short max_y)
{
	INPUT_RECORD	inputBuffer;
	unsigned int	uSize = sizeof(inputBuffer);
   BOOL				bSuccess;
   UINT				dwTotalEventCnt;
   UINT				dwNumEventsRead;
   UINT				i;
	short				x_val;
	short				y_val;
	BOOL				bAnyButton = FALSE; // -FRN
   DWORD				dwAnyButtonPressed	= FROM_LEFT_1ST_BUTTON_PRESSED
													| RIGHTMOST_BUTTON_PRESSED
													| FROM_LEFT_2ND_BUTTON_PRESSED
													| FROM_LEFT_3RD_BUTTON_PRESSED
													| FROM_LEFT_4TH_BUTTON_PRESSED;

	if (GetNumberOfConsoleInputEvents(hConIn, (ULONG*)&dwTotalEventCnt)) 
   {
	  for (i = 0; i < dwTotalEventCnt; i++) 
	  {
		 // get a single input event 
		 bSuccess = ReadConsoleInput(hConIn, &inputBuffer, 1, (ULONG*)&dwNumEventsRead);
		 if (bSuccess						// If ReadConsoleInput was successful and...
				&& inputBuffer.EventType == MOUSE_EVENT // It is a mouse event, and
				&& inputBuffer.Event.MouseEvent.dwEventFlags == 0) // a button press
		 {
   			x_val = inputBuffer.Event.MouseEvent.dwMousePosition.X;
				y_val = inputBuffer.Event.MouseEvent.dwMousePosition.Y;

			bAnyButton = inputBuffer.Event.MouseEvent.dwButtonState && dwAnyButtonPressed;
			if (bAnyButton) // <- any button, filtering out extraneous bits
			{
			   if (	y_val >= min_y && y_val <= max_y &&
						x_val >= min_x && x_val <= max_x	)
				{
					 return(TRUE);
				}					 	
			}
		 }	
	  }
   }
   return(FALSE);
}
                                                                                                                                                                                                        document/set2/WATCH.cpp_3.pdf                                                                       0000644 €    %çg4001001 00000201232 14011517334 014205  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               
/* Result Sets Interface */
#ifndef SQL_CRSR
#  define SQL_CRSR
  struct sql_cursor
  {
    unsigned int curocn;
    void *ptr1;
    void *ptr2;
    unsigned int magic;
  };
  typedef struct sql_cursor sql_cursor;
  typedef struct sql_cursor SQL_CURSOR;
#endif /* SQL_CRSR */

/* Thread Safety */
typedef void * sql_context;
typedef void * SQL_CONTEXT;

/* Object support */
struct sqltvn
{
  unsigned char *tvnvsn; 
  unsigned short tvnvsnl; 
  unsigned char *tvnnm;
  unsigned short tvnnml; 
  unsigned char *tvnsnm;
  unsigned short tvnsnml;
};
typedef struct sqltvn sqltvn;

struct sqladts
{
  unsigned int adtvsn; 
  unsigned short adtmode; 
  unsigned short adtnum;  
  sqltvn adttvn[1];       
};
typedef struct sqladts sqladts;

static struct sqladts sqladt = {
  1,0,0,
};

/* Binding to PL/SQL Records */
struct sqltdss
{
  unsigned int tdsvsn; 
  unsigned short tdsnum; 
  unsigned char *tdsval[1]; 
};
typedef struct sqltdss sqltdss;
static struct sqltdss sqltds =
{
  1,
  0,
};

/* File name & Package Name */
struct sqlcxp
{
  unsigned short fillen;
           char  filnam[11];
};
static const struct sqlcxp sqlfpn =
{
    10,
    ".\\WATCH.pc"
};


static unsigned int sqlctx = 67147;


static struct sqlexd {
   unsigned int   sqlvsn;
   unsigned int   arrsiz;
   unsigned int   iters;
   unsigned int   offset;
   unsigned short selerr;
   unsigned short sqlety;
   unsigned int   occurs;
      const short *cud;
   unsigned char  *sqlest;
      const char  *stmt;
   sqladts *sqladtp;
   sqltdss *sqltdsp;
            void  **sqphsv;
   unsigned int   *sqphsl;
            int   *sqphss;
            void  **sqpind;
            int   *sqpins;
   unsigned int   *sqparm;
   unsigned int   **sqparc;
   unsigned short  *sqpadto;
   unsigned short  *sqptdso;
   unsigned int   sqlcmax;
   unsigned int   sqlcmin;
   unsigned int   sqlcincr;
   unsigned int   sqlctimeout;
   unsigned int   sqlcnowait;
              int   sqfoff;
   unsigned int   sqcmod;
   unsigned int   sqfmod;
   unsigned int   sqlpfmem;
            void  *sqhstv[4];
   unsigned int   sqhstl[4];
            int   sqhsts[4];
            void  *sqindv[4];
            int   sqinds[4];
   unsigned int   sqharm[4];
   unsigned int   *sqharc[4];
   unsigned short  sqadto[4];
   unsigned short  sqtdso[4];
} sqlstm = {13,4};

// Prototypes
extern "C" {
  void sqlcxt (void **, unsigned int *,
               struct sqlexd *, const struct sqlcxp *);
  void sqlcx2t(void **, unsigned int *,
               struct sqlexd *, const struct sqlcxp *);
  void sqlbuft(void **, char *);
  void sqlgs2t(void **, char *);
  void sqlorat(void **, unsigned int *, void *);
}

// Forms Interface
static const int IAPSUCC = 0;
static const int IAPFAIL = 1403;
static const int IAPFTL  = 535;
extern "C" { void sqliem(unsigned char *, signed int *); }

typedef struct { unsigned short len; unsigned char arr[1]; } VARCHAR;
typedef struct { unsigned short len; unsigned char arr[1]; } varchar;

/* cud (compilation unit data) array */
static const short sqlcud0[] =
{13,4130,178,0,0,
5,0,0,1,79,0,518,212,0,0,1,1,0,1,0,2,97,0,0,
24,0,0,2,0,0,542,231,0,0,0,0,0,1,0,
39,0,0,3,38,0,516,311,0,0,1,0,0,1,0,2,3,0,0,
58,0,0,4,32,0,516,327,0,0,1,0,0,1,0,2,97,0,0,
77,0,0,5,178,0,517,402,0,0,2,2,0,1,0,1,97,0,0,1,97,0,0,
100,0,0,6,133,0,517,424,0,0,1,1,0,1,0,1,97,0,0,
119,0,0,7,0,0,541,443,0,0,0,0,0,1,0,
134,0,0,8,105,0,517,459,0,0,1,1,0,1,0,1,97,0,0,
153,0,0,9,0,0,541,482,0,0,0,0,0,1,0,
168,0,0,10,66,0,516,529,0,0,1,0,0,1,0,2,97,0,0,
187,0,0,11,151,0,516,558,0,0,4,0,0,1,0,2,97,0,0,2,97,0,0,2,97,0,0,2,97,0,0,
218,0,0,12,81,0,516,603,0,0,4,1,0,1,0,2,97,0,0,2,97,0,0,2,97,0,0,1,97,0,0,
249,0,0,13,0,0,542,647,0,0,0,0,0,1,0,
264,0,0,14,64,0,516,681,0,0,2,1,0,1,0,2,97,0,0,1,97,0,0,
};


char  prog_name[] = "WATCH.EXE";
char  prog_vers[] = "1.13.01";
/*******************************************************************************
WATCH.PC -- An ACHOS Program

Copyright (C) 1995, 1996, 1997 Deluxe Data Systems, Inc.
Copyright (C) 1997, 1998 Deluxe Electronic Payent Systems, Inc.

This program accepts two command line parameters

The program watches the ioq, file_sch, task_sch and fi tables, and submits
jobs to handle all scheduled processes. 
*******************************************************************************/

/*******************************************************************************
   INCLUDES, DEFINES & TYPEDEFS                              
*******************************************************************************/

/* EXEC SQL BEGIN DECLARE SECTION; */ 

/* This #define PREVENTS the sqlca to be declared as external in sqlca.h */
#define SQLCA_STORAGE_CLASS 
#define ORACA_STORAGE_CLASS 
#define INCLUDE_AS_EXTERN   

/* EXEC SQL END DECLARE SECTION; */ 


/* EXEC SQL INCLUDE  "sqlproto.h";
 */ 
#include <sqlcpr.h>

/* EXEC SQL INCLUDE  "sqlca.h";
 */ 
/*
 * $Header: sqlca.h,v 1.3 1994/12/12 19:27:27 jbasu Exp $ sqlca.h 
 */

/* Copyright (c) 1985,1986, 1998 by Oracle Corporation. */
 
/*
NAME
  SQLCA : SQL Communications Area.
FUNCTION
  Contains no code. Oracle fills in the SQLCA with status info
  during the execution of a SQL stmt.
NOTES
  **************************************************************
  ***                                                        ***
  *** This file is SOSD.  Porters must change the data types ***
  *** appropriately on their platform.  See notes/pcport.doc ***
  *** for more information.                                  ***
  ***                                                        ***
  **************************************************************

  If the symbol SQLCA_STORAGE_CLASS is defined, then the SQLCA
  will be defined to have this storage class. For example:
 
    #define SQLCA_STORAGE_CLASS extern
 
  will define the SQLCA as an extern.
 
  If the symbol SQLCA_INIT is defined, then the SQLCA will be
  statically initialized. Although this is not necessary in order
  to use the SQLCA, it is a good pgming practice not to have
  unitialized variables. However, some C compilers/OS's don't
  allow automatic variables to be init'd in this manner. Therefore,
  if you are INCLUDE'ing the SQLCA in a place where it would be
  an automatic AND your C compiler/OS doesn't allow this style
  of initialization, then SQLCA_INIT should be left undefined --
  all others can define SQLCA_INIT if they wish.

  If the symbol SQLCA_NONE is defined, then the SQLCA variable will
  not be defined at all.  The symbol SQLCA_NONE should not be defined
  in source modules that have embedded SQL.  However, source modules
  that have no embedded SQL, but need to manipulate a sqlca struct
  passed in as a parameter, can set the SQLCA_NONE symbol to avoid
  creation of an extraneous sqlca variable.
 
MODIFIED
    lvbcheng   07/31/98 -  long to int
    jbasu      12/12/94 -  Bug 217878: note this is an SOSD file
    losborne   08/11/92 -  No sqlca var if SQLCA_NONE macro set 
  Clare      12/06/84 - Ch SQLCA to not be an extern.
  Clare      10/21/85 - Add initialization.
  Bradbury   01/05/86 - Only initialize when SQLCA_INIT set
  Clare      06/12/86 - Add SQLCA_STORAGE_CLASS option.
*/
 
#ifndef SQLCA
#define SQLCA 1
 
struct   sqlca
         {
         /* ub1 */ char    sqlcaid[8];
         /* b4  */ int     sqlabc;
         /* b4  */ int     sqlcode;
         struct
           {
           /* ub2 */ unsigned short sqlerrml;
           /* ub1 */ char           sqlerrmc[70];
           } sqlerrm;
         /* ub1 */ char    sqlerrp[8];
         /* b4  */ int     sqlerrd[6];
         /* ub1 */ char    sqlwarn[8];
         /* ub1 */ char    sqlext[8];
         };

#ifndef SQLCA_NONE 
#ifdef   SQLCA_STORAGE_CLASS
SQLCA_STORAGE_CLASS struct sqlca sqlca
#else
         struct sqlca sqlca
#endif
 
#ifdef  SQLCA_INIT
         = {
         {'S', 'Q', 'L', 'C', 'A', ' ', ' ', ' '},
         sizeof(struct sqlca),
         0,
         { 0, {0}},
         {'N', 'O', 'T', ' ', 'S', 'E', 'T', ' '},
         {0, 0, 0, 0, 0, 0},
         {0, 0, 0, 0, 0, 0, 0, 0},
         {0, 0, 0, 0, 0, 0, 0, 0}
         }
#endif
         ;
#endif
 
#endif
 
/* end SQLCA */
/* EXEC SQL INCLUDE  "orcltype.h";
 */ 
/***************************************************************

ACHOS Function Library
Copyright (C) 1996 Deluxe Electronic Payment Systems, Inc.

Header Containing TypeDefs for Native ORACLE data types
and function prototypes for ORCLTYPE.LIB.

NOTE:  Programs should use EXEC SQL INCLUDE orcltype;
to include this header AFTER including achosprd.h!

FILE:			ORCLTYPE.H

CREATED:		07/01/96		Troy Clark
MODIFIED:	11/25/96		Troy Clark

***************************************************************/

#ifndef	ORCLTYPE_H_
#define	ORCLTYPE_H_

/***************************************************************
	Typedefs
***************************************************************/
/*
NOTICE:  Any changes made to oracle_date or oracle_varnum typedefs
			must also be made to their re-definition within DDSI.H
			The duplication is required so that DDSI.H does not
			required using oracles pro*c precompiler!
*/

/* EXEC SQL BEGIN DECLARE SECTION; */ 


typedef	struct	oracle_date_tag {
	unsigned char	century;
	unsigned	char	year;
	unsigned	char	month;
	unsigned	char	day;
	unsigned	char	hour;
	unsigned char	minute;
	unsigned char	second;
} oracle_date;

typedef struct oracle_varnum_tag {
	unsigned char	length;			/* # of bytes to follow -- includes expon. */
	unsigned char	exponent;			
	unsigned char	mantissa[20];	/* signif.digits - NO lead/trail zeros */
} oracle_varnum;

/* EXEC SQL TYPE	oracle_date		IS		DATE; */ 

/* EXEC SQL TYPE	oracle_varnum	IS		VARNUM(22); */ 


/* EXEC SQL END DECLARE SECTION; */ 


#endif

#include          "ddsi.h"
#include          "achosprd.h"

/* 
   The above include inserts the contents of sqlca.h into this source file
   for pro*c.  It's contents declares and defines (allocates storage) for 
   sqlca.  If you just want an extern ref. to sqlca (eg, for a 2nd src file
   when sqlca has already been defined by main src file) then do a 
      #define SQLCA_STORAGE_CLASS extern
   prior to the EXEC SQL INCLUDE sqlca; statement.
   NOTE:  Pro*C 2.1 will not generate the error handling code properly

          if you use a normal #include <sqlca.h> so stick with this method!
*/

/* EXEC SQL INCLUDE watch; /o inserts watch.h into src for Pro*C o/ 
 */ 
/***************************************************************

WATCH.H Header File for WATCH.EXE and it's assoc. sub-programs
Version 1.08.10

Copyright (C) 1995 Deluxe Data Systems, Inc.
Copyright (C) 1997, 1998 Deluxe Electronic Payent Systems, Inc.

Header Containing Prototypes for all functions in the ACHOSPRD.LIB
   FILE:       watch.h
   CREATED:    06/18/1996  Troy Clark
   MODIFIED:   06/18/1996  Troy Clark
   MODIFIED:   05/14/1998  FRNash
***************************************************************/


/***************************************************************
   INCLUDES 
***************************************************************/


/***************************************************************
   TYPEDEFS, DEFINES AND DECLARATIONS
***************************************************************/
#ifndef _WATCH_H_
#define _WATCH_H_

/* EXEC SQL BEGIN DECLARE SECTION; */ 


#define  TSCH_BUF_CNT            100
#define  IOQ_BUF_CNT             100
#define  FSCH_BUF_CNT            100
#define  FI_BUF_CNT              101
#define  MAX_LOOP_CNT            50
#define  MAX_NACHA_CURSOR_CNT    100
#define  MOUSE_TARGET_MIN_X      36
#define  MOUSE_TARGET_MIN_Y      23

#define  MOUSE_TARGET_MAX_X      39
#define  MOUSE_TARGET_MAX_Y      23

#define  blank_line " "
/* 
   Max allowed FI cnt = (FI_BUF_CNT - 1) or 100 
   This makes detecting when more than max allowed FI recs exist easy
   since doing an array fetch only sets sqlca.sqlcode == 0 when it
   fetches exactly the same # of rows as the array size.  Otherwise,
   it will set sqlca.sqlcode = 100 and sqlca.sqlerrd[2] = actual fetch
   cnt.
*/

typedef struct rpt_info_rec_tag {
   char     task_type[2];
   char     fi_rt[10];
   double   task_id;
   double   dist_prof_id;
   char     task_name[31];       /* max len is 30 */
   char     file_name[13];
   char     run_at_eod_yn[2];
   char     proc_opt[101];        /* max len is 100  Increased the size for SLA Report */
   char     dist_ts[16];         /* max len is 15 */
   char     corp_orig_id[11];
} rpt_info_rec_type;

typedef struct watch_tsch_recs_tag {
   char     task_type       [TSCH_BUF_CNT][2];
   char     fi_rt           [TSCH_BUF_CNT][10];
   double   task_id         [TSCH_BUF_CNT];
   double   dist_prof_id    [TSCH_BUF_CNT];
   char     task_name       [TSCH_BUF_CNT][31];  /* max len is 30 */
   char     file_name       [TSCH_BUF_CNT][13];
   char     run_at_eod_yn   [TSCH_BUF_CNT][2];
   char     proc_opt        [TSCH_BUF_CNT][101];  /* max len is 100 */
   int      days_past       [TSCH_BUF_CNT];
   char     dist_ts         [TSCH_BUF_CNT][16];
   char     corp_orig_id    [TSCH_BUF_CNT][11];
} watch_tsch_recs;

typedef struct watch_tsch_ind_recs_tag {
   short    task_type       [TSCH_BUF_CNT];
   short    fi_rt           [TSCH_BUF_CNT];
   short    task_id         [TSCH_BUF_CNT];
   short    dist_prof_id    [TSCH_BUF_CNT];
   short    task_name       [TSCH_BUF_CNT];
   short    file_name       [TSCH_BUF_CNT];
   short    run_at_eod_yn   [TSCH_BUF_CNT];
   short    proc_opt        [TSCH_BUF_CNT];
   short    days_past       [TSCH_BUF_CNT];
   short    dist_ts         [TSCH_BUF_CNT];
   short    corp_orig_id    [TSCH_BUF_CNT];
} watch_tsch_ind_recs;  /* indicators for watch_task_recs */

typedef struct watch_ioq_recs_tag {
   char     file_name      [IOQ_BUF_CNT][13];
   char     recv_ts        [IOQ_BUF_CNT][15];
   char     fi_rt          [IOQ_BUF_CNT][10];
   char     type           [IOQ_BUF_CNT][4];
} watch_ioq_recs;

typedef struct watch_ioq_ind_recs_tag {
   short    file_name      [IOQ_BUF_CNT];
   short    recv_ts        [IOQ_BUF_CNT];
   short    fi_rt          [IOQ_BUF_CNT];
   short    type           [IOQ_BUF_CNT];
} watch_ioq_ind_recs;

typedef struct watch_fsch_recs_tag {
   char     fi_rt          [FSCH_BUF_CNT][10];
   double   file_sch_id    [FSCH_BUF_CNT];
   double   file_id        [FSCH_BUF_CNT];
   char     earliest_ts    [FSCH_BUF_CNT][15];  /* TS is in 'YYYYMMDDHH24MISS' format */
   char     latest_ts      [FSCH_BUF_CNT][15];
} watch_fsch_recs;

typedef struct watch_fsch_ind_recs_tag {
   short    fi_rt          [FSCH_BUF_CNT];
   short    file_sch_id    [FSCH_BUF_CNT];
   short    file_id        [FSCH_BUF_CNT];
   short    earliest_ts    [FSCH_BUF_CNT];
   short    latest_ts      [FSCH_BUF_CNT];
} watch_fsch_ind_recs;

typedef  struct watch_fi_rt_rec_tag {
   char     fi_rt[FSCH_BUF_CNT][10];
} watch_fi_rt_rec;

typedef  struct watch_eod_rec_tag {
   char     fi_rt[FSCH_BUF_CNT][10];
   char     eod_status[FSCH_BUF_CNT][2];
} watch_eod_rec;

typedef  struct watch_eod_ind_rec_tag {
   short    fi_rt[FSCH_BUF_CNT];
   short    eod_status[FSCH_BUF_CNT];
} watch_eod_ind_rec;

typedef  struct g_nacha_file_id_tag 
{
char     fi_rt[MAX_NACHA_CURSOR_CNT][10];
double   nacha_file_id[MAX_NACHA_CURSOR_CNT];
}g_nacha_file_rec;


typedef  struct g_nacha_file_ind_tag 
{
short    fi_rt[MAX_NACHA_CURSOR_CNT];
short    nacha_file_id[MAX_NACHA_CURSOR_CNT];
}g_nacha_file_ind;   

/* Struct Def. for Nacha File Id used in CKTSKSCH.PC (DS)*/

INCLUDE_AS_EXTERN watch_tsch_recs        g_tsch_recs;
INCLUDE_AS_EXTERN watch_tsch_ind_recs    g_tsch_inds;
INCLUDE_AS_EXTERN int                    g_tsch_cnt;
INCLUDE_AS_EXTERN watch_ioq_recs         g_ioq_recs;
INCLUDE_AS_EXTERN watch_ioq_ind_recs     g_ioq_inds;
INCLUDE_AS_EXTERN int                    g_ioq_cnt;
INCLUDE_AS_EXTERN watch_fsch_recs        g_fsch_recs;
INCLUDE_AS_EXTERN watch_fsch_ind_recs    g_fsch_inds;
INCLUDE_AS_EXTERN int                    g_fsch_cnt;
INCLUDE_AS_EXTERN watch_fi_rt_rec        g_fi_rt_rec;


INCLUDE_AS_EXTERN g_nacha_file_rec  g_nacha_file_id;
INCLUDE_AS_EXTERN g_nacha_file_ind  g_nacha_file_id_ind; 
INCLUDE_AS_EXTERN  rpt_info_rec_type rpt_info_rec;
INCLUDE_AS_EXTERN char        g_prn_dt[9];
INCLUDE_AS_EXTERN char        g_prn_time[6];
INCLUDE_AS_EXTERN char        g_cur_dt[9];               /* current date */
INCLUDE_AS_EXTERN char        g_cur_time[5];             /* current time */
INCLUDE_AS_EXTERN char        g_cur_dt_time[14];         /* current date and time */
INCLUDE_AS_EXTERN char*       gpszIFSMsg;
INCLUDE_AS_EXTERN char        g_user_name[81];
INCLUDE_AS_EXTERN char        g_db_name[81];
INCLUDE_AS_EXTERN char        g_orcl_etext_buf[256];
INCLUDE_AS_EXTERN char        g_fi_info[81];
INCLUDE_AS_EXTERN int         g_orcl_etext_len;
INCLUDE_AS_EXTERN int         g_orcl_etext_size;
INCLUDE_AS_EXTERN char        p_fi_rt[10];
INCLUDE_AS_EXTERN char        gs_scratch[81];
INCLUDE_AS_EXTERN char        g_corp_orig_id[11];                 /* psm - 5/08/1997 mod */
INCLUDE_AS_EXTERN int         g_num_fi;
INCLUDE_AS_EXTERN int         g_cur_fi;
INCLUDE_AS_EXTERN int         loop_cnt;                  

/* EXEC SQL END DECLARE SECTION; */ 


/* job path and btrieve path */
INCLUDE_AS_EXTERN  char        job_path[81];        
INCLUDE_AS_EXTERN char        exe_path[81];
INCLUDE_AS_EXTERN char        eod_job_name[81];

/***************************************************************
   FUNCTION PROTOTYPES 
***************************************************************/

/* Functions are listed by source file in order of their appearance */


/* SOURCE FILE:   ckeod.pc       */
void  ck_eod               (void);
void  do_start_eod         (int task_no);
BOOL  do_eod_reports       (char*);
BOOL  do_eod_job           (char*);
int   no_tasks_in_proc     (char*);
int   no_input_in_proc     (char*);
int   no_eod_in_proc       (char*);
BOOL  fail_check           (char *);


/* SOURCE FILE:   ckfildlv.pc       */
void  ck_file_dlvrs        (void);
void  deliver_file         (int ioq_no);


/* SOURCE FILE:   ckfilsch.pc       */
void  ck_file_sch          (void);
void  input_file           (int ioq_no);
int   ioq_set_status       (char *file_name, char *fi_rt, char *status_str);
/* 
   NOTE: ioq_set_status() needs to be put in ACHOSPRD.LIB once tested.
*/
int   file_sch_set_status  (char *fi_rt, double fsch_id, char new_status);
/* 
   NOTE: file_sch_set_status() needs to be put in ACHOSPRD.LIB once tested.
*/
int   id_input_file        (char *rec_one, char *fi_rt, FILE *file_handle, 
                              char * file_name_str, double *file_id,
                              char *reject_yn, int *rec_size);
long  find_one_rec         (FILE* fPointer, int* rec_size, long offset_to_one,
                              char* file_name_str);
int   id_nonnacha_file     (FILE *, char *);
long  one_rec_offset       (FILE *filePtr, char* file_name_str, int *rec_size);
void  log_file             (char *fi_rt, char *file_name, char *recv_ts, 
                              double dwFileID);
int   file_sch_hit         (char *fi_rt, double file_id, double *fsch_id);
void  file_sch_ck_at_risk  (void);
void  file_sch_ck_missed   (void);
void  get_corp_orig_id     (int fsch_no);


/* SOURCE FILE:   cktsksch.pc    */
void  ck_task_sch          (void);
void  do_task_dist         (int task_no);
void  do_task_fpickup      (int task_no);
void  do_task_integ        (int task_no);
void  do_task_report       (void);
void  do_nacha_file        (int task_no);
void  do_task_system       (int task_no);
void  do_group_task        (int task_no); // Added for DR#97-018 -FRN
void    do_task_purge         (int task_no); // Added for DR#97-199 -RMM
void  do_task_extract      (int task_no); // Added for DR#99-018 -SHA
void  do_task_billing      (int task_no); // Added for DR#99-018 -SHA
/* SOURCE FILE:   watch.pc       */
void  build_fi_rec();
void  do_exit              (int exit_value);
void  ck_mouse_quit        (HANDLE hConOut);
void  refresh_fi();
void  watch_events         (HANDLE hStdIn);
void  wr_cur_time();
void  wr_start_time();
void  wr_status(void);
int   submit_job(char* task_fi_rt, char* job_file, char* errstr,  char* arg[22], int arguments);
BOOL WINAPI CtrlHandler    (DWORD dwEvent);


/* SOURCE FILE:   mousehit.c     */
/* [Replaces the ACHOSPRD.LIB version of this function, which doesn't work!] */
short ck_mouse_hitx (HANDLE hConIn,  short min_x, short min_y, short max_x, short max_y);

#endif //_WATCH_H_




/*******************************************************************************
   GLOBALS
*******************************************************************************/

/* EXEC SQL BEGIN DECLARE SECTION; */ 



/* EXEC SQL END DECLARE SECTION; */ 



/************************** main ***********************************************
* Description:                                                                 *
*    Paints a standard screen, connects to the ACHOS Database and calls the    *
* watch_events() function to do the actual processing.                         *
*                                                                              *
* Creation Date:  06/13/1996  By: Troy Clark                                   *
* Modified Date:  11/04/1996  By: Dan Jung                                     *
* Modified Date:  04/28/1998  By: Mike West                                    *
*     Added SetConsoleCtrlHandler(CtrlHandler, TRUE) to ensure a graceful exit *
*     from WATCH when closing.                                                 *
* Modified Date:  12/03/1998  By: FRNash                                       *
*     Added Group Task processing per DR#97-018 [WATCH.H & WATCH.PC]           *
* Modified Date:  12/13/1998  By: FRNash  DR#97-300 [watch_events]             *
* Modified Date:  12/15/1998  By: FRNash  DR#97-300 [watch_events]             *
*******************************************************************************/
int main(int argc, char *argv[])
{
   char     connect_str[MAX_CONNECT_STR];
   ULONG    dwStdInMode;
   HANDLE   hStdIn;

   int      i;
   UINT     j;
   char     temp_str[81];
   char     jb_args[] = "/JOB_PATH=";     /* job path argument       */
   char     ls_scratch[513];
   char     buf[11];

   /* EXEC SQL BEGIN DECLARE SECTION; */ 

      char logname[31];
   /* EXEC SQL END DECLARE SECTION; */ 


   db_connect_str(connect_str);

   if (ifs_init(prog_name, prog_vers, NULL) != SUCCESS)
   {
      puts("Error initializing IFS Error system.");
      exit(1);
   }

   // Start of program.
   gpszIFSMsg = ifs_message("PROGRAM_START",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              NULL);

   if (!init_achos_msg(connect_str))
   {
      gpszIFSMsg = ifs_message("AOS_OPEN_MSG",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 connect_str,
                                 "none",
                                 NULL);                              
      sprintf(ls_scratch, "Error initializing ACHOS Message System: %s.",
               get_last_achos_errmsg());
      paint_task_line(1, ls_scratch);
      exit(1);
   }

   /* check the number of arguments */
   if (argc != 2)
   {
      gpszIFSMsg = ifs_fatal("CMDLINE_ERR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              " - Invalid Number of Arguments",
                              NULL);
                        // Wrong number of arguments.
      paint_task_line(0, "Insufficient number of parameters entered");
      paint_task_line(1, "....Program Exit Code  20");
      exit(20);
   }

   /* Parse command line parameters */
   for (i = 1; i < argc; i++) /* note that we skip argv[0] (path/prgname) */
   {
      strcpy(temp_str, argv[i]);
      upch(temp_str);
         

      if (strstr(temp_str, jb_args))
         for (j = strlen(jb_args); j < strlen(argv[i]); j++)
            job_path[j-strlen(jb_args)] = argv[i][j];

      else /* invalid parameter */
      {
         gpszIFSMsg = ifs_warning("CMDLINE_KWD",
                                    __FILE__, (DWORD) __LINE__, IFS_LOG,
                                    _itoa(i, buf, 10), argv[i],
                                    NULL);
         paint_task_line(0, "Invalid input parameter entered!");
         paint_task_line(1, "....Program Exit Code  21");
         exit(21);
      }
   }

   /* remove slashes */
   
   if (job_path[strlen(job_path) - 1] == '\\')
      job_path[strlen(job_path) - 1] = '\0';
   
   /*Sets up the Console Control handler routine that will be called if the
   console closes or if the system is log off or shuts down.
   This is so that the process has an  opportunity to clean up before termination.  
   */
   SetConsoleCtrlHandler((int(__stdcall*)(unsigned long))CtrlHandler, TRUE);

   /* Get Handle to the Standard Input (Console) */
   hStdIn = GetStdHandle((ULONG)STD_INPUT_HANDLE);
   if (hStdIn == INVALID_HANDLE_VALUE)
   {
      paint_task_line(0, "GetStdHandle() Failed!");
      exit(0);
   }
   /* Get the current Console Mode */
   if (!GetConsoleMode(hStdIn, &dwStdInMode))
   {
      paint_task_line(0, "GetConsoleMode Failed");
      exit(0);
   }
   /* Set the Console Mode old mode with Mouse Input Enabled! */
   if (!SetConsoleMode(hStdIn, dwStdInMode | ENABLE_MOUSE_INPUT))
   {
      paint_task_line(0, "SetConsoleMode Failed!");
      exit(1);
   }

   paint_screen ("ACHOS Program", prog_name, prog_vers); /* paints screen */
   qtexth(MOUSE_TARGET_MIN_X,MOUSE_TARGET_MIN_Y,"QUIT");

   g_orcl_etext_len = 0;
   g_orcl_etext_size = 256;
   strcpy(p_fi_rt, "ALL      ");

   paint_task_line(1, "Connecting to Database.....");
   
   if (db_connect(connect_str) != OK)
   {
      strncpy(g_user_name, connect_str, strcspn(connect_str, "/"));
      strcpy(g_db_name, connect_str + 1 + strcspn(connect_str, "@"));
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CONNECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              g_user_name,
                              g_db_name,
                              g_fi_info,
                              g_orcl_etext_buf,
                              NULL);
      paint_task_line(0, "DB_Connect failed!!");
      paint_task_line(1, "....Program Exit Code  22");
      exit(22);
   }
   else paint_task_line(1, "Connection to Database Successful!");

   /* Added 6/19/1997 - Mike West */
   /* EXEC SQL EXECUTE
      BEGIN
         Achos_Session.SetAchosLogName('SYSTEM','WATCH', :logname);
      END;
   END-EXEC; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 1;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "begin Achos_Session . SetAchosLogName ( 'SYSTEM' , 'WATCH'\
 , :logname ) ; END ;";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )5;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)logname;
   sqlstm.sqhstl[0] = (unsigned int  )31;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      ifs_fatal("ORC_EXECUTE", __FILE__, (DWORD)__LINE__, IFS_LOG,
            "Achos_Session.SetAchosLogName", g_orcl_etext_buf, g_fi_info, NULL);
      paint_task_line(0, "Unable to Run Stored Procedure.");
      paint_task_line(1, "....Program Exit Code  23");
      exit(23);
   }

   watch_events(hStdIn);   /* Only returns when admin requests a shutdown */

   /* EXEC SQL COMMIT WORK RELEASE; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 1;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )24;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

 /* Logoff Database */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      ifs_fatal("ORC_COMMIT", __FILE__, (DWORD)__LINE__, IFS_LOG,
            g_orcl_etext_buf, g_fi_info, NULL);
      paint_task_line(0, "Unable to Commit Changes");
      paint_task_line(1, "....Program Exit Code  24");
      exit(24);
   }

   gpszIFSMsg = ifs_message("PROGRAM_END", 
                            __FILE__, (DWORD) __LINE__, IFS_LOG,
                            " - Administrator Shutdown",
                            NULL);

   paint_task_line(0,"Administrator Shutdown the Watch Program!");
   paint_task_line(1,"...Program Exit Code = 999");
   return(999);
} /* end main() */


/********************************  CtrlHandler *********************************
* Description:                                                                 *
*    System generated CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT, and                 *
* CTRL_SHUTDOWN_EVENTs signal when the user closes the console, logs off, or   *
* shuts down the system so that the process has an opportunity to clean up     *
* before termination.                                                          *
*                                                                              *
* Creation Date:  04/28/1998  By: Mike West                                    *
*******************************************************************************/
BOOL WINAPI CtrlHandler(DWORD dwEvent)
{
   switch(dwEvent)
   {
      case CTRL_LOGOFF_EVENT:
      case CTRL_SHUTDOWN_EVENT:
      case CTRL_CLOSE_EVENT:
            paint_task_line(0,"Administrator Shutdown the Watch Program!");
            paint_task_line(1, "...Program Exit Code = 0");
            do_exit(0);
            break;

      default:
         return(FALSE);
   }
   return(TRUE);
} /* end CtrlHandler() */


/*************************** void ck_mouse_quit() ******************************
* Description: graciously exit out of the program when user clicks on QUIT.    *
*******************************************************************************/
void ck_mouse_quit(HANDLE hConIn)
{

   if (ck_mouse_hitx((HANDLE)hConIn,   MOUSE_TARGET_MIN_X, MOUSE_TARGET_MIN_Y,
                              MOUSE_TARGET_MAX_X, MOUSE_TARGET_MAX_Y))
   {
      gpszIFSMsg = ifs_message("PROGRAM_END", 
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 " - Administrator Shutdown",
                                 NULL);
      paint_task_line(0, "Administrator Shutdown the Watch Program!");
      paint_task_line(1, "....Program Exit Code  0");
      do_exit(0);
   }
} /* end ck_mouse_quit() */


/****************************** build_fi_rec ***********************************
* Description:                                                                 *
*     This function builds or refreshes the g_fi_rt_rec.                       *
*     Because sometimes we may add or delete an fi from the fi table.          *
* Creation Date:  01/06/1997  By: Dan Jung                                     *
*******************************************************************************/
void build_fi_rec()
{
   /* EXEC SQL SELECT COUNT(fi_rt) INTO :g_num_fi FROM fi; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 1;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select count(fi_rt) into :b0  from fi ";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )39;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)&g_num_fi;
   sqlstm.sqhstl[0] = (unsigned int  )sizeof(int);
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(COUNT(fi_rt) FROM) FI",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select from fi failed in Watch_events()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   /* EXEC SQL SELECT fi_rt INTO :g_fi_rt_rec   FROM FI; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 1;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select fi_rt into :s1   from FI ";
   sqlstm.iters = (unsigned int  )100;
   sqlstm.offset = (unsigned int  )58;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)g_fi_rt_rec.fi_rt;
   sqlstm.sqhstl[0] = (unsigned int  )10;
   sqlstm.sqhsts[0] = (         int  )10;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqharc[0] = (unsigned int   *)0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


	   
   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(fi_rt FROM) FI",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select from fi failed in Watch_events()!");
      do_exit(1);
   }

   g_cur_fi = 0;
} /* end build_fi_rec() */


/************************* refresh_fi() ****************************************
* Description:                                                                 *
*     When loop_cnt > MAX_LOOP_CNT, refresh the g_fi_rt_rec.                   *
*     We do this because some FI maybe delete or added.                        *
* Creation Date:  01/06/1997  Created By: Dan Jung                             *
*******************************************************************************/
void refresh_fi()
{
   loop_cnt++;
   if (loop_cnt > MAX_LOOP_CNT)
   {
      build_fi_rec();
      loop_cnt = 0;
   }  
} /* end refresh_fi() */


/*********************** watch_events ******************************************
* Description:                                                                 *
*     Loops until user breaks out, calling functions to process all scheduled  *
* events.                                                                      *
*                                                                              *
* Creation Date:  06/13/1996  By:  Troy Clark                                  *
* Modified Date:  06/19/1996  By:  Troy Clark                                  *
* Modified Date:  12/13/1998  By: FRNash  DR#97-300                            *
* Modified Date:  12/15/1998  By: FRNash  DR#97-300 fixed sqlcode check        *
*******************************************************************************/
void watch_events(HANDLE hStdIn) 
{
   /* get root_path and input_path of where the achinput are located */
   wr_start_time();     /* write start time */
   wr_cur_time();       /* write current date and time  added DR#97-300 */
   build_fi_rec();      /* build fi record */

   /* get the number of fi's and their fi_rt's */
   for   (;;)
      {  /* Infinite Loop...Until an ADMINISTATOR breaks out */
      /* 
         Add some mechanism of allowing an ADMINISTRATOR to gracefully shutdown
         the program.  This will help ensure the integrity of the database.

         Probably a mouse click in a QUIT area of the console, and optionally a
         windows message box that fetches a password to verify permission to
         shutdown the program. The password should be fetched from a table
         somewhere to avoid hard-coding and to allow future changes to pw.
      */

      // Display message to screen DR#97-300
         ck_mouse_quit(hStdIn);  /* check for mouse click */
         paint_task_line(1, "Updating File Schedule Event Status for ALL FI's...");
         Sleep(2000);
         ck_mouse_quit(hStdIn);  /* check for mouse click */

      // DR#97-300 For ALL FI's:
      // Open the file schedule window: roll "Expected" events into "Waiting" status
         /* EXEC SQL UPDATE   file_sch_event
                  SET      fs_event_status='W'
                  WHERE    fs_event_status = 'E'
                  AND      expected_from_ts  <= TO_DATE(:g_cur_dt_time, 'YYYYMMDDHH24MI')
                  AND      expected_to_ts    >= TO_DATE(:g_cur_dt_time, 'YYYYMMDDHH24MI'); */ 

{
         struct sqlexd sqlstm;
         sqlstm.sqlvsn = 13;
         sqlstm.arrsiz = 2;
         sqlstm.sqladtp = &sqladt;
         sqlstm.sqltdsp = &sqltds;
         sqlstm.stmt = "update file_sch_event  set fs_event_status='W' where\
 ((fs_event_status='E' and expected_from_ts<=TO_DATE(:b0,'YYYYMMDDHH24MI')) an\
d expected_to_ts>=TO_DATE(:b0,'YYYYMMDDHH24MI'))";
         sqlstm.iters = (unsigned int  )1;
         sqlstm.offset = (unsigned int  )77;
         sqlstm.cud = sqlcud0;
         sqlstm.sqlest = (unsigned char  *)&sqlca;
         sqlstm.sqlety = (unsigned short)4352;
         sqlstm.occurs = (unsigned int  )0;
         sqlstm.sqhstv[0] = (         void  *)g_cur_dt_time;
         sqlstm.sqhstl[0] = (unsigned int  )14;
         sqlstm.sqhsts[0] = (         int  )0;
         sqlstm.sqindv[0] = (         void  *)0;
         sqlstm.sqinds[0] = (         int  )0;
         sqlstm.sqharm[0] = (unsigned int  )0;
         sqlstm.sqadto[0] = (unsigned short )0;
         sqlstm.sqtdso[0] = (unsigned short )0;
         sqlstm.sqhstv[1] = (         void  *)g_cur_dt_time;
         sqlstm.sqhstl[1] = (unsigned int  )14;
         sqlstm.sqhsts[1] = (         int  )0;
         sqlstm.sqindv[1] = (         void  *)0;
         sqlstm.sqinds[1] = (         int  )0;
         sqlstm.sqharm[1] = (unsigned int  )0;
         sqlstm.sqadto[1] = (unsigned short )0;
         sqlstm.sqtdso[1] = (unsigned short )0;
         sqlstm.sqphsv = sqlstm.sqhstv;
         sqlstm.sqphsl = sqlstm.sqhstl;
         sqlstm.sqphss = sqlstm.sqhsts;
         sqlstm.sqpind = sqlstm.sqindv;
         sqlstm.sqpins = sqlstm.sqinds;
         sqlstm.sqparm = sqlstm.sqharm;
         sqlstm.sqparc = sqlstm.sqharc;
         sqlstm.sqpadto = sqlstm.sqadto;
         sqlstm.sqptdso = sqlstm.sqtdso;
         sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



         if    (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
            {
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
               gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "FILE_SCH_EVENT (STATUS E->W)",
                                       g_orcl_etext_buf,
                                       g_fi_info,
                                       NULL);
               paint_task_line(0, "Update file_sch_event(STATUS E->W) failed in watch_events()!");
               do_exit(1);
            }

         // DR#97-300 For ALL FI's:
         // Close the file schedule window: roll stale events into "Past Due" status
         /* EXEC SQL UPDATE   file_sch_event
                  SET      fs_event_status='P' 
                  WHERE    fs_event_status IN ('E', 'W')
                  AND      expected_to_ts    <= TO_DATE(:g_cur_dt_time, 'YYYYMMDDHH24MI'); */ 

{
         struct sqlexd sqlstm;
         sqlstm.sqlvsn = 13;
         sqlstm.arrsiz = 2;
         sqlstm.sqladtp = &sqladt;
         sqlstm.sqltdsp = &sqltds;
         sqlstm.stmt = "update file_sch_event  set fs_event_status='P' where\
 (fs_event_status in ('E','W') and expected_to_ts<=TO_DATE(:b0,'YYYYMMDDHH24MI\
'))";
         sqlstm.iters = (unsigned int  )1;
         sqlstm.offset = (unsigned int  )100;
         sqlstm.cud = sqlcud0;
         sqlstm.sqlest = (unsigned char  *)&sqlca;
         sqlstm.sqlety = (unsigned short)4352;
         sqlstm.occurs = (unsigned int  )0;
         sqlstm.sqhstv[0] = (         void  *)g_cur_dt_time;
         sqlstm.sqhstl[0] = (unsigned int  )14;
         sqlstm.sqhsts[0] = (         int  )0;
         sqlstm.sqindv[0] = (         void  *)0;
         sqlstm.sqinds[0] = (         int  )0;
         sqlstm.sqharm[0] = (unsigned int  )0;
         sqlstm.sqadto[0] = (unsigned short )0;
         sqlstm.sqtdso[0] = (unsigned short )0;
         sqlstm.sqphsv = sqlstm.sqhstv;
         sqlstm.sqphsl = sqlstm.sqhstl;
         sqlstm.sqphss = sqlstm.sqhsts;
         sqlstm.sqpind = sqlstm.sqindv;
         sqlstm.sqpins = sqlstm.sqinds;
         sqlstm.sqparm = sqlstm.sqharm;
         sqlstm.sqparc = sqlstm.sqharc;
         sqlstm.sqpadto = sqlstm.sqadto;
         sqlstm.sqptdso = sqlstm.sqtdso;
         sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



         if    (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
            {
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
               gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "FILE_SCH_EVENT (STATUS [E|W]->P)",
                                       g_orcl_etext_buf,
                                       g_fi_info,
                                       NULL);
               paint_task_line(0, "Update file_sch_event (STATUS [E|W]->P) failed in watch_events()!");
               do_exit(1);
            }
         
         /* EXEC SQL COMMIT WORK; */ 

{
         struct sqlexd sqlstm;
         sqlstm.sqlvsn = 13;
         sqlstm.arrsiz = 2;
         sqlstm.sqladtp = &sqladt;
         sqlstm.sqltdsp = &sqltds;
         sqlstm.iters = (unsigned int  )1;
         sqlstm.offset = (unsigned int  )119;
         sqlstm.cud = sqlcud0;
         sqlstm.sqlest = (unsigned char  *)&sqlca;
         sqlstm.sqlety = (unsigned short)4352;
         sqlstm.occurs = (unsigned int  )0;
         sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


         if    (sqlca.sqlcode != ORCL_NO_ERROR)
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
               ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
               paint_task_line(0, "Unable to Commit Changes");
               paint_task_line(1, "....Program Exit Code  24");
               exit(24);
            }

         /* EXEC SQL
            UPDATE   file_sch 
            SET      at_risk_yn = 'N' 
            WHERE :g_cur_dt_time < TO_CHAR(at_risk_ts, 'YYYYMMDDHH24MISS')
            AND      at_risk_yn = 'Y'; */ 

{
         struct sqlexd sqlstm;
         sqlstm.sqlvsn = 13;
         sqlstm.arrsiz = 2;
         sqlstm.sqladtp = &sqladt;
         sqlstm.sqltdsp = &sqltds;
         sqlstm.stmt = "update file_sch  set at_risk_yn='N' where (:b0<TO_CH\
AR(at_risk_ts,'YYYYMMDDHH24MISS') and at_risk_yn='Y')";
         sqlstm.iters = (unsigned int  )1;
         sqlstm.offset = (unsigned int  )134;
         sqlstm.cud = sqlcud0;
         sqlstm.sqlest = (unsigned char  *)&sqlca;
         sqlstm.sqlety = (unsigned short)4352;
         sqlstm.occurs = (unsigned int  )0;
         sqlstm.sqhstv[0] = (         void  *)g_cur_dt_time;
         sqlstm.sqhstl[0] = (unsigned int  )14;
         sqlstm.sqhsts[0] = (         int  )0;
         sqlstm.sqindv[0] = (         void  *)0;
         sqlstm.sqinds[0] = (         int  )0;
         sqlstm.sqharm[0] = (unsigned int  )0;
         sqlstm.sqadto[0] = (unsigned short )0;
         sqlstm.sqtdso[0] = (unsigned short )0;
         sqlstm.sqphsv = sqlstm.sqhstv;
         sqlstm.sqphsl = sqlstm.sqhstl;
         sqlstm.sqphss = sqlstm.sqhsts;
         sqlstm.sqpind = sqlstm.sqindv;
         sqlstm.sqpins = sqlstm.sqinds;
         sqlstm.sqparm = sqlstm.sqharm;
         sqlstm.sqparc = sqlstm.sqharc;
         sqlstm.sqpadto = sqlstm.sqadto;
         sqlstm.sqptdso = sqlstm.sqtdso;
         sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


         
         if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
         {
            sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
            g_orcl_etext_buf[g_orcl_etext_len] = '\0';
            copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
            gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                    __FILE__, (DWORD) __LINE__, IFS_LOG,
                                    "FILE_SCH",
                                    g_orcl_etext_buf,
                                    g_fi_info,
                                    NULL);
            paint_task_line(0,"Update file_sch; -- FAILED!");
            paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
            do_exit(1);
         }
         else
         {
            /* EXEC SQL COMMIT WORK; */ 

{
            struct sqlexd sqlstm;
            sqlstm.sqlvsn = 13;
            sqlstm.arrsiz = 2;
            sqlstm.sqladtp = &sqladt;
            sqlstm.sqltdsp = &sqltds;
            sqlstm.iters = (unsigned int  )1;
            sqlstm.offset = (unsigned int  )153;
            sqlstm.cud = sqlcud0;
            sqlstm.sqlest = (unsigned char  *)&sqlca;
            sqlstm.sqlety = (unsigned short)4352;
            sqlstm.occurs = (unsigned int  )0;
            sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

   /* commit update work */
            if (sqlca.sqlcode != ORCL_NO_ERROR)
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
               ifs_fatal("ORC_COMMIT",
                           __FILE__, (DWORD)__LINE__, IFS_LOG,
                           g_orcl_etext_buf,
                           g_fi_info,
                           NULL);
               paint_task_line(0, "Unable to Commit Changes");
               exit(1);
            }
         }


      /* Call Functions that submit jobs to handle all required processing    */
      /* events for ALL FI's!                                                 */
      ck_mouse_quit(hStdIn);  /* check for mouse click */
      wr_cur_time();          /* write current date and time */
      wr_status();            /* write fi status to the screen */
      ck_mouse_quit(hStdIn);  /* check for mouse click */
      ck_file_sch();          /* Do reqd. file inputs --> see ckfilsch.pc  */
      ck_mouse_quit(hStdIn);  /* check for mouse click */
      wr_status();            /* write fi status to the screen */
      ck_task_sch();          /* Do all scheduled tasks --> see cktsksch.pc   */
      ck_mouse_quit(hStdIn);  /* check for mouse click */
      wr_status();            /* write fi status to the screen */
      ck_eod();               /* add records */
      ck_mouse_quit(hStdIn);  /* check for mouse click */
      refresh_fi();           /* check if fi rec needs to be refreshed */
      
   } /* End For Loop... */
} /* end watch_events() */


/************************* wr_start_time ***************************************
* Description:  Prints start time to the screen.                               *
* Creation Date:  12/04/1996  Created By: Dan Jung                             *
*******************************************************************************/
void wr_start_time()
{
   /* EXEC SQL BEGIN DECLARE SECTION; */ 

      char start_time[22];
   /* EXEC SQL END DECLARE SECTION; */ 


   /* EXEC SQL SELECT TO_CHAR(sysdate, 'MM/DD/YYYY  HH24:MI')
   INTO :start_time FROM DUAL; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 2;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select TO_CHAR(sysdate,'MM/DD/YYYY  HH24:MI') into :b0  fr\
om DUAL ";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )168;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)start_time;
   sqlstm.sqhstl[0] = (unsigned int  )22;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}



   if (sqlca.sqlcode != ORCL_NO_ERROR) {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(sysdate FROM) DUAL",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select sysdate failed in wr_start_time()!");
      do_exit(1);
   }

   paint_sess_line(4, "Running Since:");
   paint_sess_line(5, start_time);
} /* end wr_start_time() */


/************************* wr_cur_time *****************************************
* Description:  Prints current time to the screen.                             *
* Creation Date:  12/04/1996  Created By: Dan Jung                             *
*******************************************************************************/
void wr_cur_time()
{
   char msg_text[30];      /* message text */
   
   /* EXEC SQL SELECT   TO_CHAR(sysdate, 'YYYYMMDD'), 
                     TO_CHAR(sysdate, 'HH24MI'),
                     TO_CHAR(sysdate, 'MM/DD/RR'), 
                     TO_CHAR(sysdate, 'HH24:MI')
            INTO     :g_cur_dt, 
                     :g_cur_time, 
                     :g_prn_dt, 
                     :g_prn_time 
            FROM     DUAL; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 4;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select TO_CHAR(sysdate,'YYYYMMDD') ,TO_CHAR(sysdate,'HH24M\
I') ,TO_CHAR(sysdate,'MM/DD/RR') ,TO_CHAR(sysdate,'HH24:MI') into :b0,:b1,:b2,\
:b3  from DUAL ";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )187;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)g_cur_dt;
   sqlstm.sqhstl[0] = (unsigned int  )9;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)g_cur_time;
   sqlstm.sqhstl[1] = (unsigned int  )5;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)g_prn_dt;
   sqlstm.sqhstl[2] = (unsigned int  )9;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)g_prn_time;
   sqlstm.sqhstl[3] = (unsigned int  )6;
   sqlstm.sqhsts[3] = (         int  )0;
   sqlstm.sqindv[3] = (         void  *)0;
   sqlstm.sqinds[3] = (         int  )0;
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   if (sqlca.sqlcode != ORCL_NO_ERROR) {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(sysdate FROM) DUAL",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select sysdate failed in wr_cur_time()!");
      do_exit(1);
   }

   copy_cat(g_cur_dt_time, g_cur_dt, g_cur_time, NULL);
   copy_cat(msg_text, "Cur Date: ", g_prn_dt, NULL);
   paint_sess_line(1, msg_text);

   copy_cat(msg_text, "Cur Time: ", g_prn_time, NULL);
   paint_sess_line(2, msg_text);
} /* end wr_cur_time() */


/************************* wr_status *******************************************
* Description:  Writes out the wh_status, eod_status to the console for an FI. *
* Creation Date:  12/09/1996  Created By: Dan Jung                             *
*******************************************************************************/
void wr_status()
{
   /* EXEC SQL BEGIN DECLARE SECTION; */ 

      char wh_status[2], eod_status[2], active_yn[2];
   /* EXEC SQL END DECLARE SECTION; */ 

   char fi_rt_str[20];
   char wh_status_str[15];
   char eod_status_str[15];
   char active_yn_str[15];

   /* EXEC SQL SELECT wh_status, eod_status, active_yn
      INTO :wh_status, :eod_status, :active_yn
      FROM fi
      WHERE fi_rt = :g_fi_rt_rec.fi_rt[g_cur_fi]; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 4;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.stmt = "select wh_status ,eod_status ,active_yn into :b0,:b1,:b2  \
from fi where fi_rt=:b3";
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )218;
   sqlstm.selerr = (unsigned short)1;
   sqlstm.sqlpfmem = (unsigned int  )0;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlstm.sqhstv[0] = (         void  *)wh_status;
   sqlstm.sqhstl[0] = (unsigned int  )2;
   sqlstm.sqhsts[0] = (         int  )0;
   sqlstm.sqindv[0] = (         void  *)0;
   sqlstm.sqinds[0] = (         int  )0;
   sqlstm.sqharm[0] = (unsigned int  )0;
   sqlstm.sqadto[0] = (unsigned short )0;
   sqlstm.sqtdso[0] = (unsigned short )0;
   sqlstm.sqhstv[1] = (         void  *)eod_status;
   sqlstm.sqhstl[1] = (unsigned int  )2;
   sqlstm.sqhsts[1] = (         int  )0;
   sqlstm.sqindv[1] = (         void  *)0;
   sqlstm.sqinds[1] = (         int  )0;
   sqlstm.sqharm[1] = (unsigned int  )0;
   sqlstm.sqadto[1] = (unsigned short )0;
   sqlstm.sqtdso[1] = (unsigned short )0;
   sqlstm.sqhstv[2] = (         void  *)active_yn;
   sqlstm.sqhstl[2] = (unsigned int  )2;
   sqlstm.sqhsts[2] = (         int  )0;
   sqlstm.sqindv[2] = (         void  *)0;
   sqlstm.sqinds[2] = (         int  )0;
   sqlstm.sqharm[2] = (unsigned int  )0;
   sqlstm.sqadto[2] = (unsigned short )0;
   sqlstm.sqtdso[2] = (unsigned short )0;
   sqlstm.sqhstv[3] = (         void  *)(g_fi_rt_rec.fi_rt)[g_cur_fi];
   sqlstm.sqhstl[3] = (unsigned int  )10;
   sqlstm.sqhsts[3] = (         int  )0;
   sqlstm.sqindv[3] = (         void  *)0;
   sqlstm.sqinds[3] = (         int  )0;
   sqlstm.sqharm[3] = (unsigned int  )0;
   sqlstm.sqadto[3] = (unsigned short )0;
   sqlstm.sqtdso[3] = (unsigned short )0;
   sqlstm.sqphsv = sqlstm.sqhstv;
   sqlstm.sqphsl = sqlstm.sqhstl;
   sqlstm.sqphss = sqlstm.sqhsts;
   sqlstm.sqpind = sqlstm.sqindv;
   sqlstm.sqpins = sqlstm.sqinds;
   sqlstm.sqparm = sqlstm.sqharm;
   sqlstm.sqparc = sqlstm.sqharc;
   sqlstm.sqpadto = sqlstm.sqadto;
   sqlstm.sqptdso = sqlstm.sqtdso;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}


   
   /* this fails when an FI has been deleted, so refresh fi record */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_fi_rt_rec.fi_rt[g_cur_fi], NULL);
      gpszIFSMsg = ifs_warning("ORC_SELECT",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "FI",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
      build_fi_rec();   /* rebuild fi record */
   }

   copy_cat(fi_rt_str, "FI_RT: ", g_fi_rt_rec.fi_rt[g_cur_fi], NULL);
   copy_cat(wh_status_str,  "WH_STATUS  = ", wh_status, NULL);
   copy_cat(eod_status_str, "EOD_STATUS = ", eod_status, NULL);
   copy_cat(active_yn_str,  "ACTIVE_YN  = ", active_yn, NULL);
   paint_sess_line(7, "----- FI Status -----");
   paint_sess_line(8, fi_rt_str);
   paint_sess_line(9, wh_status_str);
   paint_sess_line(10, eod_status_str);
   paint_sess_line(11, active_yn_str);

   /* find the next fi count */
   g_cur_fi = (g_cur_fi + 1) % g_num_fi;     
} /* end wr_status() */


/************************* do_exit *********************************************
* Description:                                                                 *
*  Just does a COMMIT work release and exits w/ arg value.                     *
*  If rollback is desired, then do it yourself prior do_exit.                  *
*                                                                              *
* Creation Date:  06/15/1996  By: Troy Clark                                   *
* Modified Date:              By:                                              *
*******************************************************************************/
void do_exit(int exit_value)
{
   /* EXEC SQL COMMIT WORK RELEASE; */ 

{
   struct sqlexd sqlstm;
   sqlstm.sqlvsn = 13;
   sqlstm.arrsiz = 4;
   sqlstm.sqladtp = &sqladt;
   sqlstm.sqltdsp = &sqltds;
   sqlstm.iters = (unsigned int  )1;
   sqlstm.offset = (unsigned int  )249;
   sqlstm.cud = sqlcud0;
   sqlstm.sqlest = (unsigned char  *)&sqlca;
   sqlstm.sqlety = (unsigned short)4352;
   sqlstm.occurs = (unsigned int  )0;
   sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}

 /* COMMIT transactions & Logoff Database */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      ifs_fatal("ORC_COMMIT", __FILE__, (DWORD)__LINE__, IFS_LOG,
            g_orcl_etext_buf, g_fi_info, NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   exit(exit_value);
} /* end do_exit() */


int submit_job(char* task_fi_rt, char* job_file, char* errstr, char* arg[], int arguments)
{

	int   ret;
	int   job_arguments;
	char temp[50];

	/* EXEC SQL BEGIN DECLARE SECTION; */ 

		char fi_rt[10];
		char job_server_group[10];
	/* EXEC SQL END DECLARE SECTION; */ 


	strcpy(fi_rt, task_fi_rt);
	job_arguments = arguments;

	memset(job_server_group,0,sizeof(job_server_group));
	memset(temp, 0 , sizeof(temp));
	
	/* EXEC SQL SELECT NVL(jsgroup,'NA')
		INTO :job_server_group
		FROM SYS_INFO
		WHERE fi_rt = :fi_rt; */ 

{
 struct sqlexd sqlstm;
 sqlstm.sqlvsn = 13;
 sqlstm.arrsiz = 4;
 sqlstm.sqladtp = &sqladt;
 sqlstm.sqltdsp = &sqltds;
 sqlstm.stmt = "select NVL(jsgroup,'NA') into :b0  from SYS_INFO where fi_rt\
=:b1";
 sqlstm.iters = (unsigned int  )1;
 sqlstm.offset = (unsigned int  )264;
 sqlstm.selerr = (unsigned short)1;
 sqlstm.sqlpfmem = (unsigned int  )0;
 sqlstm.cud = sqlcud0;
 sqlstm.sqlest = (unsigned char  *)&sqlca;
 sqlstm.sqlety = (unsigned short)4352;
 sqlstm.occurs = (unsigned int  )0;
 sqlstm.sqhstv[0] = (         void  *)job_server_group;
 sqlstm.sqhstl[0] = (unsigned int  )10;
 sqlstm.sqhsts[0] = (         int  )0;
 sqlstm.sqindv[0] = (         void  *)0;
 sqlstm.sqinds[0] = (         int  )0;
 sqlstm.sqharm[0] = (unsigned int  )0;
 sqlstm.sqadto[0] = (unsigned short )0;
 sqlstm.sqtdso[0] = (unsigned short )0;
 sqlstm.sqhstv[1] = (         void  *)fi_rt;
 sqlstm.sqhstl[1] = (unsigned int  )10;
 sqlstm.sqhsts[1] = (         int  )0;
 sqlstm.sqindv[1] = (         void  *)0;
 sqlstm.sqinds[1] = (         int  )0;
 sqlstm.sqharm[1] = (unsigned int  )0;
 sqlstm.sqadto[1] = (unsigned short )0;
 sqlstm.sqtdso[1] = (unsigned short )0;
 sqlstm.sqphsv = sqlstm.sqhstv;
 sqlstm.sqphsl = sqlstm.sqhstl;
 sqlstm.sqphss = sqlstm.sqhsts;
 sqlstm.sqpind = sqlstm.sqindv;
 sqlstm.sqpins = sqlstm.sqinds;
 sqlstm.sqparm = sqlstm.sqharm;
 sqlstm.sqparc = sqlstm.sqharc;
 sqlstm.sqpadto = sqlstm.sqadto;
 sqlstm.sqptdso = sqlstm.sqtdso;
 sqlcxt((void **)0, &sqlctx, &sqlstm, &sqlfpn);
}




   trimlr(job_server_group);
   if (strcmp(job_server_group,"NA" ) != 0)
   {
       sprintf(temp, "MROJSG=\"%s\"", job_server_group);
	   arg[job_arguments] = temp;
       job_arguments++;
   }
   
    ret = sql_jcsubmit(job_file, errstr, arg, job_arguments);
	return(ret);

}                                                                                                                                                                                                                                                                                                                                                                      document/set2/WATCH.H_1.pdf                                                                         0000644 €    %çg4001001 00000024156 14011517332 013616  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               /***************************************************************

WATCH.H Header File for WATCH.EXE and it's assoc. sub-programs
Version 1.08.10

Copyright (C) 1995 Deluxe Data Systems, Inc.
Copyright (C) 1997, 1998 Deluxe Electronic Payent Systems, Inc.

Header Containing Prototypes for all functions in the ACHOSPRD.LIB
   FILE:       watch.h
   CREATED:    06/18/1996  Troy Clark
   MODIFIED:   06/18/1996  Troy Clark
   MODIFIED:   05/14/1998  FRNash
***************************************************************/


/***************************************************************
   INCLUDES 
***************************************************************/


/***************************************************************
   TYPEDEFS, DEFINES AND DECLARATIONS
***************************************************************/
#ifndef _WATCH_H_
#define _WATCH_H_

EXEC SQL BEGIN DECLARE SECTION;

#define  TSCH_BUF_CNT            100
#define  IOQ_BUF_CNT             100
#define  FSCH_BUF_CNT            100
#define  FI_BUF_CNT              101
#define  MAX_LOOP_CNT            50
#define  MAX_NACHA_CURSOR_CNT    100
#define  MOUSE_TARGET_MIN_X      36
#define  MOUSE_TARGET_MIN_Y      23

#define  MOUSE_TARGET_MAX_X      39
#define  MOUSE_TARGET_MAX_Y      23

#define  blank_line " "
/* 
   Max allowed FI cnt = (FI_BUF_CNT - 1) or 100 
   This makes detecting when more than max allowed FI recs exist easy
   since doing an array fetch only sets sqlca.sqlcode == 0 when it
   fetches exactly the same # of rows as the array size.  Otherwise,
   it will set sqlca.sqlcode = 100 and sqlca.sqlerrd[2] = actual fetch
   cnt.
*/

typedef struct rpt_info_rec_tag {
   char     task_type[2];
   char     fi_rt[10];
   double   task_id;
   double   dist_prof_id;
   char     task_name[31];       /* max len is 30 */
   char     file_name[13];
   char     run_at_eod_yn[2];
   char     proc_opt[101];        /* max len is 100  Increased the size for SLA Report */
   char     dist_ts[16];         /* max len is 15 */
   char     corp_orig_id[11];
} rpt_info_rec_type;

typedef struct watch_tsch_recs_tag {
   char     task_type       [TSCH_BUF_CNT][2];
   char     fi_rt           [TSCH_BUF_CNT][10];
   double   task_id         [TSCH_BUF_CNT];
   double   dist_prof_id    [TSCH_BUF_CNT];
   char     task_name       [TSCH_BUF_CNT][31];  /* max len is 30 */
   char     file_name       [TSCH_BUF_CNT][13];
   char     run_at_eod_yn   [TSCH_BUF_CNT][2];
   char     proc_opt        [TSCH_BUF_CNT][101];  /* max len is 100 */
   int      days_past       [TSCH_BUF_CNT];
   char     dist_ts         [TSCH_BUF_CNT][16];
   char     corp_orig_id    [TSCH_BUF_CNT][11];
} watch_tsch_recs;

typedef struct watch_tsch_ind_recs_tag {
   short    task_type       [TSCH_BUF_CNT];
   short    fi_rt           [TSCH_BUF_CNT];
   short    task_id         [TSCH_BUF_CNT];
   short    dist_prof_id    [TSCH_BUF_CNT];
   short    task_name       [TSCH_BUF_CNT];
   short    file_name       [TSCH_BUF_CNT];
   short    run_at_eod_yn   [TSCH_BUF_CNT];
   short    proc_opt        [TSCH_BUF_CNT];
   short    days_past       [TSCH_BUF_CNT];
   short    dist_ts         [TSCH_BUF_CNT];
   short    corp_orig_id    [TSCH_BUF_CNT];
} watch_tsch_ind_recs;  /* indicators for watch_task_recs */

typedef struct watch_ioq_recs_tag {
   char     file_name      [IOQ_BUF_CNT][13];
   char     recv_ts        [IOQ_BUF_CNT][15];
   char     fi_rt          [IOQ_BUF_CNT][10];
   char     type           [IOQ_BUF_CNT][4];
} watch_ioq_recs;

typedef struct watch_ioq_ind_recs_tag {
   short    file_name      [IOQ_BUF_CNT];
   short    recv_ts        [IOQ_BUF_CNT];
   short    fi_rt          [IOQ_BUF_CNT];
   short    type           [IOQ_BUF_CNT];
} watch_ioq_ind_recs;

typedef struct watch_fsch_recs_tag {
   char     fi_rt          [FSCH_BUF_CNT][10];
   double   file_sch_id    [FSCH_BUF_CNT];
   double   file_id        [FSCH_BUF_CNT];
   char     earliest_ts    [FSCH_BUF_CNT][15];  /* TS is in 'YYYYMMDDHH24MISS' format */
   char     latest_ts      [FSCH_BUF_CNT][15];
} watch_fsch_recs;

typedef struct watch_fsch_ind_recs_tag {
   short    fi_rt          [FSCH_BUF_CNT];
   short    file_sch_id    [FSCH_BUF_CNT];
   short    file_id        [FSCH_BUF_CNT];
   short    earliest_ts    [FSCH_BUF_CNT];
   short    latest_ts      [FSCH_BUF_CNT];
} watch_fsch_ind_recs;

typedef  struct watch_fi_rt_rec_tag {
   char     fi_rt[FSCH_BUF_CNT][10];
} watch_fi_rt_rec;

typedef  struct watch_eod_rec_tag {
   char     fi_rt[FSCH_BUF_CNT][10];
   char     eod_status[FSCH_BUF_CNT][2];
} watch_eod_rec;

typedef  struct watch_eod_ind_rec_tag {
   short    fi_rt[FSCH_BUF_CNT];
   short    eod_status[FSCH_BUF_CNT];
} watch_eod_ind_rec;

typedef  struct g_nacha_file_id_tag 
{
char     fi_rt[MAX_NACHA_CURSOR_CNT][10];
double   nacha_file_id[MAX_NACHA_CURSOR_CNT];
}g_nacha_file_rec;


typedef  struct g_nacha_file_ind_tag 
{
short    fi_rt[MAX_NACHA_CURSOR_CNT];
short    nacha_file_id[MAX_NACHA_CURSOR_CNT];
}g_nacha_file_ind;   

/* Struct Def. for Nacha File Id used in CKTSKSCH.PC (DS)*/

INCLUDE_AS_EXTERN watch_tsch_recs        g_tsch_recs;
INCLUDE_AS_EXTERN watch_tsch_ind_recs    g_tsch_inds;
INCLUDE_AS_EXTERN int                    g_tsch_cnt;
INCLUDE_AS_EXTERN watch_ioq_recs         g_ioq_recs;
INCLUDE_AS_EXTERN watch_ioq_ind_recs     g_ioq_inds;
INCLUDE_AS_EXTERN int                    g_ioq_cnt;
INCLUDE_AS_EXTERN watch_fsch_recs        g_fsch_recs;
INCLUDE_AS_EXTERN watch_fsch_ind_recs    g_fsch_inds;
INCLUDE_AS_EXTERN int                    g_fsch_cnt;
INCLUDE_AS_EXTERN watch_fi_rt_rec        g_fi_rt_rec;


INCLUDE_AS_EXTERN g_nacha_file_rec  g_nacha_file_id;
INCLUDE_AS_EXTERN g_nacha_file_ind  g_nacha_file_id_ind; 
INCLUDE_AS_EXTERN  rpt_info_rec_type rpt_info_rec;
INCLUDE_AS_EXTERN char        g_prn_dt[9];
INCLUDE_AS_EXTERN char        g_prn_time[6];
INCLUDE_AS_EXTERN char        g_cur_dt[9];               /* current date */
INCLUDE_AS_EXTERN char        g_cur_time[5];             /* current time */
INCLUDE_AS_EXTERN char        g_cur_dt_time[14];         /* current date and time */
INCLUDE_AS_EXTERN char*       gpszIFSMsg;
INCLUDE_AS_EXTERN char        g_user_name[81];
INCLUDE_AS_EXTERN char        g_db_name[81];
INCLUDE_AS_EXTERN char        g_orcl_etext_buf[256];
INCLUDE_AS_EXTERN char        g_fi_info[81];
INCLUDE_AS_EXTERN int         g_orcl_etext_len;
INCLUDE_AS_EXTERN int         g_orcl_etext_size;
INCLUDE_AS_EXTERN char        p_fi_rt[10];
INCLUDE_AS_EXTERN char        gs_scratch[81];
INCLUDE_AS_EXTERN char        g_corp_orig_id[11];                 /* psm - 5/08/1997 mod */
INCLUDE_AS_EXTERN int         g_num_fi;
INCLUDE_AS_EXTERN int         g_cur_fi;
INCLUDE_AS_EXTERN int         loop_cnt;                  

EXEC SQL END DECLARE SECTION;

/* job path and btrieve path */
INCLUDE_AS_EXTERN  char        job_path[81];        
INCLUDE_AS_EXTERN char        exe_path[81];
INCLUDE_AS_EXTERN char        eod_job_name[81];

/***************************************************************
   FUNCTION PROTOTYPES 
***************************************************************/

/* Functions are listed by source file in order of their appearance */


/* SOURCE FILE:   ckeod.pc       */
void  ck_eod               (void);
void  do_start_eod         (int task_no);
BOOL  do_eod_reports       (char*);
BOOL  do_eod_job           (char*);
int   no_tasks_in_proc     (char*);
int   no_input_in_proc     (char*);
int   no_eod_in_proc       (char*);
BOOL  fail_check           (char *);


/* SOURCE FILE:   ckfildlv.pc       */
void  ck_file_dlvrs        (void);
void  deliver_file         (int ioq_no);


/* SOURCE FILE:   ckfilsch.pc       */
void  ck_file_sch          (void);
void  input_file           (int ioq_no);
int   ioq_set_status       (char *file_name, char *fi_rt, char *status_str);
/* 
   NOTE: ioq_set_status() needs to be put in ACHOSPRD.LIB once tested.
*/
int   file_sch_set_status  (char *fi_rt, double fsch_id, char new_status);
/* 
   NOTE: file_sch_set_status() needs to be put in ACHOSPRD.LIB once tested.
*/
int   id_input_file        (char *rec_one, char *fi_rt, FILE *file_handle, 
                              char * file_name_str, double *file_id,
                              char *reject_yn, int *rec_size);
long  find_one_rec         (FILE* fPointer, int* rec_size, long offset_to_one,
                              char* file_name_str);
int   id_nonnacha_file     (FILE *, char *);
long  one_rec_offset       (FILE *filePtr, char* file_name_str, int *rec_size);
void  log_file             (char *fi_rt, char *file_name, char *recv_ts, 
                              double dwFileID);
int   file_sch_hit         (char *fi_rt, double file_id, double *fsch_id);
void  file_sch_ck_at_risk  (void);
void  file_sch_ck_missed   (void);
void  get_corp_orig_id     (int fsch_no);


/* SOURCE FILE:   cktsksch.pc    */
void  ck_task_sch          (void);
void  do_task_dist         (int task_no);
void  do_task_fpickup      (int task_no);
void  do_task_integ        (int task_no);
void  do_task_report       (void);
void  do_nacha_file        (int task_no);
void  do_task_system       (int task_no);
void  do_group_task        (int task_no); // Added for DR#97-018 -FRN
void    do_task_purge         (int task_no); // Added for DR#97-199 -RMM
void  do_task_extract      (int task_no); // Added for DR#99-018 -SHA
void  do_task_billing      (int task_no); // Added for DR#99-018 -SHA
/* SOURCE FILE:   watch.pc       */
void  build_fi_rec();
void  do_exit              (int exit_value);
void  ck_mouse_quit        (HANDLE hConOut);
void  refresh_fi();
void  watch_events         (HANDLE hStdIn);
void  wr_cur_time();
void  wr_start_time();
void  wr_status(void);
int   submit_job(char* task_fi_rt, char* job_file, char* errstr,  char* arg[22], int arguments);
BOOL WINAPI CtrlHandler    (DWORD dwEvent);


/* SOURCE FILE:   mousehit.c     */
/* [Replaces the ACHOSPRD.LIB version of this function, which doesn't work!] */
short ck_mouse_hitx (HANDLE hConIn,  short min_x, short min_y, short max_x, short max_y);

#endif //_WATCH_H_


                                                                                                                                                                                                                                                                                                                                                                                                                  document/set2/WATCH.PC_2.pdf                                                                        0000644 €    %çg4001001 00000070155 14011517335 013735  0                                                                                                    ustar   e5585437                                                                                                                                                                                                                                               char  prog_name[] = "WATCH.EXE";
char  prog_vers[] = "1.13.01";
/*******************************************************************************
WATCH.PC -- An ACHOS Program

Copyright (C) 1995, 1996, 1997 Deluxe Data Systems, Inc.
Copyright (C) 1997, 1998 Deluxe Electronic Payent Systems, Inc.

This program accepts two command line parameters

The program watches the ioq, file_sch, task_sch and fi tables, and submits
jobs to handle all scheduled processes. 
*******************************************************************************/

/*******************************************************************************
   INCLUDES, DEFINES & TYPEDEFS                              
*******************************************************************************/

EXEC SQL BEGIN DECLARE SECTION;
/* This #define PREVENTS the sqlca to be declared as external in sqlca.h */
#define SQLCA_STORAGE_CLASS 
#define ORACA_STORAGE_CLASS 
#define INCLUDE_AS_EXTERN   

EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE  "sqlproto.h";
EXEC SQL INCLUDE  "sqlca.h";
EXEC SQL INCLUDE  "orcltype.h";
#include          "ddsi.h"
#include          "achosprd.h"

/* 
   The above include inserts the contents of sqlca.h into this source file
   for pro*c.  It's contents declares and defines (allocates storage) for 
   sqlca.  If you just want an extern ref. to sqlca (eg, for a 2nd src file
   when sqlca has already been defined by main src file) then do a 
      #define SQLCA_STORAGE_CLASS extern
   prior to the EXEC SQL INCLUDE sqlca; statement.
   NOTE:  Pro*C 2.1 will not generate the error handling code properly

          if you use a normal #include <sqlca.h> so stick with this method!
*/

EXEC SQL INCLUDE watch; /* inserts watch.h into src for Pro*C */ 

/*******************************************************************************
   GLOBALS
*******************************************************************************/

EXEC SQL BEGIN DECLARE SECTION;


EXEC SQL END DECLARE SECTION;


/************************** main ***********************************************
* Description:                                                                 *
*    Paints a standard screen, connects to the ACHOS Database and calls the    *
* watch_events() function to do the actual processing.                         *
*                                                                              *
* Creation Date:  06/13/1996  By: Troy Clark                                   *
* Modified Date:  11/04/1996  By: Dan Jung                                     *
* Modified Date:  04/28/1998  By: Mike West                                    *
*     Added SetConsoleCtrlHandler(CtrlHandler, TRUE) to ensure a graceful exit *
*     from WATCH when closing.                                                 *
* Modified Date:  12/03/1998  By: FRNash                                       *
*     Added Group Task processing per DR#97-018 [WATCH.H & WATCH.PC]           *
* Modified Date:  12/13/1998  By: FRNash  DR#97-300 [watch_events]             *
* Modified Date:  12/15/1998  By: FRNash  DR#97-300 [watch_events]             *
*******************************************************************************/
int main(int argc, char *argv[])
{
   char     connect_str[MAX_CONNECT_STR];
   ULONG    dwStdInMode;
   HANDLE   hStdIn;

   int      i;
   UINT     j;
   char     temp_str[81];
   char     jb_args[] = "/JOB_PATH=";     /* job path argument       */
   char     ls_scratch[513];
   char     buf[11];

   EXEC SQL BEGIN DECLARE SECTION;
      char logname[31];
   EXEC SQL END DECLARE SECTION;

   db_connect_str(connect_str);

   if (ifs_init(prog_name, prog_vers, NULL) != SUCCESS)
   {
      puts("Error initializing IFS Error system.");
      exit(1);
   }

   // Start of program.
   gpszIFSMsg = ifs_message("PROGRAM_START",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              NULL);

   if (!init_achos_msg(connect_str))
   {
      gpszIFSMsg = ifs_message("AOS_OPEN_MSG",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 connect_str,
                                 "none",
                                 NULL);                              
      sprintf(ls_scratch, "Error initializing ACHOS Message System: %s.",
               get_last_achos_errmsg());
      paint_task_line(1, ls_scratch);
      exit(1);
   }

   /* check the number of arguments */
   if (argc != 2)
   {
      gpszIFSMsg = ifs_fatal("CMDLINE_ERR",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              " - Invalid Number of Arguments",
                              NULL);
                        // Wrong number of arguments.
      paint_task_line(0, "Insufficient number of parameters entered");
      paint_task_line(1, "....Program Exit Code  20");
      exit(20);
   }

   /* Parse command line parameters */
   for (i = 1; i < argc; i++) /* note that we skip argv[0] (path/prgname) */
   {
      strcpy(temp_str, argv[i]);
      upch(temp_str);
         

      if (strstr(temp_str, jb_args))
         for (j = strlen(jb_args); j < strlen(argv[i]); j++)
            job_path[j-strlen(jb_args)] = argv[i][j];

      else /* invalid parameter */
      {
         gpszIFSMsg = ifs_warning("CMDLINE_KWD",
                                    __FILE__, (DWORD) __LINE__, IFS_LOG,
                                    _itoa(i, buf, 10), argv[i],
                                    NULL);
         paint_task_line(0, "Invalid input parameter entered!");
         paint_task_line(1, "....Program Exit Code  21");
         exit(21);
      }
   }

   /* remove slashes */
   
   if (job_path[strlen(job_path) - 1] == '\\')
      job_path[strlen(job_path) - 1] = '\0';
   
   /*Sets up the Console Control handler routine that will be called if the
   console closes or if the system is log off or shuts down.
   This is so that the process has an  opportunity to clean up before termination.  
   */
   SetConsoleCtrlHandler((int(__stdcall*)(unsigned long))CtrlHandler, TRUE);

   /* Get Handle to the Standard Input (Console) */
   hStdIn = GetStdHandle((ULONG)STD_INPUT_HANDLE);
   if (hStdIn == INVALID_HANDLE_VALUE)
   {
      paint_task_line(0, "GetStdHandle() Failed!");
      exit(0);
   }
   /* Get the current Console Mode */
   if (!GetConsoleMode(hStdIn, &dwStdInMode))
   {
      paint_task_line(0, "GetConsoleMode Failed");
      exit(0);
   }
   /* Set the Console Mode old mode with Mouse Input Enabled! */
   if (!SetConsoleMode(hStdIn, dwStdInMode | ENABLE_MOUSE_INPUT))
   {
      paint_task_line(0, "SetConsoleMode Failed!");
      exit(1);
   }

   paint_screen ("ACHOS Program", prog_name, prog_vers); /* paints screen */
   qtexth(MOUSE_TARGET_MIN_X,MOUSE_TARGET_MIN_Y,"QUIT");

   g_orcl_etext_len = 0;
   g_orcl_etext_size = 256;
   strcpy(p_fi_rt, "ALL      ");

   paint_task_line(1, "Connecting to Database.....");
   
   if (db_connect(connect_str) != OK)
   {
      strncpy(g_user_name, connect_str, strcspn(connect_str, "/"));
      strcpy(g_db_name, connect_str + 1 + strcspn(connect_str, "@"));
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_CONNECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              g_user_name,
                              g_db_name,
                              g_fi_info,
                              g_orcl_etext_buf,
                              NULL);
      paint_task_line(0, "DB_Connect failed!!");
      paint_task_line(1, "....Program Exit Code  22");
      exit(22);
   }
   else paint_task_line(1, "Connection to Database Successful!");

   /* Added 6/19/1997 - Mike West */
   EXEC SQL EXECUTE
      BEGIN
         Achos_Session.SetAchosLogName('SYSTEM','WATCH', :logname);
      END;
   END-EXEC;
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      ifs_fatal("ORC_EXECUTE", __FILE__, (DWORD)__LINE__, IFS_LOG,
            "Achos_Session.SetAchosLogName", g_orcl_etext_buf, g_fi_info, NULL);
      paint_task_line(0, "Unable to Run Stored Procedure.");
      paint_task_line(1, "....Program Exit Code  23");
      exit(23);
   }

   watch_events(hStdIn);   /* Only returns when admin requests a shutdown */

   EXEC SQL COMMIT WORK RELEASE; /* Logoff Database */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      ifs_fatal("ORC_COMMIT", __FILE__, (DWORD)__LINE__, IFS_LOG,
            g_orcl_etext_buf, g_fi_info, NULL);
      paint_task_line(0, "Unable to Commit Changes");
      paint_task_line(1, "....Program Exit Code  24");
      exit(24);
   }

   gpszIFSMsg = ifs_message("PROGRAM_END", 
                            __FILE__, (DWORD) __LINE__, IFS_LOG,
                            " - Administrator Shutdown",
                            NULL);

   paint_task_line(0,"Administrator Shutdown the Watch Program!");
   paint_task_line(1,"...Program Exit Code = 999");
   return(999);
} /* end main() */


/********************************  CtrlHandler *********************************
* Description:                                                                 *
*    System generated CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT, and                 *
* CTRL_SHUTDOWN_EVENTs signal when the user closes the console, logs off, or   *
* shuts down the system so that the process has an opportunity to clean up     *
* before termination.                                                          *
*                                                                              *
* Creation Date:  04/28/1998  By: Mike West                                    *
*******************************************************************************/
BOOL WINAPI CtrlHandler(DWORD dwEvent)
{
   switch(dwEvent)
   {
      case CTRL_LOGOFF_EVENT:
      case CTRL_SHUTDOWN_EVENT:
      case CTRL_CLOSE_EVENT:
            paint_task_line(0,"Administrator Shutdown the Watch Program!");
            paint_task_line(1, "...Program Exit Code = 0");
            do_exit(0);
            break;

      default:
         return(FALSE);
   }
   return(TRUE);
} /* end CtrlHandler() */


/*************************** void ck_mouse_quit() ******************************
* Description: graciously exit out of the program when user clicks on QUIT.    *
*******************************************************************************/
void ck_mouse_quit(HANDLE hConIn)
{

   if (ck_mouse_hitx((HANDLE)hConIn,   MOUSE_TARGET_MIN_X, MOUSE_TARGET_MIN_Y,
                              MOUSE_TARGET_MAX_X, MOUSE_TARGET_MAX_Y))
   {
      gpszIFSMsg = ifs_message("PROGRAM_END", 
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 " - Administrator Shutdown",
                                 NULL);
      paint_task_line(0, "Administrator Shutdown the Watch Program!");
      paint_task_line(1, "....Program Exit Code  0");
      do_exit(0);
   }
} /* end ck_mouse_quit() */


/****************************** build_fi_rec ***********************************
* Description:                                                                 *
*     This function builds or refreshes the g_fi_rt_rec.                       *
*     Because sometimes we may add or delete an fi from the fi table.          *
* Creation Date:  01/06/1997  By: Dan Jung                                     *
*******************************************************************************/
void build_fi_rec()
{
   EXEC SQL SELECT COUNT(fi_rt) INTO :g_num_fi FROM fi;
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(COUNT(fi_rt) FROM) FI",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select from fi failed in Watch_events()!");
      paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
      do_exit(1);
   }

   EXEC SQL SELECT fi_rt INTO :g_fi_rt_rec   FROM FI;
	   
   if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(fi_rt FROM) FI",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select from fi failed in Watch_events()!");
      do_exit(1);
   }

   g_cur_fi = 0;
} /* end build_fi_rec() */


/************************* refresh_fi() ****************************************
* Description:                                                                 *
*     When loop_cnt > MAX_LOOP_CNT, refresh the g_fi_rt_rec.                   *
*     We do this because some FI maybe delete or added.                        *
* Creation Date:  01/06/1997  Created By: Dan Jung                             *
*******************************************************************************/
void refresh_fi()
{
   loop_cnt++;
   if (loop_cnt > MAX_LOOP_CNT)
   {
      build_fi_rec();
      loop_cnt = 0;
   }  
} /* end refresh_fi() */


/*********************** watch_events ******************************************
* Description:                                                                 *
*     Loops until user breaks out, calling functions to process all scheduled  *
* events.                                                                      *
*                                                                              *
* Creation Date:  06/13/1996  By:  Troy Clark                                  *
* Modified Date:  06/19/1996  By:  Troy Clark                                  *
* Modified Date:  12/13/1998  By: FRNash  DR#97-300                            *
* Modified Date:  12/15/1998  By: FRNash  DR#97-300 fixed sqlcode check        *
*******************************************************************************/
void watch_events(HANDLE hStdIn) 
{
   /* get root_path and input_path of where the achinput are located */
   wr_start_time();     /* write start time */
   wr_cur_time();       /* write current date and time  added DR#97-300 */
   build_fi_rec();      /* build fi record */

   /* get the number of fi's and their fi_rt's */
   for   (;;)
      {  /* Infinite Loop...Until an ADMINISTATOR breaks out */
      /* 
         Add some mechanism of allowing an ADMINISTRATOR to gracefully shutdown
         the program.  This will help ensure the integrity of the database.

         Probably a mouse click in a QUIT area of the console, and optionally a
         windows message box that fetches a password to verify permission to
         shutdown the program. The password should be fetched from a table
         somewhere to avoid hard-coding and to allow future changes to pw.
      */

      // Display message to screen DR#97-300
         ck_mouse_quit(hStdIn);  /* check for mouse click */
         paint_task_line(1, "Updating File Schedule Event Status for ALL FI's...");
         Sleep(2000);
         ck_mouse_quit(hStdIn);  /* check for mouse click */

      // DR#97-300 For ALL FI's:
      // Open the file schedule window: roll "Expected" events into "Waiting" status
         EXEC SQL UPDATE   file_sch_event
                  SET      fs_event_status='W'
                  WHERE    fs_event_status = 'E'
                  AND      expected_from_ts  <= TO_DATE(:g_cur_dt_time, 'YYYYMMDDHH24MI')
                  AND      expected_to_ts    >= TO_DATE(:g_cur_dt_time, 'YYYYMMDDHH24MI');

         if    (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
            {
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
               gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "FILE_SCH_EVENT (STATUS E->W)",
                                       g_orcl_etext_buf,
                                       g_fi_info,
                                       NULL);
               paint_task_line(0, "Update file_sch_event(STATUS E->W) failed in watch_events()!");
               do_exit(1);
            }

         // DR#97-300 For ALL FI's:
         // Close the file schedule window: roll stale events into "Past Due" status
         EXEC SQL UPDATE   file_sch_event
                  SET      fs_event_status='P' 
                  WHERE    fs_event_status IN ('E', 'W')
                  AND      expected_to_ts    <= TO_DATE(:g_cur_dt_time, 'YYYYMMDDHH24MI');

         if    (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
            {
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
               gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                       __FILE__, (DWORD) __LINE__, IFS_LOG,
                                       "FILE_SCH_EVENT (STATUS [E|W]->P)",
                                       g_orcl_etext_buf,
                                       g_fi_info,
                                       NULL);
               paint_task_line(0, "Update file_sch_event (STATUS [E|W]->P) failed in watch_events()!");
               do_exit(1);
            }
         
         EXEC SQL COMMIT WORK;
         if    (sqlca.sqlcode != ORCL_NO_ERROR)
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
               ifs_fatal("ORC_COMMIT",
                  __FILE__, (DWORD)__LINE__, IFS_LOG,
                  g_orcl_etext_buf,
                  g_fi_info,
                  NULL);
               paint_task_line(0, "Unable to Commit Changes");
               paint_task_line(1, "....Program Exit Code  24");
               exit(24);
            }

         EXEC SQL
            UPDATE   file_sch 
            SET      at_risk_yn = 'N' 
            WHERE :g_cur_dt_time < TO_CHAR(at_risk_ts, 'YYYYMMDDHH24MISS')
            AND      at_risk_yn = 'Y';
         
         if (sqlca.sqlcode != ORCL_NO_ERROR && sqlca.sqlcode != ORCL_NOT_FOUND)
         {
            sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
            g_orcl_etext_buf[g_orcl_etext_len] = '\0';
            copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
            gpszIFSMsg = ifs_fatal("ORC_UPDATE",
                                    __FILE__, (DWORD) __LINE__, IFS_LOG,
                                    "FILE_SCH",
                                    g_orcl_etext_buf,
                                    g_fi_info,
                                    NULL);
            paint_task_line(0,"Update file_sch; -- FAILED!");
            paint_task_line(1, sqlca.sqlerrm.sqlerrmc);
            do_exit(1);
         }
         else
         {
            EXEC SQL COMMIT WORK;   /* commit update work */
            if (sqlca.sqlcode != ORCL_NO_ERROR)
            {
               sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
               g_orcl_etext_buf[g_orcl_etext_len] = '\0';
               copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
               ifs_fatal("ORC_COMMIT",
                           __FILE__, (DWORD)__LINE__, IFS_LOG,
                           g_orcl_etext_buf,
                           g_fi_info,
                           NULL);
               paint_task_line(0, "Unable to Commit Changes");
               exit(1);
            }
         }


      /* Call Functions that submit jobs to handle all required processing    */
      /* events for ALL FI's!                                                 */
      ck_mouse_quit(hStdIn);  /* check for mouse click */
      wr_cur_time();          /* write current date and time */
      wr_status();            /* write fi status to the screen */
      ck_mouse_quit(hStdIn);  /* check for mouse click */
      ck_file_sch();          /* Do reqd. file inputs --> see ckfilsch.pc  */
      ck_mouse_quit(hStdIn);  /* check for mouse click */
      wr_status();            /* write fi status to the screen */
      ck_task_sch();          /* Do all scheduled tasks --> see cktsksch.pc   */
      ck_mouse_quit(hStdIn);  /* check for mouse click */
      wr_status();            /* write fi status to the screen */
      ck_eod();               /* add records */
      ck_mouse_quit(hStdIn);  /* check for mouse click */
      refresh_fi();           /* check if fi rec needs to be refreshed */
      
   } /* End For Loop... */
} /* end watch_events() */


/************************* wr_start_time ***************************************
* Description:  Prints start time to the screen.                               *
* Creation Date:  12/04/1996  Created By: Dan Jung                             *
*******************************************************************************/
void wr_start_time()
{
   EXEC SQL BEGIN DECLARE SECTION;
      char start_time[22];
   EXEC SQL END DECLARE SECTION;

   EXEC SQL SELECT TO_CHAR(sysdate, 'MM/DD/YYYY  HH24:MI')
   INTO :start_time FROM DUAL;

   if (sqlca.sqlcode != ORCL_NO_ERROR) {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(sysdate FROM) DUAL",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select sysdate failed in wr_start_time()!");
      do_exit(1);
   }

   paint_sess_line(4, "Running Since:");
   paint_sess_line(5, start_time);
} /* end wr_start_time() */


/************************* wr_cur_time *****************************************
* Description:  Prints current time to the screen.                             *
* Creation Date:  12/04/1996  Created By: Dan Jung                             *
*******************************************************************************/
void wr_cur_time()
{
   char msg_text[30];      /* message text */
   
   EXEC SQL SELECT   TO_CHAR(sysdate, 'YYYYMMDD'), 
                     TO_CHAR(sysdate, 'HH24MI'),
                     TO_CHAR(sysdate, 'MM/DD/RR'), 
                     TO_CHAR(sysdate, 'HH24:MI')
            INTO     :g_cur_dt, 
                     :g_cur_time, 
                     :g_prn_dt, 
                     :g_prn_time 
            FROM     DUAL;
   if (sqlca.sqlcode != ORCL_NO_ERROR) {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      gpszIFSMsg = ifs_fatal("ORC_SELECT",
                              __FILE__, (DWORD) __LINE__, IFS_LOG,
                              "(sysdate FROM) DUAL",
                              g_orcl_etext_buf,
                              g_fi_info,
                              NULL);
      paint_task_line(0, "Select sysdate failed in wr_cur_time()!");
      do_exit(1);
   }

   copy_cat(g_cur_dt_time, g_cur_dt, g_cur_time, NULL);
   copy_cat(msg_text, "Cur Date: ", g_prn_dt, NULL);
   paint_sess_line(1, msg_text);

   copy_cat(msg_text, "Cur Time: ", g_prn_time, NULL);
   paint_sess_line(2, msg_text);
} /* end wr_cur_time() */


/************************* wr_status *******************************************
* Description:  Writes out the wh_status, eod_status to the console for an FI. *
* Creation Date:  12/09/1996  Created By: Dan Jung                             *
*******************************************************************************/
void wr_status()
{
   EXEC SQL BEGIN DECLARE SECTION;
      char wh_status[2], eod_status[2], active_yn[2];
   EXEC SQL END DECLARE SECTION;
   char fi_rt_str[20];
   char wh_status_str[15];
   char eod_status_str[15];
   char active_yn_str[15];

   EXEC SQL SELECT wh_status, eod_status, active_yn
      INTO :wh_status, :eod_status, :active_yn
      FROM fi
      WHERE fi_rt = :g_fi_rt_rec.fi_rt[g_cur_fi];
   
   /* this fails when an FI has been deleted, so refresh fi record */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", g_fi_rt_rec.fi_rt[g_cur_fi], NULL);
      gpszIFSMsg = ifs_warning("ORC_SELECT",
                                 __FILE__, (DWORD) __LINE__, IFS_LOG,
                                 "FI",
                                 g_orcl_etext_buf,
                                 g_fi_info,
                                 NULL);
      build_fi_rec();   /* rebuild fi record */
   }

   copy_cat(fi_rt_str, "FI_RT: ", g_fi_rt_rec.fi_rt[g_cur_fi], NULL);
   copy_cat(wh_status_str,  "WH_STATUS  = ", wh_status, NULL);
   copy_cat(eod_status_str, "EOD_STATUS = ", eod_status, NULL);
   copy_cat(active_yn_str,  "ACTIVE_YN  = ", active_yn, NULL);
   paint_sess_line(7, "----- FI Status -----");
   paint_sess_line(8, fi_rt_str);
   paint_sess_line(9, wh_status_str);
   paint_sess_line(10, eod_status_str);
   paint_sess_line(11, active_yn_str);

   /* find the next fi count */
   g_cur_fi = (g_cur_fi + 1) % g_num_fi;     
} /* end wr_status() */


/************************* do_exit *********************************************
* Description:                                                                 *
*  Just does a COMMIT work release and exits w/ arg value.                     *
*  If rollback is desired, then do it yourself prior do_exit.                  *
*                                                                              *
* Creation Date:  06/15/1996  By: Troy Clark                                   *
* Modified Date:              By:                                              *
*******************************************************************************/
void do_exit(int exit_value)
{
   EXEC SQL COMMIT WORK RELEASE; /* COMMIT transactions & Logoff Database */
   if (sqlca.sqlcode != ORCL_NO_ERROR)
   {
      sqlglm(g_orcl_etext_buf, (UINT*)&g_orcl_etext_size, (UINT*)&g_orcl_etext_len);
      g_orcl_etext_buf[g_orcl_etext_len] = '\0';
      copy_cat(g_fi_info, "FI: ", p_fi_rt, NULL);
      ifs_fatal("ORC_COMMIT", __FILE__, (DWORD)__LINE__, IFS_LOG,
            g_orcl_etext_buf, g_fi_info, NULL);
      paint_task_line(0, "Unable to Commit Changes");
      exit(1);
   }

   exit(exit_value);
} /* end do_exit() */


int submit_job(char* task_fi_rt, char* job_file, char* errstr, char* arg[], int arguments)
{

	int   ret;
	int   job_arguments;
	char temp[50];

	EXEC SQL BEGIN DECLARE SECTION;
		char fi_rt[10];
		char job_server_group[10];
	EXEC SQL END DECLARE SECTION;

	strcpy(fi_rt, task_fi_rt);
	job_arguments = arguments;

	memset(job_server_group,0,sizeof(job_server_group));
	memset(temp, 0 , sizeof(temp));
	
	EXEC SQL SELECT NVL(jsgroup,'NA')
		INTO :job_server_group
		FROM SYS_INFO
		WHERE fi_rt = :fi_rt;


   trimlr(job_server_group);
   if (strcmp(job_server_group,"NA" ) != 0)
   {
       sprintf(temp, "MROJSG=\"%s\"", job_server_group);
	   arg[job_arguments] = temp;
       job_arguments++;
   }
   
    ret = sql_jcsubmit(job_file, errstr, arg, job_arguments);
	return(ret);

}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   